<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="记录了学习《Programming Rust》笔记。"><title>Programming Rust</title>
<link rel=canonical href=https://wenjin1997.github.io/2022/07/05/Programming-Rust/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Programming Rust"><meta property='og:description' content="记录了学习《Programming Rust》笔记。"><meta property='og:url' content='https://wenjin1997.github.io/2022/07/05/Programming-Rust/'><meta property='og:site_name' content="Jade's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Rust'><meta property='article:tag' content='笔记'><meta property='article:published_time' content='2022-07-05T00:00:00+00:00'><meta property='article:modified_time' content='2022-07-05T00:00:00+00:00'><meta name=twitter:title content="Programming Rust"><meta name=twitter:description content="记录了学习《Programming Rust》笔记。"><link rel="shortcut icon" href=/img/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/ghost_hu15175528053352950562.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Jade's Blog</a></h1><h2 class=site-description>Keep Learning and Thinking!</h2></div></header><ol class=menu-social><li><a href=https://github.com/wenjin1997 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/ChinnellHeish target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span></span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title"></h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#chapter-3-fundamental-types>Chapter 3. Fundamental Types</a><ol><li><a href=#fixed-width-numerical-types>Fixed-Width Numerical Types</a><ol><li><a href=#integer-types>Integer Types</a></li><li><a href=#checked-wrapping-saturating-and-overflowing-arithmetic>Checked, Wrapping, Saturating, and Overflowing Arithmetic</a></li><li><a href=#floating-point-types>Floating-Point Types</a></li></ol></li><li><a href=#the-bool-type>The bool Type</a></li><li><a href=#characters>Characters</a></li><li><a href=#tuples>Tuples</a></li><li><a href=#pointer-types>Pointer Types</a><ol><li><a href=#references>References</a></li><li><a href=#boxes>Boxes</a></li><li><a href=#raw-pointers>Raw Pointers</a></li></ol></li><li><a href=#arrays-vectors-and-slices>Arrays, Vectors, and Slices</a><ol><li><a href=#arrays>Arrays</a></li><li><a href=#vectors>Vectors</a></li><li><a href=#slices>Slices</a></li></ol></li><li><a href=#string-types>String Types</a><ol><li><a href=#string-literals>String Literals</a></li><li><a href=#byte-strings>Byte Strings</a></li><li><a href=#strings-in-memory>Strings in Memory</a></li><li><a href=#string>String</a></li><li><a href=#using-strings>Using Strings</a></li><li><a href=#other-string-like-types>Other String-Like Types</a></li></ol></li><li><a href=#type-aliases>Type Aliases</a></li></ol></li><li><a href=#chapter-4-ownership-and-moves>Chapter 4. Ownership and Moves</a><ol><li><a href=#ownership>Ownership</a></li><li><a href=#moves>Moves</a><ol><li><a href=#more-operations-that-move>More Operations That Move</a></li><li><a href=#moves-and-control-flow>Moves and Control Flow</a></li><li><a href=#moves-and-indexed-content>Moves and Indexed Content</a></li></ol></li><li><a href=#copy-types-the-exception-to-moves>Copy Types: The Exception to Moves</a></li><li><a href=#rc-and-arc-shared-ownership>Rc and Arc: Shared Ownership</a></li></ol></li><li><a href=#chapter-5-references>Chapter 5. References</a><ol><li><a href=#references-to-values><strong>References to Values</strong></a></li><li><a href=#working-with-references><strong>Working with References</strong></a><ol><li><a href=#rust-references-versus-c-references><strong>Rust References Versus C++ References</strong></a></li><li><a href=#assigning-references><strong>Assigning References</strong></a></li><li><a href=#references-to-references><strong>References to References</strong></a></li><li><a href=#comparing-references><strong>Comparing References</strong></a></li><li><a href=#references-are-never-null><strong>References Are Never Null</strong></a></li><li><a href=#borrowing-references-to-arbitrary-expressions><strong>Borrowing References to Arbitrary Expressions</strong></a></li><li><a href=#references-to-slices-and-trait-objects><strong>References to Slices and Trait Objects</strong></a></li></ol></li><li><a href=#reference-safety><strong>Reference Safety</strong></a><ol><li><a href=#borrowing-a-local-variable><strong>Borrowing a Local Variable</strong></a></li><li><a href=#receiving-references-as-function-arguments><strong>Receiving References as Function Arguments</strong></a></li><li><a href=#passing-references-to-functions><strong>Passing References to Functions</strong></a></li><li><a href=#returning-references><strong>Returning References</strong></a></li><li><a href=#structs-containing-references><strong>Structs Containing References</strong></a></li><li><a href=#distinct-lifetime-parameters><strong>Distinct Lifetime Parameters</strong></a></li><li><a href=#omitting-lifetime-parameters><strong>Omitting Lifetime Parameters</strong></a></li></ol></li><li><a href=#sharing-versus-mutation>Sharing Versus Mutation</a></li><li><a href=#taking-arms-against-a-sea-of-objects><strong>Taking Arms Against a Sea of Objects</strong></a></li></ol></li><li><a href=#chapter-6-expressions>Chapter 6. Expressions</a><ol><li><a href=#an-expression-language>An Expression Language</a></li><li><a href=#precedence-and-associativity>Precedence and Associativity</a></li><li><a href=#blocks-and-semicolons>Blocks and Semicolons</a></li><li><a href=#declarations>Declarations</a></li><li><a href=#if-and-match>if and match</a></li><li><a href=#if-let>if let</a></li><li><a href=#loops>Loops</a></li><li><a href=#control-flow-in-loops>Control Flow in Loops</a></li><li><a href=#return-expressions>return Expressions</a></li><li><a href=#why-rust-has-loop>Why Rust Has loop</a></li><li><a href=#function-and-method-calls>Function and Method Calls</a></li><li><a href=#fields-and-elements>Fields and Elements</a></li><li><a href=#reference-operators>Reference Operators</a></li><li><a href=#arithmetic-bitwise-comparsion-and-logical-operators>Arithmetic, Bitwise, Comparsion, and Logical Operators</a></li><li><a href=#assignment>Assignment</a></li><li><a href=#type-casts>Type Casts</a></li><li><a href=#closures>Closures</a></li><li><a href=#onward>Onward</a></li></ol></li><li><a href=#chapter-7--error-handling>Chapter 7. Error Handling</a><ol><li><a href=#panic>Panic</a><ol><li><a href=#unwinding>Unwinding</a></li><li><a href=#aborting>Aborting</a></li></ol></li><li><a href=#result>Result</a><ol><li><a href=#catching-errors>Catching Errors</a></li><li><a href=#result-type-aliases>Result Type Aliases</a></li><li><a href=#printing-errors>Printing Errors</a></li><li><a href=#propagating-errors>Propagating Errors</a></li><li><a href=#working-with-multiple-error-types>Working with Multiple Error Types</a></li><li><a href=#dealing-with-errors-that-cant-happen>Dealing with Errors That &ldquo;Can&rsquo;t Happen&rdquo;</a></li><li><a href=#ingoring-errors>Ingoring Errors</a></li><li><a href=#handling-errors-in-main>Handling Errors in main()</a></li><li><a href=#declaring-a-custom-error-type>Declaring a Custom Error Type</a></li><li><a href=#why-results>Why Results?</a></li></ol></li></ol></li><li><a href=#chapter-8-crates-and-modules>Chapter 8. Crates and Modules</a><ol><li><a href=#crates>Crates</a><ol><li><a href=#editions>Editions</a></li><li><a href=#build-profiles>Build Profiles</a></li></ol></li><li><a href=#modules>Modules</a><ol><li><a href=#nested-modules>Nested Modules</a></li><li><a href=#modules-in-separate-files>Modules in Separate Files</a></li><li><a href=#paths-and-imports>Paths and Imports</a></li><li><a href=#the-standard-prelude><strong>The Standard Prelude</strong></a></li><li><a href=#making-use-declarations-pub><strong>Making use Declarations pub</strong></a></li><li><a href=#making-struct-fields-pub><strong>Making Struct Fields pub</strong></a></li><li><a href=#statics-and-constants><strong>Statics and Constants</strong></a></li></ol></li><li><a href=#turning-a-program-into-a-library><strong>Turning a Program into a Library</strong></a></li><li><a href=#the-srcbin-directory><strong>The src/bin Directory</strong></a></li><li><a href=#attributes>Attributes</a></li><li><a href=#tests-and-documention>Tests and Documention</a><ol><li><a href=#integration-tests>Integration Tests</a></li><li><a href=#documentation>Documentation</a></li><li><a href=#doc-tests>Doc-Tests</a></li></ol></li><li><a href=#specifying-dependencies><strong>Specifying Dependencies</strong></a><ol><li><a href=#versions><strong>Versions</strong></a></li><li><a href=#cargolock><strong>Cargo.lock</strong></a></li></ol></li><li><a href=#publishing-crates-to-cratesio><strong>Publishing Crates to crates.io</strong></a></li><li><a href=#workspace>Workspace</a></li></ol></li><li><a href=#chapter-9-structs><strong>Chapter 9. Structs</strong></a><ol><li><a href=#named-field-structs><strong>Named-Field Structs</strong></a></li><li><a href=#tuple-like-structs><strong>Tuple-Like Structs</strong></a></li><li><a href=#unit-like-structs><strong>Unit-Like Structs</strong></a></li><li><a href=#struct-layout><strong>Struct Layout</strong></a></li><li><a href=#defining-methods-with-impl><strong>Defining Methods with impl</strong></a><ol><li><a href=#passing-self-as-a-box-rc-or-arc><strong>Passing Self as a Box, Rc, or Arc</strong></a></li><li><a href=#type-associated-functions><strong>Type-Associated Functions</strong></a></li></ol></li><li><a href=#associated-consts><strong>Associated Consts</strong></a></li><li><a href=#generic-structs><strong>Generic Structs</strong></a></li><li><a href=#structs-with-lifetime-parameters><strong>Structs with Lifetime Parameters</strong></a></li><li><a href=#deriving-common-traits-for-struct-types><strong>Deriving Common Traits for Struct Types</strong></a></li><li><a href=#interior-mutability><strong>Interior Mutability</strong></a></li></ol></li><li><a href=#chapter-10-enums-and-patterns>Chapter 10. Enums and Patterns</a><ol><li><a href=#enums><strong>Enums</strong></a><ol><li><a href=#enums-with-data>Enums with Data</a></li><li><a href=#enums-in-memory>Enums in Memory</a></li><li><a href=#rich-data-structures-using-enums><strong>Rich Data Structures Using Enums</strong></a></li><li><a href=#generic-enums><strong>Generic Enums</strong></a></li></ol></li><li><a href=#patterns><strong>Patterns</strong></a><ol><li><a href=#literals-variables-and-wildcards-in-patterns><strong>Literals, Variables, and Wildcards in Patterns</strong></a></li><li><a href=#tuple-and-struct-patterns>Tuple and Struct Patterns</a></li><li><a href=#array-and-slice-patterns>Array and Slice Patterns</a></li><li><a href=#reference-patterns>Reference Patterns</a></li><li><a href=#match-guards>Match Guards</a></li><li><a href=#matching-multiple-possibilities>Matching Multiple Possibilities</a></li><li><a href=#binding-with--patterns>Binding with @ Patterns</a></li><li><a href=#where-patterns-are-allowed>Where Patterns Are Allowed</a></li><li><a href=#populating-a-binary-tree>Populating a Binary Tree</a></li></ol></li></ol></li><li><a href=#chapter-11-traits-and-generics><strong>Chapter 11. Traits and Generics</strong></a><ol><li><a href=#using-traits><strong>Using Traits</strong></a><ol><li><a href=#trait-objects><strong>Trait Objects</strong></a></li><li><a href=#trait-object-layout><strong>Trait object layout</strong></a></li><li><a href=#generic-functions-and-type-parameters><strong>Generic Functions and Type Parameters</strong></a></li><li><a href=#which-to-use>Which to Use</a></li></ol></li><li><a href=#defining-and-implementing-traits>Defining and Implementing Traits</a><ol><li><a href=#default-methods>Default Methods</a></li><li><a href=#traits-and-other-peoples-types><strong>Traits and Other People’s Types</strong></a></li><li><a href=#self-in-traits>Self in Traits</a></li><li><a href=#subtraits>Subtraits</a></li><li><a href=#type-associated-functions-1>Type-Associated Functions</a></li></ol></li><li><a href=#fully-qualified-method-calls>Fully Qualified Method Calls</a></li><li><a href=#traits-that-define-relationships-between-types>Traits That Define Relationships Between Types</a><ol><li><a href=#associated-types-or-how-iterators-work>Associated Types (or How Iterators Work)</a></li><li><a href=#generic-traits-or-how-operator-overloading-works>Generic Traits (or How Operator Overloading Works)</a></li><li><a href=#impl-trait>impl Trait</a></li><li><a href=#associated-consts-1>Associated Consts</a></li></ol></li><li><a href=#reverse-engineering-bounds>Reverse-Engineering Bounds</a></li><li><a href=#traits-as-a-foundation>Traits as a Foundation</a></li></ol></li><li><a href=#chapter-12-operator-overloading><strong>Chapter 12. Operator Overloading</strong></a><ol><li><a href=#arithmetic-and-bitwise-operators><strong>Arithmetic and Bitwise Operators</strong></a><ol><li><a href=#unary-operators><strong>Unary Operators</strong></a></li><li><a href=#binary-operators><strong>Binary Operators</strong></a></li><li><a href=#compound-assignment-operators><strong>Compound Assignment Operators</strong></a></li></ol></li><li><a href=#equivalence-comparisons><strong>Equivalence Comparisons</strong></a></li><li><a href=#ordered-comparisons><strong>Ordered Comparisons</strong></a></li><li><a href=#index-and-indexmut><strong>Index and IndexMut</strong></a></li><li><a href=#other-operators><strong>Other Operators</strong></a></li></ol></li><li><a href=#chapter-13-utility-traits><strong>Chapter 13. Utility Traits</strong></a><ol><li><a href=#drop>Drop</a></li><li><a href=#sized><strong>Sized</strong></a></li><li><a href=#clone><strong>Clone</strong></a></li><li><a href=#copy><strong>Copy</strong></a></li><li><a href=#deref-and-derefmut><strong>Deref and DerefMut</strong></a></li><li><a href=#default><strong>Default</strong></a></li><li><a href=#asref-and-asmut><strong>AsRef and AsMut</strong></a></li><li><a href=#borrow-and-borrowmut><strong>Borrow and BorrowMut</strong></a></li><li><a href=#from-and-into><strong>From and Into</strong></a></li><li><a href=#tryfrom-and-tryinto><strong>TryFrom and TryInto</strong></a></li><li><a href=#toowned><strong>ToOwned</strong></a></li><li><a href=#borrow-and-toowned-at-work-the-humble-cow><strong>Borrow and ToOwned at Work: The Humble Cow</strong></a></li></ol></li><li><a href=#chapter-14-closures><strong>Chapter 14. Closures</strong></a><ol><li><a href=#capturing-variables><strong>Capturing Variables</strong></a><ol><li><a href=#closures-that-borrow>Closures That Borrow</a></li><li><a href=#closures-that-steal><strong>Closures That Steal</strong></a></li></ol></li><li><a href=#function-and-closure-types><strong>Function and Closure Types</strong></a></li><li><a href=#closure-performance><strong>Closure Performance</strong></a></li><li><a href=#closures-and-safety><strong>Closures and Safety</strong></a><ol><li><a href=#closures-that-kill><strong>Closures That Kill</strong></a></li><li><a href=#fnonce><strong>FnOnce</strong></a></li><li><a href=#fnmut>FnMut</a></li><li><a href=#copy-and-clone-for-closures><strong>Copy and Clone for Closures</strong></a></li></ol></li><li><a href=#callbacks><strong>Callbacks</strong></a></li><li><a href=#using-closures-effectively><strong>Using Closures Effectively</strong></a></li></ol></li><li><a href=#chapter-15-iterators><strong>Chapter 15. Iterators</strong></a><ol><li><a href=#the-iterator-and-intoiterator-traits><strong>The Iterator and IntoIterator Traits</strong></a></li><li><a href=#creating-iterators><strong>Creating Iterators</strong></a><ol><li><a href=#iter-and-iter_mut-methods><strong>iter and iter_mut Methods</strong></a></li><li><a href=#intoiterator-implementations><strong>IntoIterator Implementations</strong></a></li><li><a href=#from_fn-and-successors><strong>from_fn and successors</strong></a></li><li><a href=#drain-methods><strong>drain Methods</strong></a></li><li><a href=#other-iterator-sources><strong>Other Iterator Sources</strong></a></li></ol></li><li><a href=#iterator-adapters><strong>Iterator Adapters</strong></a><ol><li><a href=#map-and-filter><strong>map and filter</strong></a></li><li><a href=#filter_map-and-flat_map><strong>filter_map and flat_map</strong></a></li><li><a href=#flatten><strong>flatten</strong></a></li><li><a href=#take-and-take_while><strong>take and take_while</strong></a></li><li><a href=#skip-and-skip_while><strong>skip and skip_while</strong></a></li><li><a href=#peekable><strong>peekable</strong></a></li><li><a href=#fuse><strong>fuse</strong></a></li><li><a href=#reversible-iterators-and-rev><strong>Reversible Iterators and rev</strong></a></li><li><a href=#inspect><strong>inspect</strong></a></li><li><a href=#chain><strong>chain</strong></a></li><li><a href=#enumerate><strong>enumerate</strong></a></li><li><a href=#zip><strong>zip</strong></a></li><li><a href=#by_ref><strong>by_ref</strong></a></li><li><a href=#cloned-copied>cloned, copied</a></li><li><a href=#cycle><strong>cycle</strong></a></li></ol></li><li><a href=#consuming-iterators><strong>Consuming Iterators</strong></a><ol><li><a href=#simple-accumulation-count-sum-product><strong>Simple Accumulation: count, sum, product</strong></a></li><li><a href=#max-min><strong>max, min</strong></a></li><li><a href=#max_by-min_by><strong>max_by, min_by</strong></a></li><li><a href=#max_by_key-min_by_key><strong>max_by_key, min_by_key</strong></a></li><li><a href=#comparing-item-sequences><strong>Comparing Item Sequences</strong></a></li><li><a href=#any-and-all><strong>any and all</strong></a></li><li><a href=#position-rposition-and-exactsizeiterator><strong>position, rposition, and ExactSizeIterator</strong></a></li><li><a href=#fold-and-rfold><strong>fold and rfold</strong></a></li><li><a href=#try_fold-and-try_rfold><strong>try_fold and try_rfold</strong></a></li><li><a href=#nth-nth_back><strong>nth, nth_back</strong></a></li><li><a href=#last><strong>last</strong></a></li><li><a href=#find-rfind-and-find_map><strong>find, rfind, and find_map</strong></a></li><li><a href=#building-collections-collect-and-fromiterator><strong>Building Collections: collect and FromIterator</strong></a></li><li><a href=#the-extend-trait><strong>The Extend Trait</strong></a></li><li><a href=#partition><strong>partition</strong></a></li><li><a href=#for_each-and-try_for_each><strong>for_each and try_for_each</strong></a></li></ol></li><li><a href=#implementing-your-own-iterators>Implementing Your Own Iterators</a></li></ol></li><li><a href=#chapter-19-concurrency>Chapter 19. Concurrency</a><ol><li><a href=#fork-join-parallelism>Fork-Join Parallelism</a><ol><li><a href=#spawn-and-join>spawn and join</a></li><li><a href=#error-handling-across-threads>Error Handling Across Threads</a></li><li><a href=#sharing-immutable-data-across-threads>Sharing Immutable Data Across Threads</a></li><li><a href=#rayon>Rayon</a></li></ol></li><li><a href=#channels>Channels</a><ol><li><a href=#sending-values>Sending Values</a></li><li><a href=#receiving-values>Receiving Values</a></li><li><a href=#running-the-pipeline>Running the Pipeline</a></li><li><a href=#channel-features-and-performance>Channel Features and Performance</a></li><li><a href=#thread-safety-send-and-sync>Thread Safety: Send and Sync</a></li><li><a href=#piping-almost-any-iterator-to-a-channel>Piping Almost Any Iterator to a Channel</a></li><li><a href=#beyond-pipelines>Beyond Pipelines</a></li></ol></li><li><a href=#shared-mutable-state>Shared Mutable State</a><ol><li><a href=#what-is-a-mutex>What Is a Mutex?</a></li><li><a href=#mutext><code>Mutex&lt;T></code></a></li><li><a href=#mut-and-mutex>mut and Mutex</a></li><li><a href=#why-mutexes-are-not-always-a-good-idea>Why Mutexes Are Not Always a Good Idea</a></li><li><a href=#deadlock>Deadlock</a></li><li><a href=#poisoned-mutexes>Poisoned Mutexes</a></li><li><a href=#multiconsumer-channels-using-mutexes><strong>Multiconsumer Channels Using Mutexes</strong></a></li><li><a href=#readwrite-locksrwlockt>Read/Write Locks(<code>RwLock&lt;T></code>)</a></li><li><a href=#condition-variables-condvar>Condition Variables (Condvar)</a></li><li><a href=#atomics><strong>Atomics</strong></a></li><li><a href=#global-variables><strong>Global Variables</strong></a></li></ol></li><li><a href=#what-hacking-concurrent-code-in-rust-is-like><strong>What Hacking Concurrent Code in Rust Is Like</strong></a></li></ol></li><li><a href=#chapter-20-asynchronous-programming><strong>Chapter 20. Asynchronous Programming</strong></a><ol><li><a href=#from-synchronous-to-asynchronous><strong>From Synchronous to Asynchronous</strong></a><ol><li><a href=#futures><strong>Futures</strong></a></li></ol></li></ol></li><li><a href=#chapter-21-macros>Chapter 21. Macros</a><ol><li><a href=#macro-basics>Macro Basics</a><ol><li><a href=#basics-of-macro-expansion>Basics of Macro Expansion</a></li><li><a href=#unintended-consenquences>Unintended Consenquences</a></li><li><a href=#repetition>Repetition</a></li></ol></li><li><a href=#built-in-macros>Built-In Macros</a></li></ol></li><li><a href=#chapter-22-unsafe-code>Chapter 22. Unsafe Code</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/tech/>Tech</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/2022/07/05/Programming-Rust/>Programming Rust</a></h2><h3 class=article-subtitle>记录了学习《Programming Rust》笔记。</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jul 05, 2022</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading></time></div></footer></div></header><section class=article-content><p>记录了学习《Programming Rust》笔记。</p><h2 id=chapter-3-fundamental-types>Chapter 3. Fundamental Types</h2><ul><li>Rust有类型推断</li><li>函数可以是泛型的</li></ul><p>Rust的类型</p><div class=table-wrapper><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>i8,i16,i32,i64,i128,u8,u16,u32,u64,u128</td><td></td></tr><tr><td>isize,usize</td><td></td></tr><tr><td>f32,f64</td><td></td></tr><tr><td>bool</td><td></td></tr><tr><td>char</td><td></td></tr><tr><td>(char, u8, i32)</td><td>元组</td></tr><tr><td>()</td><td></td></tr><tr><td><code>struct S { x: f32, y:f32 }</code></td><td>结构体</td></tr><tr><td><code>struct T (i32, char);</code></td><td>Tuple-like struct</td></tr><tr><td><code>struct E;</code></td><td>Unit-like struct; has no fields</td></tr><tr><td><code>enum Attend { OnTime, Late(u32) }</code></td><td></td></tr><tr><td><code>Box&lt;Attend></code></td><td></td></tr><tr><td>&amp;i32,&amp;mut i32</td><td></td></tr><tr><td>String</td><td></td></tr><tr><td>&amp;str</td><td></td></tr><tr><td>[f64; 4], [u8; 256]</td><td></td></tr><tr><td><code>Vec&lt;f64></code></td><td></td></tr><tr><td>&[u8], &amp;mut [u8]</td><td></td></tr><tr><td>Option&lt;&amp;str></td><td></td></tr><tr><td>Result&lt;u64, Error></td><td></td></tr><tr><td>&amp;dyn Any, &amp;mut dyn Read</td><td></td></tr><tr><td>fn(&amp;str) -> bool</td><td></td></tr><tr><td>(Clousure types have no written form)</td><td>Clousure</td></tr></tbody></table></div><h3 id=fixed-width-numerical-types>Fixed-Width Numerical Types</h3><p>如果需要任意精度表示的一些数值，可以查看 <em>num</em> 包。</p><h4 id=integer-types>Integer Types</h4><p>不像C和C++，Rust将字符看作是和数值不同的类型，一个 char 不是 u8，也不是 u32（尽管字符是32位长的）。</p><p>Rust要求数组的索引必须是 usize 类型的值。</p><p>在Rust整数可以带一个后缀来表示它们的类型，比如<code>42u8</code>。如果没有给整数指定具体的类型，Rust会将值存放在一个特定的类型中，传给函数期望的参数，比较另一个有别的特定类型的值，最后，如果有多个可能，而 <code>i32</code>是其中一个的话，就默认是 <code>i32</code>类型，否则就会报错。</p><p>前缀<code>0x</code>，<code>0o</code>和<code>0b</code>表示十六进制、八进制和二进制。</p><p>为了更清楚地表示很长的数字，还可以给数字加下划线，比如<code>4_294_967_295</code>。有前缀和后缀的数字依然可以加下划线。</p><p>尽管Rust中数字和字符是不同的类型，但是也提供了 <strong>字节字面量</strong>（ <em>byte literals</em>），即用类字符字面量表示u8值：<code>b'X'</code>代表的ASCII编码的字符<code>X</code>，它是一个u8值。比如，由于字符A的ASCII编码是65，因此<code>b'A'</code>等价于<code>65u8</code>。字节字面量中只能出现在ASCII编码的字符。</p><p>特殊的ACSII编码的字符</p><div class=table-wrapper><table><thead><tr><th>Character</th><th>Byte literal</th></tr></thead><tbody><tr><td>单引号</td><td><code>b'\''</code></td></tr><tr><td>反斜杠</td><td><code>b'\\'</code></td></tr><tr><td>换行</td><td><code>b'\n'</code></td></tr><tr><td>回车</td><td><code>b'\r'</code></td></tr><tr><td>制表符</td><td><code>b'\t'</code></td></tr></tbody></table></div><p>对于一些ASCII编码的字符可以用十六进制来表示，这样更容易阅读。比如<code>b'\x1b'</code>。</p><p>整数类型之间转换可以用 <code>as</code> 操作符。比如 <code>10_i8 as u16</code>。</p><p>整数的一些方法，参见 <a class=link href=https://rustwiki.org/zh-CN/std/primitive.i32.html# target=_blank rel=noopener>std::i32</a>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>assert_eq!</span><span class=p>(</span><span class=mi>2_</span><span class=k>u16</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=mi>4</span><span class=p>),</span><span class=w> </span><span class=mi>16</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>((</span><span class=o>-</span><span class=mi>4_</span><span class=k>i32</span><span class=p>).</span><span class=n>abs</span><span class=p>(),</span><span class=w> </span><span class=mi>4</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mb>0b101101_</span><span class=k>u8</span><span class=p>.</span><span class=n>count_ones</span><span class=p>(),</span><span class=w> </span><span class=mi>4</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>看下面这段代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=o>-</span><span class=mi>4</span><span class=p>).</span><span class=n>abs</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这里没有给出数值的类型，是不是默认 <code>i32</code> 呢？但其实会报错：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>error: can&#39;t call method `abs` on ambiguous numeric type `{integer}`
</span></span></code></pre></td></tr></table></div></div><p>为什么会这样子呢？因为Rust想要在调用一个类型自己的方法之前明确地知道一个值的整数类型。i32 的默认值仅适用于在所有方法调用都已解决后类型仍然不明确的情况，在这里就太晚了，因此会报错。换句话说，就是这里我要先调用 <code>abs()</code>方法，这个时候需要确定类型，还没等推断出默认类型，就已经报错了。解决方案：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=o>-</span><span class=mi>4_</span><span class=k>i32</span><span class=p>).</span><span class=n>abs</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=kt>i32</span>::<span class=n>abs</span><span class=p>(</span><span class=o>-</span><span class=mi>4</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>注意<strong>方法调用会发生在一元前缀操作符之前</strong>，所以处理负数的时候要当心。比如<code>-4_i32.abs()</code>，这里没有括号，会先调用函数<code>4_i32.abs()</code>，然后再取负号，最终结果为-4。</p><h4 id=checked-wrapping-saturating-and-overflowing-arithmetic>Checked, Wrapping, Saturating, and Overflowing Arithmetic</h4><p>在Debug模式下，如果整数数值操作溢出，会报错。但是在发布模式构建的时候，会 <em>wraps</em>。</p><blockquote><p>In a release build, the operation <em>wraps around</em>: it produces the value equivalent to the mathematically correct result modulo the range of the value. (In neither case is overflow undefined behavior, as it is in C and C++.)</p></blockquote><p>上述是默认的，如果这不是你想要的，可以调用一些方法，主要有四类。</p><ul><li><em><strong>Checked</strong></em> operations return an Option of the result: Some(v) if the mathematically correct result can be represented as a value of that type, or None if it cannot.</li><li><em><strong>Wrapping</strong></em> operations return the value equivalent to the mathematically correct result modulo the range of the value.</li><li><em><strong>Saturating</strong></em> operations return the representable value that is closest to the mathematically correct result. In other words, the result is “clamped” to the maximum and minimum values the type can represent.</li><li><em><strong>Overflowing</strong></em> operations return a tuple (result, overflowed), where result is what the wrapping version of the function would return, and overflowed is a bool indicating whether an overflow occurred.</li></ul><div class=table-wrapper><table><thead><tr><th>Operation</th><th>Name suffix</th><th>Example</th></tr></thead><tbody><tr><td>Addition</td><td>add</td><td>100_i8.checked_add(27) == Some(127)</td></tr><tr><td>Subtraction</td><td>sub</td><td>10_u8.checked_sub(11) == None</td></tr><tr><td>Multiplication</td><td>mul</td><td>128_u8.saturating_mul(3) == 255</td></tr><tr><td>Division</td><td>div</td><td>64_u16.wrapping_div(8) == 8</td></tr><tr><td>Remainder</td><td>rem</td><td>(-32768_i16).wrapping_rem(-1) == 0</td></tr><tr><td>Negation</td><td>neg</td><td>(-128_i8).checked_neg() == None</td></tr><tr><td>Absolute value</td><td>abs</td><td>(-32768_i16).wrapping_abs() == -32768</td></tr><tr><td>Exponentiation</td><td>pow</td><td>3_u8.checked_pow(4) == Some(81)</td></tr><tr><td>Bitwise left shift</td><td>shl</td><td>10_u32.wrapping_shl(34) == 40</td></tr><tr><td>Bitwise right shift</td><td>shr</td><td>40_u64.wrapping_shr(66) == 10</td></tr></tbody></table></div><h4 id=floating-point-types>Floating-Point Types</h4><p><img src=/img/2022-07-05-Programming-Rust/programming-rust-floating-point.png loading=lazy alt=img></p><p>整数部分后的分数部分，指数或者类型后缀至少包含一个，来区别于整数字面量。<code>5.</code>整数部分之后只有一个小数点，也是一个有效的浮点数常数。</p><p>浮点数默认类型是 f64 。</p><p>为了类型推断的目的，Rust中整数和浮点数之间不会进行相互推断。</p><p>f32和f64都有一些特殊值，如 <code>INFINITY</code>，<code>NEG_INFINITY</code>，<code>NAN</code>（that not-a-number value），<code>MIN</code>和<code>MAX</code>。</p><p><a class=link href=https://rustwiki.org/zh-CN/std/primitive.f32.html target=_blank rel=noopener>std::f32</a>和<a class=link href=https://rustwiki.org/zh-CN/std/primitive.f64.html target=_blank rel=noopener>std::f64</a>提供了很多方法。</p><p><a class=link href=https://rustwiki.org/zh-CN/std/f32/consts/index.html target=_blank rel=noopener>std::f32::consts</a>和<a class=link href=https://rustwiki.org/zh-CN/std/f64/consts/index.html target=_blank rel=noopener>std::f64::consts</a>提供一些数学常量。</p><p>Rust是没有数值的隐式转换的，所以如果传入的参数类型和函数的参数类型不一致，这里不会发生隐式转换，因此会报错。想要转换只能显式地用 <code>as</code> 操作符。</p><h3 id=the-bool-type>The bool Type</h3><p>在Rust中，bool类型的值为 true 和 false。</p><p>Rust中在要求一个Boolean值的上下文中是非常严格的。控制结构<code>if</code>和<code>while</code>要求条件必须是 bool 表达式， 短路逻辑操作符 <code>&&</code> 和 <code>||</code> 也要求必须是 bool 表达式。必须 <code>if x!= 0 { ... }</code>这样写，而不能简单地写为 <code>if x { ... }</code>。</p><p>Rust可以用 as 操作符将 bool 值转换为数字，但是不能反过来将数值转换为 bool 值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>assert_eq!</span><span class=p>(</span><span class=kc>false</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=kc>true</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>虽然可以只有一位就表示 bool 值，但是Rust底层用一整个字节来存储 bool 值，这样的话就可以创建一个指针来指向它。</p><h3 id=characters>Characters</h3><p>char 类型表示单个Unicode字符，占 32 位。</p><p>字符可以用十六进制来表示或者<code>\u{}</code>来表示。</p><ul><li>如果字符编码在ASCII编码范围内，可以用十六进制。例如<code>'\xHH'</code>。</li><li>也可以用<code>\u{}</code>来表示任何的Unicode编码字符。例如<code>'\u{HHHHHH}'</code>。</li></ul><p>字符必须在有效的 Unicode 码点范围内。</p><p>char 和其他类型之间没有隐式地转换。当然可以显式用 as 操作符将 char 类型转换成一个整数类型，如果类型小于32位，会进行截断。相反地，只有 u8 类型能用 as 操作符显式地转换为 char 类型。这一点也很自然，Rust要保证可靠，其他数值类型转换成 char 类型时，可能是无效的字符。不过<code>std::char::from_u32</code>可以将任何 u32 类型的值转换，返回的是 <code>Option&lt;char></code>。</p><p><a class=link href=https://rustwiki.org/zh-CN/std/primitive.char.html target=_blank rel=noopener>char(primitive type)</a>文档有相关的方法。</p><h3 id=tuples>Tuples</h3><p>元组可以将不同类型的值组合在一起，可以用在返回多个不同类型的值的函数中。</p><p>用 <code>a.0</code>可以来获取具体的元素。</p><p>元组的索引必须是常数，不可以是变量，比如<code>t[i]</code>或者<code>t.i</code>就是错误的。</p><p>可以用模式匹配得到元组对应的值。在指定变量值或者函数返回多个值时很有用。用元组来表示相关的变量是很清晰的，比如宽和高，可以用一个元组把它们放在一起，语义更加清晰。</p><p>unit type <code>()</code>可以用于函数的返回类型，表示什么也不返回。</p><p>可以在元组的最后加上逗号，容易看出列表删除或添加了元素。如果是单个值，<code>("lonely hearts",)</code>相比 <code>("lonely hearts")</code>更加清晰，可以判断是元组而不是括号表达式。</p><h3 id=pointer-types>Pointer Types</h3><h4 id=references>References</h4><p><code>&amp;x</code> 产生了对 <code>x</code> 的一个引用，用Rust的术语来说是向 <code>x</code> 借了一个引用。</p><p>在Rust中，引用始终不为空。Rust会跟踪值的所有权和生命周期，在编译时期会检查出悬垂指针，二次释放以及指针无效的错误。</p><ul><li>& T：不可变的共享引用</li><li>&amp;mut T：可变的独占引用</li></ul><p>将不可变引用和可变引用看作单个读-写者和多个读者。</p><h4 id=boxes>Boxes</h4><p>用于堆分配的指针类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>12</span><span class=p>,</span><span class=w> </span><span class=s>&#34;eggs&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>t</span><span class=p>);</span><span class=w> </span><span class=c1>// 在堆上分配内存，类型为 Box&lt;(i32, &amp;str)&gt;
</span></span></span></code></pre></td></tr></table></div></div><h4 id=raw-pointers>Raw Pointers</h4><ul><li>*const T</li><li>*mut T</li></ul><p>只能在 unsafe 块中对原始指针解引用。</p><h3 id=arrays-vectors-and-slices>Arrays, Vectors, and Slices</h3><p>有三种类型表示内存中连续的一块数据。</p><ul><li><code>[T; N]</code>表示数组。数组的长度必须要在编译时期就确定。</li><li><code>Vec&lt;T></code> 表示 T 类型的向量。动态分配的，元素存放在堆上。</li><li><code>&[T]</code>和<code>&amp;mut [T]</code> 称为 T 的共享切片或可变切片。可以把切片看作是一个胖指针，指向第一个元素，同时还包含可以访问到的元素的个数。</li></ul><p>一些方法：</p><ul><li><code>v.len()</code> 返回元素的个数。</li><li><code>v[i]</code> 表示 v 的第 i 个元素，注意这里索引 i 必须是 usize 类型的。Rust总是会去检查 i 有没有在有效的范围内。</li></ul><h4 id=arrays>Arrays</h4><p>直接用方括号生成数组，或者[T; N]生成数组，Rust不提供未初始化的数组。</p><p>数组的长度必须在编译时就确定，不可以用变量，比如<code>[true; n]</code> 这就是错误的。如果想在运行期间获得数组的长度，应该用向量。</p><p>在调用一些数组的方法时，Rust会隐式地将一个数组的引用转换为切片，这样可以直接在一个数组上使用任何切片的方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>chaos</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>chaos</span><span class=p>.</span><span class=n>sort</span><span class=p>();</span><span class=w> </span><span class=c1>// 这里隐式地转换为 &amp;mut [i32]，调用了切片的 sort 方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>chaos</span><span class=p>,</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>关于这一点，<a class=link href=https://rustwiki.org/zh-CN/std/primitive.array.html target=_blank rel=noopener>官方文档</a>是这样说的。</p><blockquote><p>数组强制转换为 <code>slices ([T]) </code>，因此可以在数组上调用 slice 方法。实际上，这提供了用于处理数组的大多数 API。 切片具有动态大小，并且不强制转换为数组。</p></blockquote><h4 id=vectors>Vectors</h4><p>在堆上分配的容器。</p><p>可以用 <code>vec!</code>或者<code>Vec::new()</code>来生成新的 vector。</p><p>可以动态添加元素:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>primes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>7</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>primes</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>11</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>可以用重复表达式来创建 vector：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>new_pixel_buffer</span><span class=p>(</span><span class=n>rows</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>cols</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>rows</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>cols</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>迭代器构造：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>v</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=mi>5</span><span class=p>).</span><span class=n>collect</span><span class=p>();</span><span class=w> </span><span class=c1>// 这里必须指定 v 的类型，因为 collect 方法有很多种
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>和数组一样，向量也会在调用一些方法时隐式地转换为切片类型。</p><p>一个 <code>Vec&lt;T></code> 包含三个值：指向元素的堆 buffer 的指针，这个是被 <code>Vec&lt;T></code> 所创建和拥有的； buffer 中的容量；包含元素的个数，也就是长度。</p><p>知道向量的容量，可以用<code>Vec::with_capacity</code>来创建。提升效率，减少重新分配空间。</p><p><code>capacity</code>方法返回向量不需要再分配时向量的容量。</p><p>一些方法：</p><ul><li>insert</li><li>remove</li><li>pop</li></ul><p>可以用 for 在向量上进行迭代。</p><h4 id=slices>Slices</h4><p>切片，直接指向引用的数据，看作一个胖指针，指向第一个元素，以及包含 len。</p><h3 id=string-types>String Types</h3><h4 id=string-literals>String Literals</h4><p>字符串字面量在双引号内。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 空格和换行照样输出
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;In the room the women come and go,
</span></span></span><span class=line><span class=cl><span class=s>  Singing of Mount Abora&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 去掉换行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;It was a bright, cold day in April, and </span><span class=se>\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>      there were four of us—</span><span class=se>\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>      more or less.&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// raw strings
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>default_win_install_path</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=sa>r</span><span class=s>&#34;C:\Program Files\Gorillas&#34;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>pattern</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Regex</span>::<span class=n>new</span><span class=p>(</span><span class=sa>r</span><span class=s>&#34;\d+(\.\d+)*&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 包含双引号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>println!</span><span class=p>(</span><span class=sa>r</span><span class=s>###&#34;
</span></span></span><span class=line><span class=cl><span class=s>      This raw string started with &#39;r###&#34;&#39;.
</span></span></span><span class=line><span class=cl><span class=s>      Therefore it does not end until we reach a quote mark (&#39;&#34;&#39;)
</span></span></span><span class=line><span class=cl><span class=s>      followed immediately by three pound signs (&#39;###&#39;):
</span></span></span><span class=line><span class=cl><span class=s>&#34;###</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=byte-strings>Byte Strings</h4><p>带有 b 前缀的是一个字节字面量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>method</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=sa>b</span><span class=s>&#34;GET&#34;</span><span class=p>;</span><span class=w> </span><span class=c1>// &amp;[u8; 3] 类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>method</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=p>[</span><span class=sa>b</span><span class=sc>&#39;G&#39;</span><span class=p>,</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;E&#39;</span><span class=p>,</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;T&#39;</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=strings-in-memory>Strings in Memory</h4><p>内存中以UTF-8编码存储。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>noodles</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;noodles&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w> </span><span class=c1>// String 底层是 Vec&lt;u8&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>oodles</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>noodles</span><span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=p>];</span><span class=w> </span><span class=c1>// &amp;str
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>poodles</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;ಠ_ಠ&#34;</span><span class=p>;</span><span class=w> </span><span class=c1>// &amp;str
</span></span></span></code></pre></td></tr></table></div></div><p>内存布局：</p><p><img src=/img/2022-07-05-Programming-Rust/rust-programming-string.png loading=lazy alt=img></p><h4 id=string>String</h4><p><code>&amp;str</code>像<code>&[T]</code>，而 <code>String</code>像<code>Vec&lt;T></code>。</p><p>创建 String:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// to_string 方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>error_message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;too many pets&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// format!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>°</span><span class=si>{:02}</span><span class=s>′</span><span class=si>{:02}</span><span class=s>′′N&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>24</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>23</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                     </span><span class=s>&#34;24°05′23′′N&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 数组、向量的 concat、join 方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>bits</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;veni&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;vidi&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;vici&#34;</span><span class=p>];</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>bits</span><span class=p>.</span><span class=n>concat</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;venividivici&#34;</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>bits</span><span class=p>.</span><span class=n>join</span><span class=p>(</span><span class=s>&#34;, &#34;</span><span class=p>),</span><span class=w> </span><span class=s>&#34;veni, vidi, vici&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=using-strings>Using Strings</h4><p>Strings support the == and != operators. Two strings are equal if they contain the same characters in the same order (regardless of whether they point to the same location in memory).</p><h4 id=other-string-like-types>Other String-Like Types</h4><ul><li>Stick to <strong>String</strong> and <strong>&amp;str</strong> for Unicode text.</li><li>When working with filenames, use <strong>std::path::PathBuf</strong> and <strong>&amp;Path</strong> instead.</li><li>When working with binary data that isn’t UTF-8 encoded at all, use <strong><code>Vec&lt;u8></code></strong> and <strong>&[u8]</strong>.</li><li>When working with environment variable names and command-line arguments in the native form presented by the operating system, use <strong>OsString</strong> and <strong>&amp;OsStr</strong>.</li><li>When interoperating with C libraries that use null-terminated strings, use <strong>std::ffi::CString</strong> and <strong>&amp;CStr</strong>.</li></ul><h3 id=type-aliases>Type Aliases</h3><p>类型别名用 <code>type</code> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>type</span> <span class=nc>Bytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=chapter-4-ownership-and-moves>Chapter 4. Ownership and Moves</h2><p>管理内存，想达到的效果：</p><ul><li>当我们选择一个时间时，内存可以及时释放</li><li>内存释放后，不再有指针指向它</li></ul><p>目前的内存管理方案：</p><ul><li>GC，垃圾回收。解决了悬垂指针的问题，但是会出现世界停时，也就是我们期望释放内存的时候，它还没有释放。</li><li>自己完全控制内存，比如C和C++。但是对程序员要求高，使用不当有时也会发生错误。</li></ul><p>Rust是怎么解决这个问题的呢？秘密武器就是限制你的程序对指针的使用。给的这些限制会保证安全，但也不会丧失自由度。书中这样写道：</p><blockquote><p>Rust’s radical wager, the claim on which it stakes its success and that forms the root of the language, is that <strong>even with these restrictions in place, you’ll find the language more than flexible enough for almost every task and that the benefits</strong>—the elimination of broad classes of memory management and concurrency bugs—will justify the adaptations you’ll need to make to your style. The authors of this book are bullish on Rust exactly because of our extensive experience with C and C++. For us, Rust’s deal is a no-brainer.</p></blockquote><h3 id=ownership>Ownership</h3><p>在Rust中，所有权的概念是内建在语言中的，并且会通过编译器检查强制执行。每个值都有一个所有者，这个所有者决定它的生命周期。当所有者被释放时，它所拥有的值也会被释放。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>((</span><span class=mf>0.625</span><span class=p>,</span><span class=w> </span><span class=mf>0.5</span><span class=p>));</span><span class=w> </span><span class=c1>// point allocated here 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>label</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>point</span><span class=p>);</span><span class=w> </span><span class=c1>// label allocated here , 这里返回 String
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>label</span><span class=p>,</span><span class=w> </span><span class=s>&#34;(0.625, 0.5)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>									  </span><span class=c1>// both dropped here
</span></span></span></code></pre></td></tr></table></div></div><p>内存布局：</p><p><img src=/img/2022-07-05-Programming-Rust/rust-programming-fig4-3.png loading=lazy alt=image-20220709110854213></p><p>像变量会拥有它的值，结构体会拥有它们的字段，元组、数组以及向量会拥有它们的元素。</p><p>再看一个复杂的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Person</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=n>birth</span>: <span class=kt>i32</span> <span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>composers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>composers</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Person</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=s>&#34;Palestrina&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>birth</span>: <span class=mi>1525</span><span class=w> </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>composers</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Person</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=s>&#34;Dowland&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>birth</span>: <span class=mi>1563</span><span class=w> </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>composers</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Person</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=s>&#34;Lully&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>												</span><span class=n>birth</span>: <span class=mi>1632</span><span class=w> </span><span class=p>});</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>composer</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>&amp;</span><span class=n>composers</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>, born </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>composer</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>composer</span><span class=p>.</span><span class=n>birth</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>内存布局：</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220709111433484.png loading=lazy alt=image-20220709111433484></p><p>每个值都有一个单独的所有者，这个所有者很容易来决定什么时候 drop 它所拥有的值。但是一个单独的值可能会拥有很多其他的值，如上面这个例子中的向量 composers。所有者和它们所拥有的值会形成一个<strong>树</strong>。在每个树的根部是一个变量，当这个变量离开它的作用范围，整棵树也会跟着离开。</p><p>Rust通常不会显式地 drop 它的值，而是通过：离开变量的作用域，从向量中删除一个元素，或者其他的。</p><p>Rust怎么在这些严格的限制下实现灵活性呢？如下列出了一些方式：</p><ul><li>You can <strong>move</strong> values from one owner to another. This allows you to build, rearrange, and tear down the tree.</li><li>Very simple types like integers, floating-point numbers, and characters are excused from the ownership rules. These are called <strong>Copy</strong> types.</li><li>The standard library provides the reference-counted pointer types <strong>Rc</strong> and <strong>Arc</strong>, which allow values to have multiple owners, under some restrictions.</li><li>You can “<strong>borrow a reference</strong>” to a value; references are non-owning pointers, with limited lifetimes.</li></ul><h3 id=moves>Moves</h3><p>In Rust, for most types, operations like assigning a value to a variable, passing it to a function, or returning it from a function don’t copy the value: they <em>move</em> it. <strong>The source</strong> relinquishes ownership of the value to the destination and <strong>becomes uninitialized</strong>; the destination now controls the value’s lifetime. Rust programs build up and tear down complex structures one value at a time, one move at a time.</p><p>看看Python中的变量赋值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;udon&#39;</span><span class=p>,</span> <span class=s1>&#39;ramen&#39;</span><span class=p>,</span> <span class=s1>&#39;soba&#39;</span><span class=p>]</span> 
</span></span><span class=line><span class=cl><span class=n>t</span><span class=o>=</span><span class=n>s</span>
</span></span><span class=line><span class=cl><span class=n>u</span><span class=o>=</span><span class=n>s</span>
</span></span></code></pre></td></tr></table></div></div><p>开始的内存布局：</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220709132630820.png loading=lazy alt=image-20220709132630820></p><p>执行代码后的内存布局：</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220709131847520.png loading=lazy alt=image-20220709131847520></p><p>Python has copied the pointer from s into t and u and updated the list’s reference count to 3. Assignment in Python is cheap, but because it creates a new reference to the object, we must maintain reference counts to know when we can free the value.</p><p>来看看C++中的实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>s</span> <span class=o>=</span> <span class=p>{</span> <span class=s>&#34;udon&#34;</span><span class=p>,</span> <span class=s>&#34;ramen&#34;</span><span class=p>,</span> <span class=s>&#34;soba&#34;</span> <span class=p>};</span> 
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>t</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>u</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>开始的内存布局</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220709132451059.png loading=lazy alt=image-20220709132451059></p><p>代码执行后的内存布局：</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220709132539575.png loading=lazy alt=image-20220709132539575></p><p>Depending on the values involved, assignment in C++ can consume unbounded amounts of memory and processor time. The advantage, however, is that it’s easy for the program to decide when to free all this memory: when the variables go out of scope, everything allocated here gets cleaned up automatically.</p><p>Rust中的实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;udon&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;ramen&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;soba&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()];</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>开始的内存分布：</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220709132918760.png loading=lazy alt=image-20220709132918760></p><p>在<code>let t = s;</code>之后，s 的所有权就 move 到 t 上了。</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220709133027720.png loading=lazy alt=image-20220709133027720></p><p>这时 s 变成未初始化状态，再执行 <code>let u = s;</code> 就会报错，因为使用了未初始化的变量。</p><p>Consider the consequences of Rust’s use of a move here. Like Python, the assignment is cheap: the program simply moves the three-word header of the vector from one spot to another. But like C++, ownership is always clear: the program doesn’t need reference counting or garbage collection to know when to free the vector elements and string contents.</p><p>如果想实现Python那样的引用计数，可以用 Rc 和 Arc，如果想实现C++那样的深拷贝，可以显式调用 clone() 方法。</p><h4 id=more-operations-that-move>More Operations That Move</h4><p>move语义的发生：</p><ul><li>给一个函数传递参数，会将所有权给参数</li><li>从函数返回一个值会将所有权给调用者</li><li>创建一个元组，会将值的所有权给元组</li></ul><p>Moving values around like this may sound inefficient, but there are two things to keep in mind. First, the moves always apply to the value proper, not the heap storage they own. For vectors and strings, the <em>value proper</em> is the three-word header alone; the potentially large element arrays and text buffers sit where they are in the heap. Second, the Rust compiler’s code generation is good at “seeing through” all these moves; in practice, the machine code often stores the value directly where it belongs.</p><h4 id=moves-and-control-flow>Moves and Control Flow</h4><p>If it’s possible for a variable to have had its value moved away and it hasn’t definitely been given a new value since, it’s considered uninitialized.</p><h4 id=moves-and-indexed-content>Moves and Indexed Content</h4><p>We’ve mentioned that a move leaves its source uninitialized, as the destination takes ownership of the value. <strong>But not every kind of value owner is prepared to become uninitialized.</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Build a vector of the strings &#34;101&#34;, &#34;102&#34;, ... &#34;105&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>101</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=mi>106</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>v</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Pull out random elements from the vector.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>third</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span><span class=w> </span><span class=c1>// error: Cannot move out of index of Vec 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>fifth</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span><span class=w> </span><span class=c1>// here too
</span></span></span></code></pre></td></tr></table></div></div><p>要将 vector 看作一个整体，这里不能单独将 v[2] move 出来。如果确实想拿出其中的元素，有下面一些方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Build a vector of the strings &#34;101&#34;, &#34;102&#34;, ... &#34;105&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>101</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=mi>106</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>v</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 1. Pop a value off the end of the vector:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>fifth</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>pop</span><span class=p>().</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;vector empty!&#34;</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>fifth</span><span class=p>,</span><span class=w> </span><span class=s>&#34;105&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// [&#34;101&#34;, &#34;102&#34;, &#34;103&#34;, &#34;104&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 2. Move a value out of a given index in the vector, 
</span></span></span><span class=line><span class=cl><span class=c1>// and move the last element into its spot:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>second</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>swap_remove</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>second</span><span class=p>,</span><span class=w> </span><span class=s>&#34;102&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// [&#34;101&#34;, &#34;104&#34;, &#34;103&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 3. Swap in another value for the one we&#39;re taking out:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>third</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span>::<span class=n>mem</span>::<span class=n>replace</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span><span class=w> </span><span class=s>&#34;substitute&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>third</span><span class=p>,</span><span class=w> </span><span class=s>&#34;103&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// [&#34;101&#34;, &#34;104&#34;, &#34;substitute&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Let&#39;s see what&#39;s left of our vector.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;101&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;104&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;substitute&#34;</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>来看看循环</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;liberté&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  			    </span><span class=s>&#34;égalité&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=s>&#34;fraternité&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>s</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=sc>&#39;!&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这里在for循环中，v 的所有权给了for循环，v 就变成未初始化的状态，然后 for 循环分离每一个元素，将所有权给每一个。因为 s 有所有权，就可以在内部修改字符串了。</p><p>由于在循环中将 v 的所有权给了循环，因此后面就不能再使用 v 了，下面代码就会报错。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;liberté&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  				</span><span class=s>&#34;égalité&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  				</span><span class=s>&#34;fraternité&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>s</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=sc>&#39;!&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>_u</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>;</span><span class=w> </span><span class=c1>// error[E0382]: use of moved value: `v`
</span></span></span></code></pre></td></tr></table></div></div><p>如果想得到结构体中的元素值，可以调用 <code>std::mem::replace</code>方法，将原来的值用<code>None</code>来占位。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Person</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>birth</span>: <span class=kt>i32</span> <span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>composers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>composers</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Person</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=nb>Some</span><span class=p>(</span><span class=s>&#34;Palestrina&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>birth</span>: <span class=mi>1525</span><span class=w> </span><span class=p>});</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span>::<span class=n>mem</span>::<span class=n>replace</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>composers</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// let first_name = composers[0].name.take(); // 和上述语句达到的效果一样
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>first_name</span><span class=p>,</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;Palestrina&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>composers</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=copy-types-the-exception-to-moves>Copy Types: The Exception to Moves</h3><p>Assigning a value of a Copy type copies the value, rather than moving it. The source of the assignment remains initialized and usable, with the same value it had before. Passing Copy types to functions and constructors behaves similarly.</p><p>The standard Copy types include all the machine integer and floating-point numeric types, the char and bool types, and a few others. A tuple or fixed-size array of Copy types is itself a Copy type.</p><p>Only types for which a simple bit-for-bit copy suffices can be Copy. As a rule of thumb, any type that needs to do something special when a value is dropped cannot be Copy.</p><p>自定义的结构体或者枚举类型可以用属性宏实现 Copy trait。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Copy, Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Label</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>number</span>: <span class=kt>u32</span> <span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>In Rust, every move is a byte-for-byte, shallow copy that leaves the source uninitialized. Copies are the same, except that the source remains initialized.</p><p>One of Rust’s principles is that costs should be apparent to the programmer. Basic operations must remain simple. Potentially expensive operations should be explicit, like the calls to <code>clone</code> in the earlier example that make deep copies of vectors and the strings they contain.</p><h3 id=rc-and-arc-shared-ownership>Rc and Arc: Shared Ownership</h3><p>The Rc and Arc types are very similar; the only difference between them is that an Arc is safe to share between threads directly—the name Arc is short for <em>atomic reference count</em>—whereas a plain Rc uses faster non-thread-safe code to update its reference count.</p><p>前面的例子用Rust实现Python中引用计数的效果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>rc</span>::<span class=n>Rc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Rust can infer all these types; written out for clarity
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>s</span>: <span class=nc>Rc</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;shirataki&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>t</span>: <span class=nc>Rc</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>u</span>: <span class=nc>Rc</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>内存布局：</p><p><img src=/image-20220709143228683.png loading=lazy alt=image-20220709143228683></p><p>Rust’s memory and thread-safety guarantees depend on ensuring that no value is ever simultaneously shared and mutable. Rust assumes the referent of an Rc pointer might in general be shared, so it must not be mutable.</p><p>However, Rust does provide ways to create mutable portions of otherwise immutable values; this is called <em>interior mutability</em>. 这可能造成循环引用。</p><p>想要用Rc避免循环引用。You can sometimes avoid creating cycles of Rc pointers by using <em>weak pointers</em>, <strong>std::rc::Weak</strong>, for some of the links instead.</p><h2 id=chapter-5-references>Chapter 5. References</h2><p>Rust also has non-owning pointer types called <em>references</em>, which have no effect on their referents’ lifetimes.</p><p>In fact, it’s rather the opposite: <strong>references must never outlive their referents</strong>. You must make it apparent in your code that no reference can possibly outlive the value it points to. To emphasize this, Rust refers to creating a reference to some value as <em>borrowing</em> the value: what you have borrowed, you must eventually return to its owner.</p><h3 id=references-to-values><strong>References to Values</strong></h3><p>A reference lets you access a value without affecting its ownership. References come in two kinds:</p><ul><li>A <em>shared reference</em> lets you read but not modify its referent. However, you can have as many shared references to a particular value at a time as you like. The expression <code>&amp;e </code>yields a shared reference to e’s value; if e has the type T, then &amp;e has the type &amp;T, pronounced “ref T.” Shared references are Copy.</li><li>If you have a <em>mutable reference</em> to a value, you may both read and modify the value. However, <strong>you may not have any other references of any sort to that value active at the same time</strong>. The expression &amp;mut e yields a mutable reference to e’s value; you write its type as &amp;mut T, which is pronounced “ref mute T.” Mutable references are not Copy.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>show</span><span class=p>(</span><span class=n>table</span>: <span class=kp>&amp;</span><span class=nc>Table</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>artist</span><span class=p>,</span><span class=w> </span><span class=n>works</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>table</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;works by </span><span class=si>{}</span><span class=s>:&#34;</span><span class=p>,</span><span class=w> </span><span class=n>artist</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>work</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>works</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;  </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>work</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Iterating over a shared reference to a HashMap is defined to produce shared references to each entry’s key and value: artist has changed from a <code>String</code> to a <code>&amp;String</code>, and works from a <code>Vec&lt;String></code> to a <code>&amp;Vec&lt;String></code>.</p><p>The inner loop is changed similarly. Iterating over a shared reference to a vector is defined to produce shared references to its elements, so work is now a &amp;String. No ownership changes hands anywhere in this function; it’s just passing around non-owning references.</p><p>When we pass a value to a function in a way that moves ownership of the value to the function, we say that we have passed it <em><strong>by value</strong></em>. If we instead pass the function a reference to the value, we say that we have passed the value <em><strong>by reference</strong></em>.</p><h3 id=working-with-references><strong>Working with References</strong></h3><h4 id=rust-references-versus-c-references><strong>Rust References Versus C++ References</strong></h4><p>In Rust, references are created explicitly with the <code>&</code> operator, and dereferenced explicitly with the <code>*</code> operator.</p><p>Since references are so widely used in Rust, the . operator implicitly dereferences its left operand, if needed.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Anime</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>bechdel_pass</span>: <span class=kt>bool</span> <span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>aria</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Anime</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=s>&#34;Aria: The Animation&#34;</span><span class=p>,</span><span class=w> </span><span class=n>bechdel_pass</span>: <span class=nc>true</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>anime_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>aria</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>anime_ref</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Aria: The Animation&#34;</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Equivalent to the above, but with the dereference written out:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>((</span><span class=o>*</span><span class=n>anime_ref</span><span class=p>).</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Aria: The Animation&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The <code>println!</code> macro used in the show function expands to code that uses the <code>. </code>operator.</p><p>The <code>. </code>operator can also implicitly borrow a reference to its left operand, if needed for a method call.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>1973</span><span class=p>,</span><span class=w> </span><span class=mi>1968</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>v</span><span class=p>.</span><span class=n>sort</span><span class=p>();</span><span class=w> </span><span class=c1>// implicitly borrows a mutable reference to v
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=p>).</span><span class=n>sort</span><span class=p>();</span><span class=w> </span><span class=c1>// equivalent, but more verbose
</span></span></span></code></pre></td></tr></table></div></div><h4 id=assigning-references><strong>Assigning References</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>20</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>y</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert!</span><span class=p>(</span><span class=o>*</span><span class=n>r</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=o>*</span><span class=n>r</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>20</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The reference r initially points to x. But if b is true, the code points it at y instead.</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220711094925795.png loading=lazy alt=image-20220711094925795></p><h4 id=references-to-references><strong>References to References</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kt>i32</span> <span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mi>1000</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mi>729</span><span class=w> </span><span class=p>};</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r</span>: <span class=kp>&amp;</span><span class=nc>Point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>point</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rr</span>: <span class=kp>&amp;&amp;</span><span class=nc>Point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>r</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rrr</span>: <span class=kp>&amp;&amp;&amp;</span><span class=nc>Point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>rr</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The . operator follows as many references as it takes to find its target.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>rrr</span><span class=p>.</span><span class=n>y</span><span class=p>,</span><span class=w> </span><span class=mi>729</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=/img/2022-07-05-Programming-Rust/image-20220711095223237.png loading=lazy alt=image-20220711095223237></p><p>So the expression <code>rrr.y</code>, guided by the type of <code>rrr</code>, actually traverses three references to get to the <code>Point</code> before fetching its <code>y</code> field.</p><h4 id=comparing-references><strong>Comparing References</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>ry</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>y</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rrx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>rx</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rry</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>ry</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert!</span><span class=p>(</span><span class=n>rrx</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>rry</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert!</span><span class=p>(</span><span class=n>rrx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>rry</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>比较操作符和<code>.</code>操作符一样可以解引用到最终的目标值。</p><p>可以用<code>std::ptr::eq</code>来比较地址是否相等：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>assert!</span><span class=p>(</span><span class=n>rx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>ry</span><span class=p>);</span><span class=w> </span><span class=c1>// their referents are equal 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert!</span><span class=p>(</span><span class=o>!</span><span class=n>std</span>::<span class=n>ptr</span>::<span class=n>eq</span><span class=p>(</span><span class=n>rx</span><span class=p>,</span><span class=w> </span><span class=n>ry</span><span class=p>));</span><span class=w> </span><span class=c1>// but occupy different addresses
</span></span></span></code></pre></td></tr></table></div></div><p>比较操作符两端的类型必须相同：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>assert!</span><span class=p>(</span><span class=n>rx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>rrx</span><span class=p>);</span><span class=w> </span><span class=c1>// error: type mismatch: `&amp;i32` vs `&amp;&amp;i32` 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert!</span><span class=p>(</span><span class=n>rx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>*</span><span class=n>rrx</span><span class=p>);</span><span class=w> </span><span class=c1>// this is okay
</span></span></span></code></pre></td></tr></table></div></div><h4 id=references-are-never-null><strong>References Are Never Null</strong></h4><p>Rust references are never null. There is no default initial value for a reference (you can’t use any variable until it’s been initialized, regardless of its type) and Rust won’t convert integers to references (outside of unsafe code), so you can’t convert zero into a reference.</p><p>In Rust, if you need a value that is either a reference to something or not, use the type <code>Option&lt;&amp;T></code>.</p><h4 id=borrowing-references-to-arbitrary-expressions><strong>Borrowing References to Arbitrary Expressions</strong></h4><p>Rust lets you borrow a reference to the value of any sort of expression at all:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>factorial</span><span class=p>(</span><span class=n>n</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>(</span><span class=mi>1</span><span class=o>..</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>).</span><span class=n>product</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>factorial</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Arithmetic operators can see through one level of references. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>r</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=o>&amp;</span><span class=mi>1009</span><span class=p>,</span><span class=w> </span><span class=mi>1729</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Rust simply creates an anonymous variable to hold the expression’s value and makes the reference point to that. The lifetime of this anonymous variable depends on what you do with the reference:</p><ul><li>If you immediately assign the reference to a variable in a let statement (or make it part of some struct or array that is being immediately assigned), then Rust makes the anonymous variable live as long as the variable the let initializes.</li><li>Otherwise, the anonymous variable lives to the end of the enclosing statement.</li></ul><h4 id=references-to-slices-and-trait-objects><strong>References to Slices and Trait Objects</strong></h4><p><em><strong>fat pointers</strong></em>:</p><ul><li><strong>A reference to a slice</strong> is a fat pointer, carrying the starting address of the slice and its length.</li><li>Rust’s other kind of fat pointer is a <em><strong>trait object</strong></em>, a reference to a value that implements a certain trait. A trait object carries a value’s address and a pointer to the trait’s implementation appropriate to that value, for invoking the trait’s methods.</li></ul><h3 id=reference-safety><strong>Reference Safety</strong></h3><h4 id=borrowing-a-local-variable><strong>Borrowing a Local Variable</strong></h4><p>You can’t borrow a reference to a local variable and take it out of the variable’s scope:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w> </span><span class=c1>// bad: reads memory `x` used to occupy 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The variables r and x both have a lifetime, extending from the point at which <strong>they’re initialized until the point that the compiler can prove they are no longer in use</strong>. The third lifetime is that of a reference type: the type of the reference we borrow to x and store in r.</p><p><strong>We say that the variable’s lifetime must <em>contain</em> or <em>enclose</em> that of the reference borrowed from it.</strong> 变量的生命周期必须包含或涵盖从它那里借来的引用的生命期。</p><p>Here’s another kind of constraint: <strong>if you store a reference in a variable r, the reference’s type must be good for the entire lifetime of the variable, from its initialization until its last us</strong>.</p><p><strong>We say that the reference’s lifetime must contain or enclose the variable’s.</strong> 引用的生命期必须包含或涵盖保存它的变量的生命期。</p><p>The first kind of constraint limits how large a reference’s lifetime can be, while the second kind limits how small it can be.</p><p>下面的生命周期是正确的：</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220711103418336.png loading=lazy alt=image-20220711103418336></p><p>First, understand the constraints arising from the way the program uses references; then, find lifetimes that satisfy them.</p><h4 id=receiving-references-as-function-arguments><strong>Receiving References as Function Arguments</strong></h4><ul><li><strong>Every static must be initialized.</strong></li><li>Mutable statics are inherently not thread-safe (after all, any thread can access a static at any time), and even in single-threaded programs, they can fall prey to other sorts of reentrancy problems. For these reasons, you may access a mutable static only within an unsafe block. In this example we’re not concerned with those particular problems, so we’ll just throw in an unsafe block and move on.</li></ul><p><code>fn f&lt;'a>(p: &'a i32)</code>, we’re defining a function that takes a reference to an i32 with any given lifetime &lsquo;a.</p><p>In other words, we were unable to write a function that stashed a reference in a global variable without reflecting that intention in the function’s signature. In Rust, a function’s signature always exposes the body’s behavior.</p><p>If we do see a function with a signature like <code>g(p: &amp;i32)</code> (or with the lifetimes written out, <code>g&lt;'a>(p: &'a i32)</code>), we can tell that it <em>does not</em> stash its argument <code>p</code> anywhere that will outlive the call.</p><h4 id=passing-references-to-functions><strong>Passing References to Functions</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// This could be written more briefly: fn g(p: &amp;i32), 
</span></span></span><span class=line><span class=cl><span class=c1>// but let&#39;s write out the lifetimes for now.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>g</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>g</span><span class=p>(</span><span class=o>&amp;</span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>从g的签名看，Rust知道它不会把p保存到超出调用生命周期的变量里；任何涵盖调用的生命周期都满足<code>'a</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>f</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>f</span><span class=p>(</span><span class=o>&amp;</span><span class=n>x</span><span class=p>);</span><span class=w> </span><span class=c1>// error
</span></span></span></code></pre></td></tr></table></div></div><p>这里 <code>&amp;x</code>不能存活得比<code>x</code>长，而函数签名要求<code>&amp;x</code>活得和<code>&'static</code>一样长，这就无法得到满足，因此报错。</p><h4 id=returning-references><strong>Returning References</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// v should have at least one element.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>smallest</span><span class=p>(</span><span class=n>v</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>i32</span><span class=p>])</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>i32</span> <span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>&amp;</span><span class=n>v</span><span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=k>if</span><span class=w> </span><span class=o>*</span><span class=n>r</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=o>*</span><span class=n>s</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如果一个函数只有一个引用作为参数并返回一个引用，则它们拥有相同的生命周期。</p><h4 id=structs-containing-references><strong>Structs Containing References</strong></h4><p>当引用类型出现在另一个类型的定义中时，必须写出其生命周期。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>S</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>r</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>i32</span> <span class=c1>// 这里 r 必须写上生命周期
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>或者</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>S</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>r</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>保存在r中的任何引用的生命周期最好包含<code>'a</code>，而<code>'a</code>也必须比保存在S的任何值都长寿。</p><p>The lifetime of any reference you store in r had better enclose &lsquo;a, and &lsquo;a must outlast the lifetime of wherever you store the S.</p><p>The assignment s = S { &mldr; } stores this S in a variable whose lifetime extends to the end of the example, constraining &lsquo;a to outlast the lifetime of s.</p><p>And now Rust has arrived at the same contradictory constraints as before: &lsquo;a must not outlive x, yet must live at least as long as s.</p><h4 id=distinct-lifetime-parameters><strong>Distinct Lifetime Parameters</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>S</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>x</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>y</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span> 
</span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>20</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=kp>&amp;</span><span class=nc>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kp>&amp;</span><span class=nc>y</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>x</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>If you work through the code carefully, you can follow its reasoning:</p><ul><li>Both fields of S are references with the same lifetime &lsquo;a, so Rust must find a single lifetime that works for both s.x and s.y.</li><li>We assign r = s.x, requiring &lsquo;a to enclose r’s lifetime. (r &lt;= &lsquo;a)</li><li>We initialized s.y with &amp;y, requiring &lsquo;a to be no longer than y’s lifetime. (&lsquo;a &lt;= y)</li></ul><h4 id=omitting-lifetime-parameters><strong>Omitting Lifetime Parameters</strong></h4><p>三条规则（见<a class=link href=https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html target=_blank rel=noopener>生命周期与引用有效性</a>）：</p><ul><li><p>第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;'a>(x: &'a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，<code>fn foo&lt;'a, 'b>(x: &'a i32, y: &'b i32)</code>，依此类推。</p></li><li><p>第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;'a>(x: &'a i32) -> &'a i32</code>。</p></li><li><p>第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，说明是个对象的方法(method)(译者注： 这里涉及 Rust 的面向对象参见 17 章), 那么所有输出生命周期参数被赋予 <code>self</code> 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。</p></li></ul><h3 id=sharing-versus-mutation>Sharing Versus Mutation</h3><p>Throughout its lifetime, a shared reference makes its referent read-only: you may not assign to the referent or move its value elsewhere.</p><ol><li><p><em>Shared access is read-only access.</em></p><p>Values borrowed by shared references are read-only. Across the lifetime of a shared reference, neither its referent, nor anything reachable from that referent, can be changed <em>by anything</em>. There exist no live mutable references to anything in that structure, its owner is held read-only, and so on. It’s really frozen.</p></li><li><p><em>Mutable access is exclusive access.</em></p><p>A value borrowed by a mutable reference is reachable exclusively via that reference. Across the lifetime of a mutable reference, there is no other usable path to its referent or to any value reachable from there. The only references whose lifetimes may overlap with a mutable reference are those you borrow from the mutable reference itself.</p></li></ol><h3 id=taking-arms-against-a-sea-of-objects><strong>Taking Arms Against a Sea of Objects</strong></h3><p><img src=/img/2022-07-05-Programming-Rust/image-20220712115540366.png loading=lazy alt=image-20220712115540366></p><p><img src=/img/2022-07-05-Programming-Rust/image-20220712115559036.png loading=lazy alt=image-20220712115559036></p><h2 id=chapter-6-expressions>Chapter 6. Expressions</h2><p>Rust中绝大多数都是表达式。</p><h3 id=an-expression-language>An Expression Language</h3><ul><li>在Rust中，if 和 match 都可以产生值。一个match表达式可以给一个函数或者宏来传参。</li><li>Rust 中没有三元操作符。</li><li>Rust中所有的控制流程工具是表达式。</li></ul><h3 id=precedence-and-associativity>Precedence and Associativity</h3><ul><li>闭包的优先级在最后。</li><li>All of the operators that can usually be chained are left-associative. 所有这些操作符在链式操作时都具有左关联性。</li><li>比较操作符，赋值操作符（assignment iperators）以及范围操作符（<code>..</code>range operators）不能链式链接。</li></ul><h3 id=blocks-and-semicolons>Blocks and Semicolons</h3><ul><li>block 的值是最后一个表达式的值。</li><li><strong>let 声明必须要有分号。</strong></li><li><strong>如果 if 表达式没有 else，那么总是返回 ()。</strong></li></ul><h3 id=declarations>Declarations</h3><ul><li>let 声明必须要有分号。</li><li>let 声明可以只声明变量而不初始化它。</li><li>在没有初始化一个变量之前是不能使用它的。</li><li>变量遮蔽，可以是不同的类型。</li><li><strong>一个块可以包含<em>特性项</em>（ item） declarations</strong>，就是指任何可以在程序或模块的全局中出现的声明，比如 fn，struct 或者 use。</li><li>嵌套的 fn 不能使用 scope 中的局部变量。</li><li>块中甚至可以包含一个完整的模块。</li></ul><h3 id=if-and-match>if and match</h3><ul><li><strong>if 表达式的 condition 必须是 bool 类型的</strong>，Rust 不会将数值或者指针隐式转换成 Boolean 类型。</li><li>在 if 表达式形式中，围绕条件的圆括号不是必需的。事实上，rustc在发现不必要的圆括号时会给出警告。但花括号是必需的。</li><li>一个只有 if 没有 else 的表达式相当于有一个 空的else 块。因此<strong>如果 if 表达式没有 else，那么总是返回 <code>()</code>。</strong></li><li>编译器可以用一个跳转表（ jump table ）来优化 match 表达式。如果 match 的每个分支都产生一个常量值，那么也可以应用同样的优化。此时，编译器会构建一个这些值的数组，而 match 会被编译为对数组的访问。除了边界检查，编译后的代码中根本没有分支。</li><li><strong>Rust 禁止 match 表达式没有覆盖到所有情况。</strong></li><li><strong>一个 if 表达式的所有块必须产生相同类型的值，对于 match 表达式也是一样的</strong>，match 表达式的所有分支也都必须返回相同类型的值。</li></ul><h3 id=if-let>if let</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>pattern</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>block1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>block2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>等价于</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>pattern</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>block1</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>block2</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=loops>Loops</h3><p>有四种 looping 表达式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>while</span><span class=w> </span><span class=n>condition</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>block</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>pattern</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>block</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>block</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>pattern</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>iterable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>block</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>while 和 for 的值一直都是 ()，循环的值是<code>()</code>。</li><li>用 loop 可以无限循环，除非遇到 break，return或者线程 panics。</li><li><strong><code>for</code> 循环每迭代一个值就会消耗一个值，有时候可以使用引用。</strong></li></ul><h3 id=control-flow-in-loops>Control Flow in Loops</h3><ul><li>break 只能在 loop 中，不能在 match 中。</li><li><strong>可以给 break 一个表达式，这个表达式的值就是 loop 的值。</strong></li><li>自然地，<strong>所有 break 表达式在一个循环中必须是相同类型的</strong>，并且这个类型就是 loop 的类型。</li><li><strong>循环可以加上生命周期的标签</strong>，然后可以 break 这个标签，break 也可以同时带上值表达式。</li><li>标签同样可以用于 continue。</li></ul><h3 id=return-expressions>return Expressions</h3><ul><li>return 表达式会退出当前函数，并且给调用者返回一个值。</li><li>可以将函数体看成一个块表达式。</li><li><strong>return 可以放弃正在运行中的工作。</strong></li></ul><h3 id=why-rust-has-loop>Why Rust Has loop</h3><p>Rust编译器分析你的程序的控制流程：</p><ul><li>检查返回类型</li><li>检查局部变量不会使用未初始化的值</li><li>警告不可到达的代码</li></ul><p>以上这些称为<strong>流敏感</strong>（flow-sensitive）分析。</p><p>Rust追求简单，其流敏感分析压根不会检查循环条件，而只是假设程序中的任何条件不是true就是false。</p><p><code>!</code> 表示是一个发散函数。比如 break，return，panic!()，无穷循环，std::process::exit() ，它们都不以惯常的方式结束，这些可以跳过之前说的类型一致规则。</p><h3 id=function-and-method-calls>Function and Method Calls</h3><ul><li><code>.location()</code> 方法可能取 player 的值或者引用。</li><li><code>.</code> 操作符可以自动的解引用 <code>player</code>或者借一个引用。可以接收值或引用。</li><li>静态方法<code>Vec::new()</code> ，非静态方法通过值调用：<code>my_vec.len()</code>。</li><li>对于泛型，函数或者方法调用要用比目鱼 turbofish 操作符，比如：<code>return Vec::&lt;i32>::with_capcity(1000);</code></li></ul><h3 id=fields-and-elements>Fields and Elements</h3><p>点操作符或者方括号的左侧是一个引用或者智能指针，那么它可以被自动地解引用，这样的表达式被称为 <strong><code>lvalues</code></strong>，它们可以出现在一个 assignment 的左侧。</p><p>操作符：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=o>..</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>a</span><span class=w> </span><span class=o>..</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>..</span><span class=w> </span><span class=n>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>a</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=n>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>..=</span><span class=w> </span><span class=n>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>a</span><span class=w> </span><span class=o>..=</span><span class=w> </span><span class=n>b</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=reference-operators>Reference Operators</h3><ul><li>&</li><li>& mut</li><li><code>*</code>操作符可以用来解引用</li></ul><h3 id=arithmetic-bitwise-comparsion-and-logical-operators>Arithmetic, Bitwise, Comparsion, and Logical Operators</h3><ul><li><strong>不能将<code>-</code>和<code>+</code> 用到无符号的数值类型上。</strong></li><li><code>%</code>也可以用在浮点数上。</li><li><code>!</code>表示按位非。</li><li>位操作符的优先级高于比较操作符的优先级。</li><li>比较操作符两端的类型必须都是 bool 类型。</li></ul><h3 id=assignment>Assignment</h3><ul><li>Rust中可以有复合操作符：<code>+=</code> <code>-=</code> <code>*=</code></li><li>Rust<strong>不支持</strong>链式 assignment，比如 <code>a = b = 3</code></li><li>Rust<strong>没有</strong>自增和自减操作符：<code>++</code>和<code>--</code>。</li></ul><h3 id=type-casts>Type Casts</h3><p>可以用 <code>as</code> 进行类型转换。几种类型转换是允许的：</p><ul><li>任何内置的数值之间可以转换。</li><li>bool、char 或者 C-like enum 类型可以转换为整数。u8 可能转换为 char 类型。</li><li>有些含有 unsafe 的指针类型的转换也是允许的。</li></ul><p>一些自动转换，被称为<em>解引用强制转换</em>（deref coercions）：</p><ul><li><code>&amp;String</code> -> <code>&amp;str</code></li><li><code>&amp;Vec&lt;i32></code> -> <code>&[i32]</code></li><li><code>&amp;Box[Chessboard]</code> -> <code>&amp;Chessboard</code></li></ul><p>它们实现了内置的 Deref trait。</p><h3 id=closures>Closures</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>is_even</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>x</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Rust自动推断类型。调用闭包就像调用一个函数那样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>is_even</span><span class=p>(</span><span class=mi>14</span><span class=p>),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=onward>Onward</h3><p>表达式只是我们思考 running code。</p><h2 id=chapter-7--error-handling>Chapter 7. Error Handling</h2><h3 id=panic>Panic</h3><p>panic 是程序本身出现一个bug。比如：</p><ul><li>数组越界</li><li>整数除零</li><li>对于一个 <code>Result</code>调用<code>.expect()</code>。</li><li>断言失败</li></ul><p>panic时要么展开栈，要么中止程序，展开栈是默认的。</p><h4 id=unwinding>Unwinding</h4><p>panic发生：</p><ul><li>终端打印错误信息</li><li>运行 <code>RUST_BACKTRACE=1</code>会将栈展开。资源会关闭，会调用drop方法。</li><li>最后，线程退出。</li></ul><p>panic不是崩溃，不是未定义行为。panic像Java中的运行时异常，其行为是明确定义的，只是不应该发生而已。</p><p>panic是安全的，它不违反任何Rust的安全规则。不会在内存中导致悬空指针或初始化一半的值，Rust展开栈后，进程的其他部分还可以运行。</p><p>panic是线程级别的。</p><p>有一种方法可以捕获栈展开，运行panic线程存活并继续运行。使用标准库中的<code>std::panic::catch_unwind()</code>函数。</p><h4 id=aborting>Aborting</h4><ul><li>如果<code>.drop()</code>方法触发了第二个panic当Rust在第一个panic后尝试 clean up，这会被当作是致命的。Rust会停止展开并且直接终止整个流程。</li><li>编译加上<code>-C panic=abort</code>，第一个 panic 就立马终止程序。</li></ul><h3 id=result>Result</h3><p>如果不使用Result值，会得到一个警告。</p><h4 id=catching-errors>Catching Errors</h4><p>用 match 来处理 error</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>get_weather</span><span class=p>(</span><span class=n>hometown</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Ok</span><span class=p>(</span><span class=n>report</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>display_weather</span><span class=p>(</span><span class=n>hometown</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>report</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Err</span><span class=p>(</span><span class=n>err</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;error querying the weather: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>err</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>schedule_weather_retry</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>但是上面这种方式太冗长了。这里有一些方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 1. 返回一个bool值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span><span class=p>.</span><span class=n>is_ok</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>result</span><span class=p>.</span><span class=n>is_err</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 2. 返回成功的值，返回 Option&lt;T&gt;, 成功就返回值，失败就返回 None
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span><span class=p>.</span><span class=n>ok</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 3. 返回失败的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span><span class=p>.</span><span class=n>err</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 4. 返回成功的值，否则就返回 fallback，抛弃错误的值，只有在存在适当后备值的情况下才可以使用这个方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span><span class=p>.</span><span class=n>unwrap_or</span><span class=p>(</span><span class=n>fallback</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 5. 返回成功的值，否则返回 fallback_fn，这里可以是一个函数或者闭包，这个方法适合计算
</span></span></span><span class=line><span class=cl><span class=c1>//    后备值如果用不上会浪费的情况。只有在返回错误结果时才会调用 fallback_fn
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span><span class=p>.</span><span class=n>unwrap_or_else</span><span class=p>(</span><span class=n>fallback_fn</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 6. 返回成功的值，否则就 panic
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span><span class=p>.</span><span class=n>unwrap</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>result</span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=c1>// panic 时打印信息
</span></span></span><span class=line><span class=cl><span class=c1>// 7. 将 Result&lt;T, E&gt; 转换为 Result&lt;&amp;T, &amp;E&gt;，这对于还要用原来的 result 的值很有用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span><span class=p>.</span><span class=n>as_ref</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 8. 将 Result&lt;T, E&gt; 转换为 Result&lt;&amp;mut T, &amp;mut E&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>result</span><span class=p>.</span><span class=n>as_mut</span><span class=p>()</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=result-type-aliases>Result Type Aliases</h4><p>在标准库 std::io 模块中有：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>type</span> <span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>result</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>Error</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这里用了 type aliases。</p><h4 id=printing-errors>Printing Errors</h4><p><code>std::io::Error</code>、<code>std::fmt::Error</code>、<code>std::str::Utf8Error</code>等等实现了<code>std::error::Error</code> trait。一些公用的方法：</p><ul><li><p><code>println!()</code></p><p>打印错误，用<code>{}</code>可以打印简短的错误信息，用<code>{:?}</code>的Debug模式打印出错误。</p></li><li><p><code>err.to_string()</code></p><p>返回错误信息字符串。</p></li><li><p><code>err.source()</code></p><p>返回一个Option，包含潜在的错误。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>error</span>::<span class=n>Error</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=p>{</span><span class=n>Write</span><span class=p>,</span><span class=w> </span><span class=n>stderr</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=sd>/// Dump an error message to `stderr`.
</span></span></span><span class=line><span class=cl><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd>/// If another error happens while building the error message or 
</span></span></span><span class=line><span class=cl><span class=sd>/// writing to `stderr`, it is ignored.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>fn</span> <span class=nf>print_error</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=n>err</span>: <span class=kp>&amp;</span><span class=nc>dyn</span><span class=w> </span><span class=n>Error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>writeln!</span><span class=p>(</span><span class=n>stderr</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;error: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>err</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>source</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>err</span><span class=p>.</span><span class=n>source</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>writeln!</span><span class=p>(</span><span class=n>stderr</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;caused by: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>source</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>source</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>想要展开错误，在Rust不稳定版本下，可以使用<code>anyhow</code>包。</p><h4 id=propagating-errors>Propagating Errors</h4><p>如果错误发生，我们希望调用者来处理。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>weather</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>get_weather</span><span class=p>(</span><span class=n>hometown</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>weather</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kr>try</span><span class=o>!</span><span class=p>(</span><span class=n>get_weather</span><span class=p>(</span><span class=n>hometown</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>?</code>操作符的行为取决于这个函数的返回值：</p><ul><li>如果是成功结果，那么它会打开Result并取出其中的成功值。</li><li>如果是错误结果，那么它会立即从闭合函数中返回，将错误结果沿调用链向上传播。</li></ul><p><code>?</code>操作符一样可以使用match表达式实现。</p><p><code>?</code>可以类似地用在<code>Option</code>类型的值上面。In a function that returns Option, you can use ? to unwrap a value and return early in the case of None.</p><h4 id=working-with-multiple-error-types>Working with Multiple Error Types</h4><ul><li><code>?</code>不能将<code>std::num::ParseIntError</code>转换为<code>std::io::Error</code>类型。</li><li>所有标准库中的错误都可以转成<code>Box&lt;dyn std::error::Error + Send + Sync + 'static'></code>类型。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>type</span> <span class=nc>GenericError</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>std</span>::<span class=n>error</span>::<span class=n>Error</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Sync</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span> <span class=nc>GenericResult</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>GenericError</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>?</code>会调用<code>GenericError::from()</code>方法来进行自动转换。</p><ul><li>如果想要其中一种特别的错误类型进行处理，其它的错误进行传播的话，可以用泛型方法<code>error.downcast_ref::&lt;ErrorType>()</code></li></ul><h4 id=dealing-with-errors-that-cant-happen>Dealing with Errors That &ldquo;Can&rsquo;t Happen&rdquo;</h4><ul><li>当我们不想处理不会发生的错误时，用<code>.unwrap()</code>方法。</li><li>也可以用<code>.expect(message)</code>方法。</li></ul><h4 id=ingoring-errors>Ingoring Errors</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>writeln!</span><span class=p>(</span><span class=n>stderr</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;error: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>err</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>用 <code>let _ = ...</code>用来禁止警告。</p><h4 id=handling-errors-in-main>Handling Errors in main()</h4><ul><li>一般情况下在 main 函数中不能用 <code>?</code> ，因为 <code>main()</code> 函数的返回类型不是 <code>Result</code>。</li><li>最简单的方法是用 <code>.expect()</code>方法。发生错误时会 panic 并且返回一个非零的退出代码。</li><li>或者可以返回一个 <code>Result</code> 类型，这样就能用<code>?</code>，同时用debug <code>{:?}</code>方式打印出错误。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>TideCalcError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>或者自己处理相应的错误。用<code>print_error()</code>方法结合<code>if let</code> 打印简介的错误信息。</li></ul><h4 id=declaring-a-custom-error-type>Declaring a Custom Error Type</h4><ul><li>可以自定义<code>Error</code>类型，用 struct 实现。Errors 应该实现<code>fmt::Display</code>和 <code>std::error::Error</code> trait。</li><li>或者直接用<code>thiserror</code> 中的，加上属性宏<code>#[derive(Error)]</code>。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>thiserror</span>::<span class=n>Error</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Error, Debug)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[error(</span><span class=s>&#34;{message:} ({line:}, {column})&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>JsonError</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>message</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>line</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>column</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=why-results>Why Results?</h4><ul><li>在代码中记录错误，对错误做出决定。</li><li>允许错误传播，传播路径可见。</li><li>每一个函数都有返回类型，这样更清楚函数可不可能失败。</li><li>Rust 会检查 Result 类型的值是否被使用。</li><li>因为 Result 是一个数据类型，因此更容易处理一系列成功或者失败的值，也更容易存储。</li></ul><h2 id=chapter-8-crates-and-modules>Chapter 8. Crates and Modules</h2><h3 id=crates>Crates</h3><p>Rust programs are made of <em>crates</em>. Each crate is a complete, cohesive unit: all the source code for a single library or executable, plus any associated tests, examples, tools, configuration, and other junk.</p><p>要了解包是什么，以及它们如何协作，可以对一个使用了依赖的已有项目运行 <code>cargo build</code> 命令，同时加上 <code>--verbose</code> 标记。</p><p>Cargo 的依赖会形成 <em>dependency graph</em> 。</p><p>Cargo 会使用 <code>--crate-type lib</code>选项，会告诉 rustc 不要去找 main() 函数，而是生成一个 <code>.rlib</code> 文件，其中包含编译后的代码，可以供以后在创建库或者<code>.rlib</code>文件使用。</p><blockquote><p>When compiling libraries, Cargo uses the &ndash; crate-type lib option. This tells rustc not to look for a main() function but instead to produce an <em>.rlib</em> file containing compiled code that can be used to create binaries and other <em>.rlib</em> files.</p></blockquote><p>Cargo使用 <code>--crate-type bin</code> 选项，编译结果将是一个针对目标平台的二进制可执行文件。</p><p>运行每个 rustc 命令时，Cargo会通过<code>--extern</code>选项给出当前包用到的每个库的文件名。这样，当rustc看到<code>use image::png::PNGEncoder</code>这行代码时，它就知道到磁盘的什么位置去找这个库编码后的代码了。Rust编译器需要访问<code>.rlib</code>文件，因为其中包含第三方库编译后的代码。Rust会将这些代码静态链接到最终的可执行文件上。<code>.rlib</code>文件也包含类型信息，Rust可以据此检查我们代码中用到的库特性确实在对应的包里存在，从而保证正确地使用它们。这个文件里还包含包的公共内联函数、泛型和宏的一个副本，这些特性直到Rust遇到调用它们的代码时才会编译为机器码。</p><p><code>cargo build --release</code>产生优化代码，优化代码的运行速度更快，但编译时间比较长，而且不会检查整型溢出，还会跳过<code>debug_assert!()</code>断言，另外它们针对 panic 生成的栈追踪信息一般不太可靠。</p><h4 id=editions>Editions</h4><p>To evolve without breaking existing code, Rust uses <em>editions</em>. The 2015 edition of Rust is compatible with Rust 1.0. The 2018 edition changed <strong>async</strong> and <strong>await</strong> into keywords, streamlined the module system, and introduced various other language changes that are incompatible with the 2015 edition.</p><p>Rust promises that the compiler will always accept all extant editions of the language, and programs can freely mix crates written in different editions. It’s even fine for a 2015 edition crate to depend on a 2018 edition crate. In other words, <strong>a crate’s edition only affects how its source code is construed; edition distinctions are gone by the time the code has been compiled</strong>. This means there’s no pressure to update old crates just to continue to participate in the modern Rust ecosystem. Similarly, <strong>there’s no pressure to keep your crate on an older edition to avoid inconveniencing its users</strong>. <strong>You only need to change editions when you want to use new language features in your own code.</strong></p><p>If you have a crate written in an older edition of Rust, the <strong>cargo fix</strong> command may be able to help you automatically upgrade your code to the newer edition. The Rust Edition Guide explains the cargo fix command in detail.</p><h4 id=build-profiles>Build Profiles</h4><p>构建分析</p><div class=table-wrapper><table><thead><tr><th>命令行</th><th>Cargo.toml使用的区块</th></tr></thead><tbody><tr><td>cargo build</td><td>[profile.dev]</td></tr><tr><td>cargo build &ndash;realse</td><td>[profile.realse]</td></tr><tr><td>cargo test</td><td>[profile.test]</td></tr></tbody></table></div><p>想要同时启用优化和调试，可以这样设置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=p>[</span><span class=nx>profile</span><span class=p>.</span><span class=nx>realse</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>debug</span> <span class=p>=</span> <span class=kc>true</span> <span class=c># 在发布构建中启用调试标记</span>
</span></span></code></pre></td></tr></table></div></div><p>这里debug设置控制 rustc 中的 -g 选项。有了这个配置，再执行 <code>cargo build --realse</code>，就可以得到一个带有调试符号的二进制文件。优化设置不受影响。</p><h3 id=modules>Modules</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>mod</span> <span class=nn>spores</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>use</span><span class=w> </span><span class=n>cells</span>::<span class=p>{</span><span class=n>Cell</span><span class=p>,</span><span class=w> </span><span class=n>Gene</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// A cell made by an adult fern. It disperses on the wind as part of
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// the fern life cycle. A spore grows into a prothallus -- a whole
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// separate organism, up to 5mm across -- which produces the zygote
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// that grows into a new fern. (Plant sex is complicated.)
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Spore</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Simulate the production of a spore by meiosis.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>produce_spore</span><span class=p>(</span><span class=n>factory</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Sporangium</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Spore</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Extract the genes in a particular spore.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>genes</span><span class=p>(</span><span class=n>spore</span>: <span class=kp>&amp;</span><span class=nc>Spore</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Gene</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Mix genes to prepare for meiosis (part of interphase).
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>recombine</span><span class=p>(</span><span class=n>parent</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Cell</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>One function is marked pub(crate), <strong>meaning that it is available anywhere inside this crate</strong>, but isn’t exposed as part of the external interface. It can’t be used by other crates, and it won’t show up in this crate’s documentation.</p><p>Anything that isn’t marked pub is private and <strong>can only be used in the same module</strong> in which it is defined, or <strong>any child modules</strong>.</p><h4 id=nested-modules>Nested Modules</h4><p>mod可以嵌套。</p><p>It’s also possible to specify<code>pub(super)</code>, making an item visible to the parent module only, and <code>pub(in &lt;path>)</code>, which makes it visible in a specific parent module and its descendants.</p><h4 id=modules-in-separate-files>Modules in Separate Files</h4><p>These three options—modules in their own file, modules in their own directory with a <em>mod.rs</em>, and modules in their own file with a supplementary directory containing submodules—give the module system enough flexibility to support almost any project structure you might desire.</p><h4 id=paths-and-imports>Paths and Imports</h4><p>用<code>::</code>操作符。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>std</span>::<span class=n>mem</span>::<span class=n>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s1</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>或者用<code>use</code>导入。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>mem</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>mem</span>::<span class=n>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s1</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>一次导入多个模块：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>collections</span>::<span class=p>{</span><span class=n>HashMap</span><span class=p>,</span><span class=w> </span><span class=n>HashSet</span><span class=p>};</span><span class=w> </span><span class=c1>// import both
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fs</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>File</span><span class=p>};</span><span class=w> </span><span class=c1>// import both `std::fs` and `std::fs::File`. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=n>prelude</span>::<span class=o>*</span><span class=p>;</span><span class=w> </span><span class=c1>// import everything
</span></span></span></code></pre></td></tr></table></div></div><p>导入时起别名</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=nb>Result</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>IOResult</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// This return type is just another way to write `std::io::Result&lt;()&gt;`:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>save_spore</span><span class=p>(</span><span class=n>spore</span>: <span class=kp>&amp;</span><span class=nc>Spore</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>IOResult</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>模块不会自动从自己的父模块继承名字。关键字super是父模块的一个别名，self则是当前模块的一个别名，关键词 crate 表示包含当前模块的包。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// proteins/synthesis.rs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>proteins</span>::<span class=n>AminoAcid</span><span class=p>;</span><span class=w> </span><span class=c1>// explicitly import relative to crate root
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>synthesize</span><span class=p>(</span><span class=n>seq</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>AminoAcid</span><span class=p>])</span><span class=w> </span><span class=c1>// ok 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>使用相对于根的路径，这样当模块移动时，也是有效的。</p><p><code>use super::*</code>可以让子模块获得父模块的私有项。</p><p>绝对路径：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 外部 crate
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>use</span><span class=w> </span>::<span class=n>image</span>::<span class=n>Pixels</span><span class=p>;</span><span class=w> </span><span class=c1>// the `image` crate&#39;s `Pixels`
</span></span></span><span class=line><span class=cl><span class=c1>// 自己定义的模块
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>use</span><span class=w> </span><span class=bp>self</span>::<span class=n>image</span>::<span class=n>Sampler</span><span class=p>;</span><span class=w> </span><span class=c1>// the `image` module&#39;s `Sampler`
</span></span></span></code></pre></td></tr></table></div></div><h4 id=the-standard-prelude><strong>The Standard Prelude</strong></h4><p>Furthermore, a few particularly handy names, like Vec and Result, are included in the <em>standard prelude</em> and automatically imported. Rust behaves as though every module, including the root module, started with the following import:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>prelude</span>::<span class=n>v1</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The standard prelude contains a few dozen commonly used traits and types.</p><p>参考<a class=link href=https://rustwiki.org/zh-CN/std/prelude/index.html target=_blank rel=noopener><code>std::prelude</code></a>。</p><h4 id=making-use-declarations-pub><strong>Making use Declarations pub</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// in plant_structures/mod.rs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>use</span><span class=w> </span><span class=bp>self</span>::<span class=n>leaves</span>::<span class=n>Leaf</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>use</span><span class=w> </span><span class=bp>self</span>::<span class=n>roots</span>::<span class=n>Root</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This means that Leaf and Root are public items of the plant_structures module. They are still simple aliases for <code>plant_structures::leaves::Leaf</code> and <code>plant_structures::roots::Root</code>.</p><h4 id=making-struct-fields-pub><strong>Making Struct Fields pub</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Fern</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>pub</span><span class=w> </span><span class=n>roots</span>: <span class=nc>RootSet</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>pub</span><span class=w> </span><span class=n>stems</span>: <span class=nc>StemSet</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Outside the module, only public fields are accessible.</p><h4 id=statics-and-constants><strong>Statics and Constants</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=no>ROOM_TEMPERATURE</span>: <span class=kt>f64</span> <span class=o>=</span><span class=w> </span><span class=mf>20.0</span><span class=p>;</span><span class=w> </span><span class=c1>// degrees Celsius
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>pub</span><span class=w> </span><span class=k>static</span><span class=w> </span><span class=no>ROOM_TEMPERATURE</span>: <span class=kt>f64</span> <span class=o>=</span><span class=w> </span><span class=mf>68.0</span><span class=p>;</span><span class=w> </span><span class=c1>// degrees Fahrenheit
</span></span></span></code></pre></td></tr></table></div></div><p>A constant is a bit like a C++ #define: the value is compiled into your code every place it’s used. A static is a variable that’s set up before your program starts running and lasts until it exits. Use constants for magic numbers and strings in your code. Use statics for larger amounts of data, or any time you need to borrow a reference to the constant value.</p><p>There are no mut constants.</p><h3 id=turning-a-program-into-a-library><strong>Turning a Program into a Library</strong></h3><p>The first step is to factor your existing project into two parts: <strong>a library crate</strong>, which contains all the shared code, and <strong>an executable</strong>, which contains the code that’s only needed for your existing command-line program.</p><p>By default, cargo build looks at the files in our source directory and figures out what to build. When it sees the file <em>src/lib.rs</em>, it knows to build a library. The code in <em>src/lib.rs</em> forms the <em>root module</em> of the library. Other crates that use our library can only access the public items of this root module.</p><h3 id=the-srcbin-directory><strong>The src/bin Directory</strong></h3><p>We can keep our program and our library in the same crate, too. Put this code into a file named <em>src/bin/efern.rs</em>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>fern_sim</span>::<span class=p>{</span><span class=n>Fern</span><span class=p>,</span><span class=w> </span><span class=n>run_simulation</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>fern</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Fern</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=n>size</span>: <span class=mf>1.0</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>growth_rate</span>: <span class=mf>0.001</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>run_simulation</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>fern</span><span class=p>,</span><span class=w> </span><span class=mi>1000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;final fern size: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>fern</span><span class=p>.</span><span class=n>size</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Because we’ve put this file into <em>src/bin</em>, Cargo will compile both the fern_sim library and this program the next time we run cargo build. We can run the efern program using cargo run &ndash;bin efern. Here’s what it looks like, using &ndash;verbose to show the commands Cargo is running.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=p>[</span><span class=nx>dependencies</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>fern_sim</span> <span class=p>=</span> <span class=p>{</span> <span class=nx>path</span> <span class=p>=</span> <span class=s2>&#34;../fern_sim&#34;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以将 fern_sim 作为一个单独的项目，然后在 Cargo.toml 上加上依赖。</p><h3 id=attributes>Attributes</h3><p>Rust程序中的任何 item 都可以用属性来修饰。</p><ul><li><code>#[allow(non_camel_case_types)]</code> 可以不使用驼峰命名法。</li><li><code>#[cfg]</code> 条件编译</li><li><code>#[inline]</code> 内联函数。当出现一个函数或者一个方法定义在一个 crate 中，而我们在另一个 crate 中去调用，可以显式使用这个属性。<ul><li><code>#[inline(always)]</code> 要求函数在每一次调用的点都展开内联</li><li><code>#[inline(never)]</code> 要求一个函数从不进行内联</li></ul></li><li><code>#[cfg]</code>和<code>#[allow]</code>可以用在一整个模块或者里面的任何东西，但是 <code>#[inline]</code> 和 <code>#[test]</code>只能用在单个项上面。</li><li>想在整个 crate 上面绑定属性，在main.rs<code>或者</code>lib.rs<code>文件顶部中用</code>#!。<code>#!</code>也可以用在函数，结构体中，但是它只能一贯地用在文件的开头，来绑定给整个模块或者 crate 绑定一个属性。而有的属性总是用 <code>#!</code>，因为它只能作用在整个 crate 上，比如 <code>#![feature]</code>。</li><li><code>#![feature]</code> 用来表示 Rust 语言不稳定的 features，这些是实验性质的。当后面这个 feature 稳定之后，编译器就会警告，建议移除 <code>#![feature]</code>。</li></ul><h3 id=tests-and-documention>Tests and Documention</h3><ul><li><code>#[test]</code> 标记函数，表明这个是测试函数，用<code>cargo test</code> 可以测试所有测试函数，如果只想测试某一个，可以用<code>cargo test name</code>来测试具体的函数。</li><li><code>assert!(expr)</code>：如果表达式为真就通过测试，否则 panic。</li><li><code>assert_eq!(v1, v2)</code>：判别 v1 和 v2 是否相等。</li><li>如果只想在 debug 模式下检验是否相等，可以用 <code>debug_assert!</code> 和 <code>debug_assert_eq!</code>。</li><li><code>#[should_panic]</code> 表示会 panic。或者返回<code>Result&lt;(), E></code>。</li><li><code>cargo build</code>和<code>cargo build --realse</code>会跳过<code>#[test]</code>测试代码。</li><li>当运行 <code>cargo test</code> ，cargo 会编译两次代码。一次是常规的，还有一次是测试程序并启用测试套件。</li><li><code>#[cfg(test)]</code>标记整个模块。</li><li>一般 cargo test 会启用多线程来一次运行多个测试，用 <code>cargo test name</code> 和 <code>cargo test -- --test-threads 1</code>来限制只用一个线程测试。</li><li><code>cargo test -- --no-capture</code>：也输出那些通过的测试。</li></ul><h4 id=integration-tests>Integration Tests</h4><ul><li>集成测试，可以用来测试一些公共的API，站在用户的角度。</li><li>单独建立一个 <code>tests</code>的文件夹，放在和 <code>src</code> 同一个路径下，当运行 <code>cargo test</code> 的时候，集成测试和单元测试都会运行。如果只想运行集成测试，可以用命令<code>cargo test --test unfurl</code>来运行一个具体的集成测试。</li></ul><h4 id=documentation>Documentation</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>cargo</span><span class=w> </span><span class=n>doc</span><span class=w> </span><span class=o>--</span><span class=n>no</span><span class=o>-</span><span class=n>deps</span><span class=w> </span><span class=o>--</span><span class=n>open</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>&ndash;no-deps ：只生成自己的文档，不生成所有它依赖的 crates。</li><li>&ndash;open：在浏览器中打开文档。</li><li>生成的文档放在 target/doc 目录下。</li><li><code>///</code>的文档注释类似<code>#[doc]</code>属性。而<code>//!</code>和<code>#![doc]</code>一样。</li><li>文档注释中markdown 的链接也可以链接到相应代码的文档。</li><li>One special feature of doc comments in Rust is that Markdown links can use Rust item paths, like leaves::Leaf, instead of relative URLs, to indicate what they refer to.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Create and return a [`VascularPath`] which represents the path of
</span></span></span><span class=line><span class=cl><span class=sd>/// nutrients from the given [`Root`][r] to the given [`Leaf`](leaves::Leaf). 
</span></span></span><span class=line><span class=cl><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd>/// [r]: roots::Root
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>trace_path</span><span class=p>(</span><span class=n>leaf</span>: <span class=kp>&amp;</span><span class=nc>leaves</span>::<span class=n>Leaf</span><span class=p>,</span><span class=w> </span><span class=n>root</span>: <span class=kp>&amp;</span><span class=nc>roots</span>::<span class=n>Root</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>VascularPath</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>You can also add search aliases to make it easier to find things using the built-in search feature.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[doc(alias = </span><span class=s>&#34;route&#34;</span><span class=cp>)]</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>VascularPath</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>文档中的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// A block of code in a doc comment:
</span></span></span><span class=line><span class=cl><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=c1>////	if samples::everything().works() {
</span></span></span><span class=line><span class=cl><span class=c1>////	    println!(&#34;ok&#34;);
</span></span></span><span class=line><span class=cl><span class=c1>////	}
</span></span></span></code></pre></td></tr></table></div></div><p>或者用Markdown格式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Another snippet, the same code, but written differently:
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// ```
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// if samples::everything().works() {
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>///     println!(&#34;ok&#34;);
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// }
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// ```
</span></span></span></code></pre></td></tr></table></div></div><h4 id=doc-tests>Doc-Tests</h4><ul><li>Rust 也会测试在文档注释中的代码，会隐式的加在 <code>fn main()</code> 函数里面。</li><li>The idea behind doc-tests is not to put all your tests into comments. Rather, you write the best possible documentation, and Rust makes sure the code samples in your documentation actually compile and run.</li><li>To hide a line of a code sample, put a # followed by a space at the beginning of that line.</li><li>rustdoc therefore treats any code block containing the exact string fn main as a complete program and doesn’t add anything to it.</li><li>To tell Rust to compile your example, but stop short of actually running it, use a fenced code block with the <code>no_run</code> annotation.</li><li>If the code isn’t even expected to compile, use <code>ignore</code> instead of <code>no_run</code>. Blocks marked with <code>ignore</code> don’t show up in the output of cargo run, but no_run tests show up as having passed if they compile.</li><li>If the code block isn’t Rust code at all, use the name of the language, like c++ or sh, or text for plain text.</li></ul><h3 id=specifying-dependencies><strong>Specifying Dependencies</strong></h3><p>用版本号：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=nx>image</span> <span class=p>=</span> <span class=s2>&#34;0.6.1&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Git仓库地址和修订版本号：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=nx>image</span> <span class=p>=</span> <span class=p>{</span> <span class=nx>git</span> <span class=p>=</span> <span class=s2>&#34;https://github.com/Piston/image.git&#34;</span><span class=p>,</span> <span class=nx>rev</span> <span class=p>=</span> <span class=s2>&#34;528f19c&#34;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以指定使用哪个 rev、tag 或 branch。</p><p>另一种方式是指定包含依赖包源代码的目录：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=nx>image</span> <span class=p>=</span> <span class=p>{</span> <span class=nx>path</span> <span class=p>=</span> <span class=s2>&#34;vendor/image&#34;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=versions><strong>Versions</strong></h4><p>对于在 Cargo.toml 中写的 <code>image = "0.6.1"</code> ，Cargo 的解释并没有那么严格。它会使用与 0.6.1 版兼容的最新版本的 image 。</p><p>兼容性的判断基本上遵循“语义化版本”的思想。</p><ul><li>以0.0开头的版本过于原始，Cargo不会假设它与任何其他版本兼容。</li><li>以0.x（基本x不是0）开头的版本，会被认为同其他以0.x开头的版本兼容。</li><li>如果项目达到1.0版，则只有新的主版本号才会破坏兼容性。</li></ul><p>不同项目对依赖和版本有不同的需求。因此，指定版本时可以使用操作符。例如<code>></code>、<code>>=</code>、<code>&lt;=</code>。</p><p>使用通配符<code>*</code>表示任何版本都可以，这个并不多见。</p><h4 id=cargolock><strong>Cargo.lock</strong></h4><p>在第一次构建项目时，Cargo会输出一个Cargo.lock文件，记录它使用的每个包的确切的版本号。如果手动修改了Cargo.toml文件中的版本号或者运行<code>cargo update</code>时，会把新版本号保存到Cargo.lock文件中。</p><p>对于保存在Git代码库的依赖也是类似的。</p><p>如果你的项目是一个可执行文件，应该把Cargo.lock提交到版本控制系统。如果是一个普通的Rust库，就不用提交Cargo.lock了。如果恰好你的项目是一个共享库，没有这种下游的cargo用户，那就应该提供Cargo.lock。</p><h3 id=publishing-crates-to-cratesio><strong>Publishing Crates to crates.io</strong></h3><p><code>cargo package</code> 让Cargo打包。会创建一个<code>.crate</code>文件，其中包含库的源文件以及Cargo.toml。</p><p><code>cargo package --list</code>可以查看其中包含什么文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=p>[</span><span class=nx>package</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>name</span> <span class=p>=</span> <span class=s2>&#34;fern_sim&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>version</span> <span class=p>=</span> <span class=s2>&#34;0.1.0&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>edition</span> <span class=p>=</span> <span class=s2>&#34;2018&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>authors</span> <span class=p>=</span> <span class=p>[</span><span class=s2>&#34;You &lt;you@example.com&gt;&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>license</span> <span class=p>=</span> <span class=s2>&#34;MIT&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>homepage</span> <span class=p>=</span> <span class=s2>&#34;https://fernsim.example.com/&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>repository</span> <span class=p>=</span> <span class=s2>&#34;https://gitlair.com/sporeador/fern_sim&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>documentation</span> <span class=p>=</span> <span class=s2>&#34;http://fernsim.example.com/docs&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>description</span> <span class=p>=</span> <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>Fern simulation, from the cellular level up.
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>可以同时指定本地依赖和版本号，不过要保证二者同步：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=nx>image</span> <span class=p>=</span> <span class=p>{</span> <span class=nx>path</span> <span class=p>=</span> <span class=s2>&#34;vendor/image&#34;</span><span class=p>,</span> <span class=nx>version</span> <span class=p>=</span> <span class=s2>&#34;0.13.0&#34;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>接着就是发布了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ cargo login 5j0dV54BjlXBpUUbfIj7G9DvNl1vsWW1
</span></span><span class=line><span class=cl>$ cargo publish
</span></span><span class=line><span class=cl>Updating registry <span class=sb>`</span>https://github.com/rust-lang/crates.io-index<span class=sb>`</span>
</span></span><span class=line><span class=cl>     Uploading fern_sim v0.1.0 <span class=o>(</span>file:///.../fern_sim<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=workspace>Workspace</h3><p>使用Cargo工作空间可以节省编译时间和磁盘空间。所谓工作空间，就是共享相同构建目录和Cargo.lock文件的一组包。</p><p>要使用工作空间，只需在存储库的根目录下创建一个Cargo.toml文件，并把下面几行放进去：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=p>[</span><span class=nx>workspace</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>members</span> <span class=p>=</span> <span class=p>[</span><span class=s2>&#34;fern_sim&#34;</span><span class=p>,</span> <span class=s2>&#34;fern_img&#34;</span><span class=p>,</span> <span class=s2>&#34;fern_video&#34;</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>Here fern_sim etc. are the names of the subdirectories containing your crates. Delete any leftover <em>Cargo.lock</em> files and <em>target</em> directories that exist in those subdirectories.</p><p>The command <code>cargo build --workspace</code> builds all crates in the current workspace. <code>cargo test</code> and <code>cargo doc</code> accept the <code>--workspace</code> option as well.</p><h2 id=chapter-9-structs><strong>Chapter 9. Structs</strong></h2><p>Rust has three kinds of struct types, <em><strong>named-field</strong></em>, <em><strong>tuple-like</strong></em>, and <em><strong>unit-like</strong></em>, which differ in how you refer to their components: a named-field struct gives a name to each component, whereas a tuple- like struct identifies them by the order in which they appear. Unit-like structs have no components at all; these are not common, but more useful than you might think.</p><h3 id=named-field-structs><strong>Named-Field Structs</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// A rectangle of eight-bit grayscale pixels.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>struct</span> <span class=nc>GrayscaleMap</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>pixels</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>size</span>: <span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>结构体的名字用驼峰命名法，其中的字段用蛇形拼写法。</p><p>You can use <code>key: value</code> syntax for some fields and shorthand for others in the same struct expression.</p><p>To access a struct’s fields, use the familiar <code>.</code> operator.</p><p>可以将结构体设为pub，但是字段默认私有。这样可以通过一些公有的方法创建结构体或者修改它。</p><p>使用<code>.. EXPR</code>，任何没有出现的字段都将从<code>EXPR</code>中取得自己的值，前提是<code>EXPR</code>必须为同一结构体类型的另一个值。</p><h3 id=tuple-like-structs><strong>Tuple-Like Structs</strong></h3><p>类元组结构体：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Bounds</span><span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>通过<code>.</code>操作符来访问。</p><p>定义此结构体会隐式定义一个函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>Bounds</span><span class=p>(</span><span class=n>elem0</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>elem1</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Bounds</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><em>newtypes</em>，即只包含一个要经过更严格类型检查的组件的结构体。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Ascii</span><span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=unit-like-structs><strong>Unit-Like Structs</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Onesuch</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这种类型的值不占任何内存，像<code>()</code>。</p><blockquote><p>Rust doesn’t bother actually storing unit-like struct values in memory or generating code to operate on them, because it can tell everything it might need to know about the value from its type alone. But logically, an empty struct is a type with values like any other—or more precisely, <strong>a type of which there is only a single value</strong>.</p></blockquote><h3 id=struct-layout><strong>Struct Layout</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>GrayscaleMap</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>pixels</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>size</span>: <span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>一种可能的内存布局：</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220715110333582.png loading=lazy alt=image-20220715110333582></p><p>Rust不保证结构体的字段或元素在内存中会以某种顺序存储，但是保证把字段的值直接存储在结构体的内存块中。</p><h3 id=defining-methods-with-impl><strong>Defining Methods with impl</strong></h3><p>Functions defined in an impl block are called <em>associated functions</em>, since they’re associated with a specific type. The opposite of an associated function is a <em>free function</em>, one that is not defined as an impl block’s item.</p><ul><li><code>self</code></li><li><code>&amp;self</code></li><li><code>&amp;mut self</code></li></ul><p>当调用方法时，<code>.</code> 操作符会隐式转换，如果方法定义的是借用，就会隐式转换为引用。注意<code>self</code>会移动所有权。</p><h4 id=passing-self-as-a-box-rc-or-arc><strong>Passing Self as a Box, Rc, or Arc</strong></h4><p>A method’s self argument can also be a <code>Box&lt;Self></code>, <code>Rc&lt;Self></code>, or <code>Arc&lt;Self></code>. Such a method can only be called on a value of the given pointer type. Calling the method passes ownership of the pointer to it.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>bq</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>Queue</span>::<span class=n>new</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// `Queue::push` expects a `&amp;mut Queue`, but `bq` is a `Box&lt;Queue&gt;`. 
</span></span></span><span class=line><span class=cl><span class=c1>// This is fine: Rust borrows a `&amp;mut Queue` from the `Box` for the 
</span></span></span><span class=line><span class=cl><span class=c1>// duration of the call.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>bq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=sc>&#39;■&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Rust automatically borrows a reference from pointer types like Box, Rc, and Arc, so &amp;self and &amp;mut self are almost always the right thing in a method signature, along with the occasional self.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>append_to</span><span class=p>(</span><span class=bp>self</span>: <span class=nc>Rc</span><span class=o>&lt;</span><span class=bp>Self</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>parent</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Node</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>parent</span><span class=p>.</span><span class=n>children</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=bp>self</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>If the caller has an <code>Rc&lt;Node></code> at hand, it can call append_to directly, passing the Rc by value:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>shared_node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Node</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;first&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>shared_node</span><span class=p>.</span><span class=n>append_to</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>parent</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Again, for most methods, &amp;self, &amp;mut self, and self (by value) are all you need. But if a method’s purpose is to affect the ownership of the value, using other pointer types for self can be just the right thing.</p><h4 id=type-associated-functions><strong>Type-Associated Functions</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>Queue</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Queue</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Queue</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>older</span>: <span class=nb>Vec</span>::<span class=n>new</span><span class=p>(),</span><span class=w> </span><span class=n>younger</span>: <span class=nb>Vec</span>::<span class=n>new</span><span class=p>()</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Separating a type’s methods from its definition may seem unusual, but there are several advantages to doing so:</p><ul><li>It’s always easy to find a type’s data members.</li><li>Pulling methods out into an impl block allows a single syntax for all three. In fact, Rust uses this same syntax for defining methods on types that are not structs at all, such as enum types and primitive types like i32.</li><li>The same impl syntax also serves neatly for implementing traits, which we’ll go into in Chapter 11.</li></ul><h3 id=associated-consts><strong>Associated Consts</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Vector2</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>x</span>: <span class=kt>f32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>y</span>: <span class=kt>f32</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Vector2</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>const</span><span class=w> </span><span class=no>ZERO</span>: <span class=nc>Vector2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Vector2</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mf>0.0</span><span class=w> </span><span class=p>};</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>const</span><span class=w> </span><span class=no>UNIT</span>: <span class=nc>Vector2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Vector2</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mf>1.0</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mf>0.0</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>scaled</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Vector2</span>::<span class=no>UNIT</span><span class=p>.</span><span class=n>scaled_by</span><span class=p>(</span><span class=mf>2.0</span><span class=p>);</span><span class=w> </span><span class=c1>// scaled_by() 方法需要自己定义，这里没有列出
</span></span></span></code></pre></td></tr></table></div></div><h3 id=generic-structs><strong>Generic Structs</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-RUST data-lang=RUST><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Queue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>older</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>younger</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>相关方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Queue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Queue</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>older</span>: <span class=nb>Vec</span>::<span class=n>new</span><span class=p>(),</span><span class=w> </span><span class=n>younger</span>: <span class=nb>Vec</span>::<span class=n>new</span><span class=p>()</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>push</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>younger</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>is_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>older</span><span class=p>.</span><span class=n>is_empty</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>younger</span><span class=p>.</span><span class=n>is_empty</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>使用<code>Self</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Queue</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>older</span>: <span class=nb>Vec</span>::<span class=n>new</span><span class=p>(),</span><span class=w> </span><span class=n>younger</span>: <span class=nb>Vec</span>::<span class=n>new</span><span class=p>()</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>For associated function calls, you can supply the type parameter explicitly using the ::&lt;> (turbofish) notation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Queue</span>::<span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=structs-with-lifetime-parameters><strong>Structs with Lifetime Parameters</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>find_extrema</span><span class=o>&lt;</span><span class=na>&#39;s</span><span class=o>&gt;</span><span class=p>(</span><span class=n>slice</span>: <span class=kp>&amp;</span><span class=na>&#39;s</span> <span class=p>[</span><span class=kt>i32</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>Extrema</span><span class=o>&lt;</span><span class=na>&#39;s</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>greatest</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>slice</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>least</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>slice</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=o>..</span><span class=n>slice</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>slice</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=o>*</span><span class=n>least</span><span class=w>    </span><span class=p>{</span><span class=w> </span><span class=n>least</span><span class=w>     </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>slice</span><span class=p>[</span><span class=n>i</span><span class=p>];</span><span class=w> </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>slice</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=o>*</span><span class=n>greatest</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>greatest</span><span class=w>  </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>slice</span><span class=p>[</span><span class=n>i</span><span class=p>];</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Extrema</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>greatest</span><span class=p>,</span><span class=w> </span><span class=n>least</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>当然这里生命周期参数也可以省略，因为可以根据三条规则进行推断。</p><h3 id=deriving-common-traits-for-struct-types><strong>Deriving Common Traits for Struct Types</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Copy, Clone, Debug, PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>x</span>: <span class=kt>f64</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>y</span>: <span class=kt>f64</span> 
</span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=interior-mutability><strong>Interior Mutability</strong></h3><p>支持内部可变性，用<code>Cell&lt;T></code>和<code>RefCell&lt;T></code>，定义在<code>std::cell</code>模块中。</p><p><code>Cell&lt;T></code>是只包含一个<code>T</code>类型私有值的结构体。Cell唯一特别的地方是不需要对其自身的mut引用，你也能取得或设置其私有字段的值。</p><ul><li><code>Cell::new(value)</code>：创建一个新Cell，将value转移到其中。</li><li><code>cell.get()</code>：返回cell中值的副本。要求 cell 实现 Copy trait。</li><li><code>cell.set(value)</code>：把value保存到cell，丢弃之间保存的值。</li></ul><p><code>RefCell&lt;T></code>是只包含一个T类型值的泛型类型。但与Cell不同，<code>RefCell&lt;T></code>支持借用它的T类型值的引用。</p><ul><li><code>RefCell::new(value)</code>：创建一个新RefCell，将value转移到其中。</li><li><code>ref_cell.borrow()</code>：返回一个<code>Ref&lt;T></code>，基本上是对 ref_cell 中值的共享引用。This method panics if the value is already mutably borrowed.</li><li><code>ref_cell.borrow_mut()</code>: Returns a <code>RefMut&lt;T></code>, essentially a mutable reference to the value in ref_cell. This method panics if the value is already borrowed.</li><li><code>ref_cell.try_borrow()</code>, <code>ref_cell.try_borrow_mut()</code> : Work just like <code>borrow()</code> and <code>borrow_mut()</code>, but return a <code>Result</code>. Instead of panicking if the value is already mutably borrowed, they return an <code>Err</code> value.</li></ul><p>This is a lot like how normal references work. The only difference is that normally, when you borrow a reference to a variable, Rust checks at compile time to ensure that you’re using the reference safely. If the checks fail, you get a compiler error. RefCell enforces the same rule using run-time checks. So if you’re breaking the rules, you get a panic (or an Err, for try_borrow and try_borrow_mut).</p><p>The other drawback is less obvious and more serious: cells—and any types that contain them—are not thread-safe.</p><p><strong>补充：参考<a class=link href=https://rustwiki.org/zh-CN/book/ch15-05-interior-mutability.html#refcellt-%e5%92%8c%e5%86%85%e9%83%a8%e5%8f%af%e5%8f%98%e6%80%a7%e6%a8%a1%e5%bc%8f target=_blank rel=noopener><code>RefCell</code> 和内部可变性模式</a></strong>。</p><ul><li>因为 <code>RefCell&lt;T></code> 允许在运行时执行可变借用检查，所以我们可以在即便 <code>RefCell&lt;T></code> 自身是不可变的情况下修改其内部的值。</li></ul><p>结构体是“与”的逻辑，而枚举是“或”的逻辑。</p><h2 id=chapter-10-enums-and-patterns>Chapter 10. Enums and Patterns</h2><h3 id=enums><strong>Enums</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Ordering</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Less</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Equal</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Greater</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个是标准库中的，导入用use。也可以自己定义枚举，自己导入。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Pet</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Orca</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Giraffe</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=bp>self</span>::<span class=n>Pet</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>In memory, values of C-style enums are stored as integers. Occasionally it’s useful to tell Rust
which integers to use:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>HttpStatus</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Ok</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>200</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>NotModified</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>304</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>NotFound</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>404</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Otherwise Rust will assign the numbers for you, starting at 0.</p><p>By default, Rust stores C-style enums using the smallest built-in integer type that can accommodate them. Most fit in a single byte.</p><p><code>#[repr]</code>可以自己选择枚举的内存表示。</p><p>可以将C式枚举转换为整数，但是反过来不可以。</p><p>和结构体一样，可以给枚举加上属性，定义相关方法。</p><h4 id=enums-with-data>Enums with Data</h4><p>一个枚举可以同时包含三种变体：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>RelationshipStatus</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Single</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>InARelationship</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ItsComplicated</span><span class=p>(</span><span class=nb>Option</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ItsExtremelyComplicated</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>car</span>: <span class=nc>DifferentialEquation</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>cdr</span>: <span class=nc>EarlyModernistPoem</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>All constructors and fields of an enum share the same visibility as the enum itself.</p><h4 id=enums-in-memory>Enums in Memory</h4><p>在内存中，带数据的每个构造式都需要一个小整数标签。</p><p><code>RoughTime</code>的每个构造式占用8个字节。</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220715164735845.png loading=lazy alt=image-20220715164735845></p><p>为了方便优化，Rust并未对枚举的内存布局方式做出任何承诺。For instance, some generic structs can be stored without a tag at all, as we’ll see later.</p><h4 id=rich-data-structures-using-enums><strong>Rich Data Structures Using Enums</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>collections</span>::<span class=n>HashMap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>enum</span> <span class=nc>Json</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Null</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Boolean</span><span class=p>(</span><span class=kt>bool</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Number</span><span class=p>(</span><span class=kt>f64</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>String</span><span class=p>(</span><span class=nb>String</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Array</span><span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Json</span><span class=o>&gt;</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Object</span><span class=p>(</span><span class=nb>Box</span><span class=o>&lt;</span><span class=n>HashMap</span><span class=o>&lt;</span><span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=n>Json</span><span class=o>&gt;&gt;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>内存布局：</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220716084624016.png loading=lazy alt=image-20220716084624016></p><p>在内存中，Json类型的值占4个机器字。String和Vec值占3个机器字，Rust还会加一个标签字节。Null和Boolean值用不了那么多内存空间，但所有Json值的大小必须相同。</p><p><code>Box&lt;HashMap></code>只占一个机器字，因为它只是一个指向分配到堆内存数据的指针。</p><h4 id=generic-enums><strong>Generic Enums</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>None</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Some</span><span class=p>(</span><span class=n>T</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>enum</span> <span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>E</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Ok</span><span class=p>(</span><span class=n>T</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Err</span><span class=p>(</span><span class=n>E</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>**如果类型<code>T</code>是引用或<code>Box</code>或其他智能指针类型，Rust就会省掉<code>Option&lt;T></code>的标签字段。**因此<code>Option&lt;Box&lt;i32>></code>在内存中只用1个机器字节存储。0表示<code>None</code>，非零表示<code>Some</code>封装的值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// An ordered collection of `T`s.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Empty</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>NonEmpty</span><span class=p>(</span><span class=nb>Box</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// A part of a BinaryTree.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>TreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>element</span>: <span class=nc>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>left</span>: <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>right</span>: <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=/img/2022-07-05-Programming-Rust/image-20220716091503724.png loading=lazy alt=image-20220716091503724></p><p>访问枚举数据唯一的方式是一种安全的方式：使用模式。</p><h3 id=patterns><strong>Patterns</strong></h3><p>在枚举中不能直接通过<code>.</code>操作符访问枚举的字段。可以用match表达式来进行模式匹配。</p><p>表达式产生值，模式消费值。</p><p>模式匹配会从左到右对比模式的每个组件，依次检查当前值是否与之匹配。如果不匹配，就前进到下一个模式。</p><div class=table-wrapper><table><thead><tr><th>模式类型</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>Literal</td><td></td><td></td></tr><tr><td>Range</td><td></td><td></td></tr><tr><td>Wildcard Variable</td><td></td><td></td></tr><tr><td>ref variable</td><td></td><td></td></tr><tr><td>Binding with subpattern</td><td></td><td></td></tr><tr><td>Enum pattern</td><td></td><td></td></tr><tr><td>Tuple pattern</td><td></td><td></td></tr><tr><td>Array pattern</td><td></td><td></td></tr><tr><td>Slice pattern</td><td></td><td></td></tr><tr><td>Struct pattern</td><td></td><td></td></tr><tr><td>Reference</td><td></td><td></td></tr><tr><td>Multiple patterns</td><td>`&lsquo;a&rsquo;</td><td>&lsquo;A&rsquo;`</td></tr><tr><td>Guard expression</td><td><code>x if x * x &lt;= r2</code></td><td>In match only (not valid in let, etc.)</td></tr></tbody></table></div><h4 id=literals-variables-and-wildcards-in-patterns><strong>Literals, Variables, and Wildcards in Patterns</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>calendar</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>settings</span><span class=p>.</span><span class=n>get_string</span><span class=p>(</span><span class=s>&#34;calendar&#34;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;gregorian&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Calendar</span>::<span class=n>Gregorian</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;chinese&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Calendar</span>::<span class=n>Chinese</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;ethiopian&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Calendar</span>::<span class=n>Ethiopian</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>other</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>parse_error</span><span class=p>(</span><span class=s>&#34;calendar&#34;</span><span class=p>,</span><span class=w> </span><span class=n>other</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>可以使用通配符<code>_</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>caption</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>photo</span><span class=p>.</span><span class=n>tagged_pet</span><span class=p>()</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Pet</span>::<span class=n>Tyrannosaur</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;RRRAAAAAHHHHHH&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Pet</span>::<span class=n>Samoyed</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;*dog thoughts*&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;I&#39;m cute, love me&#34;</span><span class=p>,</span><span class=w> </span><span class=c1>// generic caption, works for any pet
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>即便你非常确定其他情况不会发生，也必须至少加上一个后备的panic分支：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// There are many Shapes, but we only support &#34;selecting&#34; 
</span></span></span><span class=line><span class=cl><span class=c1>// either some text, or everything in a rectangular area. 
</span></span></span><span class=line><span class=cl><span class=c1>// You can&#39;t select an ellipse or trapezoid.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>match</span><span class=w> </span><span class=n>document</span><span class=p>.</span><span class=n>selection</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Shape</span>::<span class=n>TextSpan</span><span class=p>(</span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=n>end</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>paint_text_selection</span><span class=p>(</span><span class=n>start</span><span class=p>,</span><span class=w> </span><span class=n>end</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Shape</span>::<span class=n>Rectangle</span><span class=p>(</span><span class=n>rect</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>paint_rect_selection</span><span class=p>(</span><span class=n>rect</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>panic!</span><span class=p>(</span><span class=s>&#34;unexpected selection type&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=tuple-and-struct-patterns>Tuple and Struct Patterns</h4><p>元组模式匹配元组：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>describe_point</span><span class=p>(</span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span> <span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>cmp</span>::<span class=n>Ordering</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>match</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>cmp</span><span class=p>(</span><span class=o>&amp;</span><span class=mi>0</span><span class=p>),</span><span class=w> </span><span class=n>y</span><span class=p>.</span><span class=n>cmp</span><span class=p>(</span><span class=o>&amp;</span><span class=mi>0</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=n>Equal</span><span class=p>,</span><span class=w> </span><span class=n>Equal</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;at the origin&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>Equal</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;on the x axis&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=n>Equal</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;on the y axis&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=n>Greater</span><span class=p>,</span><span class=w> </span><span class=n>Greater</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;in the first quadrant&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=n>Less</span><span class=p>,</span><span class=w> </span><span class=n>Greater</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;in the second quadrant&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;somewhere else&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>结构体模式使用花括号：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>balloon</span><span class=p>.</span><span class=n>location</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=nc>height</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;straight up </span><span class=si>{}</span><span class=s> meters&#34;</span><span class=p>,</span><span class=w> </span><span class=n>height</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=nc>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=nc>y</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;at (</span><span class=si>{}</span><span class=s>m, </span><span class=si>{}</span><span class=s>m)&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在结构体模式匹配中，可以使用<code>...</code>来告诉Rust你并不关心其他字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=nb>Some</span><span class=p>(</span><span class=n>Account</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>language</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=p>})</span><span class=w> </span><span class=o>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>language</span><span class=p>.</span><span class=n>show_custom_greeting</span><span class=p>(</span><span class=n>name</span><span class=p>),</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=array-and-slice-patterns>Array and Slice Patterns</h4><p>数组匹配：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>hsl_to_rgb</span><span class=p>(</span><span class=n>hsl</span>: <span class=p>[</span><span class=kt>u8</span><span class=p>;</span><span class=w> </span><span class=mi>3</span><span class=p>])</span><span class=w> </span>-&gt; <span class=p>[</span><span class=kt>u8</span><span class=p>;</span><span class=w> </span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>match</span><span class=w> </span><span class=n>hsl</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>[</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>[</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=mi>255</span><span class=p>]</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>[</span><span class=mi>255</span><span class=p>,</span><span class=w> </span><span class=mi>255</span><span class=p>,</span><span class=w> </span><span class=mi>255</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>切片匹配：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>greet_people</span><span class=p>(</span><span class=n>names</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>match</span><span class=w> </span><span class=n>names</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>[]</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Hello, nobody.&#34;</span><span class=p>)</span><span class=w> </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Hello, </span><span class=si>{}</span><span class=s>.&#34;</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w> </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>[</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>]</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Hello, </span><span class=si>{}</span><span class=s> and </span><span class=si>{}</span><span class=s>.&#34;</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>[</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>]</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Hello, everyone from </span><span class=si>{}</span><span class=s> to </span><span class=si>{}</span><span class=s>.&#34;</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=reference-patterns>Reference Patterns</h4><p>对于引用，Rust支持两种模式：<code>ref</code>模式和<code>&</code>模式。<strong>前者借用匹配值的元素，后者匹配引用</strong>。</p><p>需要一种模式来借用而不<code>move</code>匹配的值。用关键字<code>ref</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>account</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Account</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>ref</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=k>ref</span><span class=w> </span><span class=n>language</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ui</span><span class=p>.</span><span class=n>greet</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>language</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ui</span><span class=p>.</span><span class=n>show_settings</span><span class=p>(</span><span class=o>&amp;</span><span class=n>account</span><span class=p>);</span><span class=w> </span><span class=c1>// ok 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>使用<code>ref mut</code>借用<code>mut</code>引用</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>line_result</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Err</span><span class=p>(</span><span class=k>ref</span><span class=w> </span><span class=n>err</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>log_error</span><span class=p>(</span><span class=n>err</span><span class=p>),</span><span class=w>   </span><span class=c1>// `err` is &amp;Error (shared ref) 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=nb>Ok</span><span class=p>(</span><span class=k>ref</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>line</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>             </span><span class=c1>// `line` is &amp;mut String (mut ref)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>trim_comments</span><span class=p>(</span><span class=n>line</span><span class=p>);</span><span class=w>            </span><span class=c1>// modify the String in place
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>handle</span><span class=p>(</span><span class=n>line</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>以<code>&</code>开头的模式匹配引用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>sphere</span><span class=p>.</span><span class=n>center</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>&amp;</span><span class=n>Point3d</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>,</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=c1>// 这里 x, y, z 是值，实现了 Copy trait
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>表达式和模式天生是相反的。表达式<code>(x, y)</code>用两个值创建一个新元组，模式<code>(x, y)</code>则相反：它匹配元组并破坏后取出两个值。对<code>&</code>而言也一样：表达式<code>&</code>创建引用，模式中的<code>&</code>匹配引用。匹配引用中，生命周期是必要条件。不能对共享引用采取<code>mut</code>操作。不能从引用（包括<code>mut</code>引用）中move出值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>friend</span><span class=p>.</span><span class=n>borrow_car</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Car</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>engine</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=p>})</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=c1>// error: can&#39;t move out of borrow 这里 engine 没有实现 Copy trait
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>修改：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Car</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>ref</span><span class=w> </span><span class=n>engine</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=p>})</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=c1>// ok, engine is a reference
</span></span></span></code></pre></td></tr></table></div></div><p>可以使用<code>&</code>模式取得引用所指向的字符：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>chars</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// chars.peek() 返回 Option&lt;&amp;char&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;coming up: </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;end of chars&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=match-guards>Match Guards</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>point_to_hex</span><span class=p>(</span><span class=n>click</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;That&#39;s not a game space.&#34;</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Some</span><span class=p>(</span><span class=n>hex</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>hex</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>current_hex</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;You are already there! You must click somewhere else&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nb>Ok</span><span class=p>(</span><span class=n>hex</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>But Rust also provides match guards, extra conditions that must be true in order for a match arm to apply, written as <code>if CONDITION</code>, between the pattern and the arm’s <code>=></code> token:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>point_to_hex</span><span class=p>(</span><span class=n>click</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;That&#39;s not a game space.&#34;</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Some</span><span class=p>(</span><span class=n>hex</span><span class=p>)</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>hex</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>current_hex</span><span class=w> </span><span class=o>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;You are already there! You must click somewhere else&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Some</span><span class=p>(</span><span class=n>hex</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>hex</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>If the pattern matches, but the condition is false, matching continues with the next arm.</p><h4 id=matching-multiple-possibilities>Matching Multiple Possibilities</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>at_end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>chars</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=sc>&#39;\r&#39;</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=sc>&#39;\n&#39;</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>或者</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>next_char</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sc>&#39;0&#39;</span><span class=o>..=</span><span class=sc>&#39;9&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>read_number</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sc>&#39;a&#39;</span><span class=o>..=</span><span class=sc>&#39;z&#39;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;A&#39;</span><span class=o>..=</span><span class=sc>&#39;Z&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>read_word</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sc>&#39; &#39;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;\t&#39;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;\n&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>skip_whitespace</span><span class=p>(),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>handle_punctuation</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=binding-with--patterns>Binding with @ Patterns</h4><p><strong><code>x @ pattern</code>匹配给定的 pattern，但成功之后，不是基于匹配值的元素来创建变量，而是把匹配值整个移动或复制到一个变量 <code>x</code> 中</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>rect</span><span class=w> </span><span class=o>@</span><span class=w> </span><span class=n>Shape</span>::<span class=n>Rect</span><span class=p>(</span><span class=o>..</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>optimized_paint</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rect</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>@ </code>patterns are also useful with ranges:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>chars</span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Some</span><span class=p>(</span><span class=n>digit</span><span class=w> </span><span class=o>@</span><span class=w> </span><span class=sc>&#39;0&#39;</span><span class=o>..=</span><span class=sc>&#39;9&#39;</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>read_number</span><span class=p>(</span><span class=n>digit</span><span class=p>,</span><span class=w> </span><span class=n>chars</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>},</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=where-patterns-are-allowed>Where Patterns Are Allowed</h4><p>The meaning is always the same: instead of just storing a value in a single variable, Rust uses pattern matching to take the value apart.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// ...unpack a struct into three new local variables
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>Track</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>album</span><span class=p>,</span><span class=w> </span><span class=n>track_number</span><span class=p>,</span><span class=w> </span><span class=n>title</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>song</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...unpack a function argument that&#39;s a tuple
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>distance_to</span><span class=p>((</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>)</span>: <span class=p>(</span><span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=kt>f64</span><span class=p>))</span><span class=w> </span>-&gt; <span class=kt>f64</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...iterate over keys and values of a HashMap
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>document</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>&amp;</span><span class=n>cache_map</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Document #</span><span class=si>{}</span><span class=s>: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>document</span><span class=p>.</span><span class=n>title</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...automatically dereference an argument to a closure
</span></span></span><span class=line><span class=cl><span class=c1>// (handy because sometimes other code passes you a reference 
</span></span></span><span class=line><span class=cl><span class=c1>// when you&#39;d rather have a copy)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>numbers</span><span class=p>.</span><span class=n>fold</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=o>|</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>num</span><span class=o>|</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>num</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>上面的都是 <em>irrefutable patterns</em>，下面的是<em>refutable pattern</em>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w> </span><span class=c1>// ...handle just one enum variant specially
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>RoughTime</span>::<span class=n>InTheFuture</span><span class=p>(</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>user</span><span class=p>.</span><span class=n>date_of_birth</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>user</span><span class=p>.</span><span class=n>set_time_traveler</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...run some code only if a table lookup succeeds
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>document</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cache_map</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>send_cached_response</span><span class=p>(</span><span class=n>document</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...repeatedly try something until it succeeds
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>err</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>present_cheesy_anti_robot_task</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>log_robot_attempt</span><span class=p>(</span><span class=n>err</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// let the user try again (it might still be a human)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...manually loop over an iterator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lines</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>read_paragraph</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>lines</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=populating-a-binary-tree>Populating a Binary Tree</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Empty</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>NonEmpty</span><span class=p>(</span><span class=nb>Box</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>TreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>element</span>: <span class=nc>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>left</span>: <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>right</span>: <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>Ord</span><span class=o>&gt;</span><span class=w>  </span><span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=o>*</span><span class=bp>self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>BinaryTree</span>::<span class=n>Empty</span><span class=w> </span><span class=o>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=o>*</span><span class=bp>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BinaryTree</span>::<span class=n>NonEmpty</span><span class=p>(</span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>TreeNode</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>element</span>: <span class=nc>value</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>left</span>: <span class=nc>BinaryTree</span>::<span class=n>Empty</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>right</span>: <span class=nc>BinaryTree</span>::<span class=n>Empty</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>})),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>BinaryTree</span>::<span class=n>NonEmpty</span><span class=p>(</span><span class=k>ref</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=n>element</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>tree</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BinaryTree</span>::<span class=n>Empty</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tree</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=s>&#34;Mercury&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tree</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=s>&#34;Venus&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=chapter-11-traits-and-generics><strong>Chapter 11. Traits and Generics</strong></h2><p>Rust supports polymorphism with two related features: <strong>traits</strong> and <strong>generics</strong>.</p><p>Generics and traits are closely related: generic functions use traits in bounds to spell out what types of arguments they can be applied to. So we’ll also talk about <strong>how <code>&amp;mut dyn Write</code> and <code>&lt;T: Write></code> are similar, how they’re different</strong>, and how to choose between these two ways of using traits.</p><h3 id=using-traits><strong>Using Traits</strong></h3><ul><li>A value that implements <code>std::io::Write</code> can write out bytes.</li><li>A value that implements <code>std::iter::Iterator</code> can produce a sequence of values.</li><li>A value that implements <code>std::clone::Clone</code> can make clones of itself in memory.</li><li>A value that implements <code>std::fmt::Debug</code> can be printed using println!() with the {:?} format specifier.</li></ul><p>trait本身必须在作用域中。否则，trait的所有方法都是隐藏的。</p><p>But since Rust makes you import the traits you plan to use, crates are free to take advantage of this superpower. To get a conflict, you’d have to import two traits that add a method with the same name to the same type. This is rare in practice. (If you do run into a conflict, you can spell out what you want using fully qualified method syntax, covered later in the chapter.)</p><p>The reason <strong>Clone and Iterator</strong> methods work without any special imports is that they’re always in scope by default: they’re part of <strong>the standard prelude</strong>, names that Rust automatically imports into every module.</p><h4 id=trait-objects><strong>Trait Objects</strong></h4><p>Rust doesn’t permit variables of type dyn Write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=n>Write</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>buf</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>writer</span>: <span class=nc>dyn</span><span class=w> </span><span class=n>Write</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buf</span><span class=p>;</span><span class=w> </span><span class=c1>// error: `Write` does not have a constant size
</span></span></span></code></pre></td></tr></table></div></div><p>A variable’s size has to be known at compile time, and types that implement Write can be any size.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>buf</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>writer</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=n>Write</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>buf</span><span class=p>;</span><span class=w> </span><span class=c1>// ok
</span></span></span></code></pre></td></tr></table></div></div><p>A reference to a trait type, like writer, is called a <em><strong>trait object</strong></em>. Like any other reference, a trait object points to some value, it has a lifetime, and it can be either mut or shared.</p><h4 id=trait-object-layout><strong>Trait object layout</strong></h4><p>In memory, <strong>a trait object is a fat pointer</strong> consisting of a pointer to the value, plus a pointer to a table representing that value’s type. <strong>Each trait object therefore takes up two machine words.</strong></p><p><img src=/img/2022-07-05-Programming-Rust/image-20220716142028472.png loading=lazy alt=image-20220716142028472></p><p>In Rust, as in C++, <strong>the vtable is generated once, at compile time</strong>, and shared by all objects of the same type. Everything shown in the darker shade in Figure 11-1, <strong>including the vtable, is a private implementation</strong> detail of Rust. Again, these aren’t fields and data structures that you can access directly. Instead, the language automatically uses the vtable when you call a method of a trait object, to determine which implementation to call.</p><p>Rust automatically converts ordinary references into trait objects when needed.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>local_file</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>File</span>::<span class=n>create</span><span class=p>(</span><span class=s>&#34;hello.txt&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>say_hello</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>local_file</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Likewise, Rust will happily convert a <code>Box&lt;File></code> to a <code>Box&lt;dyn Write></code>, a value that owns a writer in the heap:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>w</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Write</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>local_file</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This kind of conversion is the only way to create a trait object. What the compiler is actually doing here is very simple. At the point where the conversion happens, Rust knows the referent’s true type (in this case, File), so it just adds the address of the appropriate vtable, turning the regular pointer into a fat pointer.</p><h4 id=generic-functions-and-type-parameters><strong>Generic Functions and Type Parameters</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>say_hello</span><span class=p>(</span><span class=n>out</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=n>Write</span><span class=p>)</span><span class=w>   </span><span class=c1>// plain function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>say_hello</span><span class=o>&lt;</span><span class=n>W</span>: <span class=nc>Write</span><span class=o>&gt;</span><span class=p>(</span><span class=n>out</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>W</span><span class=p>)</span><span class=w> </span><span class=c1>// generic function
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>say_hello</span><span class=o>&lt;</span><span class=n>W</span>: <span class=nc>Write</span><span class=o>&gt;</span><span class=p>(</span><span class=n>out</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>W</span><span class=p>)</span><span class=w> </span><span class=c1>// generic function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>say_hello</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>local_file</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=c1>// calls say_hello::&lt;File&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>say_hello</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>bytes</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=c1>// calls say_hello::&lt;Vec&lt;u8&gt;&gt;
</span></span></span></code></pre></td></tr></table></div></div><p>This process is known as <em><strong>monomorphization</strong></em>, and the compiler handles it all automatically.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// calling a generic method collect&lt;C&gt;() that takes no arguments 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>v1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=mi>1000</span><span class=p>).</span><span class=n>collect</span><span class=p>();</span><span class=w>             </span><span class=c1>// error: can&#39;t infer type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>v2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=mi>1000</span><span class=p>).</span><span class=n>collect</span>::<span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;&gt;</span><span class=p>();</span><span class=w> </span><span class=c1>// ok
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>run_query</span><span class=o>&lt;</span><span class=n>M</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=o>&gt;</span><span class=p>(</span><span class=n>data</span>: <span class=kp>&amp;</span><span class=nc>DataSet</span><span class=p>,</span><span class=w> </span><span class=n>map</span>: <span class=nc>M</span><span class=p>,</span><span class=w> </span><span class=n>reduce</span>: <span class=nc>R</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Results</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=w> </span><span class=n>M</span>: <span class=nc>Mapper</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Serialize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>R</span>: <span class=nc>Reducer</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Serialize</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>生命周期参数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Return a reference to the point in `candidates` that&#39;s
</span></span></span><span class=line><span class=cl><span class=sd>/// closest to the `target` point.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>fn</span> <span class=nf>nearest</span><span class=o>&lt;</span><span class=na>&#39;t</span><span class=p>,</span><span class=w> </span><span class=na>&#39;c</span><span class=p>,</span><span class=w> </span><span class=n>P</span><span class=o>&gt;</span><span class=p>(</span><span class=n>target</span>: <span class=kp>&amp;</span><span class=na>&#39;t</span> <span class=nc>P</span><span class=p>,</span><span class=w> </span><span class=n>candidates</span>: <span class=kp>&amp;</span><span class=na>&#39;c</span> <span class=p>[</span><span class=n>P</span><span class=p>])</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;c</span> <span class=nc>P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=w> </span><span class=n>P</span>: <span class=nc>MeasureDistance</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>生命周期不会对机器码有任何影响。</p><p>All the features introduced in this section—bounds, where clauses, lifetime parameters, and so forth—<strong>can be used on all generic items</strong>, not just functions.</p><h4 id=which-to-use>Which to Use</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Vegetable</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Salad</span><span class=o>&lt;</span><span class=n>V</span>: <span class=nc>Vegetable</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>veggies</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>V</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>沙拉结构体用泛型函数实现，但是只能放一种蔬菜。</p><p>考虑到蔬菜值的大小可能差别比较大，不能直接用 Vec。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Salad</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>veggies</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Vegetable</span><span class=o>&gt;</span><span class=w> </span><span class=c1>// error: `dyn Vegetable` does
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                              </span><span class=c1>// not have a constant size
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>可以这样实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Salad</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>veggies</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Vegetable</span><span class=o>&gt;&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Another possible reason to use trait objects is to reduce the total amount of compiled code.</p><p>那么在不考虑沙拉或者low-resource environments这两种情况下，选择泛型函数有三个优点：</p><ul><li>The first advantage is <strong>speed</strong>. 会通过静态分发的方式，消除动态查找的时间。</li><li>The second advantage of generics is that <strong>not every trait can support trait objects</strong>.</li><li>The third advantage of generics is that it’s easy to <strong>bound a generic type parameter with several traits at once</strong>, as our top_ten function did when it required its T parameter to implement Debug + Hash + Eq. Trait objects can’t do this: types like &amp;mut (dyn Debug + Hash + Eq) aren’t supported in Rust. (You can work around this with subtraits, defined later in this chapter, but it’s a bit involved.)</li></ul><h3 id=defining-and-implementing-traits>Defining and Implementing Traits</h3><p>定义trait：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// A trait for characters, items, and scenery -
</span></span></span><span class=line><span class=cl><span class=sd>/// anything in the game world that&#39;s visible on screen. 
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>trait</span><span class=w> </span><span class=n>Visible</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Render this object on the given canvas.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>draw</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>canvas</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Canvas</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Return true if clicking at (x, y) should /// select this object.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>hit_test</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>实现trait，用<code>impl TraitName for Type</code>。</p><p>Everything defined in a trait <code>impl</code> must actually be a feature of the trait.</p><p>不在trait里的辅助方法要单独放在<code>impl Type</code>里面实现。而且实现trait时也可以调用这个辅助方法。</p><h4 id=default-methods>Default Methods</h4><p>trait的默认实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Write</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>write</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>buf</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>u8</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>flush</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>write_all</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>buf</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>u8</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>bytes_written</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=n>bytes_written</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>buf</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>bytes_written</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>write</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buf</span><span class=p>[</span><span class=n>bytes_written</span><span class=o>..</span><span class=p>])</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(())</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=traits-and-other-peoples-types><strong>Traits and Other People’s Types</strong></h4><p>Rust lets you implement any trait on any type, as long as <strong>either the trait or the type is introduced in the current crate</strong>.</p><p>The sole purpose of this particular trait is to add a method to an existing type, char. This is called an <em><strong>extension trait</strong></em>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>IsEmoji</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>is_emoji</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=sd>/// Implement IsEmoji for the built-in character type.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>impl</span><span class=w> </span><span class=n>IsEmoji</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>is_emoji</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=sc>&#39;$&#39;</span><span class=p>.</span><span class=n>is_emoji</span><span class=p>(),</span><span class=w> </span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>You can even use a generic impl block to add an extension trait to a whole family of types at once.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// You can write HTML to any std::io writer.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>W</span>: <span class=nc>Write</span><span class=o>&gt;</span><span class=w> </span><span class=n>WriteHtml</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>W</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>write_html</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>html</span>: <span class=kp>&amp;</span><span class=nc>HtmlDocument</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>We said earlier that when you implement a trait, either the trait or the type must be new in the current crate. This is called the <strong>orphan rule</strong>. It helps Rust ensure that trait implementations are unique.</p><h4 id=self-in-traits>Self in Traits</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>Clone</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Self作为返回类型意味着<code>x.clone()</code>的类型就是<code>x</code>的类型，不管具体什么类型。</p><p><strong>使用Self类型的trait与trait objects不能共存。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Spliceable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>splice</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// error: the trait `Spliceable` cannot be made into an object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>splice_anything</span><span class=p>(</span><span class=n>left</span>: <span class=kp>&amp;</span><span class=nc>dyn</span><span class=w> </span><span class=n>Spliceable</span><span class=p>,</span><span class=w> </span><span class=n>right</span>: <span class=kp>&amp;</span><span class=nc>dyn</span><span class=w> </span><span class=n>Spliceable</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>combo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=p>.</span><span class=n>splice</span><span class=p>(</span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Rust rejects this code because it has no way to type-check the call <code>left.splice(right)</code>. The whole point of trait objects is that the type isn’t known until run time. Rust has no way to know at compile time if left and right will be the same type, as required.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>MegaSpliceable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>splice</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>dyn</span><span class=w> </span><span class=n>MegaSpliceable</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>MegaSpliceable</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>There’s no problem type-checking calls to this <code>.splice()</code> method because the type of the argument other is not required to match the type of self, as long as both types are MegaSpliceable.</p><h4 id=subtraits>Subtraits</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Someone in the game world, either the player or some other 
</span></span></span><span class=line><span class=cl><span class=sd>/// pixie, gargoyle, squirrel, ogre, etc.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>trait</span><span class=w> </span><span class=n>Creature</span>: <span class=nc>Visible</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>position</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=kt>i32</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>facing</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Direction</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Here, we say that <strong>Creature is a subtrait of Visible</strong>, and that Creature is Visible’s supertrait.</p><p>But in Rust, <strong>a subtrait does not inherit the associated items of its supertrait</strong>; each trait still needs to be in scope if you want to call its methods.</p><p>In fact, <strong>Rust’s subtraits are really just a shorthand for a bound on Self</strong>. A definition of Creature like this is exactly equivalent to the one shown earlier:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Creature</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nc>Visible</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=type-associated-functions-1>Type-Associated Functions</h4><p>Traits can include type-associated functions, Rust’s analog to static methods:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>StringSet</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Return a new empty set. 
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w> </span><span class=c1>// 没有 self 参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Return a set that contains all the strings in `strings`.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>from_slice</span><span class=p>(</span><span class=n>strings</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w> </span><span class=c1>// 没有 self 参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Find out if this set contains a particular `value`.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>contains</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>string</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Add a string to this set.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>string</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>If you want to use <code>&amp;dyn StringSet</code> trait objects, you must change the trait, adding the bound where <code>Self: Sized</code> to each associated function that doesn’t take a self argument by reference:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>StringSet</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>from_slice</span><span class=p>(</span><span class=n>strings</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>contains</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>string</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>string</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>With these additions, StringSet trait objects are allowed; they still don’t support <code>new</code> or <code>from_slice</code>, but you can create them and use them to call <code>.contains()</code> and <code>.add()</code>.</strong></p><h3 id=fully-qualified-method-calls>Fully Qualified Method Calls</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=s>&#34;hello&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>str</span>::<span class=n>to_string</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nb>ToString</span>::<span class=n>to_string</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=kt>str</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nb>ToString</span><span class=o>&gt;</span>::<span class=n>to_string</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>)</span><span class=w> </span><span class=c1>// a fully qualified method call
</span></span></span></code></pre></td></tr></table></div></div><p>With fully qualified calls, you can say exactly which method you mean, and that can help in a few odd cases:</p><ul><li>When two methods have the same name.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>outlaw</span><span class=p>.</span><span class=n>draw</span><span class=p>();</span><span class=w> </span><span class=c1>// error: draw on screen or draw pistol? 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Visible</span>::<span class=n>draw</span><span class=p>(</span><span class=o>&amp;</span><span class=n>outlaw</span><span class=p>);</span><span class=w>   </span><span class=c1>// ok: draw on screen
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>HasPistol</span>::<span class=n>draw</span><span class=p>(</span><span class=o>&amp;</span><span class=n>outlaw</span><span class=p>);</span><span class=w> </span><span class=c1>// ok: corral
</span></span></span></code></pre></td></tr></table></div></div></li><li>When the type of the self argument can’t be inferred:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>zero</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=c1>// type unspecified; could be `i8`, `u8`, ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>zero</span><span class=p>.</span><span class=n>abs</span><span class=p>();</span><span class=w>     </span><span class=c1>// error: can&#39;t call method `abs` 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=c1>// on ambiguous numeric type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>i64</span>::<span class=n>abs</span><span class=p>(</span><span class=n>zero</span><span class=p>);</span><span class=w> </span><span class=c1>// ok
</span></span></span></code></pre></td></tr></table></div></div></li><li>When using the function itself as a function value:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>words</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>line</span><span class=p>.</span><span class=n>split_whitespace</span><span class=p>()</span><span class=w>     </span><span class=c1>// iterator produces &amp;str values
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=nb>ToString</span>::<span class=n>to_string</span><span class=p>)</span><span class=w> </span><span class=c1>// ok 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>.</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li>When calling trait methods in macros.</li></ul><h3 id=traits-that-define-relationships-between-types>Traits That Define Relationships Between Types</h3><p>Traits can also be used in situations where there are multiple types that have to work together. They can describe relationships between types.</p><h4 id=associated-types-or-how-iterators-work>Associated Types (or How Iterators Work)</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>type</span> <span class=nc>Item</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>..</span><span class=p>.</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The first feature of this trait, <code>type Item;</code>, is an associated type.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Debug</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>dump</span><span class=o>&lt;</span><span class=n>I</span><span class=o>&gt;</span><span class=p>(</span><span class=n>iter</span>: <span class=nc>I</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=w> </span><span class=n>I</span>: <span class=nb>Iterator</span><span class=p>,</span><span class=w> </span><span class=n>I</span>::<span class=n>Item</span>: <span class=nc>Debug</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>trait object:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>dump</span><span class=p>(</span><span class=n>iter</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>index</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>iter</span><span class=p>.</span><span class=n>enumerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>: </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>index</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=generic-traits-or-how-operator-overloading-works>Generic Traits (or How Operator Overloading Works)</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// std::ops::Mul, the trait for types that support `*`.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Mul</span><span class=o>&lt;</span><span class=no>RHS</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// The resulting type after applying the `*` operator 
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>type</span> <span class=nc>Output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// The method for the `*` operator
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>mul</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>RHS</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The type parameter here means the same thing that it means on a struct or function: <strong>Mul is a generic trait, and its instances <code>Mul&lt;f64></code>, <code>Mul&lt;String></code>, <code>Mul&lt;Size></code>, etc., are all different traits</strong>.</p><p>Generic traits get a special dispensation when it comes to the orphan rule: <strong>you can implement a foreign trait for a foreign type</strong>, so long as one of the trait’s type parameters is a type defined in the current crate.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Mul</span><span class=o>&lt;</span><span class=no>RHS</span><span class=o>=</span><span class=bp>Self</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The syntax <code>RHS=Self</code> means that RHS defaults to Self. If I write <code>impl Mul for Complex</code>, without specifying Mul’s type parameter, it means impl <code>Mul&lt;Complex> for Complex</code>. In a bound, if I write <code>where T: Mul</code>, it means where <code>T: Mul&lt;T></code>.</p><h4 id=impl-trait>impl Trait</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>vec</span>::<span class=n>IntoIter</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>cyclical_zip</span><span class=p>(</span><span class=n>v</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>u</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt;
</span></span><span class=line><span class=cl>  <span class=nc>iter</span>::<span class=n>Cycle</span><span class=o>&lt;</span><span class=n>iter</span>::<span class=n>Chain</span><span class=o>&lt;</span><span class=n>IntoIter</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>IntoIter</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 			 					             
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>v</span><span class=p>.</span><span class=n>into_iter</span><span class=p>().</span><span class=n>chain</span><span class=p>(</span><span class=n>u</span><span class=p>.</span><span class=n>into_iter</span><span class=p>()).</span><span class=n>cycle</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这种写法太繁琐，可以这样写：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>cyclical_zip</span><span class=p>(</span><span class=n>v</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>u</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=kt>u8</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>into_iter</span><span class=p>().</span><span class=n>chain</span><span class=p>(</span><span class=n>u</span><span class=p>.</span><span class=n>into_iter</span><span class=p>()).</span><span class=n>cycle</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>但是这是动态分发，影响效率。可以使用 <code>impl Trait</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>cyclical_zip</span><span class=p>(</span><span class=n>v</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>u</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>v</span><span class=p>.</span><span class=n>into_iter</span><span class=p>().</span><span class=n>chain</span><span class=p>(</span><span class=n>u</span><span class=p>.</span><span class=n>into_iter</span><span class=p>()).</span><span class=n>cycle</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>make_shape</span><span class=p>(</span><span class=n>shape</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=n>Shape</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>match</span><span class=w> </span><span class=n>shape</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;circle&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Circle</span>::<span class=n>new</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;triangle&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Triangle</span>::<span class=n>new</span><span class=p>(),</span><span class=w> </span><span class=c1>// error: incompatible types 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=s>&#34;shape&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Rectangle</span>::<span class=n>new</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>It’s important to note that <strong>Rust doesn’t allow trait methods to use <code>impl Trait</code> return values</strong>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>print</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=o>&gt;</span><span class=p>(</span><span class=n>val</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>print</span><span class=p>(</span><span class=n>val</span>: <span class=nc>impl</span><span class=w> </span><span class=n>Display</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>There is one important exception. Using generics allows callers of the function to specify the type of the generic arguments, like <code>print::&lt;i32>(42)</code>, while using impl Trait does not.</p><h4 id=associated-consts-1>Associated Consts</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-RUST data-lang=RUST><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Greet</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>const</span><span class=w> </span><span class=no>GREETING</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span> <span class=o>=</span><span class=w> </span><span class=s>&#34;Hello&#34;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>greet</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>fib</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Float</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Add</span><span class=o>&lt;</span><span class=n>Output</span><span class=o>=</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>n</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>match</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=mi>0</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>T</span>::<span class=no>ZERO</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=mi>1</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>T</span>::<span class=no>ONE</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>n</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>fib</span>::<span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>fib</span>::<span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=reverse-engineering-bounds>Reverse-Engineering Bounds</h3><p>和编译器做斗争，加上 Bounds。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=p>{</span><span class=n>Add</span><span class=p>,</span><span class=w> </span><span class=n>Mul</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>dot</span><span class=o>&lt;</span><span class=n>N</span><span class=o>&gt;</span><span class=p>(</span><span class=n>v1</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>N</span><span class=p>],</span><span class=w> </span><span class=n>v2</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>N</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>N</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>N</span>: <span class=nc>Add</span><span class=o>&lt;</span><span class=n>Output</span><span class=o>=</span><span class=n>N</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Mul</span><span class=o>&lt;</span><span class=n>Output</span><span class=o>=</span><span class=n>N</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Default</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Copy</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>total</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>N</span>::<span class=n>default</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=n>v1</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>total</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>total</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>v1</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>v2</span><span class=p>[</span><span class=n>i</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>total</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[test]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>test_dot</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>dot</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>],</span><span class=w> </span><span class=o>&amp;</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>]),</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>dot</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[</span><span class=mf>53.0</span><span class=p>,</span><span class=w> </span><span class=mf>7.0</span><span class=p>],</span><span class=w> </span><span class=o>&amp;</span><span class=p>[</span><span class=mf>1.0</span><span class=p>,</span><span class=w> </span><span class=mf>5.0</span><span class=p>]),</span><span class=w> </span><span class=mf>88.0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>或者用第三方库<code>num</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>num</span>::<span class=n>Num</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>dot</span><span class=o>&lt;</span><span class=n>N</span>: <span class=nc>Num</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Copy</span><span class=o>&gt;</span><span class=p>(</span><span class=n>v1</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>N</span><span class=p>],</span><span class=w> </span><span class=n>v2</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>N</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>N</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>total</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>N</span>::<span class=n>zero</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=n>v1</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>total</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>total</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>v1</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>v2</span><span class=p>[</span><span class=n>i</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>total</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Rust为什么要这样设计呢？为什么不模仿“鸭子类型”？这样设计的优点是：</p><ul><li>可以让泛型代码具有向前兼容的能力。</li><li>你能通过编译器保存就知道要解决的麻烦在哪里。</li><li>或许，明确写出绑定最重要的好处是它们在代码和文档里都存在。</li></ul><h3 id=traits-as-a-foundation>Traits as a Foundation</h3><p>Traits are one of the main organizing features in Rust, and with good reason. There’s nothing better to design a program or library around than a good interface.</p><h2 id=chapter-12-operator-overloading><strong>Chapter 12. Operator Overloading</strong></h2><p>The traits for operator overloading fall into a few categories depending on what part of the language they support.</p><div class=table-wrapper><table><thead><tr><th>类别</th><th>Trait</th><th>操作符</th></tr></thead><tbody><tr><td>Unary operators</td><td>std::ops::Neg</td><td><code>-x</code></td></tr><tr><td></td><td>std::ops::Not</td><td><code>!x</code></td></tr><tr><td>Arithmetic operators</td><td>std::ops::Add</td><td><code>x + y</code></td></tr><tr><td></td><td>std::ops::Sub</td><td><code>x - y</code></td></tr><tr><td></td><td>std::ops::Mul</td><td><code>x * y</code></td></tr><tr><td></td><td>std::ops::Div</td><td><code>x / y</code></td></tr><tr><td></td><td>std::ops::Rem</td><td><code>x % y</code></td></tr><tr><td>Bitwise operators</td><td>std::ops::BitAnd</td><td><code>x & y</code></td></tr><tr><td></td><td>std::ops::BitOr</td><td>`x</td></tr><tr><td></td><td>std::ops::BitXor</td><td><code>x ^ y</code></td></tr><tr><td></td><td>std::ops::Shl</td><td><code>x &lt;&lt; y</code></td></tr><tr><td></td><td>std::ops::Shr</td><td><code>x >> y</code></td></tr><tr><td>Compound assignment</td><td>std::ops::AddAssign</td><td><code>x += y</code></td></tr><tr><td>arithmetic operators</td><td>std::ops::SubAssign</td><td><code>x -= y</code></td></tr><tr><td></td><td>std::ops::MulAssign</td><td><code>x *= y</code></td></tr><tr><td></td><td>std::ops::DivAssign</td><td><code>x /= y</code></td></tr><tr><td></td><td>std::ops::RemAssign</td><td><code>x %= y</code></td></tr><tr><td>Compound assignment</td><td>std::ops::BitAddAssign</td><td><code>x &= y</code></td></tr><tr><td>bitwise operators</td><td>std::ops::BitOrAssign</td><td>`x</td></tr><tr><td></td><td>std::ops::BitXorAssign</td><td><code>x ^= y</code></td></tr><tr><td></td><td>std::ops::ShlAssign</td><td><code>x &lt;&lt;= y</code></td></tr><tr><td></td><td>std::ops::ShrAssign</td><td><code>x >>= y</code></td></tr><tr><td>Comparison</td><td>std::cmp::PartialEq</td><td><code>x == y</code>, <code>x != y</code></td></tr><tr><td></td><td>std::cmp::PartialOrd</td><td><code>x &lt; y</code>, <code>x &lt;= y</code>, <code>x > y</code>, <code>x >= y</code></td></tr><tr><td>Indexing</td><td>std::ops::Index</td><td><code>x[y]</code>、<code>&amp;x[y]</code></td></tr><tr><td></td><td>std::ops::IndexMut</td><td><code>x[y] = z</code>、<code>&amp;mut x[y]</code></td></tr></tbody></table></div><h3 id=arithmetic-and-bitwise-operators><strong>Arithmetic and Bitwise Operators</strong></h3><p><code>std::ops::Add</code>定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Add</span><span class=o>&lt;</span><span class=n>Rhs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Rhs</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>实现:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=n>Add</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Add</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Complex</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nc>Add</span><span class=o>&lt;</span><span class=n>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Complex</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>re</span>: <span class=nc>self</span><span class=p>.</span><span class=n>re</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>re</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>im</span>: <span class=nc>self</span><span class=p>.</span><span class=n>im</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>im</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>混合实现，加法的左边和右边不要求是同一类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=n>Add</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>L</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=o>&gt;</span><span class=w> </span><span class=n>Add</span><span class=o>&lt;</span><span class=n>Complex</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Complex</span><span class=o>&lt;</span><span class=n>L</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=w> </span><span class=n>L</span>: <span class=nc>Add</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Complex</span><span class=o>&lt;</span><span class=n>L</span>::<span class=n>Output</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Complex</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Complex</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>re</span>: <span class=nc>self</span><span class=p>.</span><span class=n>re</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>re</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>im</span>: <span class=nc>self</span><span class=p>.</span><span class=n>im</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=n>im</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=unary-operators><strong>Unary Operators</strong></h4><p>Note that ! complements bool values and performs a bitwise complement (that is, flips the bits) when applied to integers; it plays the role of both the ! and ~ operators from C and C++.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Neg</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>neg</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>trait</span><span class=w> </span><span class=n>Not</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>not</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>复数的实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=n>Neg</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Neg</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Complex</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nc>Neg</span><span class=o>&lt;</span><span class=n>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Complex</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>neg</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Complex</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Complex</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>re</span>: <span class=o>-</span><span class=bp>self</span><span class=p>.</span><span class=n>re</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>im</span>: <span class=o>-</span><span class=bp>self</span><span class=p>.</span><span class=n>im</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=binary-operators><strong>Binary Operators</strong></h4><p>All of Rust’s numeric types implement the arithmetic operators. Rust’s integer types and bool implement the bitwise operators. There are also implementations that accept references to those types as either or both operands.</p><p>You can use the + operator to concatenate a String with a &amp;str slice or another String. However, Rust does not permit the left operand of + to be a &amp;str, to discourage building up long strings by repeatedly concatenating small pieces on the left. (This performs poorly, requiring time quadratic in the final length of the string.)</p><h4 id=compound-assignment-operators><strong>Compound Assignment Operators</strong></h4><p>A compound assignment expression is one like <code>x += y</code> or <code>x &= y</code>: it takes two operands, performs some operation on them like addition or a bitwise AND, and stores the result back in the left operand. In Rust, t<strong>he value of a compound assignment expression is always <code>()</code>, never the value stored</strong>.</p><p>Many languages have operators like these and usually define them as shorthand for expressions like <code>x = x + y</code> or <code>x = x & y</code>. However, Rust doesn’t take that approach. Instead, <strong><code>x += y</code> is shorthand for the method call <code>x.add_assign(y)</code>, where <code>add_assign</code> is the sole method of the <code>std::ops::AddAssign</code> trait</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>AddAssign</span><span class=o>&lt;</span><span class=n>Rhs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>add_assign</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Rhs</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The built-in trait for a compound assignment operator is <strong>completely independent</strong> of the built-in trait for the corresponding binary operator.</p><h3 id=equivalence-comparisons><strong>Equivalence Comparisons</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>PartialEq</span><span class=o>&lt;</span><span class=n>Rhs</span>: <span class=o>?</span><span class=nb>Sized</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// This method tests for `self` and `other` values to be equal, and is used
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// by `==`.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[must_use]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>eq</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Rhs</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// This method tests for `!=`.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[must_use]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[default_method_body_is_const]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>ne</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Rhs</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>!</span><span class=bp>self</span><span class=p>.</span><span class=n>eq</span><span class=p>(</span><span class=n>other</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>用属性快速实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Clone, Copy, Debug, PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Complex</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Rust’s automatically generated implementation is essentially identical to our hand-written code, comparing each field or element of the type in turn.</p><p>This means that comparing non-Copy values like Strings, Vecs, or HashMaps doesn’t cause them to be moved, which would be troublesome:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;d</span><span class=se>\x6f</span><span class=s>v</span><span class=se>\x65</span><span class=s>t</span><span class=se>\x61</span><span class=s>i</span><span class=se>\x6c</span><span class=s>&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;</span><span class=se>\x64</span><span class=s>o</span><span class=se>\x76</span><span class=s>e</span><span class=se>\x74</span><span class=s>a</span><span class=se>\x69</span><span class=s>l&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert!</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w> </span><span class=c1>// s and t are only borrowed...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ... so they still have their values here.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s> </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=p>),</span><span class=w> </span><span class=s>&#34;dovetail dovetail&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Why is this trait called PartialEq? The traditional mathematical definition of an <em>equivalence relation</em>, of which equality is one instance, imposes three requirements. For any values x and y:</p><ul><li><p>对称性：If x == y is true, then y == x must be true as well. In other words, swapping the two sides of an equality comparison doesn’t affect the result.</p></li><li><p>传递性：If x == y and y == z, then it must be the case thatx == z. Given any chain of values, each equal to the next, each value in the chain is directly equal to every other. Equality is contagious.</p></li><li><p>自反性：It must always be true that x == x.</p></li></ul><p><strong><code>PartialEq</code>只实现了前两条，自反性不保证</strong>，比如<code>f32</code>和<code>f64</code>就不满足。<code>0.0/0.0</code>会产生非数字的值<code>NaN</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>assert!</span><span class=p>(</span><span class=kt>f64</span>::<span class=n>is_nan</span><span class=p>(</span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>Eq</code> Trait：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>Eq</span>: <span class=nb>PartialEq</span><span class=o>&lt;</span><span class=bp>Self</span><span class=o>&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>也可以用属性来快速实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Clone, Copy, Debug, Eq, PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Complex</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=ordered-comparisons><strong>Ordered Comparisons</strong></h3><p><code>std::cmp::PartialOrd</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>PartialOrd</span><span class=o>&lt;</span><span class=n>Rhs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span><span class=o>&gt;</span>: <span class=nb>PartialEq</span><span class=o>&lt;</span><span class=n>Rhs</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Rhs</span>: <span class=o>?</span><span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>partial_cmp</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Rhs</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>Ordering</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>lt</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Rhs</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>le</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Rhs</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>gt</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Rhs</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>ge</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Rhs</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Ordering</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// An ordering where a compared value is less than another.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Less</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// An ordering where a compared value is equal to another.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Equal</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// An ordering where a compared value is greater than another.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Greater</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>But if partial_cmp returns None, that means self and other are unordered with respect to each other: neither is greater than the other, nor are they equal. Among all of Rust’s primitive types, only comparisons between floating-point values ever return None: specifically, <strong>comparing a NaN (not-a-number) value with anything else returns None</strong>.</p><p>If you know that values of two types <strong>are always ordered with respect to each other</strong>, then you can implement the stricter <code>std::cmp::Ord</code> trait:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>Ord</span>: <span class=nb>Eq</span> <span class=o>+</span><span class=w> </span><span class=nb>PartialOrd</span><span class=o>&lt;</span><span class=bp>Self</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// This method returns an [`Ordering`] between `self` and `other`.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// By convention, `self.cmp(&amp;other)` returns the ordering matching the expression
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// `self &lt;operator&gt; other` if true.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// # Examples
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// ```
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// use std::cmp::Ordering;
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// assert_eq!(5.cmp(&amp;10), Ordering::Less);
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// assert_eq!(10.cmp(&amp;5), Ordering::Greater);
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// assert_eq!(5.cmp(&amp;5), Ordering::Equal);
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// ```
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=cp>#[must_use]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>cmp</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Ordering</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Almost all types that implement PartialOrd should also implement Ord. In the standard library, <strong>f32 and f64 are the only exceptions to this rule</strong>.</p><p><strong>排序应该同时实现 <code>Partial Ord</code> 和 <code>Ord</code></strong> 。You might want to sort by upper bound, for instance, and it’s easy to do that with <code>sort_by_key</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>intervals</span><span class=p>.</span><span class=n>sort_by_key</span><span class=p>(</span><span class=o>|</span><span class=n>i</span><span class=o>|</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>upper</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>The <code>Reverse</code> wrapper type</strong> takes advantage of this by implementing <code>Ord</code> with a method that simply inverts any ordering.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>cmp</span>::<span class=n>Reverse</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>intervals</span><span class=p>.</span><span class=n>sort_by_key</span><span class=p>(</span><span class=o>|</span><span class=n>i</span><span class=o>|</span><span class=w> </span><span class=n>Reverse</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>lower</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=index-and-indexmut><strong>Index and IndexMut</strong></h3><p>On any other type, the expression <code>a[i]</code> is normally shorthand for <code>*a.index(i)</code>, where index is a method of the <code>std::ops::Index</code> trait. However, if the expression is being assigned to or borrowed mutably, it’s instead shorthand for <code>*a.index_mut(i)</code>, a call to the method of the <code>std::ops::IndexMut</code> trait.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Index</span><span class=o>&lt;</span><span class=n>Idx</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Output</span>: <span class=o>?</span><span class=nb>Sized</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>index</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>index</span>: <span class=nc>Idx</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>Self</span>::<span class=n>Output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>trait</span><span class=w> </span><span class=n>IndexMut</span><span class=o>&lt;</span><span class=n>Idx</span><span class=o>&gt;</span>: <span class=nc>Index</span><span class=o>&lt;</span><span class=n>Idx</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>index_mut</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>index</span>: <span class=nc>Idx</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=bp>Self</span>::<span class=n>Output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>You can refer to a subslice with an expression like <code>a[i..j]</code> because they also implement <code>Index&lt;Range&lt;usize>></code>. That expression is shorthand for:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=o>*</span><span class=n>a</span><span class=p>.</span><span class=n>index</span><span class=p>(</span><span class=n>std</span>::<span class=n>ops</span>::<span class=n>Range</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>start</span>: <span class=nc>i</span><span class=p>,</span><span class=w> </span><span class=n>end</span>: <span class=nc>j</span><span class=w> </span><span class=p>})</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>collections</span>::<span class=n>HashMap</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>HashMap</span>::<span class=n>new</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// HashMap&lt;&amp;str, i32&gt;, 实现了 Index&lt;&amp;str&gt; trait
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;十&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;百&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>100</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;千&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>1000</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;万&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>1_0000</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;億&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>1_0000_0000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=s>&#34;十&#34;</span><span class=p>],</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=s>&#34;千&#34;</span><span class=p>],</span><span class=w> </span><span class=mi>1000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 等价于
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=n>Index</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>m</span><span class=p>.</span><span class=n>index</span><span class=p>(</span><span class=s>&#34;十&#34;</span><span class=p>),</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>m</span><span class=p>.</span><span class=n>index</span><span class=p>(</span><span class=s>&#34;千&#34;</span><span class=p>),</span><span class=w> </span><span class=mi>1000</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The Index trait’s associated type <code>Output</code> specifies what type an indexing expression produces: for our HashMap, the Index implementation’s Output type is <code>i32</code>.</p><p>Rust automatically selects <code>index_mut</code> when the indexing expression occurs in a context where it’s necessary.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>desserts</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;Howalon&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;Soan papdi&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>desserts</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>push_str</span><span class=p>(</span><span class=s>&#34; (fictional)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>desserts</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>push_str</span><span class=p>(</span><span class=s>&#34; (real)&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>后两行和下面的代码一样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=n>IndexMut</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>(</span><span class=o>*</span><span class=n>desserts</span><span class=p>.</span><span class=n>index_mut</span><span class=p>(</span><span class=mi>0</span><span class=p>)).</span><span class=n>push_str</span><span class=p>(</span><span class=s>&#34; (fictional)&#34;</span><span class=p>);</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>desserts</span><span class=p>.</span><span class=n>index_mut</span><span class=p>(</span><span class=mi>1</span><span class=p>)).</span><span class=n>push_str</span><span class=p>(</span><span class=s>&#34; (real)&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>One limitation of <code>IndexMut</code> is that, by design, it <strong>must return a mutable reference to some value</strong>.</p><p>The most common use of indexing is <strong>for collections</strong>.</p><p>This is how <code>Index</code> and <code>IndexMut</code> implementations are supposed to behave: <strong>out-of-bounds access is detected and causes a panic</strong>, the same as when you index an array, slice, or vector out of bounds.</p><h3 id=other-operators><strong>Other Operators</strong></h3><p><strong>Not all operators can be overloaded in Rust</strong>. As of Rust 1.50, <strong>the error-checking <code>?</code> operator</strong> works only with Result and Option values, though work is in progress to expand this to user-defined types as well. Similarly, <strong>the logical operators <code>&&</code> and <code>||</code></strong> are limited to Boolean values only. <strong>The <code>..</code> and <code>..=</code> operators</strong> always create a struct representing the range’s bounds, <strong>the <code>&</code> operator</strong> always borrows references, and <strong>the <code>=</code> operator</strong> always moves or copies values. None of them can be overloaded.</p><p>Rust <strong>does not support overloading the function call operator, <code>f(x)</code></strong>. Instead, when you need a callable value, you’ll typically just write a closure.</p><h2 id=chapter-13-utility-traits><strong>Chapter 13. Utility Traits</strong></h2><p><em>Language extension traits</em></p><ul><li>Drop, Deref and DerefMut</li><li>From and Into</li></ul><p><em>Marker traits</em></p><ul><li>Sized</li><li>Copy</li></ul><p><em>Public vocabulary traits</em></p><ul><li>Default</li><li>AsRef, AsMut, Borrow and BorrowMut</li><li>TryFrom and TryInto</li><li>ToOwned</li></ul><div class=table-wrapper><table><thead><tr><th>Trait</th><th>Description</th></tr></thead><tbody><tr><td><a class=link href=#drop>Drop</a></td><td>Destructors. Cleanup code that Rust runs automatically whenever a value is dropped.</td></tr><tr><td><a class=link href=#sized>Sized</a></td><td>Marker trait for types with a fixed size known at compile time, as opposed to types (such as slices) that are dynamically sized.</td></tr><tr><td><a class=link href=#clone>Clone</a></td><td>Types that support cloning values.</td></tr><tr><td><a class=link href=#copy>Copy</a></td><td>Marker trait for types that can be cloned simply by making a byte-for-byte copy of the memory containing the value.</td></tr><tr><td><a class=link href=#deref-and-derefmut>Deref and DerefMut</a></td><td>Traits for smart pointer types.</td></tr><tr><td><a class=link href=#default>Default</a></td><td>Types that have a sensible “default value.”</td></tr><tr><td><a class=link href=#asref-and-asmut>AsRef and AsMut</a></td><td>Conversion traits for borrowing one type of reference from another.</td></tr><tr><td><a class=link href=#borrow-and-borrowmut>Borrow and BorrowMut</a></td><td>Conversion traits, like AsRef/AsMut, but additionally guaranteeing consistent hashing, ordering, and equality.</td></tr><tr><td><a class=link href=#from-and-into>From and Into</a></td><td>Conversion traits for transforming one type of value into another.</td></tr><tr><td><a class=link href=#tryfrom-and-tryinto>TryFrom and TryInto</a></td><td>Conversion traits for transforming one type of value into another, for transformations that might fail.</td></tr><tr><td><a class=link href=#toowned>ToOwned</a></td><td>Conversion trait for converting a reference to an owned value.</td></tr></tbody></table></div><h3 id=drop>Drop</h3><p><code>std::ops::Drop</code> trait</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>Drop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>drop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>This implicit invocation of drop is the only way to call that method</strong>; if you try to invoke it explicitly yourself, Rust flags that as an error.</p><p>If a variable’s value gets moved elsewhere, so that the variable is uninitialized when it goes out of scope, then Rust will not try to drop that variable: there is no value in it to drop. Although a value may be moved from place to place, <strong>Rust drops it only once</strong>.</p><p>You usually won’t need to implement <code>std::ops::Drop</code> unless you’re defining <strong>a type that owns resources Rust doesn’t already know about</strong>.</p><p><strong>If a type implements <code>Drop</code>, it cannot implement the <code>Copy</code> trait</strong>. If a type is Copy, that means that simple byte-for-byte duplication is sufficient to produce an independent copy of the value. But it is typically a mistake to call the same drop method more than once on the same data.</p><p>The standard prelude includes a function to drop a value, drop, but its definition is anything but magical:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>drop</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>_x</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>从调用者那里获得所有权，然后什么也不做。Rust会在超出作用域时清楚<code>_x</code>的值，跟清除其他变量的值一样。</p><h3 id=sized><strong>Sized</strong></h3><p>A <em>sized type</em> is one whose values all have the same size in memory.</p><p>All sized types implement the <code>std::marker::Sized</code> trait, which has no methods or associated types. Rust implements it automatically for all types to which it applies; <strong>you can’t implement it yourself</strong>. The only use for <code>Sized</code> is as a bound for type variables: a bound like <strong><code>T: Sized</code></strong> requires T to be a type whose size is known at compile time. Traits of this sort are called <em><strong>marker traits</strong></em>, because the Rust language itself uses them to mark certain types as having characteristics of interest.</p><p><strong>Rust can’t store unsized values in variables or pass them as arguments</strong>. You can only deal with them through pointers like <code>&amp;str</code> or <code>Box&lt;dyn Write></code>, which themselves are sized.</p><p>In fact, this is necessary so often that it is the implicit default in Rust: if you write struct <code>S&lt;T> { ... }</code>, Rust understands you to mean struct <code>S&lt;T: Sized> { ... }</code>. If you do not want to constrain T this way, you must explicitly opt out, writing <code>struct S&lt;T: ?Sized> { ... }</code>. The <code>?Sized</code> syntax is specific to this case and means “<strong>not necessarily Sized</strong>.” For example, if you write struct <code>S&lt;T: ?Sized> { b: Box&lt;T> }</code>, then Rust will allow you to write <code>S&lt;str></code> and <code>S&lt;dyn Write></code>, where the box becomes a fat pointer, as well as <code>S&lt;i32></code> and <code>S&lt;String></code>, where the box is an ordinary pointer.</p><p>Aside from slices and trait objects, there is one more kind of unsized type. <strong>A struct type’s last field (but only its last) may be unsized, and such a struct is itself unsized</strong>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[cfg_attr(not(test), rustc_diagnostic_item = </span><span class=s>&#34;Rc&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[rustc_insignificant_dtor]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Rc</span><span class=o>&lt;</span><span class=n>T</span>: <span class=o>?</span><span class=nb>Sized</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ptr</span>: <span class=nc>NonNull</span><span class=o>&lt;</span><span class=n>RcBox</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>phantom</span>: <span class=nc>PhantomData</span><span class=o>&lt;</span><span class=n>RcBox</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// This is repr(C) to future-proof against possible field-reordering, which
</span></span></span><span class=line><span class=cl><span class=c1>// would interfere with otherwise safe [into|from]_raw() of transmutable
</span></span></span><span class=line><span class=cl><span class=c1>// inner types.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#[repr(C)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>RcBox</span><span class=o>&lt;</span><span class=n>T</span>: <span class=o>?</span><span class=nb>Sized</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>strong</span>: <span class=nc>Cell</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>weak</span>: <span class=nc>Cell</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>value</span>: <span class=nc>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=clone><strong>Clone</strong></h3><p><code>std::clone::Clone</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>Clone</span>: <span class=nb>Sized</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Returns a copy of the value.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// # Examples
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// ```
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// # #![allow(noop_method_call)]
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// let hello = &#34;Hello&#34;; // &amp;str implements Clone
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// assert_eq!(&#34;Hello&#34;, hello.clone());
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// ```
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[must_use = </span><span class=s>&#34;cloning is often expensive and is not expected to have side effects&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Performs copy-assignment from `source`.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// `a.clone_from(&amp;b)` is equivalent to `a = b.clone()` in functionality,
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// but can be overridden to reuse the resources of `a` to avoid unnecessary
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// allocations.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[default_method_body_is_const]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[cfg_attr(not(bootstrap), allow(drop_bounds))]</span><span class=w> </span><span class=c1>// FIXME remove `~const Drop` and this attr when bumping
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>clone_from</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>source</span>: <span class=kp>&amp;</span><span class=nc>Self</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>Self</span>: <span class=o>~</span><span class=k>const</span><span class=w> </span><span class=nb>Drop</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=o>~</span><span class=k>const</span><span class=w> </span><span class=n>Destruct</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>*</span><span class=bp>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>source</span><span class=p>.</span><span class=n>clone</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>clone_from</code>方法将<code>self</code>修改为<code>source</code>的一个副本。这个方法的默认定义知识简单地克隆了<code>source</code>，然后将副本转移到<code>*self</code>中。语句<code>s = t.clone();</code>必须先克隆<code>t</code>，清除<code>s</code>原来的值，然后再将克隆的值转移到<code>s</code>中。这涉及一次堆分配和一次堆释放。在泛型代码中，应该尽可能使用<code>clone_from</code>，从而在可能的情况下应用这种优化。</p><p>加上<code>#[derive(Clone)]</code>实现。</p><p>没有实现<code>Clone</code>：<code>std::sync::Mutex</code>、<code>stf::file::File</code>（但是提供了一个<code>try_clone()</code>方法）。</p><h3 id=copy><strong>Copy</strong></h3><p>A type is <code>Copy</code> if it implements the <code>std::marker::Copy</code> marker trait, which is defined as follows:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>Copy</span>: <span class=nb>Clone</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Empty.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>But because <code>Copy</code> is a marker trait with special meaning to the language, Rust permits a type to implement <code>Copy</code> only if <strong>a shallow byte-for-byte copy</strong> is all it needs. Types that own any other resources, like heap buffers or operating system handles, cannot implement <code>Copy</code>. <strong>Any type that implements the <code>Drop</code> trait cannot be <code>Copy</code></strong>. Rust presumes that if a type needs special cleanup code, it must also require special copying code and thus can’t be <code>Copy</code>.</p><p>As with <code>Clone</code>, you can ask Rust to derive Copy for you, using <code>#[derive(Copy)]</code>. You will often see both derived at once, with <code>#[derive(Copy, Clone)]</code>.</p><h3 id=deref-and-derefmut><strong>Deref and DerefMut</strong></h3><p><code>std::ops::Deref</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[lang = </span><span class=s>&#34;deref&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[doc(alias = </span><span class=s>&#34;*&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[doc(alias = </span><span class=s>&#34;&amp;*&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[rustc_diagnostic_item = </span><span class=s>&#34;Deref&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Deref</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// The resulting type after dereferencing.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[rustc_diagnostic_item = </span><span class=s>&#34;deref_target&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[lang = </span><span class=s>&#34;deref_target&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Target</span>: <span class=o>?</span><span class=nb>Sized</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Dereferences the value.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[must_use]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[rustc_diagnostic_item = </span><span class=s>&#34;deref_method&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>deref</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>Self</span>::<span class=n>Target</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>std::ops::DerefMut</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[lang = </span><span class=s>&#34;deref_mut&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[doc(alias = </span><span class=s>&#34;*&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>DerefMut</span>: <span class=nc>Deref</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Mutably dereferences the value.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>deref_mut</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=bp>Self</span>::<span class=n>Target</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Since the methods return a reference with the same lifetime as <code>&amp;self</code>, <strong><code>self</code> remains borrowed for as long as the returned reference lives</strong>.</p><p>由于<code>deref</code>接收<code>&amp;self</code>引用并返回<code>&amp;Self::Target</code>引用，因此Rust会利用这一点自动将前一种类型的引用转换为后一种类型的引用。换一句话说，<strong>如果插入一次<code>deref</code>调用可以防止类型错配，那Rust会为你插入一次</strong>。实现<code>DerefMut</code>可以实现对可修改引用的类型转换。这种类型转换称为解引用强制转型(deref coercion)，即一种类型被“强制”表现出另一种类型的行为。</p><p>使用解引用强制类型转换很方便：</p><ul><li><code>Rc&lt;T></code>实现了<code>Deref&lt;Target=T></code></li><li><code>String</code>实现了<code>Deref&lt;Target=str></code></li><li><code>Vec&lt;T></code>实现了<code>Deref&lt;Target=[T]></code></li></ul><p>必要情况下，<strong>Rust会连续多次应用解引用强制转换</strong>。</p><p><code>Deref</code>和<code>DerefMut</code> trait的设计初衷是为了实现<strong>智能指针类型</strong>（如<code>Box</code>、<code>Rc</code>和<code>Arc</code>），以及某些<strong>频繁通过引用来使用的类型的所有者版本</strong>（如<code>Vec&lt;T></code>和<code>String</code>就是<code>[T]</code>和<code>str</code>的所有者版本）。</p><p>Rust通过应用解引用强制转换来解决类型冲突，但<strong>不会应用它来满足类型变量的绑定</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Display</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>show_it_generic</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=o>&gt;</span><span class=p>(</span><span class=n>thing</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>thing</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=n>show_it_generic</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span><span class=w> </span><span class=c1>// error
</span></span></span></code></pre></td></tr></table></div></div><p>Rust不会在满足类型变量的绑定时应用解引用强制类型转换，所以检查失败。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 解决这个问题
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>show_it_generic</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Or
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>show_it_generic</span><span class=p>(</span><span class=o>&amp;*</span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=default><strong>Default</strong></h3><p><code>std::default::Default</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[cfg_attr(not(test), rustc_diagnostic_item = </span><span class=s>&#34;Default&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>Default</span>: <span class=nb>Sized</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Returns the &#34;default value&#34; for a type.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// Default values are often some kind of initial value, identity value, or anything else that
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// may make sense as a default.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// # Examples
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// Using built-in default values:
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// ```
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// let i: i8 = Default::default();
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// let (x, y): (Option&lt;String&gt;, f64) = Default::default();
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// ```
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// Making your own:
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// ```
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// # #[allow(dead_code)]
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// enum Kind {
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///     A,
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///     B,
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///     C,
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// }
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// impl Default for Kind {
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///     fn default() -&gt; Self { Kind::A }
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// }
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// ```
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>default</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>collections</span>::<span class=n>HashSet</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>squares</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>9</span><span class=p>,</span><span class=w> </span><span class=mi>16</span><span class=p>,</span><span class=w> </span><span class=mi>25</span><span class=p>,</span><span class=w> </span><span class=mi>36</span><span class=p>,</span><span class=w> </span><span class=mi>49</span><span class=p>,</span><span class=w> </span><span class=mi>64</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>powers_of_two</span><span class=p>,</span><span class=w> </span><span class=n>impure</span><span class=p>)</span>: <span class=p>(</span><span class=n>HashSet</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>HashSet</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=o>=</span><span class=w> </span><span class=n>squares</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>partition</span><span class=p>(</span><span class=o>|&amp;</span><span class=n>n</span><span class=o>|</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>powers_of_two</span><span class=p>.</span><span class=n>len</span><span class=p>(),</span><span class=w> </span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>impure</span><span class=p>.</span><span class=n>len</span><span class=p>(),</span><span class=w> </span><span class=mi>4</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>But of course, partition isn’t specific to <code>HashSets</code>; you can use it to produce any sort of collection you like, as long as the collection type implements <code>Default</code>, to produce an empty collection to start with, and <code>Extend&lt;T></code>, to add a T to the collection. <code>String</code> implements <code>Default</code> and <code>Extend&lt;char></code>, so you can write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>upper</span><span class=p>,</span><span class=w> </span><span class=n>lower</span><span class=p>)</span>: <span class=p>(</span><span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=nb>String</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>=</span><span class=w> </span><span class=s>&#34;Great Teacher Onizuka&#34;</span><span class=p>.</span><span class=n>chars</span><span class=p>().</span><span class=n>partition</span><span class=p>(</span><span class=o>|&amp;</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_uppercase</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>upper</span><span class=p>,</span><span class=w> </span><span class=s>&#34;GTO&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>lower</span><span class=p>,</span><span class=w> </span><span class=s>&#34;reat eacher nizuka&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Another common use of <code>Default</code> is to produce default values for structs that represent a large collection of parameters, most of which you won’t usually need to change.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>params</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>glium</span>::<span class=n>DrawParameters</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>line_width</span>: <span class=nb>Some</span><span class=p>(</span><span class=mf>0.02</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>point_size</span>: <span class=nb>Some</span><span class=p>(</span><span class=mf>0.02</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>..</span><span class=w> </span><span class=nb>Default</span>::<span class=n>default</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>target</span><span class=p>.</span><span class=n>draw</span><span class=p>(</span><span class=o>..</span><span class=p>.,</span><span class=w> </span><span class=o>&amp;</span><span class=n>params</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>If a type <code>T</code> implements Default, then the standard library implements Default automatically for <code>Rc&lt;T></code>, <code>Arc&lt;T></code>, <code>Box&lt;T></code>, <code>Cell&lt;T></code>, <code>RefCell&lt;T></code>, <code>Cow&lt;T></code>, <code>Mutex&lt;T></code>, and <code>RwLock&lt;T></code>. The default value for the type <code>Rc&lt;T></code>, for example, is an Rc pointing to the default value for type T.</p><p>如果元组类型的所有类型都实现了Default，且该该元组类型也实现了Default，那么这个元组默认会持有每个元素的默认值。</p><p>Rust does not implicitly implement Default for <strong>struct</strong> types, but if all of a struct’s fields implement Default, you can implement Default for the struct automatically using <code># [derive(Default)]</code>.</p><h3 id=asref-and-asmut><strong>AsRef and AsMut</strong></h3><p><code>std::convert::AsRef</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[cfg_attr(not(test), rustc_diagnostic_item = </span><span class=s>&#34;AsRef&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>AsRef</span><span class=o>&lt;</span><span class=n>T</span>: <span class=o>?</span><span class=nb>Sized</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Converts this type into a shared reference of the (usually inferred) input type.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>as_ref</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>T</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>std::convert::RefMut</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[cfg_attr(not(test), rustc_diagnostic_item = </span><span class=s>&#34;AsMut&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>AsMut</span><span class=o>&lt;</span><span class=n>T</span>: <span class=o>?</span><span class=nb>Sized</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Converts this type into a mutable reference of the (usually inferred) input type.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>as_mut</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>So, for example, <code>Vec&lt;T></code> implements <code>AsRef&lt;[T]></code>, and String implements <code>AsRef&lt;str></code>. You can also borrow a String’s contents as an array of bytes, so String implements AsRef&lt;[u8]> as well.</p><p>But this can’t be the whole story. A string literal is a &amp;str, but the type that implements <code>AsRef&lt;Path></code> is str, without an &. And as we explained in “Deref and DerefMut”, Rust doesn’t try deref coercions to satisfy type variable bounds, so they won’t help here either.</p><p>Fortunately, the standard library includes the blanket implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w> </span><span class=nb>AsRef</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>T</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>AsRef</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>T</span>: <span class=o>?</span><span class=nb>Sized</span><span class=p>,</span><span class=w> </span><span class=n>U</span>: <span class=o>?</span><span class=nb>Sized</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>as_ref</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>U</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=o>*</span><span class=bp>self</span><span class=p>).</span><span class=n>as_ref</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>In other words, for any types T and U, if <code>T: AsRef&lt;U></code>, then <code>&amp;T: AsRef&lt;U></code> as well: simply follow the reference and proceed as before.</p><p>You might assume that if a type implements AsRef<t>, it should also implement AsMut<t>. However, there are cases where this isn’t appropriate.</p><h3 id=borrow-and-borrowmut><strong>Borrow and BorrowMut</strong></h3><p>The std::borrow::Borrow trait is similar to AsRef: if a type implements <code>Borrow&lt;T></code>, then its borrow method efficiently borrows a &amp;T from it. But Borrow imposes more restrictions: a type should implement Borrow<t> only when a &amp;T hashes and compares the same way as the value it’s borrowed from. (Rust doesn’t enforce this; it’s just the documented intent of the trait.) This makes Borrow valuable in dealing with keys in hash tables and trees or when dealing with values that will be hashed or compared for some other reason.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[rustc_diagnostic_item = </span><span class=s>&#34;Borrow&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Borrow</span><span class=o>&lt;</span><span class=n>Borrowed</span>: <span class=o>?</span><span class=nb>Sized</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;rust1&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.0.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>borrow</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>Borrowed</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Borrow is designed to address a specific situation with generic hash tables and other associative collection types.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>K</span>: <span class=nb>Eq</span> <span class=o>+</span><span class=w> </span><span class=n>Hash</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>get</span><span class=o>&lt;</span><span class=n>Q</span>: <span class=o>?</span><span class=nb>Sized</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=nc>Q</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=n>V</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=k>where</span><span class=w> </span><span class=n>K</span>: <span class=nc>Borrow</span><span class=o>&lt;</span><span class=n>Q</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=n>Q</span>: <span class=nb>Eq</span> <span class=o>+</span><span class=w> </span><span class=n>Hash</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Vec<t> and [T: N] implement Borrow&lt;[T]>. Every string-like type allows borrowing its corresponding slice type: String implements Borrow<str>, PathBuf implements Borrow<path>, and so on. And all the standard library’s associative collection types use Borrow to decide which types can be passed to their lookup functions.</p><p>The standard library includes a blanket implementation so that every type T can be borrowed from itself: T: Borrow<t>. This ensures that &amp;K is always an acceptable type for looking up entries in a HashMap&lt;K, V>.</p><p><code>std::borrow::BorrowMut</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>BorrowMut</span><span class=o>&lt;</span><span class=n>Borrowed</span>: <span class=o>?</span><span class=nb>Sized</span><span class=o>&gt;</span>: <span class=nc>Borrow</span><span class=o>&lt;</span><span class=n>Borrowed</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>borrow_mut</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Borrowed</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=from-and-into><strong>From and Into</strong></h3><p>The <code>std::convert::From</code> and <code>std::convert::Into</code> traits represent conversions that consume a value of one type and return a value of another.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>Into</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>: <span class=nb>Sized</span> <span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>into</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>trait</span><span class=w> </span><span class=nb>From</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>: <span class=nb>Sized</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>from</span><span class=p>(</span><span class=n>other</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The standard library automatically implements the trivial conversion from each type to itself: every type T implements <code>From&lt;T></code> and <code>Into&lt;T></code>.</p><p>You generally use Into to make your functions more flexible in the arguments they accept.</p><p>The from method serves as a generic constructor for producing an instance of a type from some other single value.</p><p>Given an appropriate From implementation, the standard library automatically implements the corresponding Into trait.</p><p>However, cheap conversions are not part of Into and From’s contract. Whereas AsRef and AsMut conversions are expected to be cheap, From and Into conversions may allocate, copy, or otherwise process the value’s contents.</p><p>The <code>?</code> operator uses From and Into to help clean up code in functions that could fail in multiple ways by automatically converting from specific error types to general ones when needed.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>type</span> <span class=nc>GenericError</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>std</span>::<span class=n>error</span>::<span class=n>Error</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Sync</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span> <span class=nc>GenericResult</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>GenericError</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>parse_i32_bytes</span><span class=p>(</span><span class=n>b</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>u8</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>GenericResult</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Ok</span><span class=p>(</span><span class=n>std</span>::<span class=kt>str</span>::<span class=n>from_utf8</span><span class=p>(</span><span class=n>b</span><span class=p>)</span><span class=o>?</span><span class=p>.</span><span class=n>parse</span>::<span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>()</span><span class=o>?</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>	
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>E</span>: <span class=nc>Error</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Sync</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=nb>From</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Error</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Sync</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>from</span><span class=p>(</span><span class=n>err</span>: <span class=nc>E</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Error</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Sync</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>From and Into are infallible traits—their API requires that conversions will not fail.</p><h3 id=tryfrom-and-tryinto><strong>TryFrom and TryInto</strong></h3><p>Instead, i32 implements TryFrom<i64>. TryFrom and TryInto are the fallible cousins of From and Into and are similarly reciprocal; implementing TryFrom means that TryInto is implemented as well.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>TryFrom</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>: <span class=nb>Sized</span> <span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Error</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>try_from</span><span class=p>(</span><span class=n>value</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=bp>Self</span><span class=p>,</span><span class=w> </span><span class=bp>Self</span>::<span class=n>Error</span><span class=o>&gt;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>TryInto</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>: <span class=nb>Sized</span> <span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Error</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>try_into</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=bp>Self</span>::<span class=n>Error</span><span class=o>&gt;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Where From and Into relate types with simple conversions, TryFrom and TryInto extend the simplicity of From and Into conversions with the expressive error handling afforded by Result. These four traits can be used together to relate many types in a single crate.</p><h3 id=toowned><strong>ToOwned</strong></h3><p>The <code>std::borrow::ToOwned</code> trait provides a slightly looser way to convert a reference to an owned value:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>ToOwned</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>type</span> <span class=nc>Owned</span>: <span class=nc>Borrow</span><span class=o>&lt;</span><span class=bp>Self</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>to_owned</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Owned</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=borrow-and-toowned-at-work-the-humble-cow><strong>Borrow and ToOwned at Work: The Humble Cow</strong></h3><p>But in some cases you cannot decide whether to borrow or own until the program is running ; the std::borrow::Cow type (for “clone on write”) provides one way to do this.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Cow</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=o>?</span><span class=nb>Sized</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=n>B</span>: <span class=nb>ToOwned</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Borrowed</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>B</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Owned</span><span class=p>(</span><span class=o>&lt;</span><span class=n>B</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nb>ToOwned</span><span class=o>&gt;</span>::<span class=n>Owned</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>A <code>Cow&lt;B></code> either borrows a shared reference to a B or owns a value from which we could borrow such a reference. Since Cow implements Deref, you can call methods on it as if it were a shared reference to a B: if it’s Owned, it borrows a shared reference to the owned value; and if it’s Borrowed, it just hands out the reference it’s holding.</p><p>You can also get a mutable reference to a Cow’s value by calling its to_mut method, which returns a &amp;mut B. If the Cow happens to be Cow::Borrowed, to_mut simply calls the reference’s to_owned method to get its own copy of the referent, changes the Cow into a Cow::Owned, and borrows a mutable reference to the newly owned value. This is the “clone on write” behavior the type’s name refers to.</p><p>One common use for Cow is to return either a statically allocated string constant or a computed string.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>path</span>::<span class=n>PathBuf</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>borrow</span>::<span class=n>Cow</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>describe</span><span class=p>(</span><span class=n>error</span>: <span class=kp>&amp;</span><span class=nc>Error</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Cow</span><span class=o>&lt;</span><span class=nb>&#39;static</span><span class=p>,</span><span class=w> </span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>match</span><span class=w> </span><span class=o>*</span><span class=n>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>Error</span>::<span class=n>OutOfMemory</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;out of memory&#34;</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Error</span>::<span class=n>StackOverflow</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;stack overflow&#34;</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Error</span>::<span class=n>MachineOnFire</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;machine on fire&#34;</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Error</span>::<span class=n>Unfathomable</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s>&#34;machine bewildered&#34;</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Error</span>::<span class=n>FileNotFound</span><span class=p>(</span><span class=k>ref</span><span class=w> </span><span class=n>path</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;file not found: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>path</span><span class=p>.</span><span class=n>display</span><span class=p>()).</span><span class=n>into</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=chapter-14-closures><strong>Chapter 14. Closures</strong></h2><p>It’s more concise to write the helper function as a <em>closure</em>, an anonymous function expression:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>sort_cities</span><span class=p>(</span><span class=n>cities</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>City</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>cities</span><span class=p>.</span><span class=n>sort_by_key</span><span class=p>(</span><span class=o>|</span><span class=n>city</span><span class=o>|</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>city</span><span class=p>.</span><span class=n>population</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=capturing-variables><strong>Capturing Variables</strong></h3><p>A closure can use data that belongs to an enclosing function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>sort_cities</span><span class=p>(</span><span class=n>cities</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>City</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>cities</span><span class=p>.</span><span class=n>sort_by_key</span><span class=p>(</span><span class=o>|</span><span class=n>city</span><span class=o>|</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>city</span><span class=p>.</span><span class=n>population</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=closures-that-borrow>Closures That Borrow</h4><p>In this case, when Rust creates the closure, it automatically borrows a reference to stat. It stands to reason: the closure refers to stat, so it must have a reference to it.</p><p>In short, Rust ensures safety by using lifetimes instead of garbage collection. Rust’s way is faster: even a fast GC allocation will be slower than storing stat on the stack, as Rust does in this case.</p><h4 id=closures-that-steal><strong>Closures That Steal</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>start_sorting_thread</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=n>cities</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>City</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>stat</span>: <span class=nc>Statistic</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span>-&gt; <span class=nc>thread</span>::<span class=n>JoinHandle</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>City</span><span class=o>&gt;&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>key_fn</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>city</span>: <span class=kp>&amp;</span><span class=nc>City</span><span class=o>|</span><span class=w> </span>-&gt; <span class=kt>i64</span> <span class=p>{</span><span class=w> </span><span class=o>-</span><span class=n>city</span><span class=p>.</span><span class=n>get_statistic</span><span class=p>(</span><span class=n>stat</span><span class=p>)</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>cities</span><span class=p>.</span><span class=n>sort_by_key</span><span class=p>(</span><span class=n>key_fn</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>cities</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The only thing we’ve changed is to add the move keyword before each of the two closures. The move keyword tells Rust that a closure doesn’t borrow the variables it uses: it steals them.</p><p>Rust thus offers two ways for closures to get data from enclosing scopes: moves and borrowing.</p><p>We get something important by accepting Rust’s strict rules: thread safety. It is precisely because the vector is moved, rather than being shared across threads, that we know the old thread won’t free the vector while the new thread is modifying it.</p><h3 id=function-and-closure-types><strong>Function and Closure Types</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Given a list of cities and a test function, 
</span></span></span><span class=line><span class=cl><span class=sd>/// return how many cities pass the test.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>fn</span> <span class=nf>count_selected_cities</span><span class=p>(</span><span class=n>cities</span>: <span class=kp>&amp;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>City</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                          </span><span class=n>test_fn</span>: <span class=nc>fn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>City</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>city</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>cities</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>test_fn</span><span class=p>(</span><span class=n>city</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>count</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>count</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=sd>/// An example of a test function. Note that the type of 
</span></span></span><span class=line><span class=cl><span class=sd>/// this function is `fn(&amp;City) -&gt; bool`, the same as 
</span></span></span><span class=line><span class=cl><span class=sd>/// the `test_fn` argument to `count_selected_cities`. 
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>fn</span> <span class=nf>has_monster_attacks</span><span class=p>(</span><span class=n>city</span>: <span class=kp>&amp;</span><span class=nc>City</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>city</span><span class=p>.</span><span class=n>monster_attack_risk</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mf>0.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// How many cities are at risk for monster attack?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>count_selected_cities</span><span class=p>(</span><span class=o>&amp;</span><span class=n>my_cities</span><span class=p>,</span><span class=w> </span><span class=n>has_monster_attacks</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>count_selected_cities</span><span class=o>&lt;</span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=n>cities</span>: <span class=kp>&amp;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>City</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>test_fn</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> 
</span></span><span class=line><span class=cl>	<span class=nc>where</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>City</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>city</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>cities</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>test_fn</span><span class=p>(</span><span class=n>city</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>count</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>count</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>City</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=c1>// fn type (functions only)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Fn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>City</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=c1>// Fn trait (both functions and closures)
</span></span></span></code></pre></td></tr></table></div></div><p>In fact, every closure you write has its own type, because a closure may contain data: values either borrowed or stolen from enclosing scopes. This could be any number of variables, in any combination of types. So every closure has an ad hoc type created by the compiler, large enough to hold that data. No two closures have exactly the same type. But every closure implements an Fn trait; the closure in our example implements <code>Fn(&amp;City) -> i64</code>.</p><h3 id=closure-performance><strong>Closure Performance</strong></h3><p><img src=/img/2022-07-05-Programming-Rust/image-20220719092655451.png loading=lazy alt=image-20220719092655451></p><p>As the figure shows, these closures don’t take up much space. But even those few bytes are not always needed in practice. Often, the compiler can inline all calls to a closure, and then even the small structs shown in this figure are optimized away.</p><h3 id=closures-and-safety><strong>Closures and Safety</strong></h3><h4 id=closures-that-kill><strong>Closures That Kill</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>my_str</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nb>drop</span><span class=p>(</span><span class=n>my_str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>f</span><span class=p>();</span><span class=w> </span><span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>();</span><span class=w> </span><span class=c1>// error: use of moved value
</span></span></span></code></pre></td></tr></table></div></div><p>A closure that can be called only once may seem like a rather extraordinary thing, but we’ve been talking throughout this book about ownership and lifetimes. The idea of values being used up (that is, moved) is one of the core concepts in Rust. It works the same with closures as with everything else.</p><h4 id=fnonce><strong>FnOnce</strong></h4><p>The first time you call a FnOnce closure, <em>the closure itself is used up.</em> It’s as though the two traits, Fn and FnOnce, were defined like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Pseudocode for `Fn` and `FnOnce` traits with no arguments. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>trait</span><span class=w> </span><span class=nb>Fn</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>call</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>trait</span><span class=w> </span><span class=nb>FnOnce</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>call_once</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Just as an arithmetic expression like a + b is shorthand for a method call, Add::add(a, b), Rust treats closure() as shorthand for one of the two trait methods shown in the preceding example. For an Fn closure, closure() expands to closure.call(). This method takes self by reference, so the closure is not moved. But if the closure is only safe to call once, then closure() expands to closure.call_once(). That method takes self by value, so the closure is used up.</p><h4 id=fnmut>FnMut</h4><p>Therefore, Rust has one more category of closure, FnMut, the category of closures that write. FnMut closures are called by mut reference, as if they were defined like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Pseudocode for `Fn`, `FnMut`, and `FnOnce` traits.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>trait</span><span class=w> </span><span class=nb>Fn</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>call</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>trait</span><span class=w> </span><span class=nb>FnMut</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>call_mut</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>trait</span><span class=w> </span><span class=nb>FnOnce</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>call_once</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Any closure that requires mut access to a value, but doesn’t drop any values, is an FnMut closure.</p><ul><li>Fn is the family of closures and functions that you can call multiple times without restriction. This highest category also includes all fn functions.</li><li>FnMut is the family of closures that can be called multiple times if the closure itself is declared mut.</li><li>FnOnce is the family of closures that can be called once, if the caller owns the closure.</li></ul><p><img src=/img/2022-07-05-Programming-Rust/image-20220719095623728.png loading=lazy alt=image-20220719095623728></p><h4 id=copy-and-clone-for-closures><strong>Copy and Clone for Closures</strong></h4><p>Just as Rust automatically figures out which closures can be called only once, it can figure out which closures can implement Copy and Clone, and which cannot.</p><p>A non-move closure that doesn’t mutate variables holds only shared references, which are both Clone and Copy, so that closure is both Clone and Copy as well.</p><p>On the other hand, a non-move closure that <em>does</em> mutate values has mutable references within its internal representation. Mutable references are neither Clone nor Copy, so neither is a closure that uses them.</p><p>For a move closure, the rules are even simpler. If everything a move closure captures is Copy, it’s Copy. If everything it captures is Clone, it’s Clone.</p><h3 id=callbacks><strong>Callbacks</strong></h3><p>Closures have unique types because each one captures different variables, so among other things, they’re each a different size. If they don’t capture anything, though, there’s nothing to store. By using fn pointers in functions that take callbacks, you can restrict a caller to use only these noncapturing closures, gaining some perfomance and flexibility within the code using callbacks at the cost of flexibility for the users of your API.</p><h3 id=using-closures-effectively><strong>Using Closures Effectively</strong></h3><p>MVC</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220719103619045.png loading=lazy alt=image-20220719103619045></p><p>替代方案：</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220719104801927.png loading=lazy alt=image-20220719104801927></p><h2 id=chapter-15-iterators><strong>Chapter 15. Iterators</strong></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>triangle</span><span class=p>(</span><span class=n>n</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=o>..=</span><span class=n>n</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>sum</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>sum</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这里<code>1..=n</code>是一个<code>RangeInclusive&lt;i32></code>的值。A <code>RangeInclusive&lt;i32></code> is an iterator that produces the integers from its start value to its end value (both inclusive), so you can use it as the operand of the for loop to sum the values from 1 to n.</p><p>也可以用闭包写，更简洁和优雅：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>triangle</span><span class=p>(</span><span class=n>n</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>(</span><span class=mi>1</span><span class=o>..=</span><span class=n>n</span><span class=p>).</span><span class=n>fold</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=o>|</span><span class=n>sum</span><span class=p>,</span><span class=w> </span><span class=n>item</span><span class=o>|</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>item</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=the-iterator-and-intoiterator-traits><strong>The Iterator and IntoIterator Traits</strong></h3><p><code>std::iter::Iterator</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Item</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=c1>// many default methods 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>std::iter::IntoIterator</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>IntoIterator</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>::<span class=n>IntoIter</span>: <span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>type</span> <span class=nc>Item</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>type</span> <span class=nc>IntoIter</span>: <span class=nb>Iterator</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>into_iter</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>IntoIter</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个表示可迭代的，可以调用 <code>into_iter()</code> 方法产生一个迭代器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;There&#39;s:&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;antimony&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;arsenic&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;aluminum&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;selenium&#34;</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>element</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>&amp;</span><span class=n>v</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>element</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>等价于</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>iterator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=o>&amp;</span><span class=n>v</span><span class=p>).</span><span class=n>into_iter</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>element</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>iterator</span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>element</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Although a for loop always calls into_iter on its operand, you can also pass iterators to for loops directly; this occurs when you loop over a Range, for example. All iterators automatically implement IntoIterator, with an into_iter method that simply returns the iterator.</p><h3 id=creating-iterators><strong>Creating Iterators</strong></h3><h4 id=iter-and-iter_mut-methods><strong>iter and iter_mut Methods</strong></h4><p>Most collection types provide iter and iter_mut methods that return the natural iterators over the type, producing a shared or mutable reference to each item.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>20</span><span class=p>,</span><span class=w> </span><span class=mi>12</span><span class=p>,</span><span class=w> </span><span class=mi>8</span><span class=p>,</span><span class=w> </span><span class=mi>6</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>iterator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>iter</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iterator</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=mi>4</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iterator</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=mi>20</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iterator</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=mi>12</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iterator</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=mi>8</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iterator</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=mi>6</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iterator</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This iterator’s item type is &amp;i32: each call to next produces a reference to the next element, until we reach the end of the vector.</p><p>For example, there is no iter method on the &amp;str string slice type. Instead, if s is a &amp;str, then s.bytes() returns an iterator that produces each byte of s, whereas s.chars() interprets the contents as UTF-8 and produces each Unicode character.</p><h4 id=intoiterator-implementations><strong>IntoIterator Implementations</strong></h4><p>Most collections actually provide several implementations of IntoIterator, for shared references (&amp;T), mutable references (&amp;mut T), and moves (T):</p><ul><li>Given a <em>shared reference</em> to the collection, into_iter returns an iterator that produces shared references to its items. For example, in the preceding code, (&amp;favorites).into_iter() would return an iterator whose Item type is &amp;String.</li><li>Given a <em>mutable reference</em> to the collection, into_iter returns an iterator that produces mutable references to the items. For example, if vector is some Vec<string>, the call (&amp;mut vector).into_iter() returns an iterator whose Item type is &amp;mut String.</li><li>When passed the collection <em>by value</em>, into_iter returns an iterator that takes ownership of the collection and returns items by value; the items’ ownership moves from the collection to the consumer, and the original collection is consumed in the process. For example, the call favorites.into_iter() in the preceding code returns an iterator that produces each string by value; the consumer receives ownership of each string. When the iterator is dropped, any elements remaining in the BTreeSet are dropped too, and the set’s now-empty husk is disposed of.</li></ul><p>The general principle is that iteration should be efficient and predictable, so rather than providing implementations that are expensive or could exhibit surprising behavior (for example, rehashing modified HashSet entries and potentially encountering them again later in the iteration), Rust omits them entirely.</p><p>用在泛型上：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Debug</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>dump</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>IntoIterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=n>U</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>U</span>: <span class=nc>Debug</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>u</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=from_fn-and-successors><strong>from_fn and successors</strong></h4><p><code>std::iter::from_fn</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>from_fn</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>FromFn</span><span class=o>&lt;</span><span class=n>F</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>FromFn</span><span class=o>&lt;</span><span class=n>F</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>rand</span>::<span class=n>random</span><span class=p>;</span><span class=w> </span><span class=c1>// In Cargo.toml dependencies: rand = &#34;0.7&#34; 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span>::<span class=n>from_fn</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Generate the lengths of 1000 random line segments whose endpoints 
</span></span></span><span class=line><span class=cl><span class=c1>// are uniformly distributed across the interval [0, 1]. (This isn&#39;t a 
</span></span></span><span class=line><span class=cl><span class=c1>// distribution you&#39;re going to find in the `rand_distr` crate, but 
</span></span></span><span class=line><span class=cl><span class=c1>// it&#39;s easy to make yourself.)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>lengths</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>from_fn</span><span class=p>(</span><span class=o>||</span><span class=w> </span><span class=nb>Some</span><span class=p>((</span><span class=n>random</span>::<span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>random</span>::<span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=p>()).</span><span class=n>abs</span><span class=p>()))</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>take</span><span class=p>(</span><span class=mi>1000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>If each item depends on the one before, <code>std::iter::successors</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>successors</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=n>first</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>succ</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Successors</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=err>ⓘ</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=n>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Successors</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=n>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>num</span>::<span class=n>Complex</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span>::<span class=n>successors</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>escape_time</span><span class=p>(</span><span class=n>c</span>: <span class=nc>Complex</span><span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>limit</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>zero</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Complex</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>re</span>: <span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=n>im</span>: <span class=mf>0.0</span><span class=w> </span><span class=p>};</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>successors</span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>zero</span><span class=p>),</span><span class=w> </span><span class=o>|&amp;</span><span class=n>z</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>z</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>take</span><span class=p>(</span><span class=n>limit</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>enumerate</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=o>|</span><span class=p>(</span><span class=n>_i</span><span class=p>,</span><span class=w> </span><span class=n>z</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=n>z</span><span class=p>.</span><span class=n>norm_sqr</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mf>4.0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>_z</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>斐波那契数列</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>fibonacci</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>std</span>::<span class=n>iter</span>::<span class=n>from_fn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>state</span><span class=p>.</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>state</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>state</span><span class=p>.</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>state</span><span class=p>.</span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>fibonacci</span><span class=p>().</span><span class=n>take</span><span class=p>(</span><span class=mi>8</span><span class=p>).</span><span class=n>collect</span>::<span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;&gt;</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  					</span><span class=fm>vec!</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>8</span><span class=p>,</span><span class=w> </span><span class=mi>13</span><span class=p>,</span><span class=w> </span><span class=mi>21</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=drain-methods><strong>drain Methods</strong></h4><p>Many collection types provide a drain method that takes a mutable reference to the collection and returns an iterator that passes ownership of each element to the consumer. However, unlike the into_iter() method, which takes the collection by value and consumes it, drain merely borrows a mutable reference to the collection, and when the iterator is dropped, it removes any remaining elements from the collection and leaves it empty.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span>::<span class=n>FromIterator</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>outer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;Earth&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>inner</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from_iter</span><span class=p>(</span><span class=n>outer</span><span class=p>.</span><span class=n>drain</span><span class=p>(</span><span class=mi>1</span><span class=o>..</span><span class=mi>4</span><span class=p>));</span><span class=w> </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>outer</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Eh&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>inner</span><span class=p>,</span><span class=w> </span><span class=s>&#34;art&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=other-iterator-sources><strong>Other Iterator Sources</strong></h4><p>省略</p><h3 id=iterator-adapters><strong>Iterator Adapters</strong></h3><h4 id=map-and-filter><strong>map and filter</strong></h4><p>The Iterator trait’s map adapter lets you transform an iterator by applying a closure to its items. The filter adapter lets you filter out items from an iterator, using a closure to decide which to keep and which to drop.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>text</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34; ponies </span><span class=se>\n</span><span class=s> giraffes</span><span class=se>\n</span><span class=s>iguanas </span><span class=se>\n</span><span class=s>squid&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>v</span>: <span class=nb>Vec</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>text</span><span class=p>.</span><span class=n>lines</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=kt>str</span>::<span class=n>trim</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=p>[</span><span class=s>&#34;ponies&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;giraffes&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;iguanas&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;squid&#34;</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>text</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34; ponies </span><span class=se>\n</span><span class=s> giraffes</span><span class=se>\n</span><span class=s>iguanas </span><span class=se>\n</span><span class=s>squid&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>v</span>: <span class=nb>Vec</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>text</span><span class=p>.</span><span class=n>lines</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=kt>str</span>::<span class=n>trim</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>filter</span><span class=p>(</span><span class=o>|</span><span class=n>s</span><span class=o>|</span><span class=w> </span><span class=o>*</span><span class=n>s</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=s>&#34;iguanas&#34;</span><span class=p>)</span><span class=w> </span><span class=p>.</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=p>[</span><span class=s>&#34;ponies&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;giraffes&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;squid&#34;</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 标准库中返回的是 std::iter::Map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>map</span><span class=o>&lt;</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=n>B</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w> </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 标准库中返回的是 std::iter::Filter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>filter</span><span class=o>&lt;</span><span class=n>P</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span>: <span class=nc>P</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w> </span><span class=n>P</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>First, simply calling an adapter on an iterator doesn’t consume any items; it just returns a new iterator, ready to produce its own items by drawing from the first iterator as needed. In a chain of adapters, the only way to make any work actually get done is to call next on the final iterator.</p><p><strong>The term “lazy”</strong> in the error message is not a disparaging term; it’s just jargon for any mechanism that puts off a computation until its value is needed. It is Rust’s convention that iterators should do the minimum work necessary to satisfy each call to next; in the example, there are no such calls at all, so no work takes place.</p><p>The second important point is that iterator adapters are a <strong>zero-overhead abstraction</strong>.</p><h4 id=filter_map-and-flat_map><strong>filter_map and flat_map</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>filter_map</span><span class=o>&lt;</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=n>B</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w> </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=kt>str</span>::<span class=n>FromStr</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>text</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;1</span><span class=se>\n</span><span class=s>frond .25 289</span><span class=se>\n</span><span class=s>3.1415 estuary</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>number</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>text</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>split_whitespace</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>filter_map</span><span class=p>(</span><span class=o>|</span><span class=n>w</span><span class=o>|</span><span class=w> </span><span class=kt>f64</span>::<span class=n>from_str</span><span class=p>(</span><span class=n>w</span><span class=p>).</span><span class=n>ok</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:4.2}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>number</span><span class=p>.</span><span class=n>sqrt</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>flat_map</span><span class=o>&lt;</span><span class=n>U</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=n>U</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>U</span><span class=p>,</span><span class=w> </span><span class=n>U</span>: <span class=nb>IntoIterator</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>collections</span>::<span class=n>HashMap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>major_cities</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>HashMap</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>major_cities</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Japan&#34;</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;Tokyo&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Kyoto&#34;</span><span class=p>]);</span><span class=w> </span><span class=n>major_cities</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;The United States&#34;</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;Portland&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Nashville&#34;</span><span class=p>]);</span><span class=w> </span><span class=n>major_cities</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Brazil&#34;</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;São Paulo&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Brasília&#34;</span><span class=p>]);</span><span class=w> </span><span class=n>major_cities</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Kenya&#34;</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;Nairobi&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Mombasa&#34;</span><span class=p>]);</span><span class=w> </span><span class=n>major_cities</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;The Netherlands&#34;</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;Amsterdam&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Utrecht&#34;</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>countries</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=s>&#34;Japan&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Brazil&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Kenya&#34;</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=n>city</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>countries</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>flat_map</span><span class=p>(</span><span class=o>|</span><span class=n>country</span><span class=o>|</span><span class=w> </span><span class=o>&amp;</span><span class=n>major_cities</span><span class=p>[</span><span class=n>country</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w> 		</span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>city</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>运行结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Tokyo
</span></span><span class=line><span class=cl>Kyoto
</span></span><span class=line><span class=cl>São Paulo
</span></span><span class=line><span class=cl>Brasília
</span></span><span class=line><span class=cl>Nairobi
</span></span><span class=line><span class=cl>Mombasa
</span></span></code></pre></td></tr></table></div></div><h4 id=flatten><strong>flatten</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>collections</span>::<span class=n>BTreeMap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// A table mapping cities to their parks: each value is a vector.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>parks</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BTreeMap</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>parks</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Portland&#34;</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;Mt. Tabor Park&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Forest Park&#34;</span><span class=p>]);</span><span class=w> </span><span class=n>parks</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Kyoto&#34;</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;Tadasu-no-Mori Forest&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Maruyama Koen&#34;</span><span class=p>]);</span><span class=w> </span><span class=n>parks</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Nashville&#34;</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;Percy Warner Park&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Dragon Park&#34;</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Build a vector of all parks. `values` gives us an iterator producing 
</span></span></span><span class=line><span class=cl><span class=c1>// vectors, and then `flatten` produces each vector&#39;s elements in turn. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>all_parks</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parks</span><span class=p>.</span><span class=n>values</span><span class=p>().</span><span class=n>flatten</span><span class=p>().</span><span class=n>cloned</span><span class=p>().</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>all_parks</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;Tadasu-no-Mori Forest&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Maruyama Koen&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Percy Warner Park&#34;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>               </span><span class=s>&#34;Dragon Park&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Mt. Tabor Park&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Forest Park&#34;</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>flatten</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span>::<span class=n>Item</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>::<span class=n>Item</span>: <span class=nb>IntoIterator</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=take-and-take_while><strong>take and take_while</strong></h4><p>The Iterator trait’s take and take_while adapters let you end an iteration after a certain number of items or when a closure decides to cut things off.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>take</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>n</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>take_while</span><span class=o>&lt;</span><span class=n>P</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span>: <span class=nc>P</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w> </span><span class=n>P</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;To: jimb</span><span class=se>\r\n\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>							 From: superego &lt;editor@oreilly.com&gt;</span><span class=se>\r\n\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>							 </span><span class=se>\r\n\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>							 Did you get any writing done today?</span><span class=se>\r\n\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>							 When will you stop wasting time plotting fractals?</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>header</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>message</span><span class=p>.</span><span class=n>lines</span><span class=p>().</span><span class=n>take_while</span><span class=p>(</span><span class=o>|</span><span class=n>l</span><span class=o>|</span><span class=w> </span><span class=o>!</span><span class=n>l</span><span class=p>.</span><span class=n>is_empty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=n>header</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>To</span>: <span class=nc>jimb</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nb>From</span>: <span class=nc>superego</span><span class=w> </span><span class=o>&lt;</span><span class=n>editor</span><span class=o>@</span><span class=n>oreilly</span><span class=p>.</span><span class=n>com</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=skip-and-skip_while><strong>skip and skip_while</strong></h4><p>The Iterator trait’s skip and skip_while methods are the complement of take and take_while: they drop a certain number of items from the beginning of an iteration, or drop items until a closure finds one acceptable, and then pass the remaining items through unchanged.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>skip</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>n</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>skip_while</span><span class=o>&lt;</span><span class=n>P</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span>: <span class=nc>P</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w> </span><span class=n>P</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>for</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>message</span><span class=p>.</span><span class=n>lines</span><span class=p>()</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>skip_while</span><span class=p>(</span><span class=o>|</span><span class=n>l</span><span class=o>|</span><span class=w> </span><span class=o>!</span><span class=n>l</span><span class=p>.</span><span class=n>is_empty</span><span class=p>())</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>skip</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=n>body</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>输出结果为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Did you get any writing done today?
</span></span><span class=line><span class=cl>When will you stop wasting time plotting fractals?
</span></span></code></pre></td></tr></table></div></div><h4 id=peekable><strong>peekable</strong></h4><p>A peekable iterator lets you peek at the next item that will be produced without actually consuming it. You can turn any iterator into a peekable iterator by calling the Iterator trait’s peekable method:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>peekable</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>std</span>::<span class=n>iter</span>::<span class=n>Peekable</span><span class=o>&lt;</span><span class=bp>Self</span><span class=o>&gt;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Here, <code>Peekable&lt;Self></code> is a struct that implements <code>Iterator&lt;Item=Self::Item></code>, and Self is the type of the underlying iterator.</p><h4 id=fuse><strong>fuse</strong></h4><p><code>fuse</code> 适配器可以将任何适配器转换为第一次返回<code>None</code>之后始终继续返回<code>None</code>的迭代器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Flaky</span><span class=p>(</span><span class=kt>bool</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Flaky</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>type</span> <span class=nc>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=bp>self</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;totally the last item&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=bp>self</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w> </span><span class=c1>// D&#39;oh!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>      </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>flaky</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Flaky</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>flaky</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;totally the last item&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>flaky</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>flaky</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;totally the last item&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>not_flaky</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Flaky</span><span class=p>(</span><span class=kc>true</span><span class=p>).</span><span class=n>fuse</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>not_flaky</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=s>&#34;totally the last item&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>not_flaky</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>not_flaky</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=reversible-iterators-and-rev><strong>Reversible Iterators and rev</strong></h4><p>从序列两端取得项。实现<code>std::iter::DoubleEndedIterator</code> trait。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>DoubleEndedIterator</span>: <span class=nb>Iterator</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>next_back</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>bee_parts</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=s>&#34;head&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;thorax&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;abdomen&#34;</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>iter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bee_parts</span><span class=p>.</span><span class=n>iter</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;head&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>next_back</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;abdomen&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;thorax&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>next_back</span><span class=p>(),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w>      </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>If an iterator is double-ended, you can reverse it with the rev adapter:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>rev</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span> <span class=o>+</span><span class=w> </span><span class=nb>DoubleEndedIterator</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The returned iterator is also double-ended: its next and next_back methods are simply exchanged:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>meals</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=s>&#34;breakfast&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;lunch&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;dinner&#34;</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>iter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>meals</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>rev</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;dinner&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;lunch&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;breakfast&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>iter</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=inspect><strong>inspect</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>upper_case</span>: <span class=nb>String</span> <span class=o>=</span><span class=w> </span><span class=s>&#34;große&#34;</span><span class=p>.</span><span class=n>chars</span><span class=p>()</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>inspect</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;before: </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>))</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>flat_map</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>to_uppercase</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>inspect</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34; after: </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>))</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>.</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>upper_case</span><span class=p>,</span><span class=w> </span><span class=s>&#34;GROSSE&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=chain><strong>chain</strong></h4><p>将一个迭代器加到另一个迭代器后面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>chain</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=nc>U</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w> </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w> </span><span class=n>U</span>: <span class=nb>IntoIterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>In other words, you can chain an iterator together with any iterable that produces the same item type.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>v</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=o>..</span><span class=mi>4</span><span class=p>).</span><span class=n>chain</span><span class=p>(</span><span class=fm>vec!</span><span class=p>[</span><span class=mi>20</span><span class=p>,</span><span class=w> </span><span class=mi>30</span><span class=p>,</span><span class=w> </span><span class=mi>40</span><span class=p>]).</span><span class=n>collect</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>20</span><span class=p>,</span><span class=w> </span><span class=mi>30</span><span class=p>,</span><span class=w> </span><span class=mi>40</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=enumerate><strong>enumerate</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>band</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>bands</span><span class=p>.</span><span class=n>into_iter</span><span class=p>().</span><span class=n>enumerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>top</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>band_rows</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// start a thread to render rows `top..top + band_rows` ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>You can think of the (index, item) pairs that enumerate produces as analogous to the (key, value) pairs that you get when iterating over a HashMap or other associative collection. If you’re iterating over a slice or vector, the index is the “key” under which the item appears.</p><h4 id=zip><strong>zip</strong></h4><p>The zip adapter combines two iterators into a single iterator that produces pairs holding one value from each iterator, like a zipper joining its two sides into a single seam. The zipped iterator ends when either of the two underlying iterators ends.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>v</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=p>).</span><span class=n>zip</span><span class=p>(</span><span class=s>&#34;ABCD&#34;</span><span class=p>.</span><span class=n>chars</span><span class=p>()).</span><span class=n>collect</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;A&#39;</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;B&#39;</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;C&#39;</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;D&#39;</span><span class=p>)]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The argument to zip doesn’t need to be an iterator itself; it can be any iterable:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span>::<span class=n>repeat</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>endings</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;once&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;twice&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;chicken soup with rice&#34;</span><span class=p>];</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rhyme</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>repeat</span><span class=p>(</span><span class=s>&#34;going&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>.</span><span class=n>zip</span><span class=p>(</span><span class=n>endings</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>rhyme</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[(</span><span class=s>&#34;going&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;once&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                       </span><span class=p>(</span><span class=s>&#34;going&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;twice&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                       </span><span class=p>(</span><span class=s>&#34;going&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;chicken soup with rice&#34;</span><span class=p>)]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=by_ref><strong>by_ref</strong></h4><p>An iterator’s by_ref method borrows a mutable reference to the iterator so that you can apply adapters to the reference. When you’re done consuming items from these adapters, you drop them, the borrow ends, and you regain access to your original iterator.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;To: jimb</span><span class=se>\r\n</span><span class=s>\ 
</span></span></span><span class=line><span class=cl><span class=s>							From: id</span><span class=se>\r\n\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>							</span><span class=se>\r\n\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>							Oooooh, donuts!!</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>lines</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>message</span><span class=p>.</span><span class=n>lines</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Headers:&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>header</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>lines</span><span class=p>.</span><span class=n>by_ref</span><span class=p>().</span><span class=n>take_while</span><span class=p>(</span><span class=o>|</span><span class=n>l</span><span class=o>|</span><span class=w> </span><span class=o>!</span><span class=n>l</span><span class=p>.</span><span class=n>is_empty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=n>header</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Body:&#34;</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>lines</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=n>body</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=cloned-copied>cloned, copied</h4><p>The cloned adapter takes an iterator that produces references and returns an iterator that produces values cloned from those references, much like iter.map(|item| item.clone()). Naturally, the referent type must implement Clone.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=sc>&#39;1&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;2&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;3&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;∞&#39;</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>next</span><span class=p>(),</span><span class=w>          </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=sc>&#39;1&#39;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>cloned</span><span class=p>().</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=sc>&#39;1&#39;</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The copied adapter is the same idea, but more restrictive: the referent type must implement Copy. A call like iter.copied() is roughly the same as iter.map(|r| *r).</p><h4 id=cycle><strong>cycle</strong></h4><p>The cycle adapter returns an iterator that endlessly repeats the sequence produced by the underlying iterator. The underlying iterator must implement std::clone::Clone so that cycle can save its initial state and reuse it each time the cycle starts again.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>dirs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=s>&#34;North&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;East&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;South&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;West&#34;</span><span class=p>];</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>spin</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dirs</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>cycle</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>spin</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;North&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>spin</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;East&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>spin</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;South&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>spin</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;West&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>spin</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;North&#34;</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>spin</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=s>&#34;East&#34;</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=consuming-iterators><strong>Consuming Iterators</strong></h3><h4 id=simple-accumulation-count-sum-product><strong>Simple Accumulation: count, sum, product</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>count</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span>
</span></span><span class=line><span class=cl>  <span class=nc>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=bp>self</span><span class=p>.</span><span class=n>fold</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=mi>0</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=cp>#[rustc_inherit_overflow_checks]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=o>|</span><span class=n>count</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The count method draws items from an iterator until it returns None and tells you how many it got.</p><p>The sum and product methods compute the sum or product of the iterator’s items, which must be integers or floating-point numbers.</p><h4 id=max-min><strong>max, min</strong></h4><p><code>std::iter::Iterator</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>max</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>Self</span>::<span class=n>Item</span>: <span class=nb>Ord</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>max_by</span><span class=p>(</span><span class=nb>Ord</span>::<span class=n>cmp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=max_by-min_by><strong>max_by, min_by</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>max_by</span><span class=o>&lt;</span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>compare</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Ordering</span><span class=p>,</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>cmp</span>::<span class=n>Ordering</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Compare two f64 values. Panic if given a NaN.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>cmp</span><span class=p>(</span><span class=n>lhs</span>: <span class=kp>&amp;</span><span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=kp>&amp;</span><span class=kt>f64</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Ordering</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>lhs</span><span class=p>.</span><span class=n>partial_cmp</span><span class=p>(</span><span class=n>rhs</span><span class=p>).</span><span class=n>unwrap</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>numbers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mf>1.0</span><span class=p>,</span><span class=w> </span><span class=mf>4.0</span><span class=p>,</span><span class=w> </span><span class=mf>2.0</span><span class=p>];</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>numbers</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>copied</span><span class=p>().</span><span class=n>max_by</span><span class=p>(</span><span class=n>cmp</span><span class=p>),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mf>4.0</span><span class=p>));</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>numbers</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>copied</span><span class=p>().</span><span class=n>min_by</span><span class=p>(</span><span class=n>cmp</span><span class=p>),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mf>1.0</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>numbers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mf>1.0</span><span class=p>,</span><span class=w> </span><span class=mf>4.0</span><span class=p>,</span><span class=w> </span><span class=n>std</span>::<span class=kt>f64</span>::<span class=no>NAN</span><span class=p>,</span><span class=w> </span><span class=mf>2.0</span><span class=p>];</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>numbers</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>copied</span><span class=p>().</span><span class=n>max_by</span><span class=p>(</span><span class=n>cmp</span><span class=p>),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mf>4.0</span><span class=p>));</span><span class=w> </span><span class=c1>// panics
</span></span></span></code></pre></td></tr></table></div></div><h4 id=max_by_key-min_by_key><strong>max_by_key, min_by_key</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>max_by_key</span><span class=o>&lt;</span><span class=n>B</span>: <span class=nb>Ord</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>min_by_key</span><span class=o>&lt;</span><span class=n>B</span>: <span class=nb>Ord</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=p>,</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>collections</span>::<span class=n>HashMap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>populations</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>HashMap</span>::<span class=n>new</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>populations</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Portland&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>583_776</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>populations</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Fossil&#34;</span><span class=p>,</span><span class=w>  </span><span class=mi>449</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>populations</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Greenhorn&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>populations</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;Boring&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>7_762</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>populations</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;The Dalles&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>15_340</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>populations</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>max_by_key</span><span class=p>(</span><span class=o>|&amp;</span><span class=p>(</span><span class=n>_name</span><span class=p>,</span><span class=w> </span><span class=n>pop</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=n>pop</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  					</span><span class=nb>Some</span><span class=p>((</span><span class=o>&amp;</span><span class=s>&#34;Portland&#34;</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=mi>583_776</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>populations</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>min_by_key</span><span class=p>(</span><span class=o>|&amp;</span><span class=p>(</span><span class=n>_name</span><span class=p>,</span><span class=w> </span><span class=n>pop</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=n>pop</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  					</span><span class=nb>Some</span><span class=p>((</span><span class=o>&amp;</span><span class=s>&#34;Greenhorn&#34;</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=mi>2</span><span class=p>)));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=comparing-item-sequences><strong>Comparing Item Sequences</strong></h4><p>Iterators provide the eq and ne methods for equality comparisons, and lt, le, gt, and ge methods for ordered comparisons. The cmp and partial_cmp methods behave like the corresponding methods of the Ord and PartialOrd traits.</p><h4 id=any-and-all><strong>any and all</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>any</span><span class=o>&lt;</span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=nc>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>all</span><span class=o>&lt;</span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=nc>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>,</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><h4 id=position-rposition-and-exactsizeiterator><strong>position, rposition, and ExactSizeIterator</strong></h4><p>The position method applies a closure to each item from the iterator and returns the index of the first item for which the closure returns true.</p><p>The rposition method is the same, except that it searches from the right.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>rposition</span><span class=o>&lt;</span><span class=n>P</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span>: <span class=nc>P</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>P</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>Self</span>: <span class=nb>ExactSizeIterator</span> <span class=o>+</span><span class=w> </span><span class=nb>DoubleEndedIterator</span><span class=p>,</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>ExactSizeIterator</span>: <span class=nb>Iterator</span> <span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>len</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w> 			</span><span class=c1>// 返回剩余项数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>	</span><span class=k>fn</span> <span class=nf>is_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>	</span><span class=c1>// 在迭代完成时返回 true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=fold-and-rfold><strong>fold and rfold</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>fold</span><span class=o>&lt;</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>init</span>: <span class=nc>B</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=p>,</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>fold方法是一个通用工具，可以对迭代器产生项的整个序列执行某些累计操作。这个方法接收一个名为累加器的初始值和一个闭包，然后对当前累加器和迭代器的下一项重复应用闭包。每次闭包的返回值都会成为累加器的新值，然后再和迭代器的下一项一块传给闭包。累加器的最终值也是fold方法返回的值。如果序列是空的，则fold返回累加器的初始值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>6</span><span class=p>,</span><span class=w> </span><span class=mi>7</span><span class=p>,</span><span class=w> </span><span class=mi>8</span><span class=p>,</span><span class=w> </span><span class=mi>9</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>fold</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=o>|</span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span><span class=w> </span><span class=mi>6</span><span class=p>);</span><span class=w> 			</span><span class=c1>// count
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>fold</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=o>|</span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=o>|</span><span class=w> </span><span class=n>n</span><span class=o>+</span><span class=n>i</span><span class=p>),</span><span class=w> </span><span class=mi>45</span><span class=p>);</span><span class=w> 		</span><span class=c1>// sum
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>fold</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=o>|</span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=o>|</span><span class=w> </span><span class=n>n</span><span class=o>*</span><span class=n>i</span><span class=p>),</span><span class=w> </span><span class=mi>151200</span><span class=p>);</span><span class=w>	</span><span class=c1>// product
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>cloned</span><span class=p>().</span><span class=n>fold</span><span class=p>(</span><span class=kt>i32</span>::<span class=n>min_value</span><span class=p>(),</span><span class=w> </span><span class=n>std</span>::<span class=n>cmp</span>::<span class=n>max</span><span class=p>),</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w> </span><span class=c1>// max
</span></span></span></code></pre></td></tr></table></div></div><p>累加器的值会转移到闭包中再转移出来，因此可以对非Copy类型的累加器使用fold：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=s>&#34;Pack&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;my&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;box&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;with&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>           </span><span class=s>&#34;five&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;dozen&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;liquor&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;jugs&#34;</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// See also: the `join` method on slices, which won&#39;t 
</span></span></span><span class=line><span class=cl><span class=c1>// give you that extra space at the end.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>pangram</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=n>fold</span><span class=p>(</span><span class=nb>String</span>::<span class=n>new</span><span class=p>(),</span><span class=w> </span><span class=o>|</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=o>|</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; &#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>pangram</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Pack my box with five dozen liquor jugs &#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The rfold method is the same as fold, except that it requires a double-ended iterator, and processes its items from last to first.</p><h4 id=try_fold-and-try_rfold><strong>try_fold and try_rfold</strong></h4><p>The try_fold method is the same as fold, except that the process of iteration can exit early, without consuming all the values from the iterator. The closure you pass to try_fold must return a Result: if it returns Err(e), try_fold returns immediately with Err(e) as its value. Otherwise, it continues folding with the success value. The closure can also return an Option: returning None exits early, and the result is an Option of the folded value.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>try_fold</span><span class=o>&lt;</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>init</span>: <span class=nc>B</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>R</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>R</span>: <span class=nc>Try</span><span class=o>&lt;</span><span class=n>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>B</span><span class=o>&gt;</span><span class=p>,</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>error</span>::<span class=n>Error</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=n>prelude</span>::<span class=o>*</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=kt>str</span>::<span class=n>FromStr</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Error</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>stdin</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=n>stdin</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stdin</span><span class=p>.</span><span class=n>lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=n>lines</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=n>try_fold</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=o>|</span><span class=n>sum</span><span class=p>,</span><span class=w> </span><span class=n>line</span><span class=o>|</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>u64</span><span class=p>,</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Error</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>sum</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=kt>u64</span>::<span class=n>from_str</span><span class=p>(</span><span class=o>&amp;</span><span class=n>line</span><span class=o>?</span><span class=p>.</span><span class=n>trim</span><span class=p>())</span><span class=o>?</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>})</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>sum</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Ok</span><span class=p>(())</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>all</span><span class=o>&lt;</span><span class=n>P</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>predicate</span>: <span class=nc>P</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> 
</span></span><span class=line><span class=cl>	<span class=nc>where</span><span class=w> </span><span class=n>P</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=bp>Self</span>: <span class=nb>Sized</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=bp>self</span><span class=p>.</span><span class=n>try_fold</span><span class=p>((),</span><span class=w> </span><span class=o>|</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>item</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=n>predicate</span><span class=p>(</span><span class=n>item</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nb>Some</span><span class=p>(())</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nb>None</span><span class=w> </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}).</span><span class=n>is_some</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=nth-nth_back><strong>nth, nth_back</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>nth</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>n</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=last><strong>last</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>last</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This consumes all the iterator’s items starting from the front, even if the iterator is reversible. If you have a reversible iterator and don’t need to consume all its items, you should instead just write iter.next_back().</p><h4 id=find-rfind-and-find_map><strong>find, rfind, and find_map</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>find</span><span class=o>&lt;</span><span class=n>P</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span>: <span class=nc>P</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>P</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>populations</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>find</span><span class=p>(</span><span class=o>|&amp;</span><span class=p>(</span><span class=n>_name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>pop</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=n>pop</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>1_000_000</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>           </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>populations</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>find</span><span class=p>(</span><span class=o>|&amp;</span><span class=p>(</span><span class=n>_name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>pop</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=n>pop</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>500_000</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  			   </span><span class=nb>Some</span><span class=p>((</span><span class=o>&amp;</span><span class=s>&#34;Portland&#34;</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=mi>583_776</span><span class=p>)));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>find_map</span><span class=o>&lt;</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=building-collections-collect-and-fromiterator><strong>Building Collections: collect and FromIterator</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>collect</span><span class=o>&lt;</span><span class=n>B</span>: <span class=nc>FromIterator</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>FromIterator</span>::<span class=n>from_iter</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>FromIterator</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span>: <span class=nb>Sized</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>from_iter</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>IntoIterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=n>A</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>iter</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>分配时提高效率：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>size_hint</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=nb>Option</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=nb>None</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This method returns a lower bound and optional upper bound on the number of items the iterator will produce. The default definition returns zero as the lower bound and declines to name an upper bound, saying, in effect, “I have no idea,” but many iterators can do better than this. An iterator over a Range, for example, knows exactly how many items it will produce, as does an iterator over a Vec or HashMap. Such iterators provide their own specialized definitions for size_hint.</p><h4 id=the-extend-trait><strong>The Extend Trait</strong></h4><p>If a type implements the std::iter::Extend trait, then its extend method adds an iterable’s items to the collection.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>Extend</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>fn</span> <span class=nf>extend</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>iter</span>: <span class=nc>T</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>IntoIterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>=</span><span class=n>A</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=partition><strong>partition</strong></h4><p>The partition method divides an iterator’s items among two collections, using a closure to decide where each item belongs.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>partition</span><span class=o>&lt;</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>B</span>: <span class=nb>Default</span> <span class=o>+</span><span class=w> </span><span class=nb>Extend</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>extend</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=nb>Extend</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>mut</span><span class=w> </span><span class=n>f</span>: <span class=nc>impl</span><span class=w> </span><span class=nb>FnMut</span><span class=p>(</span><span class=o>&amp;</span><span class=n>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>left</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>mut</span><span class=w> </span><span class=n>B</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>right</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>mut</span><span class=w> </span><span class=n>B</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>FnMut</span><span class=p>((),</span><span class=w> </span><span class=n>T</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=p>(),</span><span class=w> </span><span class=n>x</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>f</span><span class=p>(</span><span class=o>&amp;</span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>left</span><span class=p>.</span><span class=n>extend_one</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>right</span><span class=p>.</span><span class=n>extend_one</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>left</span>: <span class=nc>B</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Default</span>::<span class=n>default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>right</span>: <span class=nc>B</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Default</span>::<span class=n>default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>fold</span><span class=p>((),</span><span class=w> </span><span class=n>extend</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>right</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Other languages offer partition operations that just split the iterator into two iterators, instead of building two collections. But this isn’t a good fit for Rust: items drawn from the underlying iterator but not yet drawn from the appropriate partitioned iterator would need to be buffered somewhere; you would end up building a collection of some sort internally, anyway.</p><h4 id=for_each-and-try_for_each><strong>for_each and try_for_each</strong></h4><p>The for_each method simply applies a closure to each item.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>for_each</span><span class=o>&lt;</span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>Self</span>: <span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnMut</span><span class=p>(</span><span class=bp>Self</span>::<span class=n>Item</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>call</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=n>f</span>: <span class=nc>impl</span><span class=w> </span><span class=nb>FnMut</span><span class=p>(</span><span class=n>T</span><span class=p>))</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>FnMut</span><span class=p>((),</span><span class=w> </span><span class=n>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=p>(),</span><span class=w> </span><span class=n>item</span><span class=o>|</span><span class=w> </span><span class=n>f</span><span class=p>(</span><span class=n>item</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>fold</span><span class=p>((),</span><span class=w> </span><span class=n>call</span><span class=p>(</span><span class=n>f</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=p>[</span><span class=s>&#34;doves&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;hens&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;birds&#34;</span><span class=p>].</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=n>zip</span><span class=p>([</span><span class=s>&#34;turtle&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;french&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;calling&#34;</span><span class=p>].</span><span class=n>iter</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=n>zip</span><span class=p>(</span><span class=mi>2</span><span class=o>..</span><span class=mi>5</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=n>rev</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=p>((</span><span class=n>item</span><span class=p>,</span><span class=w> </span><span class=n>kind</span><span class=p>),</span><span class=w> </span><span class=n>quantity</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s> </span><span class=si>{}</span><span class=s> </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>quantity</span><span class=p>,</span><span class=w> </span><span class=n>kind</span><span class=p>,</span><span class=w> </span><span class=n>item</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>.</span><span class=n>for_each</span><span class=p>(</span><span class=o>|</span><span class=n>gift</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;You have received: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>gift</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>打印输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>You have received: <span class=m>4</span> calling birds
</span></span><span class=line><span class=cl>You have received: <span class=m>3</span> french hens
</span></span><span class=line><span class=cl>You have received: <span class=m>2</span> turtle doves
</span></span></code></pre></td></tr></table></div></div><p>If your closure needs to be fallible or exit early, you can use try_for_each.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>try_for_each</span><span class=p>(</span><span class=o>|</span><span class=n>gift</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=fm>writeln!</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>output_file</span><span class=p>,</span><span class=w> </span><span class=s>&#34;You have received: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>gift</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=implementing-your-own-iterators>Implementing Your Own Iterators</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span>::<span class=nb>Iterator</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>I32Range</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>start</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=c1>// 当前的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>end</span>: <span class=kt>i32</span>    <span class=c1>// 迭代结束的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>I32Range</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>start</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>end</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>start</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>start</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>result</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>pi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>0.0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>numerator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>1.0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=n>I32Range</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>start</span>: <span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>end</span>: <span class=mi>14</span><span class=p>})</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pi</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>numerator</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=n>k</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>f64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>numerator</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=o>-</span><span class=mf>3.0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>pi</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=kt>f64</span>::<span class=n>sqrt</span><span class=p>(</span><span class=mf>12.0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// IEEE 754 specifies this result exactly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>pi</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>f32</span><span class=p>,</span><span class=w> </span><span class=n>std</span>::<span class=kt>f32</span>::<span class=n>consts</span>::<span class=no>PI</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>BinaryTree</span>::<span class=n>NonEmpty</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>enum</span> <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Empty</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>NonEmpty</span><span class=p>(</span><span class=nb>Box</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>TreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>element</span>: <span class=nc>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>left</span>: <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>right</span>: <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>Ord</span><span class=o>&gt;</span><span class=w>  </span><span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=o>*</span><span class=bp>self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>BinaryTree</span>::<span class=n>Empty</span><span class=w> </span><span class=o>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=o>*</span><span class=bp>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BinaryTree</span>::<span class=n>NonEmpty</span><span class=p>(</span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>TreeNode</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>element</span>: <span class=nc>value</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>left</span>: <span class=nc>BinaryTree</span>::<span class=n>Empty</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>right</span>: <span class=nc>BinaryTree</span>::<span class=n>Empty</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>})),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>BinaryTree</span>::<span class=n>NonEmpty</span><span class=p>(</span><span class=k>ref</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=n>element</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>TreeIter</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// A stack of references to tree nodes. Since we use `Vec`&#39;s
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// `push` and `pop` methods, the top of the stack in the end of the
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// vector.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// The node the iterator will visit next is at the top of the stack,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// with those ancestors still unvisited below it. If the stack is empty,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// the iteration is over.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>unvisited</span>: <span class=nb>Vec</span><span class=o>&lt;&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>TreeIter</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w>  </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>push_left_edge</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>tree</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>NonEmpty</span><span class=p>(</span><span class=k>ref</span><span class=w> </span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>*</span><span class=n>tree</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>unvisited</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>tree</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>iter</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>TreeIter</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>iter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TreeIter</span><span class=p>{</span><span class=w> </span><span class=n>unvisited</span>: <span class=nb>Vec</span>::<span class=n>new</span><span class=p>()</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>iter</span><span class=p>.</span><span class=n>push_left_edge</span><span class=p>(</span><span class=bp>self</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>iter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=nb>IntoIterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>IntoIter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TreeIter</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>into_iter</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>IntoIter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>TreeIter</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Find the node this iteration must produce,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// or finish the iteration. (Use the `?` operator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// to return immediately if it&#39;s `None`.)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>unvisited</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// After `node`, the next thing we produce must be the leftmost
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// child in `node`&#39;s right subtree, so push the path from here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// down. Our helper method turns out to be just what we need.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>push_left_edge</span><span class=p>(</span><span class=o>&amp;</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Produce a reference to this node&#39;s value.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=n>node</span><span class=p>.</span><span class=n>element</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Build a small tree.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>tree</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BinaryTree</span>::<span class=n>Empty</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tree</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=s>&#34;jaeger&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tree</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=s>&#34;robot&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tree</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=s>&#34;droid&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tree</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=s>&#34;mecha&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Iterate over it.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>kind</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>&amp;</span><span class=n>tree</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>v</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=o>*</span><span class=n>kind</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=p>[</span><span class=s>&#34;droid&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;jaeger&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;mecha&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;robot&#34;</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>tree</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>name</span><span class=o>|</span><span class=w> </span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;mega-</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>collect</span>::<span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;&gt;</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;mega-droid&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;mega-jaeger&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                     </span><span class=s>&#34;mega-mecha&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;mega-robot&#34;</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=/img/2022-07-05-Programming-Rust/image-20220721130532202.png loading=lazy alt=image-20220721130532202></p><h2 id=chapter-19-concurrency>Chapter 19. Concurrency</h2><p>惯用的多线程代码写法：</p><ul><li>一个<strong>后台线程</strong>只负责一件事，而且周期性“醒来”去做这件事。</li><li>通用<strong>线程池</strong>通过<strong>任务队列</strong>与客户端通信。</li><li><strong>管道</strong>将数据从一个线程导入到另一个线程，每个线程只做一小部分工作。</li><li><strong>数据并行</strong>假设（不管正确与否）整个计算机主要用于一项大型计算，这个大型计算进而又拆分成n个小任务，在n个线程上执行，希望所有n个机器的核心同时工作。</li><li><strong>同步对象海</strong>中多个线程拥有同一个数据权限，使用基于互斥量等低级原语的临时锁方案避免争用。</li><li><strong>原子整数操作</strong>允许多核心通过一个机器字大小的字段传递信息而实现通信。（除非要交换的数据就是整数值，否则这种方法比其他手段更难以保证正确。这通常意味着传递指针。）</li></ul><h3 id=fork-join-parallelism>Fork-Join Parallelism</h3><p><img src=/img/2022-07-05-Programming-Rust/image-20220806202715909.png loading=lazy alt=image-20220806202715909></p><p>Fork-join parallelism 有如下优点：</p><ul><li>非常简单。</li><li>避免瓶颈。</li><li>性能计算直观。</li><li>容易推断程序是否正确。</li></ul><p>Fork-join 的主要缺点是要求工作单元隔离。</p><h4 id=spawn-and-join>spawn and join</h4><p><code>std::thread::spawn</code> 创建一个新的线程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>thread</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;hello from a child thread&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>它接收一个参数，一个 FnOnce 闭包或者函数。</p><p>用 <code>spawn</code> 来实现前面的 <code>process_file</code> 函数的并行版：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=p>{</span><span class=n>thread</span><span class=p>,</span><span class=w> </span><span class=n>io</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>process_file_in_parallel</span><span class=p>(</span><span class=n>filename</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Divide the work into several chunks.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=k>const</span><span class=w> </span><span class=no>NTHREADS</span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=mi>8</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>worklists</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>split_vec_into_chunks</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span><span class=w> </span><span class=no>NTHREADS</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Fork: Spawn a thread to handle each chunck.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>thread_handles</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>worklist</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>worklists</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>thread_handles</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c1>// worklist move 进闭包中。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>      </span><span class=c1>// spawn move 闭包到子线程中，当然也包括 worklist vec。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>      </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>process_files</span><span class=p>(</span><span class=n>worklist</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Join: Wait for all threads to finish.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=c1>// 每一个 handle 是一个 JoinHandle。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>handle</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>thread_handles</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>handle</span><span class=p>.</span><span class=n>join</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 循环结束，8个子线程都已经成功完成。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>spawn</code> 函数定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>spawn</span><span class=o>&lt;</span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>JoinHandle</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>FnOnce</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>F</span>: <span class=nb>Send</span> <span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>T</span>: <span class=nb>Send</span> <span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=p>,</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>因此 <code>thread::spawn(move || process_files(worklist))</code> 会返回 <code>JoinHandle</code> ，并将它们放进一个 vector 中。</p><h4 id=error-handling-across-threads>Error Handling Across Threads</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>handle</span><span class=p>.</span><span class=n>join</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个<code>.join()</code>方法做了两件事情。</p><p>首先，<code>handle.join()</code>返回一个 <code>std::thread::Result</code>。</p><p>其次，<code>handle.join()</code> 把子线程返回的值传给了父线程。<code>handle.join()</code> 返回的完整类型是<code>std::thread::Result&lt;std::io::Result&lt;()>></code>。其中<code>thread::Result</code> 是 <code>spawn/join</code> API的一部分，而 <code>io::Result</code> 是我们应用的相关类型。</p><p>在Rust中，错误是一种 Result 值（数据）而不是异常（控制流）。可以像任何值一样跨线程传送它们。</p><h4 id=sharing-immutable-data-across-threads>Sharing Immutable Data Across Threads</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// before
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>process_files</span><span class=p>(</span><span class=n>filename</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// after
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>process_files</span><span class=p>(</span><span class=n>filename</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>glossary</span>: <span class=kp>&amp;</span><span class=nc>GigabyteMap</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如果像之前那样传进线程会报错。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>process_file_in_parallel</span><span class=p>(</span><span class=n>filename</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>glossary</span>: <span class=kp>&amp;</span><span class=nc>GigabyteMap</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>worklist</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>worklists</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>thread_handles</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>process_files</span><span class=p>(</span><span class=n>worklist</span><span class=p>,</span><span class=w> </span><span class=n>glossary</span><span class=p>))</span><span class=w> </span><span class=c1>// error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>会抱怨 <code>spawn</code> 中闭包的生命周期不是 <code>'static</code>。<code>spawn</code> 会启动一个独立的线程。Rust无法知道一个子线程会允许多长时间，因此它假设一种最坏的情况，即子线程可能会在父线程已经完成且父线程中所有的值都消失之后继续运行。</p><p>可以使用 <code>Arc</code> 来解决这个问题：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>Arc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>process_file_in_parallel</span><span class=p>(</span><span class=n>filename</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>glossary</span>: <span class=nc>Arc</span><span class=o>&lt;</span><span class=n>GigabyteMap</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>worklist</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>worklists</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// This call to .clone() only clones the Arc and bumps the
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// reference count. It does not clone the GigabyteMap.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>glossary_for_child</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>glossary</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>thread_handles</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>process_files</span><span class=p>(</span><span class=n>worklist</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>glossary_for_child</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>调用<code>glossary.clone()</code>后，会创建<code>Arc</code>智能指针而不是整个 <code>GigabyteMap</code> 的一个副本。这相当于增加一次引用计数。</p><p>这样修改之后，程序就可以编译通过并运行了。因为它不再依赖引用的生命周期。只要有任何线程拥有 <code>Arc&lt;GigabyteMap></code> ，映射就不会释放，即使父线程早就退出了。因为 <code>Arc</code> 中的数据是不可修改的，所以也不会出现任何数据争用。</p><h4 id=rayon>Rayon</h4><p>Rayon 库：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>rayon</span>::<span class=n>prelude</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// &#34;do 2 things in parallel&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>v1</span><span class=p>,</span><span class=w> </span><span class=n>v2</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rayon</span>::<span class=n>join</span><span class=p>(</span><span class=n>fn1</span><span class=p>,</span><span class=w> </span><span class=n>fn2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// &#34;do N things in parallel&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>giant_vector</span><span class=p>.</span><span class=n>par_iter</span><span class=p>().</span><span class=n>for_each</span><span class=p>(</span><span class=o>|</span><span class=n>value</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>do_thing_with_value</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>rayon::join(fn1, fn2)</code> 就是调用两个函数并返回两个结果。而<code>.par_iter()</code> 方法会创建一个 <code>ParallelIterator</code> ，这个值有 map、filter和其他方法，非常类似于Rust的Iterator。</p><p>下图展示了两种理解 <code>giant_vector.par_iter().for_each(...)</code> 调用的方式。(a) 表面上看，Rayon会为向量中的每个元素都启动一个线程。(b)在后台，Rayon会让每个工作线程对应一个CPU核心，这样效率更高。这个工作线程池由程序的所有线程共享。在同时数千个任务时，Rayon会自动拆分工作。</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220807082831278.png loading=lazy alt=image-20220807082831278></p><p>用Rayon写<code>process_files_in_parallel</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>rayon</span>::<span class=n>prelude</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>process_files_in_parallel</span><span class=p>(</span><span class=n>filenames</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>glossary</span>: <span class=kp>&amp;</span><span class=nc>GiabyteMap</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>filenames</span><span class=p>.</span><span class=n>par_iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>filename</span><span class=o>|</span><span class=w> </span><span class=n>process_file</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span><span class=w> </span><span class=n>glossary</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=p>.</span><span class=n>reduce_with</span><span class=p>(</span><span class=o>|</span><span class=n>r1</span><span class=p>,</span><span class=w> </span><span class=n>r2</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=n>r1</span><span class=p>.</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>r1</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>r2</span><span class=w> </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=p>.</span><span class=n>unwrap_or</span><span class=p>(</span><span class=nb>Ok</span><span class=p>(()))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>First, we use filenames.par_iter() to create a parallel iterator.</p></li><li><p><code>.map()</code> 对每个文件名调用 <code>process_file</code>。这样会得到 <code>io::Result&lt;()></code>值的一个 ParallelIterator。</p></li><li><p>然后用 .reduce_with() 组合结果。在这里，我们保留第一个错误（如果有的话），然后丢弃其他错误。</p><p>The .reduce_with() method is also handy when you pass a .map() closure that returns a useful value on success. Then you can pass .reduce_with() a closure that knows how to combine two success results.</p></li><li><p>reduce_with returns an Option that is None only if filenames was empty. We use the Option’s .unwrap_or() method to make the result Ok(()) in that case.</p></li></ul><h3 id=channels>Channels</h3><p>A <em>channel</em> is a one-way conduit for sending values from one thread to another. In other words, it’s a thread-safe queue.</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220807090828202.png loading=lazy alt=image-20220807090828202></p><p>图片中应该有误，下面一个线程应该是 thread 2。</p><p>Rust channels are faster than Unix pipes. Sending a value moves it rather than copying it, and moves are fast even when you’re moving data structures that contain many megabytes of data.</p><h4 id=sending-values>Sending Values</h4><p><img src=/img/2022-07-05-Programming-Rust/image-20220807092647679.png loading=lazy alt=image-20220807092647679></p><p>The code to start our file-reading thread looks like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=p>{</span><span class=n>fs</span><span class=p>,</span><span class=w> </span><span class=n>thread</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>mpsc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>sender</span><span class=p>,</span><span class=w> </span><span class=n>receiver</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>channel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>filename</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>documents</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>text</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>fs</span>::<span class=n>read_to_string</span><span class=p>(</span><span class=n>filename</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将 text 值 move 进 channel，
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// 最终，它会再次 move 到接收到这个值的地方。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>sender</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>text</span><span class=p>).</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Whether text contains 10 lines of text or 10 megabytes, this operation copies three machine words (the size of a String struct), and t<strong>he corresponding receiver.recv() call will also copy three machine words</strong>.</p><p><strong>The send and recv methods both return Results, but these methods fail only if the other end of the channel has been dropped.</strong></p><p>In our code, sender.send(text) will fail only if the receiver’s thread has exited early. This is typical for code that uses channels. Whether that happened deliberately or due to an error, it’s OK for our reader thread to quietly shut itself down.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>start_file_reader_thread</span><span class=p>(</span><span class=n>documents</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span>-&gt; <span class=p>(</span><span class=n>mpsc</span>::<span class=n>Receiver</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>thread</span>::<span class=n>JoinHandle</span><span class=o>&lt;</span><span class=n>io</span>::<span class=nb>Result</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>sender</span><span class=p>,</span><span class=w> </span><span class=n>receiver</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>channel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>(</span><span class=n>receiver</span><span class=p>,</span><span class=w> </span><span class=n>handle</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=receiving-values>Receiving Values</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>text</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>receiver</span><span class=p>.</span><span class=n>recv</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>do_something_with</span><span class=p>(</span><span class=n>text</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>等价于</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>for</span><span class=w> </span><span class=n>text</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>receiver</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>do_something_with</span><span class=p>(</span><span class=n>text</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The loop will exit normally when the channel is empty and the Sender has been dropped.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>start_file_indexing_thread</span><span class=p>(</span><span class=n>texts</span>: <span class=nc>mpsc</span>::<span class=n>Receiver</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span>-&gt; <span class=p>(</span><span class=n>mpsc</span>::<span class=n>Receiver</span><span class=o>&lt;</span><span class=n>InMemoryIndex</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>thread</span>::<span class=n>JoinHandle</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>sender</span><span class=p>,</span><span class=w> </span><span class=n>receiver</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>channel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>doc_id</span><span class=p>,</span><span class=w> </span><span class=n>text</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>texts</span><span class=p>.</span><span class=n>into_iter</span><span class=p>().</span><span class=n>enumerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kd>let</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>InMemoryIndex</span>::<span class=n>from_single_document</span><span class=p>(</span><span class=n>doc_id</span><span class=p>,</span><span class=w> </span><span class=n>text</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=n>sender</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>index</span><span class=p>).</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>(</span><span class=n>receiver</span><span class=p>,</span><span class=w> </span><span class=n>handle</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=running-the-pipeline>Running the Pipeline</h4><p>Stage3:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>start_in_memory_merge_thread</span><span class=p>(</span><span class=n>file_indexs</span>: <span class=nc>mpsc</span>::<span class=n>Receiver</span><span class=o>&lt;</span><span class=n>InMemoryIndex</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span>-&gt; <span class=p>(</span><span class=n>mpsc</span>::<span class=n>Receiver</span><span class=o>&lt;</span><span class=n>InMemoryIndex</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>thread</span>::<span class=n>JoinHandle</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Stage 4:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>start_index_writer_thread</span><span class=p>(</span><span class=n>big_indexs</span>: <span class=nc>mpsc</span>::<span class=n>Receiver</span><span class=o>&lt;</span><span class=n>InMemoryIndex</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>output_dir</span>: <span class=kp>&amp;</span><span class=nc>Path</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span>-&gt; <span class=p>(</span><span class=n>mpsc</span>::<span class=n>Receiver</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>thread</span>::<span class=n>JoinHandle</span><span class=o>&lt;</span><span class=n>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;&gt;</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Stage 5:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>merge_index_files</span><span class=p>(</span><span class=n>files</span>: <span class=nc>mpsc</span>::<span class=n>Receiver</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>output_dir</span>: <span class=kp>&amp;</span><span class=nc>Path</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>最终运行代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fn run_pipeline(documents: Vec&lt;PathBuf&gt;, output_dir: PathBuf)
</span></span><span class=line><span class=cl>	-&gt; io::Result&lt;()&gt;
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  // Launch all five stages of the pipeline.
</span></span><span class=line><span class=cl>  let (texts, h1) = start_file_reader_thread(documents);
</span></span><span class=line><span class=cl>  let (pints, h2) = start_file_indexing_thread(texts);
</span></span><span class=line><span class=cl>  let (gallons, h3) = start_in_memory_merge_thread(pints);
</span></span><span class=line><span class=cl>  let (files, h4) = start_index_writer_thread(gallons, &amp;output_dir); 
</span></span><span class=line><span class=cl>  let result = merge_index_files(files, &amp;output_dir);
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>  // Wait for threads to finish, holding on to any errors that they encounter.
</span></span><span class=line><span class=cl>  let r1 = h1.join().unwrap(); 
</span></span><span class=line><span class=cl>  h2.join().unwrap(); 
</span></span><span class=line><span class=cl>  h3.join().unwrap();
</span></span><span class=line><span class=cl>  let r4 = h4.join().unwrap();
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  // Return the first error encountered, if any.
</span></span><span class=line><span class=cl>  // (As it happens, h2 and h3 can&#39;t fail: those threads 
</span></span><span class=line><span class=cl>  // are pure in-memory data processing.)
</span></span><span class=line><span class=cl>  r1?;
</span></span><span class=line><span class=cl>  r4?;
</span></span><span class=line><span class=cl>  result
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h4 id=channel-features-and-performance>Channel Features and Performance</h4><p><code>std::sync::mpsc</code> 就是 &ldquo;multiproducer, single-consumer&rdquo;。</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220807101845246.png loading=lazy alt=image-20220807101845246></p><p><code>Sender&lt;T></code> implements the Clone trait. To get a channel with multiple senders, simply create a regular channel and clone the sender as many times as you like. You can move each Sender value to a different thread.</p><p>A <code>Receiver&lt;T></code> can’t be cloned, so if you need to have multiple threads receiving values from the same channel, you need a <code>Mutex</code>.</p><p>Rust通道是经过认真优化的。在刚创建通道时，Rust使用“一次性”队列实现。如果只是用这个通道发送一个对象，那可以保证开销最小。如果再发送第二个值，Rust则会切换到一个不同的队列实现。这个实现会从长远考虑，准备让通道传输很多值，同时又保持分配开销最小化。如果你选择克隆 Sender ，Rust则必须回退到另外一个实现，该实现可以保证多个线程同时发送值时的安全。不过即使是这3个实现中最慢的实现也是没有锁的队列，因此发送和接收值最多只是几个原子操作，涉及一次堆内存分配，外加转移自身。只有在队列为空且接收线程需要休眠时才需要系统调用。当然，此时经过通道的流量无论如何也不是最大的。</p><p>发送至的速度超过接收和处理值的速度。这会导致通道内部的值越积越多。Rust借用Unix管道。Unix使用 <em>backpressure</em> ，从而强迫快速发送端放慢速度。Unix系统的每个管道都有固定大小，如果一个进程尝试向随时可能满的管道写入数据，系统就会直接阻塞该进程，直至管道中有了空间。Rust中的等价机制加 <em>synchronous channel</em>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>mpsc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>sender</span><span class=p>,</span><span class=w> </span><span class=n>receiver</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>sync_channel</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>同步通道就像常规通道一样，只是在创建时需要指定它可以保存多少值。对于同步通道而言，<code>sender.send(value)</code> 是一个潜在的阻塞操作。</p><h4 id=thread-safety-send-and-sync>Thread Safety: Send and Sync</h4><p>This is mostly true, but Rust’s full thread safety story hinges on two built-in traits, <code>std::marker::Send</code> and <code>std::marker::Sync</code>.</p><ul><li>Types that implement <code>Send</code> are safe to pass by value to another thread. <strong>They can be moved across threads</strong>.</li><li>Types that implement <code>Sync</code> are safe to pass by <strong>non-mut reference to another thread</strong>. They can be shared across threads.</li></ul><p>By <em>safe</em> here, we mean the same thing we always mean: free from data races and other undefined behavior.</p><p><img src=/img/2022-07-05-Programming-Rust/image-20220807104741772.png loading=lazy alt=image-20220807104741772></p><p>The few types that are neither Send nor Sync are mostly those that use mutability in a way that isn’t thread-safe. For example, consider <code>std::rc::Rc&lt;T></code>, the type of reference-counting smart pointers.</p><h4 id=piping-almost-any-iterator-to-a-channel>Piping Almost Any Iterator to a Channel</h4><p>统一迭代器管道和线程管道。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>documents</span><span class=p>.</span><span class=n>into_iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=n>read_whole_file</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>.</span><span class=n>errors_to</span><span class=p>(</span><span class=n>error_sender</span><span class=p>)</span><span class=w> </span><span class=c1>// filter out error results
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=p>.</span><span class=n>off_thread</span><span class=p>()</span><span class=w>            </span><span class=c1>// spawn a thread for the above work
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=n>make_single_file_index</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>.</span><span class=n>off_thread</span><span class=p>()</span><span class=w>             </span><span class=c1>// spawn another thread for stage 2 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>可以定义一个 trait。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>mpsc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>OffThreadExt</span>: <span class=nb>Iterator</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Transform this iterator into an off-thread iterator: the
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// `next()` calls happen to a separate worker thread, so the
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// iterator and the body of your loop run concurrently.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>off_thread</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>mpsc</span>::<span class=n>IntoIter</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>然后为这个迭代器实现这个 trait。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>thread</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>OffThreadExt</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>T</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>T</span>: <span class=nb>Iterator</span> <span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>T</span>::<span class=n>Item</span>: <span class=nb>Send</span> <span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>off_thread</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>mpsc</span>::<span class=n>IntoIter</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Create a channel to transfer items from the worker thread.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>sender</span><span class=p>,</span><span class=w> </span><span class=n>receiver</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>sync_channel</span><span class=p>(</span><span class=mi>1024</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Move this iterator to a new worker thread and run it there.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>for</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=bp>self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>sender</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>item</span><span class=p>).</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Return an iterator that pulls values from the channel.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>receiver</span><span class=p>.</span><span class=n>into_iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=beyond-pipelines>Beyond Pipelines</h4><p>通道不仅在管道中有用，它们也是在相同进程中为其他线程提供异步服务的快速而简单的方式。</p><p>通道也适用于一个线程向另一个线程发送请求并期待得到某种响应的情形。</p><h3 id=shared-mutable-state>Shared Mutable State</h3><h4 id=what-is-a-mutex>What Is a Mutex?</h4><p><strong>互斥量</strong>（或者叫锁）用于强制多线程依次访问特定的数据。</p><p>互斥量保护数据。互斥量的作用体现在以下几方面。</p><ul><li>防止 data races，即避免多个线程并发读写同一块内存。</li><li>即使没有数据争用，即使所有读写在程序中都是顺序执行，如果没有互斥量，不同线程的操作也可能以任意方式相互交错。</li><li>互斥量支持通过 invariant 编程，即受保护数据由你负责初始化但每个临界区来维护的规则。</li></ul><h4 id=mutext><code>Mutex&lt;T></code></h4><p>因为等待列表既是共享的也是可修改的，所以必须由一个 <code>Mutex</code> 来提供保护：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>Mutex</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=sd>/// All threads have shared access to this big contex struct.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>struct</span> <span class=nc>FernEmpireApp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>waiting_list</span>: <span class=nc>Mutex</span><span class=o>&lt;</span><span class=n>WaitingList</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>创建 <code>Mutex</code> 代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>Arc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>app</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>new</span><span class=p>(</span><span class=n>FernEmpireApp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>waiting_list</span>: <span class=nc>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=fm>vec!</span><span class=p>[]),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>创建一个新的 <code>Mutex</code> 就像创建一个新 <code>Box</code> 或 <code>Arc</code>，但 <code>Box</code> 和 <code>Arc</code> 都意味着堆分配，而 <code>Mutex</code> 就是单纯的一种锁。如果想把 <code>Mutex</code> 分配在堆上，则必须明确地表示出来，就像这里使用 <code>Arc::new</code> 创建整个应用，而使用 <code>Mutex::new</code> 只是为了保护数据一样。这两个类型经常一块使用， <code>Arc</code> 方便跨线程共享数据，而 <code>Mutex</code> 方便跨线程共享可修改数据。</p><p>使用 <code>Mutex</code> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>FernEmpireApp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Add a player to the waiting list for the next game.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// Start a new game immediately if enough players are waiting.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>fn</span> <span class=nf>join_waiting_list</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>player</span>: <span class=nc>PlayerId</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Lock the mutex and gain access to the data inside.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// The scope of `guard` is a critical section.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>guard</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>waiting_list</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Now do the game logic.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>guard</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>player</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>guard</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=no>GAME_SIZE</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kd>let</span><span class=w> </span><span class=n>players</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>guard</span><span class=p>.</span><span class=n>split_off</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=bp>self</span><span class=p>.</span><span class=n>start_game</span><span class=p>(</span><span class=n>players</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>取得数据的唯一方法是调用 <code>.lock()</code> 方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>guard</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>waiting_list</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>self.waiting_list.lock()</code> 会一直阻塞到可以再次获得互斥量。这个方法调用返回的 <code>MutexGuard&lt;WaitingList></code> 值是对 <code>&amp;mut WaitingList</code> 的一个简单封装。借助 Deref 类型转换，可以直接在这个 guard 上调用 WaitingList 方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>guard</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>player</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个 guard 甚至还允许我们直接引用底层数据。Rust的生命周期系统保证这些引用的寿命比不会超出 guard 自身。如果没有拿到锁，则不可能在 Mutex 中访问数据。</p><p>在 guard 被清除后，锁也会被释放。通常这会在阻塞结束时发生，但也可以手工清除：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=n>guard</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=no>GAME_SIZE</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>players</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>guard</span><span class=p>.</span><span class=n>split_off</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>drop</span><span class=p>(</span><span class=n>guard</span><span class=p>);</span><span class=w> </span><span class=c1>// don&#39;t keep the list locked while starting a game
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=bp>self</span><span class=p>.</span><span class=n>start_game</span><span class=p>(</span><span class=n>players</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=mut-and-mutex>mut and Mutex</h4><p>在Rust中，<code>&amp;mut</code> 意味着 <em>exclusive access</em>。Plain & means <em>shared access</em>.</p><p>But Mutex does have a way: the lock. In fact, a mutex is little more than a way to do exactly this, to provide <em>exclusive</em> (mut) access to the data inside, even though many threads may have <em>shared</em> (non-mut) access to the Mutex itself.</p><p>Rust’s type system is telling us what Mutex does. It dynamically enforces exclusive access, something that’s usually done statically, at compile time, by the Rust compiler.</p><p>(You may recall that <code>std::cell::RefCell</code> does the same, except without trying to support multiple threads. <code>Mutex</code> and <code>RefCell</code> are both flavors of <strong>interior mutability</strong>, which we covered .)</p><h4 id=why-mutexes-are-not-always-a-good-idea>Why Mutexes Are Not Always a Good Idea</h4><p>However, threads that use mutexes are subject to some other problems that Rust doesn’t fix for you:</p><ul><li>Valid Rust programs can’t have data races, but they can still have other <em>race conditions</em>— situations where a program’s behavior depends on timing among threads and may therefore vary from run to run. Some race conditions are benign. Some manifest as general flakiness and incredibly hard-to-fix bugs. Using mutexes in an unstructured way invites race conditions. It’s up to you to make sure they’re benign.</li><li>Shared mutable state also affects program design. Where channels serve as an abstraction boundary in your code, making it easy to separate isolated components for testing, mutexes encourage a “just-add-a-method” way of working that can lead to a monolithic blob of interrelated code.</li><li>Lastly, mutexes are just not as simple as they seem at first, as the next two sections will show.</li></ul><p>All of these problems are inherent in the tools. Use a more structured approach when you can; use a Mutex when you must.</p><h4 id=deadlock>Deadlock</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>guard1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>waiting_list</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>guard2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>waiting_list</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w> </span><span class=c1>// deadlock
</span></span></span></code></pre></td></tr></table></div></div><p>Suppose the first call to self.waiting_list.lock() succeeds, taking the lock. The second call sees that the lock is held, so it blocks, waiting for it to be released. It will be waiting forever. The waiting thread is the one that’s holding the lock.</p><p>To put it another way, the lock in a Mutex is not a recursive lock.</p><p>Rust’s borrow system can’t protect you from deadlock. The best protection is to keep critical sections small: get in, do your work, and get out.</p><p>It’s also possible to get deadlock with channels.</p><h4 id=poisoned-mutexes>Poisoned Mutexes</h4><p>If a thread panics while holding a Mutex, Rust marks the Mutex as <em>poisoned.</em> Any subsequent attempt to lock the poisoned Mutex will get an error result. Our <code>.unwrap()</code> call tells Rust to panic if that happens, propagating panic from the other thread to this one.</p><h4 id=multiconsumer-channels-using-mutexes><strong>Multiconsumer Channels Using Mutexes</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>mod</span> <span class=nn>shared_channel</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=p>{</span><span class=n>Arc</span><span class=p>,</span><span class=w> </span><span class=n>Mutex</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>mpsc</span>::<span class=p>{</span><span class=n>channel</span><span class=p>,</span><span class=w> </span><span class=n>Sender</span><span class=p>,</span><span class=w> </span><span class=n>Receiver</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// A thread-safe wrapper around a `Receiver`.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=cp>#[derive(Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>SharedReceiver</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Arc</span><span class=o>&lt;</span><span class=n>Mutex</span><span class=o>&lt;</span><span class=n>Receiver</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;&gt;</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SharedReceiver</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Get the next item from the wrapped receiver.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kd>let</span><span class=w> </span><span class=n>guard</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=mf>0.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>guard</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=n>ok</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=sd>/// Create a new channel whose receiver can be shared across threads. 
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// This returns a sender and a receiver, just like the stdlib&#39;s
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=sd>/// `channel()`, and sometimes works as a drop-in replacement.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>  </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>shared_channel</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span>-&gt; <span class=p>(</span><span class=n>Sender</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>SharedReceiver</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>sender</span><span class=p>,</span><span class=w> </span><span class=n>receiver</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>channel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=n>sender</span><span class=p>,</span><span class=w> </span><span class=n>SharedReceiver</span><span class=p>(</span><span class=n>Arc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=n>receiver</span><span class=p>))))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=/img/2022-07-05-Programming-Rust/image-20220807141745840.png loading=lazy alt=image-20220807141745840></p><h4 id=readwrite-locksrwlockt>Read/Write Locks(<code>RwLock&lt;T></code>)</h4><p>Whereas a mutex has a single lock method, a read/write lock has two locking methods, read and write. The RwLock::write method is like Mutex::lock. It waits for exclusive, mut access to the protected data. The RwLock::read method provides non-mut access, with the advantage that it is less likely to have to wait, because many threads can safely read at once. With a mutex, at any given moment, the protected data has only one reader or writer (or none). With a read/write lock, it can have either one writer or many readers, much like Rust references generally.</p><h4 id=condition-variables-condvar>Condition Variables (Condvar)</h4><p>In Rust, the std::sync::Condvar type implements condition variables. A Condvar has methods .wait() and .notify_all(); .wait() blocks until some other thread calls .notify_all().</p><h4 id=atomics><strong>Atomics</strong></h4><p>The std::sync::atomic module contains atomic types for lock-free concurrent programming. These types are basically the same as Standard C++ atomics, with some extras:</p><p>AtomicIsize and AtomicUsize are shared integer types corresponding to the single- threaded isize and usize types.</p><p>AtomicI8, AtomicI16, AtomicI32, AtomicI64, and their unsigned variants like AtomicU8 are shared integer types that correspond to the single-threaded types i8, i16, etc.</p><p>An AtomicBool is a shared bool value.</p><p>An <code>AtomicPtr&lt;T></code> is a shared value of the unsafe pointer type *mut T.</p><h4 id=global-variables><strong>Global Variables</strong></h4><p>The simplest way to support incrementing PACKETS_SERVED, while keeping it thread-safe, is to make it an atomic integer:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>atomic</span>::<span class=n>AtomicUsize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>static</span><span class=w> </span><span class=no>PACKETS_SERVED</span>: <span class=nc>AtomicUsize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>AtomicUsize</span>::<span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Once this static is declared, incrementing the packet count is straightforward:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>atomic</span>::<span class=n>Ordering</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=no>PACKETS_SERVED</span><span class=p>.</span><span class=n>fetch_add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>SeqCst</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Atomic globals are limited to simple integers and Booleans. Still, creating a global variable of any other type amounts to solving two problems.</p><p>First, the variable must be made thread-safe somehow, because otherwise it can’t be global: for safety, static variables must be both Sync and non-mut. Fortunately, we’ve already seen the solution for this problem. Rust has types for safely sharing values that change: Mutex, RwLock, and the atomic types. These types can be modified even when declared as non-mut. It’s what they do. (See “mut and Mutex”.)</p><p>Second, static initializers can only call functions specifically marked as const, which the compiler can evaluate during compile time. Put another way, their output is deterministic; it depends only on their arguments, not any other state or I/O. That way, the compiler can embed the results of that computation as a compile-time constant. This is similar to C++ constexpr.</p><p>Rust limits what const functions can do to a small set of operations, which are enough to be useful while still not allowing any nondeterministic results. const functions can’t take types as generic arguments, only lifetimes, and it’s not possible to allocate memory or operate on raw pointers, even in unsafe blocks. We can, however, use arithmetic operations (including wrapping and saturating arithmetic), logical operations that don’t short-circuit, and other const functions. For example, we can create convenience functions to make defining statics and consts easier and reduce code duplication:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>const</span><span class=w> </span><span class=k>fn</span> <span class=nf>mono_to_rgba</span><span class=p>(</span><span class=n>level</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Color</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Color</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>red</span>: <span class=nc>level</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>green</span>: <span class=nc>level</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>blue</span>: <span class=nc>level</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>alpha</span>: <span class=mh>0xFF</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=no>WHITE</span>: <span class=nc>Color</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mono_to_rgba</span><span class=p>(</span><span class=mi>255</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=no>BLACK</span>: <span class=nc>Color</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mono_to_rgba</span><span class=p>(</span><span class=mi>000</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Combining these techniques, we might be tempted to write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>static</span><span class=w> </span><span class=no>HOSTNAME</span>: <span class=nc>Mutex</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=nb>String</span>::<span class=n>new</span><span class=p>());</span><span class=w>  </span><span class=c1>// error: calls in statics are limited to
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                              </span><span class=c1>// constant functions, tuple structs, and
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                              </span><span class=c1>// tuple variants
</span></span></span></code></pre></td></tr></table></div></div><p>Unfortunately, while AtomicUsize::new() and String::new() are const fn, Mutex::new() is not. In order to get around these limitations, we need to use the lazy_static crate.</p><p>We can declare a global Mutex-controlled HashMap with lazy_static like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>lazy_static</span>::<span class=n>lazy_static</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>Mutex</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>lazy_static!</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>static</span><span class=w> </span><span class=k>ref</span><span class=w> </span><span class=no>HOSTNAME</span>: <span class=nc>Mutex</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=nb>String</span>::<span class=n>new</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Using lazy_static! imposes a tiny performance cost on each access to the static data. The implementation uses std::sync::Once, a low-level synchronization primitive designed for one-time initialization. Behind the scenes, each time a lazy static is accessed, the program executes an atomic load instruction to check that initialization has already occurred. (Once is rather special purpose, so we will not cover it in detail here. It is usually more convenient to use lazy_static! instead. However, it is handy for initializing non-Rust libraries; for an example, see “A Safe Interface to libgit2”.)</p><h3 id=what-hacking-concurrent-code-in-rust-is-like><strong>What Hacking Concurrent Code in Rust Is Like</strong></h3><p>Rust insists on safety, so from the moment you decide to write a multithreaded program, the focus is on building safe, structured communication. Keeping threads mostly isolated is a good way to convince Rust that what you’re doing is safe. It happens that isolation is also a good way to make sure what you’re doing is correct and maintainable. Again, Rust guides you toward good programs.</p><h2 id=chapter-20-asynchronous-programming><strong>Chapter 20. Asynchronous Programming</strong></h2><p>Asynchronous tasks are similar to threads, but are much quicker to create, pass control amongst themselves more efficiently, and have memory overhead an order of magnitude less than that of a thread.</p><h3 id=from-synchronous-to-asynchronous><strong>From Synchronous to Asynchronous</strong></h3><p><img src=/img/2022-07-05-Programming-Rust/image-20220817164154643.png loading=lazy alt=image-20220817164154643></p><p>文中举了同步的获得HTTP请求再返回的例子，可以看到大部分时间都花在等待上了。</p><h4 id=futures><strong>Futures</strong></h4><p><code>std::future::Future</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Future</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>poll</span><span class=p>(</span><span class=bp>self</span>: <span class=nc>Pin</span><span class=o>&lt;&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>Self</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>cx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Context</span><span class=o>&lt;</span><span class=nb>&#39;_</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Poll</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Output</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Poll</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Represents that a value is immediately ready.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[lang = </span><span class=s>&#34;Ready&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;futures_api&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.36.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Ready</span><span class=p>(</span><span class=cp>#[stable(feature = </span><span class=s>&#34;futures_api&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.36.0&#34;</span><span class=cp>)]</span><span class=w> </span><span class=n>T</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Represents that a value is not ready yet.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// When a function returns `Pending`, the function *must* also
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// ensure that the current task is scheduled to be awoken when
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// progress can be made.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=cp>#[lang = </span><span class=s>&#34;Pending&#34;</span><span class=cp>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[stable(feature = </span><span class=s>&#34;futures_api&#34;</span><span class=cp>, since = </span><span class=s>&#34;1.36.0&#34;</span><span class=cp>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Pending</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>A Future represents an operation that you can test for completion. A future’s poll method never waits for the operation to finish: it always returns immediately. If the operation is complete, poll returns Poll::Ready(output), where output is its final result. Otherwise, it returns Pending. If and when the future is worth polling again, it promises to let us know by invoking a <em>waker</em>, a callback function supplied in the Context. We call this the “piñata model” of asynchronous programming: the only thing you can do with a future is whack it with a poll until a value falls out.</p><h2 id=chapter-21-macros>Chapter 21. Macros</h2><p>在编译期间，在类型检查和机器码生成之前，宏会进行展开。联系rust编译过程图理解。</p><h3 id=macro-basics>Macro Basics</h3><ul><li>用 <code>macro_rules!</code> 定义的声明宏，通过模式匹配来工作。</li><li>在 pattern 或者 template 中，可以用方括号或者花括号代替圆括号。它们没有什么区别。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>gcd</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>),</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>[</span><span class=n>gcd</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>),</span><span class=w> </span><span class=mi>2</span><span class=p>)];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>{</span><span class=n>gcd</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>),</span><span class=w> </span><span class=mi>2</span><span class=p>}</span><span class=w>			</span><span class=c1>// 注意结尾这里分号是可选的，也可以加上
</span></span></span></code></pre></td></tr></table></div></div><ul><li>对于宏的调用也是一样的。按照惯例，调用 <code>assert_eq!</code> 用圆括号，调用 <code>vec!</code> 用方括号，对于 <code>macro_rules!</code> 用花括号。</li></ul><h4 id=basics-of-macro-expansion>Basics of Macro Expansion</h4><ul><li>在编译期间，Rust展开宏非常早。在宏定义之前是不能调用它的，因为Rust会展开每一个宏调用，这发生在查看程序剩余代码之前。</li><li>正则表达式是在字符集上操作，而 pattern 是在 token 上操作。正则表达式和宏模式另一个重要的区别是在Rust中圆括号、块总是成对出现的。在宏展开之前就会进行检查。</li><li>注解和空白不是 token ，所以不会影响模式匹配。</li><li>一般可能会有一些错误，在参数部分用 <code>$left:expr</code> 而不是 <code>$left</code>。Rust不会立刻发现这个错误，它会将 <code>$left</code> 当作一个替换，直到调用这个宏的时候会发生错误。</li></ul><h4 id=unintended-consenquences>Unintended Consenquences</h4><p>正确的 <code>assert_eq!</code> 宏的定义是这样的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 标准库中的定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>macro_rules</span><span class=o>!</span><span class=w> </span><span class=n>assert_eq</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=cp>$left</span>:<span class=nc>expr</span><span class=p>,</span><span class=w> </span><span class=cp>$right</span>:<span class=nc>expr</span><span class=w> </span><span class=cp>$(,</span><span class=p>)</span><span class=o>?</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=p>(</span><span class=o>&amp;</span><span class=cp>$left</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=cp>$right</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>				</span><span class=c1>// 这里用的是引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=p>(</span><span class=n>left_val</span><span class=p>,</span><span class=w> </span><span class=n>right_val</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=p>(</span><span class=o>*</span><span class=n>left_val</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>*</span><span class=n>right_val</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=kd>let</span><span class=w> </span><span class=n>kind</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=cp>$crate</span>::<span class=n>panicking</span>::<span class=n>AssertKind</span>::<span class=nb>Eq</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// The reborrows below are intentional. Without them, the stack slot for the
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                    </span><span class=c1>// borrow is initialized even before the values are compared, leading to a
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                    </span><span class=c1>// noticeable slow down.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                    </span><span class=cp>$crate</span>::<span class=n>panicking</span>::<span class=n>assert_failed</span><span class=p>(</span><span class=n>kind</span><span class=p>,</span><span class=w> </span><span class=o>&amp;*</span><span class=n>left_val</span><span class=p>,</span><span class=w> </span><span class=o>&amp;*</span><span class=n>right_val</span><span class=p>,</span><span class=w> </span><span class=cp>$crate</span>::<span class=n>option</span>::<span class=nb>Option</span>::<span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>为什么不这样写呢？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=p>(</span><span class=cp>$left</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=cp>$right</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>panic!</span><span class=p>(</span><span class=s>&#34;assertion failed: `(left == right)` </span><span class=se>\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    				(left: `</span><span class=si>{:?}</span><span class=s>`, right: `</span><span class=si>{:?}</span><span class=s>`)&#34;</span><span class=p>,</span><span class=w> </span><span class=cp>$left</span><span class=p>,</span><span class=w> </span><span class=cp>$right</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如果 <code>assert_eq!(letters.pop(), Some('z'))</code> 这样调用，由于 <code>letters.pop()</code> 会从一个 vector 中移除一个值，那么当第二次调用的时候就会产生一个不同的值，这也就是为什么实际宏当中 <code>$left</code> 和 <code>$right</code> 只会保存一次它们的值。</p><p>那为什么宏里面要用引用，不能这样写吗？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>macro_rules</span><span class=o>!</span><span class=w> </span><span class=n>bad_assert_eq</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=cp>$left</span>:<span class=nc>expr</span><span class=p>,</span><span class=w> </span><span class=cp>$right</span>:<span class=nc>expr</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=p>(</span><span class=cp>$left</span><span class=p>,</span><span class=w> </span><span class=cp>$right</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>		</span><span class=c1>// 这里不用引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=p>(</span><span class=n>left_val</span><span class=p>,</span><span class=w> </span><span class=n>right_val</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=p>(</span><span class=n>left_val</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>right_val</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=fm>panic!</span><span class=p>(</span><span class=s>&#34;assertion failed&#34;</span><span class=w> </span><span class=cm>/* ... */</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如果传入的参数是 <code>String</code> ，那么就会移动所有权到变量里面。因此这里要使用引用。</p><blockquote><p>In short, macros can do surprising things.</p></blockquote><h4 id=repetition>Repetition</h4><p>标准库中 <code>vec!</code> 宏</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>macro_rules</span><span class=o>!</span><span class=w> </span><span class=n>vec</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>()</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=cp>$crate</span>::<span class=fm>__rust_force_expr!</span><span class=p>(</span><span class=cp>$crate</span>::<span class=n>vec</span>::<span class=nb>Vec</span>::<span class=n>new</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=cp>$elem</span>:<span class=nc>expr</span><span class=p>;</span><span class=w> </span><span class=cp>$n</span>:<span class=nc>expr</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=cp>$crate</span>::<span class=fm>__rust_force_expr!</span><span class=p>(</span><span class=cp>$crate</span>::<span class=n>vec</span>::<span class=n>from_elem</span><span class=p>(</span><span class=cp>$elem</span><span class=p>,</span><span class=w> </span><span class=cp>$n</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=cp>$($x</span>:<span class=nc>expr</span><span class=p>),</span><span class=o>+</span><span class=w> </span><span class=cp>$(,</span><span class=p>)</span><span class=o>?</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=cp>$crate</span>::<span class=fm>__rust_force_expr!</span><span class=p>(</span><span class=o>&lt;</span><span class=p>[</span><span class=n>_</span><span class=p>]</span><span class=o>&gt;</span>::<span class=n>into_vec</span><span class=p>(</span><span class=k>box</span><span class=w> </span><span class=p>[</span><span class=cp>$($x</span><span class=p>),</span><span class=o>+</span><span class=p>]))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>$( PATTERN ), *</code> 用来匹配任何用 <code>,</code> 分隔的立标，在列表中每个匹配一个 <code>PATTERN</code>。</li></ul><div class=table-wrapper><table><thead><tr><th>Pattern</th><th>Meaning</th></tr></thead><tbody><tr><td>$( &mldr; )*</td><td>Match 0 or more times with no separator</td></tr><tr><td>$( &mldr; ),*</td><td>Match 0 or more times, separated by commas</td></tr><tr><td>$( &mldr; );*</td><td>Match 0 or more times, separated by semicolons</td></tr><tr><td>$( &mldr; )+</td><td>Match 1 or more times with no separator</td></tr><tr><td>$( &mldr; ),+</td><td>Match 1 or more times, separated by commas</td></tr><tr><td>$( &mldr; );+</td><td>Match 1 or more times, separated by semicolons</td></tr><tr><td>$( &mldr; )?</td><td>Match 0 or 1 times with no separator</td></tr><tr><td>$( &mldr; ),?</td><td>Match 0 or 1 times, separated by commas</td></tr><tr><td>$( &mldr; );?</td><td>Match 0 or 1 times, separated by semicolons</td></tr></tbody></table></div><p>总结一下啦：</p><ul><li><code>*</code> 匹配0次或多次</li><li><code>+</code> 至少匹配一次</li><li><code>?</code> 最多匹配一次</li></ul><p>理解理解这个复杂的鬼东西</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=o>&lt;</span><span class=p>[</span><span class=n>_</span><span class=p>]</span><span class=o>&gt;</span>::<span class=n>into_vec</span><span class=p>(</span><span class=k>box</span><span class=w> </span><span class=p>[</span><span class=cp>$($x</span><span class=p>),</span><span class=o>+</span><span class=p>])</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>创建一个 boxed 数组然后用 <code>[T]::into_vec</code> 方法将 boxed 数组转换成一个 vector 。</li><li><code>&lt;[_]></code> 是一个非常规的写法，用来表示一些类型的切片（&ldquo;slice of something&rdquo;）。像 <code>fn()</code>,<code>&amp;str</code>,或者<code>[_]</code>，没有明确的类型，就必须包在尖括号<code>&lt;></code>里面。</li></ul><h3 id=built-in-macros>Built-In Macros</h3><p>下面的这些宏是内置的，硬编码在 <code>rustc</code> 中。</p><ul><li><code>file!()</code>, <code>line!()</code>, <code>column!()</code></li><li><code>stringingfy!(...tokens...)</code></li><li><code>concat!(str0, str1, ...)</code></li></ul><h2 id=chapter-22-unsafe-code>Chapter 22. Unsafe Code</h2></section><footer class=article-footer><section class=article-tags><a href=/tags/rust/>Rust</a>
<a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title></h2><div class=related-content><div class="flex article-list--tile"><article><a href=/2022/08/23/rust-web/><div class=article-details><h2 class=article-title>Rust异步Web框架</h2></div></a></article><article><a href=/2022/07/31/RustChinaConf/><div class=article-details><h2 class=article-title>Rust开发者大会</h2></div></a></article><article><a href=/2022/07/07/Rust-async/><div class=article-details><h2 class=article-title>Rust异步编程</h2></div></a></article><article><a href=/2022/07/05/Rust-meta-programming/><div class=article-details><h2 class=article-title>Rust元编程</h2></div></a></article><article><a href=/2022/07/01/Operating-System/><div class=article-details><h2 class=article-title>现代操作系统笔记</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Jade's Blog</section><section class=powerby><br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>