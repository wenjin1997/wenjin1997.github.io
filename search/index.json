[{"content":"原文链接：Zero Knowledge Proofs: An illustrated primer, Part 2。这篇博客通过Schnorr协议详细讲解了零知识证明中的完备性、可靠性以及零知识，对于弄懂提取器、模拟器以及零知识等概念很有帮助。之前对于模拟器的作用有些懵懵懂懂，现在看完后有一种透彻的感觉😃。\n📝 总结一下：\n任何零知识证明必须满足三个重要的性质：\n完备性。任何诚实的Prover最终都能够使Verifier信服。 可靠性。如果能说服Verifier，那么一定有命题是真的。逆否命题就是，如果命题不为真，那么就不能说服Verifier。 零知识。Verifier除了知道命题为真外不能获得其他任何信息。 如何在证明可靠性和零知识性质的同时又不会泄漏知识呢？秘诀就是模拟器，模拟器中拥有在实际中不可能有的超能力，比如说时间机器。这样就很巧妙的解决了这个问题！\n证明可靠性，使用模拟器！可靠性说的是如果能说服Verifier，那么一定有命题为真。博客中主要讨论的\u0026quot;statement\u0026quot;是个人知识而不是\u0026quot;facts\u0026quot;，也就是“我知道某个知识，或者说秘密吧”。具体来讲，可靠性就变成了，如果能说服Verifier，那么Prover一定是知道知识的。为了证明这一点，搬出提取器的概念，提取器充当Verifier的角色，对于任何可能的Prover，如果都存在一个提取器能够提取到知识，那么就说明Prover肯定是有知识的。这不就证明了可靠性嘛！\n那问题是提取器怎么提取知识呢？让我们上模拟器中的超能力——时光机器！提取器能够回溯，达到骗Prover在两次运行中使用相同的随机数$k$，然后计算出Prover原来拥有的密钥$a$。\n证明零知识，使用模拟器！要证明现实中的Verifier除了知道Prover知道知识这一点外不能获取到其他任何信息，我们构造一个压根就不知道密钥$a$的Prover，它和诚实的Verifier交互，让Verifier相信Prover是知道密钥$a$的。同时在统计意义上，模拟器中交互的输出分布和真实Prover和Verifier交互的输出分布是一样的。那么由于模拟器中根本没有知识，也就证明了零知识。\n那么如何在模拟器中让Prover说服Verifier呢？上超能力——时光机器！Prover先发一个初始值$g^{k_1}$骗取到Verifier的随机数$c$，回溯Verifier，让它发送随机数$z$，进行一些计算得到初始值，当Verifier发起随机挑战$c$时，Prover输出$z$就能让Verifier相信Prover知道密钥$a$，实际上Prover不知道密钥$a$。\n上面的过程都是交互的，转换成非交互零知识证明的一个方式是用可靠的哈希函数来发起随机挑战。\n好的！下面开始边读博客文章边做笔记。👇\nThis post is the second in a two-part series on zero-knowledge proofs. Click here to read Part 1.\nIn this post I’m going to continue the short, (relatively) non-technical overview of zero knowledge proofs that I started a couple of years ago. Yes, that was a very long time! If you didn’t catch the first post, now would be an excellent time to go read it.\nBefore we go much further, a bit of a warning. While this series is still intended as a high-level overview, at a certain point it’s necessary to dig a bit deeper into some specific algorithms. So you should expect this post to get a bit wonkier than the last.\nA quick recap, and a bit more on Zero Knowledge(ness) First, a brief refresher.\nIn the last post we defined a zero knowledge proof as an interaction between two computer programs (or Turing machines) — respectively called a Prover and a Verifier — where the Prover works to convince the Verifier that some mathematical statement is true. We also covered a specific example: a clever protocol by Goldreich, Micali and Wigderson that allows us to prove, in zero knowledge, that a graph possesses a three-coloring.\nIn the course of that discussion, we described three critical properties that any zero knowledge proof must satisfy:\nCompleteness: If the Prover is honest, then she will eventually convince the Verifier. Soundness: The Prover can only convince the Verifier if the statement is true. Zero-knowledge(ness): The Verifier learns no information beyond the fact that the statement is true. The real challenge turns out to be finding a way to formally define the last property. How do you state that a Verifier learns nothing beyond the truth of a statement?\nIn case you didn’t read the previous post — the answer to this question came from Goldwasser, Micali and Rackoff, and it’s very cool. What they argued is that a protocol can be proven zero knowledge if for every possible Verifier, you can demonstrate the existence of an algorithm called a ‘Simulator’, and show that this algorithm has some very special properties.\nFrom a purely mechanical perspective, the Simulator is like a special kind of Prover. However, unlike a real Prover — which starts with some special knowledge that allows it to prove the truth of a statement — the Simulator gets no special knowledge at all.* Nonetheless, the Simulator (or Simulators) must be able to ‘fool’ every Verifier into believing that the statement is true, while producing a transcript that’s statistically identical top (or indistinguishable from) the output of a real Prover.\n上面关于模拟器的叙述比较重要。可以将模拟器看作是特殊的一种Prover。模拟器必须可以骗过任何的Verifier相信命题是真的，而且模拟器产生的结果和与一个真实的Prover交互得到的结果在统计上是不可区分的。\nThe logic here flows pretty cleanly: since Simulator has no ‘knowledge’ to extract in the first place, then clearly a Verifier can’t obtain any meaningful amount of information after interacting with it. Moreover, if the transcript of the interaction is distributed identically to a real protocol run with a normal Prover, then the Verifier can’t do better against the real prover than it can do against the Simulator. (If the Verifier could do better, then that would imply that the distributions were not statistically identical.) Ergo, the Verifier can’t extract useful information from the real protocol run.\nThis is incredibly wonky, and worse, it seems contradictory! We’re asking that a protocol be both sound — meaning that a bogus（虚假的） Prover can’t trick some Verifier into accepting a statement unless it has special knowledge allowing it to prove the statement — but we’re also asking for the existence of an algorithm (the simulator) that can literally cheat. Clearly both properties can’t hold at the same time.\nThe solution to this problem is that both properties don’t hold at the same time.\nTo build our simulator, we’re allowed to do things to the Verifier that would never happen in the real world. The example that I gave in the previous post was to use a ‘time machine’ — that is, our ‘Simulator’ can rewind the Verifier program’s execution in order to ‘fool’ it. Thus, in a world where we can wind the Verifier back in time, it’s easy to show that a Simulator exists. In the real world, of course it doesn’t. This ‘trick’ gets us around the contradiction.\n看似模拟器没有知识也能骗过Verifier和Prover除非有知识才能通过Verifier的测验是矛盾的，但其实这两个不是同时成立的。模拟器有一些真实世界没有的超能力，比如说时间机器，这样模拟器是可以骗过Verifier的。\nAs a last reminder, to illustrate all of these ideas, we covered one of the first general zero knowledge proofs, devised by Goldreich, Micali and Wigderson (GMW). That protocol allowed us to prove, in zero knowledge, that a graph supports a three-coloring. Of course, proving three colorings isn’t terribly interesting. The real significance of the GMW result is theoretical. Since graph three coloring is known to be in the complexity class NP-complete, the GMW protocol can be used to prove any statement in the class NP. And that’s quite powerful.\nLet me elaborate slightly on what that means:\nIf there exists any decision problem (that is, a problem with a yes/no answer) whose witness (solution) can be verified in polynomial time, then: We can prove that said solution exists by (1) translating the problem into an instance of the graph three-coloring problem, and (2) running the GMW protocol.* This amazing result gives us interactive zero knowledge proofs for every statement in NP. The only problem is that it’s almost totally unusable.\n我们知道GMW中的图三色问题是NPC问题，而NP问题可以归约成图三色问题，然后可以用GMW协议来进行零知识证明。唯一的问题是这是不实用的。\nFrom theory into practice If you’re of a practical mindset, you’re probably shaking your head at all this talk of ZK proofs. That’s because actually using this approach would be an insanely expensive and stupid thing to do. Most likely you’d first represent your input problem as a boolean circuit where the circuit is satisfied if and only if you know the correct input. Then you’d have to translate your circuit into a graph, resulting in some further blowup. Finally you’d need to run the GMW protocol, which is damned expensive all by itself.\nSo in practice nobody does this. It’s really considered a ‘feasibility’（可行性） result. Once you show that something is possible, the next step is to make it efficient.\nBut we do use zero knowledge proofs, almost every day. In this post I’m going to spend some time talking about the more practical ZK proofs that we actually use. To do that I just need give just a tiny bit of extra background.\nProofs vs. Proofs of Knowledge Before we go on, there’s one more concept we need to cover. Specifically, we need to discuss what precisely we’re proving when we conduct（执行） a zero knowledge proof*.*Let me explain. At a high level, there are two kinds of statement you might want to prove in zero knowledge. Roughly speaking, these break up as follows.\nStatements about “facts”. For example, I might wish to prove that “a specific graph has a three coloring” or “some number N is in the set of composite numbers“. Each of these is a statement about some intrinsic property of the universe.\nStatements about my personal knowledge. Alternatively, I might wish to prove that I know some piece information. Examples of this kind of statement include: “I know a three coloring for this graph”, or “I know the factorization of N”. These go beyond merely proving that a fact is true, and actually rely on what the Prover knows.\n陈述的命题有两种，一种是事实，一种是个人的知识。在这篇博客中，主要关注在第二种命题。\nIt’s important to recognize that there’s a big difference between these two kinds of statements! For example, it may be possible to prove that a number N is composite even if you don’t know the full factorization. So merely proving the first statement is not equivalent to proving the second one.\nThe second class of proof is known as a “proof of knowledge”. It turns out to be extremely useful for proving a variety of statements that we use in real life. In this post, we’ll mostly be focusing on this kind of proof.\nThe Schnorr identification protocol Now that we’ve covered some of the required background, it’s helpful to move on to a specific and very useful proof of knowledge that was invented by Claus-Peter Schnorr in the 1980s. At first glance, the Schnorr protocol may seem a bit odd, but in fact it’s the basis of many of our modern signature schemes today.\nSchnorr wasn’t really concerned with digital signatures, however. His concern was with identification. Specifically, let’s imagine that Alice has published her public key to the world, and later on wants to prove that she knows the secret key corresponding to that public key. This is the exact problem that we encounter in real-world protocols such as public-key SSH, so it turns out to be well-motivated.\nSchnorr began with the assumption that the public key would be of a very specific format. Specifically, let p be some prime number, and let g be a generator of a cyclic group（循环群） of prime-order q. To generate a keypair, Alice would first pick a random integer a between 1 and q, and then compute the keypair as:\n$PK_A=g^a\\mod p,SK_A = a$\n(If you’ve been around the block a time or two, you’ll probably notice that this is the same type of key used for Diffie-Hellman and the DSA signing algorithm. That’s not a coincidence, and it makes this protocol very useful.)\nAlice keeps her secret key to herself, but she’s free to publish her public key to the world. Later on, when she wants to prove knowledge of her secret key, she conducts the following simple interactive protocol with Bob:\nThere’s a lot going on in here, so let’s take a minute to unpack things.\nFirst off, we should ask ourselves if the protocol is complete. This is usually the easiest property to verify: if Alice performs the protocol honestly, should Bob be satisfied at the end of it? In this case, completeness is pretty easy to see just by doing a bit of substitution:\n注意，由于选取的$k \\in { 1, \\dots, q }$，因此$k\\mod q = k$。\n这里证明了完备性：诚实的Alice是能够说服Bob的。\nProving soundness The harder property is soundness. Mainly because we don’t yet have a good definition of what it means for a proof of knowledge to be sound. Remember that what we want to show is the following:\nIf Alice successfully convinces Bob, then she must know the secret key a.\n可靠性：如果Alice能够成功让Bob信服，那么她一定知道密钥$a$。也就是说如果Alice不是诚实的，她不知道密钥$a$的话，那么她肯定不能说服Bob。\nIt’s easy to look at the equations above and try to convince yourself that Alice’s only way to cheat the protocol is to know a. But that’s hardly a proof.\nWhen it comes to demonstrating the soundness of a proof of knowledge, we have a really nice formal approach. Just as with the Simulator we discussed above, we need to demonstrate the existence of a special algorithm. This algorithm is called a knowledge extractor, and it does exactly what it claims to. A knowledge extractor (or just ‘Extractor’ for short) is a special type of Verifier that interacts with a Prover, and — if the Prover succeeds in completing the proof — the Extractor should be able to extract the Prover’s original secret.\n想要证明可靠性，借助于知识提取器来证明。一个知识提取器是一个特殊的Verifier，它和Prover进行交互，如果Prover能成功通过证明，那么提取器可以提取到Prover原来的密码。\nAnd this answers our question above. To prove soundness for a proof of knowledge, we must show that an Extractor exists for every possible Prover.\n为了证明可靠性，我们现在必须证明对于每一个可能的Prover，都存在这样一个提取器。结合上面提到的可靠性陈述，如果Alice能够成功让Bob信服，那么她一定知道密钥$a$。也就是说，如果对于每一个可能让Bob信服的Alice，如果存在一个知识提取器来与Alice交互，能提取到密钥$a$，不就说明了Alice肯定知道密钥$a$嘛！因此证明了可靠性。\n证明逻辑是：对每一个可能的Prover存在一个提取器 ⇒ 如果Alice能让Bob信服，Alice一定知道原来的秘密（可靠性）\nOf course this again seems totally contradictory to the purpose of a zero knowledge protocol — where we’re not supposed to be able to learn secrets from a Prover. Fortunately we’ve already resolved this conundrum once for the case of the Simulator. Here again, we take the same approach. The Extractor is not required to exist during a normal run of the protocol. We simply show that it exists if we’re allowed to take special liberties with the Prover — in this case, we’ll use ‘rewinding’ to wind back the Prover’s execution and allow us to extract secrets.\n当然这看起来又和零知识证明协议的目的冲突了，但是我们依然可以用模拟器的方法来解决这个问题。我们只需要让Prover拥有超能力，然后这样的提取器是存在的。这个超能力可以是时间机器，肯定现实世界不存在时间机器，因此不会和泄漏知识这个目的相冲突。\nThe extractor for the Schnorr protocol is extremely clever — and it’s also pretty simple. Let’s illustrate it in terms of a protocol diagram. Alice (the Prover) is on the left, and the Extractor is on the right:\nThe key observation here is that by rewinding Alice’s execution, the Extractor can ‘trick’ Alice into making two different proof transcripts using the same k. This shouldn’t normally happen in a real protocol run, where Alice specifically picks a new k for each execution of the protocol.\n关键的一点是通过让Alice重新执行到第2步，提取器可以骗Alice给两个不同的证明但是用同一个$k$。在实际的协议运行中，这是通常不应该发生的，Alice会在协议每次执行的时候特别选择一个新的$k$。\nIf the Extractor can trick Alice into doing this, then he can solve the following simple equation to recover Alice’s secret:\n如果提取器能够骗Alice这样做的话，提取器是可以提取到Alice拥有的密钥$a$。\n推导的详细过程：\n$$ \\begin{array}{l} \\frac{s_1 - s_2}{c_1 - c_2} \\mod q \u0026 \\\\\\ \\quad = \\frac{((ac_1+k) \\mod q)-((ac_2 + k) \\mod q)}{c_1 - c_2} \\mod q \\\\\\ \\quad = \\frac{(ac_1+k)-(ac_2 + k) }{c_1 - c_2} \\mod q \\\\\\ \\quad = \\frac{ac_1 - ac_2 }{c_1 - c_2} \\mod q \\\\\\ \\quad = a \\mod q \\end{array} $$It’s worth taking a moment right now to note that this also implies a serious vulnerability（漏洞） in bad implementations of the Schnorr protocol. If you ever accidentally use the same k for two different runs of the protocol, an attacker may be able to recover your secret key! This can happen if you use a bad random number generator.\n需要注意Schnorr protocol在实际中可能出现的漏洞，那就是在不同运行中使用相同的$k$，因此要选择好的随机生成器。\nIndeed, those with a bit more experience will notice that this is similar to a *real* attack on systems (with bad random number generators) that implement ECDSA or DSA signatures! This is also not a coincidence. The (EC)DSA signature family is based on Schnorr. Ironically（讽刺地）, the developers of DSA managed to retain this vulnerability of the Schorr family of protocols while at the same time ditching the security proof that makes Schnorr so nice.\nProving zero-knowledge(ness) against an honest Verifier Having demonstrated（证明） that Schnorr signatures are complete and sound, it remains only to prove that they’re ‘zero knowledge’. Remember that to do this, normally we require a Simulator that can interact with any possible Verifier and produce a ‘simulated’ transcript of the proof, even if the Simulator doesn’t know the secret it’s proving it knows.\n为了证明“零知识”，一般要求有一个可以和所有可能的Verifier的模拟器，输出证明的结果，而模拟器甚至不知道它要证明的知识。\nThe standard Schnorr protocol does not have such a Simulator, for reasons we’ll get into in a second. Instead, to make the proof work we need to make a special assumption. Specifically, the Verifier needs to be ‘honest’. That is, we need to make the special assumption that it will run its part of the protocol correctly — namely, that it will pick its challenge “c” using only its random number generator, and will not choose this value based on any input we provide it. As long as it does this, we can construct a Simulator.\n标准的Schnorr协议是没有这样的模拟器的。这里要做一个假设，Verifier需要是“诚实的”。我们需要假设在Verifier选择挑战“c”时，只用到一个随机数生成器，而不会选择那些基于任何我们提供的输入生成的值。\nHere’s how the Simulator works.\nLet’s say we are trying to prove knowledge of a secret $a$ for some public key $g^a \\mod p$ — but we don’t actually know the value*.* Our Simulator assumes that the Verifier will choose some value $c$ as its challenge, and moreover, it knows that the honest Verifier will choose the value $c$ only based on its random number generator — and not based on any inputs the Prover has provided.\nFirst, output some initial $g^{k_1}$ as the Prover’s first message*,* and find out what challenge $c$ the Verifier chooses. Rewind the Verifier, and pick a random integer $z$ in the range ${ 0, \\cdots, q-1 }$. Compute $g^{k_2} = g^z * g^{a(-c)}$ **and output $g^{k_2}$ as the Prover’s new initial message. When the Verifier challenges on $c$ again, output $z$. Notice that the transcript $g^k,c,z$ will verify correctly as a perfectly valid, well-distributed proof of knowledge of the value $a$. The Verifier will accept this output as a valid proof of knowledge of $a$, even though the Simulator does not know $a$ in the first place!\n详细的过程如下：\nWhat this proves is that if we can rewind a Verifier, then (just as in the first post in this series) we can always trick the Verifier into believing we have knowledge of a value, even when we don’t. And since the statistical distribution of our protocol is identical to the real protocol, this means that our protocol must be zero knowledge — against an honest Verifier.\n在模拟器世界里，我们可以回溯Verifier，让诚实的Verifier相信我们是知道密钥$a$的，但其实我们根本不知道$a$时多少。由于在统计分布上我们的协议和真实的协议是一样的，那么对于诚实的Verifier，我们的协议一定是零知识的。\nFrom interactive to non-interactive So far we’ve shown how to use the Schnorr protocol to interactively prove knowledge of a secret key $a$ that corresponds to a public key $g^a$. This is an incredibly useful protocol, but it only works if our Verifier is online and willing to interact with us.\nAn obvious question is whether we can make this protocol work without interaction. Specifically, can I make a proof that I can send you without you even being online. Such a proof is called a non-interactive zero knowledge proof (NIZK). Turning Schnorr into a non-interactive proof seems initially quite difficult — since the protocol fundamentally relies on the Verifier picking a random challenge. Fortunately there is a clever trick we can use.\nThis technique was developed by Fiat and Shamir in the 1980s. What they observed was that if you have a decent hash function lying around, you can convert an interactive protocol into a non-interactive one by simply using the hash function to pick the challenge.\n怎么将交互式零知识证明转换成非交互式零知识证明呢？转换的难点在于Verifier需要选择一个随机的挑战，一个解决方法是使用可靠的哈希函数来选择这个挑战。\nSpecifically, the revised protocol for proving knowledge of $a$ with respect to a public key $g^k$ looks like this:\nThe Prover picks $g^k$ (just as in the interactive protocol). Now, the prover computes the challenge as $c = H(g^k||M)$ where $H()$ is a hash function, and $M$ is an (optional) and arbitary message string. Compute $ac+k \\mod q$ (just as in the interactive protocol). The upshot here is that the hash function is picking the challenge $c$ without any interaction with the Verifier. In principle, if the hash function is “strong enough” (meaning, it’s a random oracle) then the result is a completely non-interactive proof of knowledge of the value $a$ that the Prover can send to the Verifier. The proof of this is relatively straightforward.\nThe particularly neat thing about this protocol is that it isn’t just a proof of knowledge, it’s also a signature scheme. That is, if you put a message into the (optional) value $M$, you obtain a signature on $M$, which can only be produced by someone who knows the secret key $a$. The resulting protocol is called the Schnorr signature scheme, and it’s the basis of real-world protocols like EdDSA.\n这个协议不仅仅是知识的证明，也是一种签名方案。\nPhew. Yes, this has been a long post and there’s probably a lot more to be said. Hopefully there will be more time for that in a third post — which should only take me another three years.\nNotes:\nIn this definition, it’s necessary that the statement be literally true. ","date":"2022-11-30T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-30-Zero-Knowledge-Proofs-An-illustrated-primer-Part2/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/30/Zero-Knowledge-Proofs-An-illustrated-primer-Part2/","title":"Zero Knowledge Proofs: An illustrated primer, Part 2"},{"content":"本篇博客记录了安比实验室知识证明介绍系列文章的笔记。几篇文章如下：\n初识「零知识」与「证明」 从「模拟」理解零知识证明：平行宇宙与时光倒流 读心术：从零知识证明中提取「知识」 亚瑟王的「随机」挑战：从交互到非交互式零知识证明 初识「零知识」与「证明」 原文链接：初识「零知识」与「证明」。\n文章先介绍了“证明”的历史。\n古希腊：「证明」 == 「洞见」 二十世纪初：「证明」 == 「符号推理」 六十年代：「证明」 == 「程序」 八十年代：「证明」 == 「交互」，拓宽了「证明」的概念。通过构造两个图灵机进行「交互」而不是「推理」，来证明一个命题在概率上是否成立。 零知识证明有什么用处？\n零知识证明技术可以解决数据的信任问题，计算的信任问题！\n零知识证明技术可以「模拟」出一个第三方，来保证某一个论断是可信的。\n换句话说，当我们收到一个加了密的数据， 然后还有一个零知识证明。这个零知识证明是说 「关于数据的 X 断言成立」，那么这等价于有一个天使在我们耳边悄声说，「关于数据的X 断言成立」！\n对于这个 X 断言，可以非常灵活，它可以是一个 NP复杂度的算法。大白话讲只要我们能写一段程序（一个多项式时间的算法）来判断一个数据是否满足 X 断言，那么这个断言就可以用零知识证明的方式来表达。通俗点讲，只要数据判定是客观的，那么零知识证明就适用。\n零知识证明的用处：\n数据的隐私保护 计算压缩与区块链扩容 端到端的通讯加密 身份认证 去中心化存储 信用记录 构造完全公平的现实数字化商品的交易协议 知识和信息的区别：\n「知识」是与「计算难度」相关，而「信息」则不是 「知识」是与公共所知的东西有关，而「信息」主要与部分公开的东西有关 可验证计算与电路可满足性问题：\n另外电路可满足问题和地图三染色问题一样，是NP-Complete问题。NP-Complete 是一类问题，他的求解过程是多项式时间内难以完成的，即「求解困难」，但是验证解的过程是多项式时间可以完成的，即「验证简单」。\n所谓的电路可满足性就是指，存在满足电路的一个解。如果这个解的输出值等于一个确定值，那么这个解就能「表示」电路的计算过程。\n「零知识的电路可满足性证明协议」提供了一种最直接的保护隐私/敏感数据的技术\n从「模拟」理解零知识证明：平行宇宙与时光倒流 原文链接：从「模拟」理解零知识证明：平行宇宙与时光倒流。\n安全的定义与不可区分性\n这一部分是密码学中的知识。\n一切安全都有前提的。只有经过数学证明之后，大家才能够确信这个 算法/方案 的安全性基于一些非常明确的「安全假设」。\n完美安全：假设你是一个攻击者，你通过密文获取不到任何有价值的信息，破解的唯一手段就是靠瞎蒙。\n📝 在Dan Boneh and Victor Shoup 的 《A Graduate Course in Applied Cryptography》书中定义为：\n通过密文获取不到信息，这就意味着你没有获得任何额外的计算能力，能够帮助让你以更短的时间来计算出明文。\n语义安全：假设你是一个攻击者，你通过密文在多项式时间内计算不出来任何有价值的信息。\n📒书中定义为： 不可区分的概念： 我们又引入一个概念——「不可区分性」，来重新表述加密算法的安全性：假设你是一个攻击者，而我有一个加密算法：\n你随机产生两段等长的明文，m1=「白日依山尽，黄河入海流」，m2=「烫烫烫烫烫，烫烫烫烫烫」 你把这两段明文，m1 与 m2 交给我 我随机挑选一个明文，不告诉你是哪一个，然后进行加密，产生一个密文 c 我把密文 c 出示给你看，让你猜这个c 究竟是由唐诗加密产生，还是乱码加密产生 如果你用一台计算机来破解c，在多项式时间内破解不出来，也就是说你没办法区分c的来源，那么就说明加密算法是语义安全的 区分两个世界\n证明的零知识过程，等价于构造（寻找）一个「模拟」算法，这个算法能够让模拟器来模拟出一个「没有知识」的理想世界。如果这个算法存在，而且两个世界不可区分，那么就证明完毕。\n所谓的不可区分性针对的是理想世界中的个体认知而言。而「可区分性」是对位于世界外部的神而言。\n首先「零知识」是为了保护 Alice 的利益，因为 Alice 不想在交互过程中透露更多的信息给 Bob，不想让 Bob 知道她所拥有的秘密 w，甚至不想让 Bob 从交互的过程中分析出哪怕一丁点的信息。那么怎么保证这一点呢？「模拟器」这时候登场了，它能模拟出一个和现实世界外表一模一样的「理想世界」，然后「模拟器」在这个世界中可以轻松地骗过任何一个对手，让对方无法分辨自己是在现实世界中，还是理想世界中。因为「模拟器」手里没有那个秘密 w，「理想世界」是零知识的。又因为两个世界的不可区分性，所以我们可以得出结论：Alice 的交互协议是「零知识」的。\n地图三染色问题的零知识证明\n文章中用图片形象的说明了零知识证明的过程。不过这是针对诚实的Bob，如果是不诚实的Bob呢？如果在模拟器第一次实施时间倒流之后，Bob又选择了不同的边，那么模拟器可以把颜色打乱之后，再次运行时间倒流，在多次时间倒流之后，Bob 极大的概率总会一次选择模拟器进行染色的那条边，然后这时候模拟器才走到第三步，打开纸片。\n阿里巴巴、洞穴与芝麻开门\n文章中再次阐述了阿里巴巴与大盗的故事，这个故事来源于论文How to explain zero-knowledge protocols to your children，我的论文的笔记见这里。The Jealous Reporter用的剪辑手段就是模拟器中的超能力，由于两家电视台放出的影片人们无法区分，而假的那个根本不知道洞穴的秘密，这也就证明了这个过程是零知识的。\n模拟器与图灵机\n模拟器不能随便开挂。模拟器其实只是一个图灵机，而前面提到的时间倒流是图灵机可以实现的功能。\n文章中下面这段话很重要👇\n证明零知识的过程，就是要寻找一个算法，或者更通俗点说，写出一段代码，它运行在外部计算机系统中，但是实现了虚拟机的功能。而且在虚拟机中，需要有一个不带有「知识」作为输入的 Zlice，可以骗过放入虚拟机运行的 Bob。\n读心术：从零知识证明中提取「知识」 这篇文章实际是在说明零知识证明中的可靠性。\n「零知识」vs. 「可靠性」 「零知识证明」并不是通过给出一个不允许发生的事件列表来定义，而是直接给出了一个最极致的「模拟条件」。\n所谓「模拟条件」是指，通过「模拟」方法来实现一个「理想世界」，使之与「现实世界」不可区分；而由于在理想世界中不存在知识，所以可以推导出结论：现实世界满足「零知识」。\n我们继续分析下一个交互系统（安全协议）的三个性质：「完备性」、「可靠性」与「零知识」。\n可靠性（Soundness）：Alice 在没有知识的情况下不能通过 Bob 的验证。\n完备性（Completeness）：Alice 在有知识的情况下可以通过 Bob 的验证。\n零知识（Zero-knowledge）：Alice 在交互的过程中不会泄露关于知识的任何信息。\n我们可以看出来「可靠性」和「完备性」有一种「对称性」。可靠性保证了恶意的 Alice 一定失败，而完备性保证了诚实的 Alice 一定成功。\n简洁的Schnorr协议\n📝 这一小节的内容补充了关于群的知识。\nAlice 拥有一个秘密数字，a，我们可以把这个数字想象成「私钥」，然后把它「映射」到椭圆曲线群上的一个点 a*G，简写为 aG。这个点我们把它当做「公钥」。\nsk = a PK = aG 请注意「映射」这个词，我们这里先简要介绍「同态」这个概念。椭圆曲线群有限域之间存在着一种同态映射关系。有限域，我们用 Zq这个符号表示，其中素数 q是指有限域的大小，它是指从 0, 1, 2, …, q-1 这样一个整数集合。而在一条椭圆曲线上，我们通过一个基点，G，可以产生一个「循环群」，标记为 0G, G, 2G, …, (q-1)G，正好是数量为 q个 曲线点的集合。任意两个曲线点正好可以进行一种「特殊的二元运算」，G + G = 2G，2G + 3G = 5G，看起来这个二元运算好像和「加法」类似，满足交换律和结合律。于是我们就用 +这个符号来表示。之所以把这个群称为循环群，因为把群的最后一个元素 (q-1)G，再加上一个 G就回卷到群的第一个元素 0G。\n给任意一个有限域上的整数 r，我们就可以在循环群中找到一个对应的点 rG，或者用一个标量乘法来表示 r*G。但是反过来计算是很「困难」的，这是一个「密码学难题」—— 被称为离散对数难题[2]。\n也就是说，如果任意给一个椭圆曲线循环群上的点 R，那么到底是有限域中的哪一个整数对应 R，这个计算是很难的，如果有限域足够大，比如说 256bit 这么大，我们姑且可以认为这个反向计算是不可能做到的。\nSchnorr 协议充分利用了有限域和循环群之间单向映射，实现了最简单的零知识证明安全协议：Alice 向 Bob 证明她拥有 PK 对应的私钥 sk。\nz 的计算和验证过程很有趣，有几个关键技巧：\n首先 Bob 必须给出一个「随机」挑战数，然后 Bob 在椭圆曲线上同态地检查 z 。如果我们把挑战数 c 看成是一个未知数，那么 r+a*c=z 可以看成是一个一元一次方程，其中 r 与 a 是方程系数。请注意在 c 未知的前提下，如果 r + a*x = r' + a'*x 要成立，那么根据 Schwatz-Zippel 定理[3]，极大概率上 r=r'，a=a' 都成立。也就是说， Alice 在 c 未知的前提下，想找到另一对不同的 r',a' 来计算 z 骗过 Bob 是几乎不可能的。这个随机挑战数 c 实现了r 和 a 的限制。虽然 Bob 随机选了一个数，但是由于 Alice 事先不知道，所以 Alice 不得不使用私钥 a 来计算 z。这里的关键： c 必须是个随机数。 Bob 验证是在椭圆曲线群上完成。Bob 不知道r，但是他知道 r 映射到曲线上的点R；Bob 也不知道 a，但是他知道 a 映射到曲线群上的点 PK，即 a*G。通过同态映射与Schwatz-Zippel 定理，Bob 可以校验 z 的计算过程是否正确，从而知道 Alice 确实是通过 r 和 a 计算得出的 z，但是又不暴露 r 与 a 的值。 还有，在协议第一步中产生的随机数 r 保证了 a 的保密性。因为任何一个秘密当和一个符合「一致性分布」的随机数相加之后的和仍然符合「一致性分布」。 📝 c必须是随机数。\n再遇模拟器\n其实，「可靠性」和「零知识」这两个性质在另一个维度上也是存在着一种对称性。**可靠性保证了恶意的 Alice 一定失败，零知识保证了恶意的 Bob 一定不会成功。**有趣地是，这种对称性将体现在模拟出来的「理想世界」中。\n","date":"2022-11-30T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-30-sec-bit-zkp-summary/toni-osmundson-ZQtk_VAvO7Y-unsplash.jpeg","permalink":"https://wenjin1997.github.io/2022/11/30/sec-bit-zkp-summary/","title":"安比实验室零知识证明介绍系列文章"},{"content":"论文见Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzles。本篇论文详细的介绍了关于数独问题的密码学和物理上的零知识证明协议。可以了解到零知识证明协议的完整过程，一般步骤有哪些。\n1 Introduction 如何在不透露解的情况下让别人相信你知道一个数独的解。关注两件事，证明者如何说明：\n给定一个数独问题，存在一个解 他知道这个解，但是不用给出关于解的任何其他信息 数独问题在计算复杂度上属于NP问题，事实上，是NP-完全问题。NP问题意味着很容易验证一个解是否正确。\n2 Definitions 一般化的数独问题，数独问题的大小是 $n = k^2$，总共 $n \\times n$个格子，每个小块是 $k \\times k$大小的，那么数的范围是 ${ 1, \u0026hellip;, n}$。比如常见的 $k = 3$，$9 \\times 9$ 大小的数独。一个具体数独问题例子和解都是 $O(n^2 \\log n)$ 位的。\nCryptographic Functionalities 协议中有两方，一个是prover，一个是verifier。一旦prover和verifier固定下来，他们交互发的消息可以看作是一个只包含prover和verifier随机数的函数。下面讨论这个协议的一些性质：\ncompleteness.\n一个诚实的verifier会accepect一个正确的证明。也就是一个prover有一个合法的解会遵循这个协议。\nsoundness error.\nThe soundness error (or soundness) of the protocol is the (upper bound on the) probability that a verifier accepts an incorrect proof, i.e. a proof to a fallacious statement; in our case this corresponds to the event that a prover who does not a solution to a given Sudoku puzzle, claims that it knows to solve it, and the verifier accepts this claim.\n对于错误的证明，会有多少的概率通过verifier的验证。\nzero-knowledge.\nThe goal in designing the protocols is to prevent the verifier from gaining any new knowledge from a correct (interactive) proof. I.e., the protocol should be zero- knowledge in the following sense: whatever a verifier could learn by interacting with the correct prover, the verifier could learn itself.\n什么是零知识呢？无论verifier通过与prover交互学到了什么，那么verifier也能通过和自己交互学到这些知识，才是真的没有泄露任何别的知识。实际操作中有一个有效的模拟器。这个模拟器会生成verifier和prover之间的对话，同时只知道puzzle，而不知道数独的解。要求模拟器中verifier与prover对话之间的分布和真实的情况下两者之间的分布是一样的，这样就无法区分模拟器和真实的情况。\nproofs-of-knowledge.\nOur protocols should also be proofs-of-knowledge: if the prover (or anyone imper- sonating him) can succeed in making the verifier accept, then there is another ma- chine, called the extractor, that can communicate with the prover and actually come up with the solution itself. This must involve running the prover several times using the same randomness (which is not possible under normal circumstances), so as not to contradict the zero-knowledge properties.\n证明prover确实有知识，存在这样一个提取器，它能够通过和prover交互得到知识，当然，它不能发送通常的随机数，它可以多次使用相同的随机数。\n论文中证明中用到的唯一的密码学工具是 commitment protocol。一个承诺协议，发送方向接收方承诺一个值，接收方不会学到任何关于这个值有用的信息。这样的一个协议包含两个阶段：\ncommit phase 承诺阶段。\n发送方绑定一些值 $v$，接收方不能决定任何关于 $v$ 有用的信息。特别地，对于任意的$b$和$b’$，接受方无法区分$v=b$和$v=b’$。这个性质称为 hiding。\ndecommit or reval phase\n接收方获得$v$后，确保它是原来的值，也就是说，一旦commit阶段结束，接收方会在reval阶段接收一个唯一的值。这个性质称为 binding。\nbit commitment可以高效执行。\nPhysical Protocols 在文章中使用 tamper-evident sealed envelopes，也就是防拆封信封。在数独的例子中，每个盖住的卡片当作是这样的 tamper-evident sealed envelopes，将卡片翻开就相当于拆开信封。\n3. Cryptographic Protocols verifer要保证两件事情：\n存在一个解 the prover 知道这个解 零知识协议证明的结构：\nThe prover commits to several values. These values are functions of the instance, the solution and some randomization known only to the prover. 证明方承诺一些值。 The verifier requests that the prover open some of the committed values—this is called the challenge. The verifier chooses the challenge at random from a collec- tion of possible challenges. 验证方发起挑战。 The prover opens the requested values. 证明方打开要求的值。 The verifier checks the consistency of the opened values with the given instance, and accepts or rejects accordingly. 验证方验证给定实例打开值的一致性，然后相应地接受或者拒绝。 要求在步骤3中打开的值的分布是一个关于数独问题和步骤2中发送的挑战的有效函数。那么结合承诺协议的不可区分性质，说明了有效模拟器的存在性。\n模拟器的操作如下：在步骤2中随机选择一个验证方可能发起的挑战，计算步骤1中会满足挑战的值。模拟器模拟将这些值发送给验证方，然后运行验证方的算法，用刚刚得到的值和数独问题作为输入。模拟器会获得在步骤2中发送的挑战。如果这个挑战是它之前猜的值，模拟器就会打开之前发送的承诺，那么验证方自然会接受，模拟器可以继续执行这个协议，否则的话，模拟器会重置并重新开始。这里有点绕，原文如下：\nThe simulator operates in the following way: it picks at random a challenge that the verifier might send in Step 2 (i.e. it guesses what the verifier’s challenge will be), and computes commitments for Step 1 that will satisfy this challenge. The simulator simulates sending these commitments to the verifier, then it runs the verifier’s algo- rithm with the puzzle as its input, a fresh set of random bits and these commitments being the first message it receives. It then obtains the challenge the verifier sends in Step 2. If this challenge is indeed the value it guessed, then the simulator can open the commitments it sent and the verifier should accept; the simulator can continue simulating the protocol and output the transcript of the simulated protocol execution. Otherwise, the simulator resets the simulation and starts it all over again.\n如果可能的挑战的数量是多项式的，那么每次模拟器猜测验证方的挑战，就是用“reasonably high”概率是正确的。这个过程保证了协议是零知识的，因为模拟器的输出和验证方从证明方交互得到的输出是不能区分的，但是模拟器这一过程的计算是没有和证明方交互的，那肯定不能得到任何关于解的知识。\n3.1 A Protocol Based on Coloring 对于3-Colorability Protocol，证明者重新排列颜色，然后提交每个顶点重新排列之后的颜色。验证方随机选择一条边，检查边的两端颜色是否是不同的。\n对于数独问题，这个协议是如下这样的：\nProver步骤1是随机选择一个排列$\\sigma$，从${1,\\dots,n}$映射到${1,\\dots,n}$，这样避免泄漏原来的解。\n3.2 An Efficient Cryptographic Protocol with Constant Soundness Error 下面这种协议有常数的soundness error。这个协议的想法是将每个单元复制三份，创建关于解的行、列以及子网格的视角。复制后的每个单元随机排列，prover的工作是说明以下性质：\n对应行、列、子网格含有所有可能的数字，如${ 1,2,\u0026hellip;,n }$。 一个单元的三个版本的值都是相同的。 这些复制后的单元中包含预先确定的值。 如果上述三个条件都满足的话，说明存在这样一个解并且prover是知道它的。具体的协议如下：\n上面过程不是很好理解，例如$n=4$的情况，$3 \\times n^2 = 2 \\times 4^2 = 3 \\times 16$，数独谜题里填的数字范围是 ${ 1,2,3,4 }$。这样有解的三个副本，分别是行、列、subgrids。\nProver：\n提交$3 \\times n^2$ 个值 $v_1,v_2,…,v_{3 \\times 4^2}$。$v_{i_1}、v_{i_2}、v_{i_3}$ 是原来数独解中的值，有相同的值，$(i_1,i_2,i_3)$ 是一个三元组，是随机的下标，例如图中的$(3,16,9)$、$(80,1,17)$。 提交范围${ 1,2, \\dots , 3 \\times n^2 }$中 $n^2$个三元组$(i_1,i_2,i_3)$，例如${ (3,16,9),(80,1,17)\\dots,(i_1,i_2,i_3), \\dots }$。 提交步骤2中个每个三元组的名字，如$(3,16,9)$的名字就是$(rows,columns,subgrids)$，$(80,1,17)$对应的是$(subgrids,rows,columns)$。 提交步骤1中$3n$组位置，对应行、列和子网格，并且在每组中不会存在相交的两个单元格。例如图中蓝色箭头部分。 Verifier：选择以下三个中的一个进行挑战：\n(a) 打开步骤1中$3 \\times n^2$个值，以及步骤4中$3n$组的位置。验证每组中是否含有$n$个不同的值，任意两组之间不相交。\n(b)打开步骤1中$3n^2$个值以及步骤2。验证提交的三元组对应下标的值都是相同的。\n(c)打开步骤2、3、4中提交的值以及步骤1中已经填好的数独，如图中紫色数字。验证(i)打开的值和之前设定的值是一致的，(ii)步骤4中的每个集合和之前的位置是一致的，(iii)每个三元组的名字对应是正确的。\nOverhead of our Protocols 上面两个协议都可以通过重复执行来降低soundness error。\n4 Physical Protocols 物理上的协议，使用 Tamper Evidence作为物理的密码学基础，就是密封的信封。\n密码学协议和物理的协议的还有一个不同是：\nThe protocol does not prevent cheating by adversaries that accept the risk of being labelled as cheaters (in this respect it is similar to the model of covert adversaries).\n两个函数需要用到：shuffle 和 triplicate。\n实现密封效果有三种方式：\n密封的信封 刮刮卡 验证方和证明方在同一个房间，用标准的不透明卡片，密封就是把数字盖着，揭开数字就是翻转卡片，将数字朝上。 协议3\nProtocol 3 A physical protocol with 1/9 soundness error\nThe prover places three scratch-off cards on each cell. On filled-in cells, he places three cards with the correct value, which are already open (scratched). For each row/column/subgrid, the verifier chooses (at random) one of the three cards of each cell in the corresponding row/column/subgrid. The prover makes packets of the verifier’s requested cards (i.e. for every row/ column/subgrid, he assembles the requested cards). He then shuffles each of the 3n packets separately (using the shuffle functionality), and hands the shuffled packets to the verifier. The verifier scratches off all the cards in each packet and verifies that each packet contains all of the numbers. 这个协议需要执行的洗牌次数比较多，对于$9 \\times 9$的情况，需要进行$3 \\times n = 3 \\times 9 = 27$次洗牌，在实际操作中这个次数过多。\n4.1.1 Reducing the Number of Shuffles 上面的意思是在验证阶段，prover给每个袋子标记一个值，从$0$到$c-1$，如果标记的是$0$表示这个口袋不被选中。那么对于每一个标记的号$i$，如果有$t$个袋子是这个标记，就把这$t$个袋子混合在一起进行洗牌操作，最后验证里面每个数字是否出现$t$次。这样就大大减少了shuffles函数的调用次数。\n4.2 A Physical Zero-Knowledge Protocol with no Soundness Error 这种协议prover是没有办法作弊的。\n4.3 A Protocol Using Scissors and a Sheet of Paper ","date":"2022-11-29T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-29-Cryptographic-and-Physical-Zero-Knowledge-Proof-Systems-for-Solutions-of-Sudoku-Puzzles/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/29/Cryptographic-and-Physical-Zero-Knowledge-Proof-Systems-for-Solutions-of-Sudoku-Puzzles/","title":"Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzles"},{"content":"在文章 How to explain zero-knowledge protocols to your children 中通过阿里巴巴与神秘的洞穴的故事介绍了什么是零知识证明。中文翻译文章见【译】How to Explain Zero-Knowledge Protocols to Your Children。下面简要记录文章的笔记：\nThe Strange Cave of Ali Baba 阿里巴巴每天都去集市上，总被小偷偷东西，每次小偷都跑到一个洞穴，里面有一个岔路口，有两条道路，阿里巴巴追着小偷来到洞穴，阿里巴巴每次只能选择一个口进入，每次小偷都能逃走。在经历悲催的40次被偷后，不科学呀，每次小偷都能选择阿里巴巴不走的那条路，那小偷得多幸运，$\\frac{1}{2^{40}}$的概率，不太可能！！！洞穴一定有什么不可告人的秘密！\n一天阿里巴巴提前藏在洞穴里，发现小偷说出了“芝麻开门”咒语，洞穴连接了起来。\n难怪这些小偷每次能顺利逃脱。后来阿里巴巴不断实验咒语，发现可以修改咒语，现在只有他知道新的咒语了。阿里巴巴把这个神奇的经历写在手稿上流传了下来。\nThe Fate of the Manuscript 后来，阿里巴巴的后代 Mick Ali 知道咒语的秘密，但是他不想告诉世人这个秘密，只想说服别人相信他知道这个秘密。一家电视台独家报道这个过程，实验是这样进行的：\n摄影团队先拍摄两个死胡同的细节 每个人都离开洞穴，Mick Ali 单独一人进入洞穴 记者进入到洞穴的岔路口，抛一枚银币，选择左边还是右边，接着大喊让Mike从选择的那一边出来 重复上述过程40次 Mick连续成功40次，已经能足够说服我们他知道咒语。\nThe Jealous Reporter 嫉妒的记者找来一个演员装扮成Mick的样子，但是他不知道咒语，记者也模拟上述过程，不过最后剪掉失败的片段，只展示连续成功40次的结果。\n模拟的情况和真实的情况一同向世人进行展示，人们也无法区别孰真孰假，这不恰好说明咒语的秘密没有泄露嘛！但是人们都相信Mick知道咒语的秘密。这一过程就在证明零知识！！！\nThe Tests in Parallel 上面的证明过程要连续进行40次，有没有方法并行呢？可以建造这样一座大厦，每一层有一个洞穴，每一个洞穴都有自己的咒语，每个洞穴有一个演员，在同一时刻他们进入洞穴然后随机选择进入哪一边，最后出来。但是这样的话，需要在秘密的数量和拍摄场景数量上做一个平衡。\nThe Prior Agreement 之前的模拟场景需要后期剪掉那些不成功的场景，有没有连续进行挑战成功的办法呢？那就是验证者和证明者之间事先商定随机选择走哪边，连续进行40次也能挑战成功。\nA Single Test, A Single Secret 如何只进行一次测试，就让人们足够相信拥有秘密呢？建造下面这样的洞穴：\n只需要单独一次测试就能够让人达到连续40次测试相同水平的信服度，来相信Mick是知道这个咒语的秘密的。\n","date":"2022-11-28T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-28-How-to-explain-zero-knowledge-protocols-to-your-children/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/28/How-to-explain-zero-knowledge-protocols-to-your-children/","title":"How to explain zero-knowledge protocols to your children"},{"content":"本篇是博客《The Incredible Machine》的笔记，文章通过一个数独的故事来解释什么是零知识证明。\n先总结一下这个过程：\n交互式证明。Alice知道数独的解，先将答案写在纸上，然后盖住，Bob发起一个随机挑战，可以选择行、列或者一个3 $\\times$ 3的块。如果选择行，那么收集每行的纸片到一个袋子里，混合后，每个袋子打开都是1～9的数字。重复此过程让我们理由相信Alice知道数独的解，并且这一过程没有泄漏解。 模拟。上述过程在Alice和Bob事先商定随机挑战选择的顺序后，可以在不知道数独解的情况下通过挑战。这也正好证明了这一过程是零知识的。 非交互式证明。由一个机器来模拟这一过程，机器内部事先焊一个随机挑战的顺序，这个顺序可以由一个仪式来完成，保证没有人知道这个顺序。这个机器也是存在缺点的，可以通过实验得到这个随机顺序。 正文如下：\nHow Alice, Bob, and Charlie used Zero-Knowledge and Blockchains to launch The Global Sudoku Revolution.\nThis post is inspired by two great papers that make zero-knowledge proofs accessible to a wide audience:\n[1] How to Explain Zero Knowledge Protocols to Your Children (Quisquater et. al.)\n[2] Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzles (Gradwohl et. al.).\nAlice, Bob, and Charlie loved to solve Sudoku problems.The three friends liked challenging each other with puzzles all the time (in fact, sometimes they solved Sudoku problems that were REALLY large — not just 9x9 taken from here). Alice was the cleverest of the three. She would draw a Sudoku board on paper, and fill in some of the constraints. Then, she’d let Bob and Charlie try to solve the puzzle.\nThe Proof One day, Bob, who was working on an especially difficult Sudoku that Alice had devised（设计的） sighed with despair（绝望的）. “I swear, this puzzle has no solution! Alice just gave me one of the unsolvable ones to mess with me!”\nHe quickly came to Alice to complain.\n“I’ll prove to you that this puzzle has a solution, and that I know it!” declared Alice. “Good!” Said Bob, who was secretly hoping to learn the answer and later taunt（嘲讽） Charlie with it.\n“In fact, I’ll prove it to you with ‘zero-knowledge’, that is, without ever revealing the solution itself”. “I’d like to see you try”, said Bob, who was still thinking of all the fun he’d have teasing （戏弄）Charlie.\nThe Commitment Alice retrieved 81 blank index cards. She quickly wrote a single digit (from 1 to 9) on each card and carefully placed the cards on the table, in a 9-by-9 matrix, organized just like a Sudoku puzzle. All of the cards were placed face down, with the exception of the few that had the constraints that Bob had already seen written on them.\n随机选择行、列或者一个块来进行验证。\nThe Random Challenge Bob was excited. The solution was close. He’d been working on the problem for ages!\n“Bob, you aren’t allowed to peak at the cards!” Alice exclaimed to Bob’s disappointment. “Not yet anyway. But I will let you test the solution. You can choose whether you want to check the rows, the columns, or the blocks. Pick one at random.”\nBob decided to pick the rows. Alice proceeded to place the cards from each row inside an opaque bag — one bag per row. She gave each bag a thorough shake, making sure the index cards inside were mixed well. She handed the bags to Bob, who gave her a quizzical look.\nVerification “Well, open them!” she said. “They should each have exactly 9 cards with all the numbers 1 through 9”. Bob opened each bag and verified that this was indeed the case.\n“This doesn’t prove a thing!” I can also do that! I’d just have to place the numbers 1 through 9 in each row in any order i’d like!” said Bob quickly.\nAlice explained that she couldn’t have known in advance that Bob would pick the rows. She’s not a mind reader! In fact, only a correct solution would have the numbers 1–9 in each row, column, and box and so if her solution was not correct, Bob would have at least a 1 in 3 chance of catching her.\nRinse and Repeat Bob thought that a 1 in 3 chance of catching Alice wasn’t good enough. He still had a gnawing suspicion that the puzzle was unsolvable. He demanded that Alice repeat the procedure with him — each time placing the same cards for the same Sudoku problem face down on the floor, but letting him pick a different test at random. After a long series of tests, Bob was forced to admit that Alice was either an extremely lucky person, or, that she simply has a solution to the Sudoku problem (or perhaps she could read his thoughts after all). He was also quite disappointed that he had gained no knowledge (zero-knowledge) about the solution. All he knew after all these tests was that it was highly likely that every row, column and block did indeed contain the numbers 1–9 exactly once, which could only be so if Alice knew the solution.\nThe three friends had made it a habit to prove to one another that their Sudoku challenges were solvable. After all, no one wants to spend his time on an unsolvable problem. Each test was long and quite exhausting, but Sudoku is after all very serious business.\n如果只进行一次验证，那么Alice可能会有1/3概率作弊，因此需要重复进行随机试验，提高可信度。\nBlockchains and The Global Sudoku Revolution One day, Alice had a great idea. Knowing that her love for Sudoku is shared by millions online, she decided to open her very own YouTube channel, where she can post her own Sudoku challenges online. She called it “The Sudoku Blockchain” (she didn’t know what blockchains were exactly, but it was such a cool buzzword（时髦术语，流行行话）). She dreamed of many channel subscribers that would send her Bitcoins and decided to include features that the competing Sudoku channels did not have: She asked Bob to verify the existence of a solution to each of the puzzles using a zero-knowledge proof. She’d film the whole thing and put it on the Sudoku Blockchain, so that everyone would know that (with high probability) each of the puzzles is indeed solvable.\nThe Simulation One day, Alice came over to Bob’s house to record the proof for a Sudoku challenge, but found that she left the solution to the puzzle at home. Since she was in a hurry to publish the new challenge online, she begged Bob to film it with her anyway. She convinced Bob to pretend to run the proof with her. Together they agreed on a sequence of tests (rows / columns / and blocks) that Bob would “randomly” pick. Since Alice too knew the sequence of tests, she could easily pass them without having the solution to the puzzle.\nCharlie, who was travelling abroad and saw the video was later surprised when Alice and Bob told him how they filmed it. “I’ll never trust you two again!” he exclaimed. “No one should trust any of your online video proofs!”.\n模拟，在模拟情况下有一种超能力，事先约定“随机”选择的顺序，不知道真正的解也能通过测试，这不正恰好说明没有泄漏知识嘛！\nThe Incredible Machine and Non-Interactive Proofs Charlie was frustrated. He did not want to easily give up his Sudoku solving habit, but knowing that Alice and Bob were not trustworthy, he wanted a way to check proofs remotely. After a few sleepless nights, he declared to Alice and Bob that he had a new idea. He locked himself in his room for hours and labored frantically through the night. In the morning, Charlie presented Alice and Bob with his incredible new invention: “The Zero-Knowledge Sudoku Non-Interactive Proof Machine” (or zk-SNIPM as he like to refer to it).\nThe Machine was basically an automated version of Alice’s test. Alice would need to place her cards on the conveyor belt, and feed Sudoku solutions to the machine. The machine would then collect the cards from rows, columns, or boxes and place them automatically into bags that would come out on the other side (after being thoroughly mixed). Then, Alice could open the bags while the camera was still rolling and reveal their contents.\nThe machine had a control panel with a long series of dials that set the test for each set of 81 cards that Alice would feed in. Charlie had set up his own secret series of tests and then welded the control panel’s cover shut (Alice was worried that he also booby-trapped it with explosives, or filled it up with scorpions, vials of acid, or some other similarly nasty thing. Charlie was a bit extreme when it came to securing his devices).\nCharlie could now trust his machine to provide a series of tests that was unknown to Alice so that he could watch youtube videos of proofs and be relatively sure that Alice had not cheated together with Bob.\nThe Ceremony Alice and Bob were jealous of Charlie’s zk-SNIPM machine and wanted to use it to verify all puzzles (including those that Charlie invented). The only problem was that Charlie was the one who had set up the secret series of tests, and they could not let him use it for proofs (he could easily cheat since he knows the sequence of tests). Instead, Alice suggested that they conduct a multi-party set up of the machine together. A sort of “trusted setup ceremony”. She asked Charlie to open the control panel (and remove all of his nasty traps). Each of the dials on the control panel had 3 states, and you would need to rotate it to select the test.\nShe suggested that they place the machine in a dark room, and remove all the labels from the knobs. Each one of them would then go into the room with the machine in the dark (Bob also suggested that they’d be blindfolded just for good measure, and that they each wear a tinfoil hat to prevent mind reading side-channel attacks by Alice) and would turn the knobs on the machine to a random position (either turn them one-third of a turn clockwise, two-thirds of a turn clockwise, or leave them as they are). This way, the final setting of each knob would not be known to any single one of them (in fact, even if two participants colluded, they would not know the final state of the knob without the third person’s assistance). After the set-up ceremony was over, they’d weld the cover of the machine shut.\nCracking the Machine One afternoon, when Bob and Charlie were off travelling, Alice was left alone with the machine. She started wondering if it was as secure as advertised. Thinking about it for a while she decided to feed it slightly modified Sudoku puzzle solutions in order to discover which tests the machine was using. She used a Sudoku puzzle that she could solve, and fed in many boards to see that the solution is indeed accepted by the machine. She then repeated the procedure, but changed the first board fed to the machine to simply include the numbers 1–9 in each row (without forming a legal solution in columns or boxes). The test still passed, and she then realized she can use this idea to learn the sequence of tests that were pre-set within the machine.\n这里Alice先用一个数独的真解喂给机器，看看机器的输出结果。接着重复这一过程，但是修改解，保证每行是数字1～9，喂给机器，查看机器的输出结果，这样可以推测出之前通过仪式得到的随机顺序。\nAlice felt very frustrated. Can you help Alice build a better zk-SNIPM? Can you think of a series of tests that would be harder to crack, or is the approach doomed to fail? Write us and tell us your ideas!\nA Note About the Real World In fact, the zk-SNIPM is a tongue-in-cheek construction of a non-interactive zero-knowledge prover, somewhere between zk-SNARKs and tamper-proof hardware. zk-SNIPM relies on a “physical” type of zero-knowledge proof. Such physical proofs could in fact be made much more powerful, for example, by using a photocopy machine to copy the cards and check the rows, columns and boxes simultaneously on the same solution. Still, we have elected to utilize a physical proving system that has some analogies to computational proofs found in cryptographic zero-knowledge constructions.\nAlice’s initial proving method is analogous to an interactive zero-knowledge proof protocol, where the verifier sends a random challenge to the prover, after she commits to the solution. A prover and verifier that are colluding and share this random challenge in advance can simulate a proof, without really knowing the solutions. A non-interactive version that must work without this challenge step, is constructed by hiding the challenge itself in some cryptographic “machinery” in advance. This prevents the prover from having access to the challenge. Indeed, one good way to generate such a trusted challenge is through a “ceremony” enacted through multiparty computation that combines the randomness from several participants into a single random challenge, encoded in the proving system.\n开始的证明方法类似交互式零知识证明协议，验证者给证明方一个随机挑战，然后进行验证。证明方和验证方可以事先作弊商量随机挑战的顺序，这样他们在不知道解的情况下可以模拟一个证明。后来的机器验证过程是非交互式证明，实现构造一个随机顺序，可以通过仪式的方式，然后再进行证明。\nThe Sudoku example in this post is taken in slightly modified form from Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzles (Gradwohl et. al.).\nMany thanks to Daniel Benarroch for his help with this post.\nThis post was originally published on qed-it.com.\n","date":"2022-11-28T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-28-The-Incredible-Machine/nicolas-houdayer-3h_uBlWlobU-unsplash.jpg","permalink":"https://wenjin1997.github.io/2022/11/28/The-Incredible-Machine/","title":"The Incredible Machine"},{"content":"开始学习密码学，这是一套不错的课程。官方课程链接Online Cryptography Course。教材A Graduate Course in Applied Cryptography，Coursera上的链接为密码学 I。\n下面记录第一周的学习笔记。\nCourse Overview 密码学无处不在，DVD使用的是CSS加密，Blu-ray使用的是AACS加密。\n常用的HTTPS底层用的是SSL/TLS。安全的交流中间是没有偷听和篡改的。\n对称加密系统使用的是同一个key。加密算法是公开的，永远不要使用一个专有的加密算法。\n密码学不是所有安全问题的解决方案，例如软件漏洞或者工程上的攻击。\nWhat is cryptography? Crypto core 密码学的核心建立密钥，保证交流的可靠和完整性。\nBut crypto can do much more 密码学可以应用在匿名交流中，上图中的匿名是相互的，Alice不知道对方是谁，Bob也不知道对方是谁。\n密码学应用在匿名电子货币，类似于我们去商店消费，不想让商店知道我们的身份，同时在网络中，要保证电子货币不能重复消费。\nProtocols 在选举或者私有拍卖的例子中，有受信的第三方来进行公布结果。这里有一个重要的理论，任何可以使用受信第三方完成的事也可以不用第三方就能完成。\nCrypto magic A rigorous science 密码学是一门严谨的学科，要遵循以上三个步骤。\nHistory 替换式加密的密钥空间很大，是26个字母的全排列。\n破解替换式加密的方法是利用了英语字母出现的频率，字母e出现的频率最高，那么我们可以对截获到的密文统计出现的频率，出现频率最高的字母就对应于字母e。接着再利用二合字母出现的频率。\n当我们知道key中加密字母的长度时，就很好破解。\nDiscrete Probability 这部分详细介绍见https://en.wikibooks.org/wiki/High_School_Mathematics_Extensions/Discrete_Probability。\nEvents The union bound Random Variables The uniform random variable Randomized algorithms Independence XOR 异或中重要的一个定理是，Y是一个随机变量，X是一个独立的均匀分布变量，Y与X异或之后是一个均匀分布变量。\nThe birthday paradox 当$n=1.2 \\times \\sqrt{|U|}$时，$U$ 中存在两个变量相等的概率大于等于$1/2$。常识认为可能是$|U|/2$，因此也叫做悖论。\nThe One Time Pad key和要加密的消息的长度一样长。\nkey也可以算出来，是m和c的异或。\n什么是安全的加密呢？香农的定义是，不能从密文中得到任何关于原文的信息。\n用概率来定义 perfect secrecy，也就是从密文中无法区分任意两个原文，得到两个不同message的概率是相同的。\nOTP是有perfect安全性的。\nOTP是没有惟密文攻击，但是有其他攻击。\nPseudorandom Generators 用伪随机key代替随机key。\n永远不要在加密中使用glibc中的random()函数。\nNegligible vs. non-negligible 可忽略的：意思是比多项式的逆下降地还要快。\nAttacks on OTP and stream ciphers 不能两次使用相同的PRG(k)。\n客户端到服务端与服务端到客户端应该使用不同的key。\n中间可以加入p，然后进行篡改。\nReal-world Stream Ciphers PRG Security Defs 一个安全的PRG是不可预测的。\n反过来也成立，一个不可预测的PRG是安全的。\n用到了前面定理(Yao’82)的逆否命题。不安全的PRG是可预测的。\n更一般的定义，computationally indistinguishable。\nSemantic security 前两个定义都太强了，需要一个弱一些的定义，找到存在的 $m_0$ 与 $m_1$。\n这里给出了semantically secure 的定义。\nOTP是 semantically secure 的。\nStream ciphers are semantically secure ","date":"2022-11-21T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-21-Dan-Boneh-Cryptography-Week1/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/21/Dan-Boneh-Cryptography-Week1/","title":"Dan Boneh Cryptography I Week1"},{"content":"最近又把自己的博客折腾了一遍，之前用的是vuepress搭建的，奈何实在看不惯字体太小，配置字体大小半天不成功，索性想着重新搭建一下。网上搜索到的主要有hexo和hugo，之前尝试过hexo，没有很满意，这次就试着用hugo搭建。\n安装Hugo 1 brew install hugo 接着运行：\n1 hugo version 显示正常则说明安装成功。\n创建Hugo网站 1 hugo new site hugo-blog 运行效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 jinjin@Mac-mini test % hugo new site hugo-blog Congratulations! Your new Hugo site is created in /Users/jinjin/code/test/hugo-blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 选择主题 在官方网站主题板块选择一个喜欢的主题，我选择的是Clean White，接着可以按照主题给的教程进行安装。为了后续方便github管理部署以及修改主题，将原主题仓库fork到自己的账户，用git submodule方式进行仓库链接。\n首先找到主题的github仓库，然后fork下来，接着在本地使用git submodule命令，这里仓库地址已经变成自己账户下主题仓库的地址了。\n1 git submodule add https://github.com/wenjin1997/hugo-theme-cleanwhite.git themes/hugo-theme-cleanwhite 在这个过程中，运行git submodule与git clone遇到了一些问题。\n解决 Failed to connect to github.com port 443 参考Failed to connect to github.com port 443: Operation timed out解决该问题，访问https://ping.chinaz.com/github.com，找到一个可用的ip地址，例如为140.82.121.4。\n1 2 cd ~ sudo vim /etc/hosts 在host文件中进行修改。\n1 2 3 4 5 6 7 8 9 10 11 ## # Host Database # # localhost is used to configure the loopback interface # when the system is booting. Do not change this entry. ## 127.0.0.1 localhost 255.255.255.255 broadcasthost ::1 localhost 140.82.121.4 github.com 解决HTTP/2 stream 1 was not closed cleanly before end of the underlying stream 之后使用git clone又出现如下错误：\n1 2 3 jinjin@Mac-mini themes % git clone https://github.com/zhaohuabing/hugo-theme-cleanwhite.git Cloning into \u0026#39;hugo-theme-cleanwhite\u0026#39;... fatal: unable to access \u0026#39;https://github.com/zhaohuabing/hugo-theme-cleanwhite.git/\u0026#39;: HTTP/2 stream 1 was not closed cleanly before end of the underlying stream 参考解决 HTTP/2 stream 1 was not closed cleanly before end of the underlying stream，需要对git进行全局配置。\n1 git config --global http.version HTTP/1.1 初始化主题配置及发布 1 2 cd themes cp -r hugo-theme-cleanwhite/exampleSite/** ../ 接着运行hugo server在本地http://localhost:1313/就能看到博客的样子了。\n1 2 cd .. hugo server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 jinjin@Mac-mini hugo-blog % hugo server Start building sites … hugo v0.101.0+extended darwin/arm64 BuildDate=unknown | EN -------------------+----- Pages | 71 Paginator pages | 8 Non-page files | 0 Static files | 70 Processed images | 0 Aliases | 17 Sitemaps | 1 Cleaned | 0 Built in 82 ms Watching for changes in /Users/jinjin/code/hugo-blog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /Users/jinjin/code/hugo-blog/config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop ^C% 修改配置 可以边修改博客边在本地预览效果，这里有一个很重要的修改，就是在根目录下的congig.toml文件中将baseurl修改为自己的博客地址。\n1 baseurl = \u0026#34;https://wenjin1997.github.io\u0026#34; GitHub Pages发布博客 首先要在github上创建自己\u0026lt;账户名\u0026gt;.github.io的仓库。\n手动发布 Hugo生成的静态页面会放在public文件夹下。\n1 2 hugo cd public 接着向远程推送我们的git仓库。\n1 2 3 4 5 git init git remote add origin git@github.com:wenjin1997/wenjin1997.github.io git add . git commit -m \u0026#34;add test\u0026#34; git push origin master 如果在添加远程仓库时出现错误，参考Git 提示fatal: remote origin already exists 错误解决办法解决方法，用下面的命令删除远程git仓库：\n1 git remote rm origin 接着再用git remote add origin git@github.com:wenjin1997/wenjin1997.github.io重新添加远程仓库。\n运行效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 jinjin@Mac-mini hugo-blog % cd public jinjin@Mac-mini public % git init hint: Using \u0026#39;master\u0026#39; as the name for the initial branch. This default branch name hint: is subject to change. To configure the initial branch name to use in all hint: of your new repositories, which will suppress this warning, call: hint: hint: git config --global init.defaultBranch \u0026lt;name\u0026gt; hint: hint: Names commonly chosen instead of \u0026#39;master\u0026#39; are \u0026#39;main\u0026#39;, \u0026#39;trunk\u0026#39; and hint: \u0026#39;development\u0026#39;. The just-created branch can be renamed via this command: hint: hint: git branch -m \u0026lt;name\u0026gt; Initialized empty Git repository in /Users/jinjin/code/hugo-blog/public/.git/ jinjin@Mac-mini public % git remote add origin git@github.com:wenjin1997/wenjin1997.github.io jinjin@Mac-mini public % git add . jinjin@Mac-mini public % git commit -m \u0026#34;add test\u0026#34; [master (root-commit) af5a609] add test 165 files changed, 60905 insertions(+) create mode 100644 2017/11/03/hello-world/index.html create mode 100644 2017/11/04/istio-install_and_example/index.html create mode 100644 2017/11/07/istio-traffic-shifting/index.html ...（省略） jinjin@Mac-mini public % git push origin master Enumerating objects: 285, done. Counting objects: 100% (285/285), done. Delta compression using up to 8 threads Compressing objects: 100% (213/213), done. Writing objects: 100% (285/285), 3.32 MiB | 341.00 KiB/s, done. Total 285 (delta 82), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (82/82), done. To github.com:wenjin1997/wenjin1997.github.io * [new branch] master -\u0026gt; master 访问自己的博客地址wenjin1997.github.io，可以看到大功告成啦！\n自动发布 使用Github Action 配置自动发布博客，先要创建一个仓库，例如hugo-blog，这里放置博客的源码，包括自己的博客文章、图片等。在仓库创建.github/workflows/deploy.yml文件，配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: wenjin1997/wenjin1997.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 注意要修改 EXTERNAL_REPOSITORY: wenjin1997/wenjin1997.github.io。\nCheckout步骤中的with中配置的submoudles值为true可以同步博客源仓库的子模块。\n在GitHub账户下Setting - Developer settings - Personal access tokens - Tkens(classic)创建一个Token。\n权限开启repo和workflow。\n配置后复制生成的Token（只会出现一次），在刚刚创建的源仓库hugo-blog的Settings - Security - Secretes - Actions中添加PERSON_TOKEN为刚刚的Token。\n完成上述配置后，本地修改博客文章，向仓库hugo-blog进行推送，可以触发GitHub Action，会自动生成博客页面并推送到GitHub Pages仓库，GitHub Pages仓库更新后，又会自动触发官方页面部署CI，实现博客发布。\n博客支持数学公式 参考Hugo博客添加LaTeX语法支持，在主题文件themes/hugo-theme-clean-white/layouts/partials下创建mathjax.html，内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; async src=\u0026#34;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[\u0026#39;$\u0026#39;,\u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;,\u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;,\u0026#39;$$\u0026#39;], [\u0026#39;\\[\\[\u0026#39;,\u0026#39;\\]\\]\u0026#39;]], processEscapes: true, processEnvironments: true, skipTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;], TeX: { equationNumbers: { autoNumber: \u0026#34;AMS\u0026#34; }, extensions: [\u0026#34;AMSmath.js\u0026#34;, \u0026#34;AMSsymbols.js\u0026#34;] } } }); MathJax.Hub.Queue(function() { // Fix \u0026lt;code\u0026gt; tags after MathJax finishes running. This is a // hack to overcome a shortcoming of Markdown. Discussion at // https://github.com/mojombo/jekyll/issues/199 var all = MathJax.Hub.getAllJax(), i; for(i = 0; i \u0026lt; all.length; i += 1) { all[i].SourceElement().parentNode.className += \u0026#39; has-jax\u0026#39;; } }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; code.has-jax { font: inherit; font-size: 100%; background: inherit; border: inherit; color: #515151; } \u0026lt;/style\u0026gt; 在themes/hugo-theme-clean-white/layouts/partials/head.html文件末尾添加下面一行代码：\n1 {{ partial \u0026#34;mathjax.html\u0026#34; . }} 这样在每个页面都会自动插入代码，支持数学公式了。\nTips：上面使用的是MathJax，对于LaTeX公式中的换行符，要使用\\\\\\三个斜杠代替\\\\，例如\n1 2 3 4 5 6 \\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2, \\\\\\ u(1)=1 \\end{cases}\t\\end{aligned} 这样才能正常显示两行公式：\n$$ \\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2, \\\\\\ u(1)=1 \\end{cases}\t\\end{aligned} $$参考资料 Hugo 官网 Hugo + GitHub Action，搭建你的博客自动发布系统 如何利用 GitHub Pages 和 Hugo 轻松搭建个人博客？ 使用 Hugo 和 GitHub Pages 搭建静态博客 Hugo Themes: Clean White zhaohuabing/hugo-theme-cleanwhite Failed to connect to github.com port 443: Operation timed out 解决 HTTP/2 stream 1 was not closed cleanly before end of the underlying stream Git 提示fatal: remote origin already exists 错误解决办法 Hugo博客添加LaTeX语法支持 ","date":"2022-11-19T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-19-hugo-post/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/19/hugo-post/","title":"如何用Hugo + Github Action部署个人博客"},{"content":"原文链接：Zero Knowledge Proofs: An illustrated primer。本篇文章通过图三色问题来介绍什么是零知识证明。\nOne of the best things about modern cryptography （密码学） is the beautiful terminology （术语）. You could start any number of punk bands（朋克乐队） (or Tumblrs) named after cryptography terms like ‘hard-core predicate’, ‘trapdoor function’, ‘ or ‘impossible differential cryptanalysis （密码分析）’. And of course, I haven’t even mentioned the one term that surpasses all of these. That term is ‘zero knowledge‘.\nIn fact, the term ‘zero knowledge’ is so appealing（有吸引力的） that it leads to problems. People misuse it, assuming that zero knowledge must be synonymous（同义词） with ‘really, really secure‘. Hence it gets tacked（附加，增补） onto all kinds of stuff — like encryption（加密） systems and anonymity（匿名） networks — that really have nothing to do with true zero knowledge protocols.\n澄清零知识的误区，像加密系统和匿名网络，真的和零知识协议没有关系。\nThis all serves to underscore a point: zero-knowledge proofs are one of the most powerful tools cryptographers have ever devised（设计的）. But unfortunately they’re also relatively poorly understood. In this series of posts I’m going try to give a (mostly) non–mathematical description of what ZK proofs are, and what makes them so special. In this post and the next I’ll talk about some of the ZK protocols we actually use.\nOrigins of Zero Knowledge The notion of ‘zero knowledge’ was first proposed in the 1980s by MIT researchers Shafi Goldwasser, Silvio Micali and Charles Rackoff. These researchers were working on problems related to interactive proof systems, theoretical systems where a first party (called a ‘Prover’) exchanges messages with a second party (‘Verifier’) to convince the Verifier that some mathematical statement is true.*\n零知识的概念出现在1980s Shafi Goldwasser，Silvio Micali 和 Charles Rackoff发表的这篇文章中。研究者关注在交互式证明系统，一方是“Prover”，另一方是“Verifier”，Prover与Verifier交换信息，来说服Verifier在数学上（可以是概率意义下）相信一些陈述是真的。\nPrior to Goldwasser et al., most work in this area focused the soundness of the proof system. That is, it considered the case where a malicious（恶意的） Prover attempts to ‘trick’ a Verifier into believing a false statement. What Goldwasser, Micali and Rackoff did was to turn this problem on its head. Instead of worrying only about the Prover, they asked: what happens if you don’t trust the Verifier?\n之前的工作主要考虑证明系统的可靠性，考虑的是恶意的证明方，而 Goldwasser, Micali 和 Rackoff 开始考虑如果不相信验证者会发生什么？我们不能傻乎乎的就把一些秘密泄漏给prover。\nThe specific concern they raised was information leakage. Concretely, they asked, how much extra information is the Verifier going to learn during the course of this proof, beyond the mere fact that the statement is true?\n他们考虑的是验证者可能会泄漏信息，也就是在除了知道陈述是真的这个信息外，验证者通过这个证明过程还知道什么额外的信息？\nIt’s important to note that this is not simply of theoretical interest. There are real, practical applications where this kind of thing matters.\nHere’s one: imagine that a real-world client wishes to log into a web server using a password. The standard ‘real world’ approach to this problem involves storing a hashed version of the password on the server. The login can thus be viewed as a sort of ‘proof’ that a given password hash is the output of a hash function on some password — and more to the point, that the client actually knows the password.\nMost real systems implement this ‘proof’ in the absolute worst possible way. The client simply transmits the original password to the server, which re-computes the password hash and compares it to the stored value. The problem here is obvious: at the conclusion of the protocol, the server has learned my cleartext password. Modern password hygiene（卫生） therefore involves a good deal of praying that servers aren’t compromised（损害）.\n这里举了现实中的一个例子，就是密码登录。大多数实际的系统中客户端简单的将原始密码发送给服务端，服务端再计算一遍密码的哈希值，然后和存储的值进行比较。这里会出现安全问题，密码不泄漏只能祈祷于服务端不会出现问题。\nWhat Goldwasser, Micali and Rackoff proposed was a new hope for conducting such proofs. If fully realized, zero knowledge proofs would allow us to prove statements like the one above, while provably revealing no information beyond the single bit of information corresponding to ‘this statement is true’.\n零知识就是除了’this statement is true’外不会泄漏任何其他的信息。\nA ‘real world’ example So far this discussion has been pretty abstract. To make things a bit more concrete, let’s go ahead and give a ‘real’ example of a (slightly insane（疯狂的；非常愚蠢的）) zero knowledge protocol.\nFor the purposes of this example, I’d like you to imagine that I’m a telecom（电信） magnate（巨头） in the process of deploying（部署） a new cellular（蜂窝） communications network. My network structure is represented by the graph below. Each vertex（顶点） in this graph represents a cellular radio tower, and the connecting lines (edges) indicate locations where two cells overlap（重叠）, meaning that their transmissions are likely to interfere with each other.\n部署蜂窝网的例子，每个顶点代表一个蜂窝塔，每个边代表着两个有重叠，意味着他们之间的传输会相互影响。\nThis overlap is problematic, since it means that signals from adjacent towers are likely to scramble（争夺） reception. Fortunately my network design allows me to configure each tower to one of three different frequency bands to avoid such interference.\nThus the challenge in deploying my network is to assign frequency bands to the towers such that no two overlapping cells share the same frequencies. If we use colors to represent the frequency bands, we can quickly work out one solution to the problem:\n两个相邻塔之间用不同的频率，也就转换为图三色问题。在计算复杂度分类上，它属于NP-complete问题。\nOf course, many of you will notice that what I’m describing here is simply an instance of the famous theory problem called the graph three-coloring problem. You might also know that what makes this problem interesting is that, for some graphs, it can be quite hard to find a solution, or even to determine if a solution exists. **In fact, graph three-coloring — specifically, the decision problem of whether a given graph supports a solution with three colors — is known to be in the complexity class NP-complete.\nIt goes without saying that the toy example above is easy to solve by hand. But what if it wasn’t? For example, imagine that my cellular network was very large and complex, so much so that the computing power at my disposal（处理） was not sufficient to find a solution. In this instance, it would be desirable to outsource the problem to someone else who has plenty of computing power. For example, I might hire my friends at Google to solve it for me on spec.\nBut this leads to a problem.\nSuppose that Google devotes a large percentage of their computing infrastructure to searching for a valid coloring for my graph. I’m certainly not going to pay them until I know that they really have such a coloring. At the same time, Google isn’t going to give me a copy of their solution until I’ve paid up. We’ll wind up at an impasse（僵局）.\nIn real life there’s probably a common-sense answer to this dilemma, one that involves lawyers and escrow（第三方托管） accounts. But this is not a blog about real life, it’s a blog about cryptography. And if you’ve ever read a crypto paper, you’ll understand that the right way to solve this problem is to dream up an absolutely crazy technical solution.\nA crazy technical solution (with hats!) The engineers at Google consult with Silvio Micali at MIT, who in consultation with his colleagues Oded Goldreich and Avi Wigderson, comes up with the following clever protocol — one so elegant that it doesn’t even require any computers. All it requires is a large warehouse, lots of crayons（蜡笔）, and plenty of paper. Oh yes, and a whole bunch of hats.**\nHere’s how it works.\nFirst I will enter the warehouse, cover the floor with paper, and draw a blank representation of my cell network graph. Then I’ll exit the warehouse. Google can now enter enter, shuffle a collection of three crayons to pick a random assignment of the three agreed-upon crayon colors (red/blue/purple, as in the example above), and color in the graph in with their solution. Note that it doesn’t matter which specific crayons they use, only that the coloring is valid.\nBefore leaving the warehouse, Google covers up each of the vertices with a hat. When I come back in, this is what I’ll see:\nObviously this approach protects Google’s secret coloring perfectly. But it doesn’t help me at all. For all I know, Google might have filled in the graph with a random, invalid solution. They might not even have colored the graph at all.\nTo address my valid concerns, Google now gives me an opportunity to ‘challenge’ their solution to the graph coloring*.* I’m allowed to pick — at random — a single ‘edge’ of this graph (that is, one line between two adjacent hats). Google will then remove the two corresponding hats, revealing a small portion of their solution:\nNotice that there are two outcomes to my experiment:\nIf the two revealed vertices are the same color (or aren’t colored in at all!) then I definitely know that Google is lying to me. Clearly I’m not going to pay Google a cent. If the two revealed vertices are different colors, then Google might not be lying to me. Hopefully the first proposition is obvious. The second one requires a bit more consideration. The problem is that even after our experiment, Google could still be lying to me — after all, I only looked under two of the hats. If there are E different edges in the graph, then Google could fill in an invalid solution and still get away with it most of the time. Specifically, after one test they could succeed in cheating me with probability up to (E-1)/E (which for a 1,000 edge graph works out to 99.9% of the time).\nFortunately Google has an answer to this. We’ll just run the protocol again!\nWe put down fresh paper with a new, blank copy of the graph. Google now picks a new (random) shuffle of the three crayons. Next they fill in the graph with a valid solution, but using the new random ordering of the three colors.\nThe hats go back on. I come back in and repeat the challenge process, picking a new random edge. Once again the logic above applies. Only this time if all goes well, I should now be slightly more confident that Google is telling me the truth. That’s because in order to cheat me, Google would have had to get lucky twice in a row. That can happen — but it happens with relatively lower probability. The chance that Google fools me twice in a row is now (E-1)/*E ** (E-1)/E (or about 99.8% probability for our 1,000 edge example above).\nFortunately we don’t have to stop at two challenges. In fact, we can keep trying this over and over again until I’m confident that Google is probably telling me the truth.\nBut don’t take my word for it. Thanks to some neat Javascript, you can go try it yourself.\nNote that I’ll never be perfectly certain that Google is being honest — there’s always going to be a tiny probability that they’re cheating me. But after a large number of iterations (E^2, as it happens) I can eventually raise my confidence to the point where Google can only cheat me with negligible probability — low enough that for all practical purposes it’s not worth worrying about. And then I’ll be able to safely hand Google my money.\nWhat you need to believe is that Google is also protected. Even if I try to learn something about their solution by keeping notes between protocol runs, it shouldn’t matter. I’m foiled by Google’s decision to randomize their color choices between each iteration. The limited information I obtain does me no good, and there’s no way for me to link the data I learn between interactions.\n总结一下上面的过程，首先我进入房间，画出图，接着Google进入房间，随机选择三种颜色，涂上解法，盖上帽子，最后我再进入房间，取下任意一个边的两个帽子，看是否是相同颜色。重复上述过程足够多次，$E^2$次，有理由相信Google有解，而我无法通过这个交互过程获得解的信息。\nWhat makes it ‘zero knowledge’? I’ve claimed to you that this protocol leaks no information about Google’s solution. But don’t let me get away with this! The first rule of modern cryptography is never to trust people who claim such things without proof.\nGoldwasser, Micali and Rackoff proposed three following properties that every zero-knowledge protocol must satisfy. Stated informally, they are:\nCompleteness. If Google is telling the truth, then they will eventually convince me (at least with high probability). Soundness. Google can only convince me if they’re actually telling the truth. Zero-knowledgeness. (Yes it’s really called this.) **I don’t learn anything else **about Google’s solution. 零知识协议需要满足：\n完备性。如果Google说的是事实，那么他们最终会说服我。 可靠性。只有当Google真的说的是事实时才能说服我。 零知识。我不能获得关于Google 解法的任何知识。 We’ve already discussed the argument for completeness. The protocol will eventually convince me (with a negligible error probability), provided we run it enough times. Soundness is also pretty easy to show here. If Google ever tries to cheat me, I will detect their treachery with overwhelming probability.\n完备性证明：上述过程已经证明了，只要交互过程重复的次数足够多，最终都会以一个可以忽略的错误概率来使我信服。\n可靠性证明：如果Google欺骗我，我会有压倒性的概率发现这一点。\n参考BIU课程，完备性和可靠性的严格定义。\nThe hard part here is the ‘zero knowledgeness’ property. To do this, we need to conduct a very strange thought experiment.\nA thought experiment (with time machines) First, let’s start with a crazy hypothetical（假设）. Imagine that Google’s engineers aren’t quite as capable as people make them out to be. They work on this problem for weeks and weeks, but they never manage to come up with a solution. With twelve hours to go until showtime, the Googlers get desperate. They decide to trick me into thinking they have a coloring for the graph, even though they don’t.\nTheir idea is to sneak into the GoogleX workshop and borrow Google’s prototype time machine. Initially the plan is to travel backwards a few years and use the extra working time to take another crack at solving the problem. Unfortunately it turns out that, like most Google prototypes, the time machine has some limitations. Most critically: it’s only capable of going backwards in time four and a half minutes.\nSo using the time machine to manufacture more working time is out. But still, it turns out that even this very limited technology can still be used to trick me.\nI don’t really know what’s going on herebut it seemed apropos.\nThe plan is diabolically（非常） simple. Since Google doesn’t actually know a valid coloring for the graph, they’ll simply color the paper with a bunch of random colors, then put the hats on. If by sheer luck, I challenge them on a pair of vertices that happen to be different colors, everyone will heave a sigh of relief and we’ll continue with the protocol. So far so good.\nInevitably（不可避免地）, though, I’m going to pull off a pair of hats and discover two vertices of the same color. In the normal protocol, Google would now be totally busted（崩溃）. And this is where the time machine comes in. Whenever Google finds themselves in this awkward situation, they simply fix it. That is, a designated Googler pulls a switch, ‘rewinds’ time about four minutes, and the Google team recolors the graph with a completely new random solution. Now they let time roll forward and try again.\nIn effect, the time machine allows Google to ‘repair’ any accidents that happen during their bogus（虚假的） protocol execution, which makes the experience look totally legitimate to me. Since bad challenge results will occur only 1/3 of the time, the expected runtime of the protocol (from Google’s perspective) is only moderately greater than the time it takes to run the honest protocol. From my perspective I don’t even know that the extra time machine trips are happening.\nThis last point is the most important. In fact, from my perspective, being unaware that the time machine is in the picture, the resulting interaction is exactly the same as the real thing. It’s statistically identical. And yet it’s worth pointing out again that in the time machine version, Google has absolutely no information about how to color the graph.\n总结一下，Google不知道图涂色的解法，但是他们有神器时间机器，可以倒退四分半的时间。 如果在交互过程中失败，他们就使用时间机器倒退，重新涂色。 从我的角度来看，我没有意识到他们有时间机器，因此产生的互动和真实的东西完全一样，在统计上是相同的。但是在时间机器版本，Google完全没有涂色的解法。\nBIU课程中对HVZK的定义：\nWhat the hell is the point of this? What we’ve just shown is an example of a simulation. Note that in a world where time runs only forward and nobody can trick me with a time machine, the hat-based protocol is correct and sound, meaning that after E^2 rounds I should be convinced (with all but negligible probability) that the graph really is colorable and that Google is putting valid inputs into the protocol.\nWhat we’ve just shown is that if time doesn’t run only forward — specifically, if Google can ‘rewind’ my view of time — then they can fake a valid protocol run even if they have no information at all about the actual graph coloring.\nFrom my perspective, what’s the difference between the two protocol transcripts? When we consider the statistical distribution of the two, there’s no difference at all*.* Both convey exactly the same amount of useful information.\nBelieve it or not, this proves something very important.\nSpecifically, assume that I (the Verifier) have some strategy that ‘extracts’ useful information about Google’s coloring after observing an execution of the honest protocol. Then my strategy should work equally well in the case where I’m being fooled with a time machine. The protocol runs are, from my perspective, statistically identical. I physically cannot tell the difference.\nThus if the amount of information I can extract is identical in the ‘real experiment’ and the ‘time machine experiment’, yet the amount of information Google puts into the ‘time machine’ experiment is exactly zero — then this implies that even in the real world the protocol must not leak any useful information.\nThus it remains only to show that computer scientists have time machines. We do! (It’s a well-kept secret.)\n总结：从我的视角来看，两个协议是没有区别的，因为它们在统计上的分布是相同的，它们都传达了完全相同数量的有用信息。 具体来说，如果我能在真实世界中提取一些有用的信息，那么我在时间机器版本中也能提取有用的信息，但是由于时间机器实验中的信息量为0，因此也就意味着即使是在现实世界，协议也不会泄漏任何有用的信息。 因此，我们知道计算机科学家拥有时间机器。\nGetting rid of the hats (and time machines) Of course we don’t actually want to run a protocol with hats. And even Google (probably?) doesn’t have a literal time machine.\nTo tie things together, we first need to bring our protocol into the digital world. This requires that we construct the digital equivalent of a ‘hat’: something that both hides a digital value, while simultaneously ‘binding’ (or ‘committing’) the maker to it, so she can’t change her mind after the fact. 这里说的就是binding性质，揭露之后值就固定下来了。\nFortunately we have a perfect tool for this application. It’s called a digital commitment scheme. A commitment scheme allows one party to ‘commit’ to a given message while keeping it secret, and then later ‘open’ the resulting commitment to reveal what’s inside. They can be built out of various ingredients（组成部分）, including (strong) cryptographic hash functions.******\n这里给出了一个数字 commitment scheme。\nGiven a commitment scheme, we now have all the ingredients we need to run the zero knowledge protocol electronically. The Prover first encodes its vertex colorings as a set of digital messages (for example, the numbers 0, 1, 2), then generates digital commitments to each one. These commitments get sent over to the Verifier. When the Verifier challenges on an edge, the Prover simply reveals the opening values for the commitments corresponding to the two vertices.\n其实就是用数字的commitment来代替之前物理上的帽子。\nSo we’ve managed to eliminate the hats. But how do we prove that this protocol is zero knowledge?\nFortunately now that we’re in the digital world, we no longer need a real time machine to prove things about this protocol. A key trick is to specify in our setting that the protocol is not going to be run between two people, but rather between two different computer programs (or, to be more formal, probabilistic Turing machines.)\nWhat we can now prove is the following theorem: if you could ever come up with a computer program (for the Verifier) that extracts useful information after participating in a run of the protocol, then it would be possible to use a ‘time machine’ on that program in order to make it extract the same amount of useful information from a ‘fake’ run of the protocol where the Prover doesn’t put in any information to begin with.\nAnd since we’re now talking about computer programs, it should be obvious that rewinding time isn’t such an extraordinary feat at all. In fact, we rewind computer programs all the time. For example, consider using virtual machine software with a snapshot capability.\nExample of rewinding through VM snapshots. An initial VM is played forward, rewound to aninitial snapshot, then execution is forked to a new path.\nEven if you don’t have fancy virtual machine software, any computer program can be ‘rewound’ to an earlier state, simply by starting the program over again from the beginning and feeding it exactly the same inputs. Provided that the inputs — including all random numbers — are fixed, the program will always follow the same execution path. Thus you can rewind a program just by running it from the start and ‘forking’ its execution when it reaches some desired point.\nUltimately what we get is the following theorem. If there exists any Verifier computer program that successfully extracts information by interactively running this protocol with some Prover, then we can simply use the rewinding trick on that program to commit to a random solution, then ‘trick’ the Verifier by rewinding its execution whenever we can’t answer its challenge correctly. The same logic holds as we gave above: if such a Verifier succeeds in extracting information after running the real protocol, then it should be able to extract the same amount of information from the simulated, rewinding-based protocol. But since there’s no information going into the simulated protocol, there’s no information to extract. Thus the information the Verifier can extract must always be zero.\nOk, so what does this all mean? So let’s recap. We know that the protocol is complete and sound, based on our analysis above. The soundness argument holds in any situation where we know that nobody is fiddling（无足轻重地） with time — that is, the Verifier is running normally and nobody is rewinding its execution.\nAt the same time, the protocol is also zero knowledge. To prove this, we showed that any Verifier program that succeeds in extracting information must also be able to extract information from a protocol run where rewinding is used and no information is available in the first place. Which leads to an obvious contradiction（矛盾）, and tells us that the protocol can’t leak information in either situation.\n同时协议也是零知识的。为了证明这一点，我们已经展示了任何能够成功提取信息的验证程序也必须在使用了rewinding超能力的协议中成功提取信息，但是这个协议是不能获取到任何知识的。这也就告诉了我们在这两种情况下都没有泄漏知识。\nThere’s an important benefit to all this. Since it’s trivial for anyone to ‘fake’ a protocol transcript, even after Google proves to me that they have a solution, I can’t re-play a recording of the protocol transcript to prove anything to anyone else (say, a judge). That’s because the judge would have no guarantee that the video was recorded honestly, and that I didn’t simply edit in the same way Google might have done using the time machine. This means that protocol transcripts themselves contain no information. The protocol is only meaningful if I myself participated, and I can be sure that it happened in real time.\n模拟的和真实的是无法在真实世界中进行区分的，所以只有当我参与进去的时候，协议才是有意义的，并且我能确保实在真实时间中发生的。\nProofs for all of NP! If you’ve made it this far, I’m pretty sure you’re ready for the big news. Which is that 3-coloring cellphone networks isn’t all that interesting of a problem — at least, not in and of itself.\nThe really interesting thing about the 3-coloring problem is that it’s in the class NP-complete. To put this informally, the wonderful thing about such problems is that any other problem in the class NP can be translated into an instance of that problem.In a single stroke, this result — due to Goldreich, Micali and Wigderson — proves that ‘efficient’ ZK proofs exists for a vast class of useful statements, many of which are way more interesting than assigning frequencies to cellular networks. You simply find a statement (in NP) that you wish to prove, such as our hash function example from above, then translate it into an instance of the 3-coloring problem. At that point you simply run the digital version of the hat protocol.\n三涂色问题是NPC问题，那么对于一个想要证明的NP问题，都可以归约到这个NPC问题，然后转化成三涂色问题，用上面的数字协议进行运行就可以了。\nIn summary, and next time Of course, actually running this protocol for interesting statements would be an insanely（疯狂地） silly thing for anyone to do, since the cost of doing so would include the total size of the original statement and witness, plus the reduction cost to convert it into a graph, plus the $E^2$ protocol rounds you’d have to conduct in order to convince someone that the proof is valid. Theoretically this is ‘efficient’, since the total cost of the proof would be polynomial in the input size, but in practice it would be anything but.\n理论上上面的三色问题的零知识证明协议是“efficent”，但是不实用。\nSo what we’ve shown so far is that such proofs are possible. It remains for us to actually find proofs that are practical enough for real-world use.\nIn the next post I’ll talk about some of those — specifically, the efficient proofs that we use for various useful statements. I’ll give some examples (from real applications) where these things have been used. Also at reader request: I’ll also talk about why I dislike SRP so much.\nSee here for Part 2.\nNotes:\nFormally, the goal of an interactive proof is to convince the Verifier that a particular string belongs to some language. Typically the Prover is very powerful (unbounded), but the Verifier is limited in computation. * This example is based on the original solution of Goldwasser, Micali and Rackoff, and the teaching example using hats is based on an explanation by Silvio Micali. I take credit only for the silly mistakes. ***** A simple example of a commitment can be built using a hash function. To commit to the value “x” simply generate some (suitably long) string of random numbers, which we’ll call ‘salt’, and output the commitment C = Hash(salt || x). To open the commitment, you simply reveal ‘x’ and ‘salt’. Anyone can check that the original commitment is valid by recomputing the hash. This is secure under some (moderately strong) assumptions about the function itself. ","date":"2022-11-16T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-16-Zero-Knowledge-Proofs-An-illustrated-primer/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/16/Zero-Knowledge-Proofs-An-illustrated-primer/","title":"Zero Knowledge Proofs: An illustrated primer"},{"content":"异步Web框架生态 Rocket tide warp tower-web Thruster gotham actix-web ntex axum Rocket框架 官方教程：The Rocket Programming Guide\nRocket设计核心哲学：\nSecurity, correctness, and developer experience are paramount. All request handling information should be typed and self-contained. Decisions should not be forced. Lifecycle\nRocket\u0026rsquo;s main task is to listen for incoming web requests, dispatch the request to the application code, and return a response to the client. We call the process that goes from request to response the \u0026ldquo;lifecycle\u0026rdquo;. We summarize the lifecycle as the following sequence of steps:\nRouting 路由 Validation 验证 Processing 处理 Response 回复 1 2 3 4 #[get(\u0026#34;/world\u0026#34;)] // \u0026lt;- route attribute fn world() -\u0026gt; \u0026amp;\u0026#39;static str { // \u0026lt;- request handler \u0026#34;hello, world!\u0026#34; } Lanuching\nRocket begins serving requests after being launched, which starts a multi-threaded asynchronous server and dispatches requests to matching routes as they arrive.\n1 2 3 4 5 6 7 8 9 10 11 #[macro_use] extern crate rocket; #[get(\u0026#34;/world\u0026#34;)] fn world() -\u0026gt; \u0026amp;\u0026#39;static str { \u0026#34;Hello, world!\u0026#34; } #[launch] fn rocket() -\u0026gt; _ { rocket::build().mount(\u0026#34;/hello\u0026#34;, routes![world]) } Dynamic Paths\n1 2 3 4 #[get(\u0026#34;/hello/\u0026lt;name\u0026gt;\u0026#34;)] fn hello(name: \u0026amp;str) -\u0026gt; String { format!(\u0026#34;Hello, {}!\u0026#34;, name) } Forwarding\nRoutes are attempted in increasing rank order. Rocket chooses a default ranking from -12 to -1, detailed in the next section, but a route\u0026rsquo;s rank can also be manually set with the rank attribute. To illustrate, consider the following routes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[get(\u0026#34;/user/\u0026lt;id\u0026gt;\u0026#34;)] fn user(id: usize) { /* ... */ } #[get(\u0026#34;/user/\u0026lt;id\u0026gt;\u0026#34;, rank = 2)] fn user_int(id: isize) { /* ... */ } #[get(\u0026#34;/user/\u0026lt;id\u0026gt;\u0026#34;, rank = 3)] fn user_str(id: \u0026amp;str) { /* ... */ } #[launch] fn rocket() -\u0026gt; _ { rocket::build().mount(\u0026#34;/\u0026#34;, routes![user, user_int, user_str]) } actix-web 官方文档：actix_web\n可以通过宏来创建提取器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use actix_web::{get, web, App, HttpServer, Responder}; #[get(\u0026#34;/hello/{name}\u0026#34;)] async fn greet(name: web::Path\u0026lt;String\u0026gt;) -\u0026gt; impl Responder { format!(\u0026#34;Hello {}!\u0026#34;, name) } #[actix_web::main] // or #[tokio::main] async fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { HttpServer::new(|| { App::new().service(greet) }) .bind((\u0026#34;127.0.0.1\u0026#34;, 8080))? .run() .await } 其他\nLemmy论坛 actix-extras：actix中间件 actix-web底层基于actix-net中间库，封装了和网络相关的东西。\n在actix-net/actix-rt/src/arbiter.rs下每个arbiter对应一个线程。\ngotham 比较早的框架，基于tokio实现。\nThruster 构建于hyper之上，这个中间件在请求过程中设置上下文。\ntower 文档： tower\nTower is a library of modular and reusable components for building robust networking clients and servers.\nhyper 官方文档：hyper\n关于路由用到route-recognizer，它的底层是非确定有限状态自动机。\nwarp github仓库地址：warp。\nfilter的工作机制，基于hyper。Rust-Warp-Example是一个应用实例。\n一些底层的库 http：解析处理HTTP协议，对http请求和响应做了一个类型抽象。 http-body：做异步http请求和响应。 http-types：基于async-std。 tower-http：基于tower、http、http-body、的中间件。 hyper：HTTP的实现，没有整合tower-http。 Rust异步Web框架 结构：\n框架接口设计 路由结构实现 实现Handler 添加tracing打印日志 实现提取器 实现中间件 错误处理 补充学习 正则表达式 Cow and_then、and dyn pin、unpin Oneshot pin_project! 网络中的请求方法有哪些？区别是什么？ Any 终端命令 curl，参考Linux curl命令详解 DSL是什么？参考谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例） uri async_trait map、map_err curl http://... -I -HEAD tower 阅读axum源码 kv-serve 和 web 如何连接在一起？ 参考资料 张汉东的Rust实战课\n张汉东的Rust实战课视频课程代码示例\n","date":"2022-08-23T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/08/23/rust-web/","title":"Rust异步Web框架"},{"content":"在mac本地打开终端，创建密钥对。\n1 ssh-keygen -t rsa -C \u0026#39;your email@domain.com\u0026#39; -t 指定密钥类型，默认即 rsa ，可以省略 -C 设置注释文字，比如你的邮箱，可以省略\n接着就按回车，如果发现之前的 id_rsa 文件需要覆盖，则可以另外创建文件存储密钥。\n1 Enter file in which to save the key (/Users/zheng/.ssh/id_rsa): linux_id_rsa 接着在用户文件夹下能找到 linux_id_rsa 和 linux_id_rsa.pub 这两个文件，将它们复制到 /.ssh 目录下。\n下面将生成的公钥复制到服务器，就是将mac本地的 linux_id_rsa.pub 中的内容复制到服务器上 ~/.ssh/authorized_keys 文件中。我这里没有用命令，直接用面板复制过去，也可以用 scp 命令。\n接着配置本地~/.ssh/config 文件，因为我们的是 linux_id_rsa 文件。\n1 2 3 4 5 Host alias #自定义别名 HostName hostname #替换为你的ssh服务器ip或domain Port port #ssh服务器端口，默认为22 User user #ssh服务器用户名 IdentityFile ~/.ssh/linux_id_rsa #第一个步骤生成的公钥文件对应的私钥文件 本来登录命令是：\n1 ssh -p \u0026lt;端口号\u0026gt; \u0026lt;用户名\u0026gt;@\u0026lt;ip地址\u0026gt; 现在直接用别名就可以登录了。\n1 ssh alias 参考资料 Mac使用ssh密钥登录Linux 设置 SSH 通过密钥登录 github生成多个ssh key，如何解决 ","date":"2022-08-01T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/08/01/Linux-ssh/","title":"Mac用ssh远程连接服务器"},{"content":"Rustdoc：你可以用它做什么，以及它的未来 Rust 计算加速技术解读及高性能代码重构实践 从零开始实现Rust Fuzzer从零开始实现Rust Fuzzer 复杂 Rust 开源项目的维护 基于LLVM Rust代码混淆设计与实现 Rust API可靠性分析与验证 你为什么需要「Rust 编码规范」 ","date":"2022-07-07T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/31/RustChinaConf/","title":"Rust开发者大会"},{"content":"本章至下而上的方式来带领大家理解异步编程:\n异步 I/O 模型 异步编程模型： 事件驱动模型 Futures 生成器 与 Pin async/await 异步运行时介绍：async-std、tokio、bastion、smol 异步IO模型 基本概念 同步和异步，关注的是消息通信机制。（调用者视角）结合烧开水的例子。 同步，发出一个调用，在没有得到结果之前不返回。水没烧好不离开。 异步，发出一个调用，在没有得到结果之前返回。水没烧好时，可以先去干别的。 阻塞和非阻塞，关注的是程序等待调用结果的状态。（被调用者视角） 阻塞，在调用结果返回之前，线程被挂起。 非阻塞，在调用结果返回之前，线程不会被挂起。 阻塞，与系统调用有关。\nI/O模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 +-+ 阻 塞 I/O (BIO) | +-+ 非 阻 塞 I/O (NIO) | +----+ 同 步 I/O +--+ | | | +-+ I/O 多 路 复 用 | | | +-+ 信 号 驱 动 I/O I/O 模 型 +---+ | | | +-+ Linux (AIO) | | (io_uring) +----+ 异 步 I/O +--+ | +-+ windows (IOCP) 同步阻塞I/O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Application kernel +---------+ +-----------+ +---+ | | syscall | no | | | Read | +--------\u0026gt; | datagram | | | recvfrom| | ready | | | | | + | +-+ wait for | | | | | +-+ data | | | v | | | | | datagram | | | | | ready | +---+ | | | | | | | copy | +---+ | | | datagram | | |process | | + | +-+ copy data |datagram | return | | | +-+ from kernel to user | | \u0026lt;--------+ | v | | | | | copy | +---+ | | | complete | +---------+ +-----------+ 输入操作两个阶段：\n进程等待内核把数据准备好；这个阶段可以阻塞也可非阻塞，设置socket属性。 阻塞： recvfrom 阻塞线程直到返回数据就绪的结果。 非阻塞：立即返回一个错误，轮询直到数据就绪。 从内核缓冲区向进程缓冲区复制数据。（一直阻塞） 异步I/O，recvfrom总是立即返回，两个阶段都由内核完成。\nI/O多路复用 IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄。\n支持I/O多路复用的系统调用有 select/pselect/poll/epoll，本质都是 同步 I/O，因为数据拷贝都是阻塞的。 通过 select/epoll 来判断数据报是否准备好，即判断可读可写状态。\n补充资料 I/O模型和I/O调用是不是分不清楚，参考理解一下5种IO模型、阻塞IO和非阻塞IO、同步IO和异步IO。\n先理解什么是IO：\n要输入输出数据分为两个阶段：用户进程空间\u0026lt;\u0026ndash;\u0026gt;内核空间、内核空间\u0026lt;\u0026ndash;\u0026gt;设备空间（磁盘、网络等）。\n阻塞IO模型\n进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。\n非阻塞IO模型\n进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。\nIO复用模型\n多个进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select，select会监听所有注册进来的IO；\n如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可用数据时，select调用就会返回；\n而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。\nselect、poll、epoll\nLinux中IO复用的实现方式主要有select、poll和epoll。 Select: 注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_SIZE。 Poll: 原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降。 Epoll：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持。 信号驱动IO模型\n当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发生一个信号给进程，进程便在信号处理函数中调用IO读取数据。\n特点：回调机制，实现、开发应用难度大。\n异步IO模型\n当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。\n一图总结：\nepoll 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 +--------------------------------+ +-------------------------+ | epoll_ctl | | epoll_wait | | | | | | | | +----+ | | +---+ | | | | | | | | | | | | | | +-+---+--+ | | +--+-+ | | | | | | | | | +--++ +-++ | | | | epoll_create +----\u0026gt; | | | | | | | +--+-+ | | +-+-+ +--+ +----\u0026gt;+ | | | | | |event| | | | | +----+--+ | | +--+-+ | | | | | | | | | ++ | | | | | | +--+ +-+-+ | | +--+-+ | | | | | | | | | | | | +--+ +---+ | | | | | | | | +----+ | | 红 黑 树 | | 链 表 | +--------------------------------+ +-------------------------+ epoll_create(int size) : 内核产生一个epoll实例数据结构，并返回一个epfd epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)：将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。 epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout): 阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入events数组中 epoll 两种触发机制：\n水平触发机制（LT)。缓冲区只要有数据就触发读写。epoll 默认工作方式。select/poll只支持该方式。 边缘触发机制（ET)。缓冲区空或满的状态才触发读写。nginx 使用该方式，避免频繁读写。 惊群问题：\n当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。 Liux 4.5 通过引入 EPOLLEXCLUSIVE 标识来保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的惊群问题。\n补充资料 Linux下的I/O复用与epoll详解\nselect、poll、epoll\nLinux中IO复用的实现方式主要有select、poll和epoll： Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_SIZE； Poll：原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降； Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持。 select的缺陷：\nselect预估错误了一件事，当数十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。 在Linux内核中，select所用到的FD_SET是有限的，即内核中有个参数__FD_SETSIZE定义了每个FD_SET的句柄个数。 内核中实现 select是用轮询方法，即每次检测都会遍历所有FD_SET中的句柄，显然，select函数执行时间与FD_SET中的句柄个数有一个比例关系，即 select要检测的句柄数越多就会越费时。 相比于select机制，poll只是取消了最大监控文件描述符数限制，并没有从根本上解决select存在的问题。\nepoll精巧的使用了3个方法来实现select方法要做的事：\n新建epoll描述符==epoll_create() epoll_ctl(epoll描述符，添加或者删除所有待监控的连接) 返回的活跃连接 ==epoll_wait（ epoll描述符 ） 与select相比，epoll分清了频繁调用和不频繁调用的操作。例如，epoll_ctl是不太频繁调用的，而epoll_wait是非常频繁调用的。这时，epoll_wait却几乎没有入参，这比select的效率高出一大截，而且，它也不会随着并发连接的增加使得入参越发多起来，导致内核执行效率下降。\n要深刻理解epoll，首先得了解epoll的三大关键要素：mmap、红黑树、链表。\nepoll是通过内核与用户空间mmap同一块内存实现的。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。\n红黑树将存储epoll所监听的套接字。上面mmap出来的内存如何保存epoll所监听的套接字，必然也得有一套数据结构，epoll在实现上采用红黑树去存储所有套接字，当添加或者删除一个套接字时（epoll_ctl），都在红黑树上去处理，红黑树本身插入和删除性能比较好，时间复杂度O(logN)。\n通过epoll_ctl函数添加进来的事件都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把事件添加进来的时候时候会完成关键的一步，那就是该事件都会与相应的设备（网卡）驱动程序建立回调关系，当相应的事件发生后，就会调用这个回调函数，该回调函数在内核中被称为：ep_poll_callback,这个回调函数其实就所把这个事件添加到rdllist这个双向链表中。一旦有事件发生，epoll就会将该事件添加到双向链表中。那么当我们调用epoll_wait时，epoll_wait只需要检查rdlist双向链表中是否有存在注册的事件，效率非常可观。这里也需要将发生了的事件复制到用户态内存中即可。\nepoll_wait的工作流程：\nepoll_wait调用ep_poll，当rdlist为空（无就绪fd）时挂起当前进程，直到rdlist不空时进程才被唤醒。 文件fd状态改变（buffer由不可读变为可读或由不可写变为可写），导致相应fd上的回调函数ep_poll_callback()被调用。 ep_poll_callback将相应fd对应epitem加入rdlist，导致rdlist不空，进程被唤醒，epoll_wait得以继续执行。 ep_events_transfer函数将rdlist中的epitem拷贝到txlist中，并将rdlist清空。 ep_send_events函数（很关键），它扫描txlist中的每个epitem，调用其关联fd对用的poll方法。此时对poll的调用仅仅是取得fd上较新的events（防止之前events被更新），之后将取得的events和相应的fd发送到用户空间（封装在struct epoll_event，从epoll_wait返回）。 select、poll和epoll三种I/O复用模式的比较：\n系统调用 select poll epoll 事件集合 用户通过3个参数分别传入感兴趣的可读，可写及异常等事件内核通过对这些参数的在线修改来反馈其中的就绪事件这使得用户每次调用select都要重置这3个参数 统一处理所有事件类型，因此只需要一个事件集参数。用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件 内核通过一个事件表直接管理用户感兴趣的所有事件。因此每次调用epoll_wait时，无需反复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件 应用程序索引就绪文件描述符的时间复杂度 O(n) O(n) O(1) 最大支持文件描述符数 一般有最大值限制 65535 65535 工作模式 LT LT 支持ET高效模式 内核实现和工作效率 采用轮询方式检测就绪事件，时间复杂度：O(n) 采用轮询方式检测就绪事件，时间复杂度：O(n) 采用回调方式检测就绪事件，时间复杂度：O(1) io_uring 异步 I/O 模型 Linux AIO 实现的并不理想，所以引入了新的异步I/O接口 io_uring。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 +----+ Head +---------+ +----------+ Head | | | | | | | | | | | +---------+ +----------+ | | | | | | | | | | | +---------+ +----------+ | | | | | | | | | | | +---------+ +----------+ | | | | | | Tail +---------+ +----------+ Tail \u0026lt;--+ | +--------------------------------------------+ | | | Kernel | | | | | | | | +-------+ +-------+ | | | | | | | | | | +---------------\u0026gt; | SQ | | CQ | +--------+ | | | | | | | +-------+ +-------+ | | | +--------------------------------------------+ io_uring接口通过两个主要数据结构工作：\n提交队列条目（sqe） 完成队列条目（cqe） 这些结构的实例位于内核和应用程序之间的共享内存单生产者单消费者环形缓冲区中。\n参考：\nHow io_uring and eBPF Will Revolutionize Programming in Linux A Universal I/O Abstraction for C++ 事件驱动编程模型 因为处理 I/O 复用的编程模型相当复杂，为了简化编程，引入了下面两种模型。\nReactor（反应器） 模式，对应同步I/O，被动的事件分离和分发模型。服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。 Preactor（主动器） 模式，对应异步I/O，主动的事件分离和分发模型。这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）。 Reactor Model:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 +----------------+ req Dispatch | | +------+ +--------\u0026gt; | req handler | | | | +----------------+ | | +----+ | +------+ | event +------------+ | | | | | +--------\u0026gt; | Service | |Dispatch +----------------+ | Handler +------------\u0026gt; | | req +---------\u0026gt; | | | | req handler | +------+ | +------------+ | +----------------+ | | | event | | +----+ | +------+ | Dispatch +----------------+ +---------\u0026gt;+ | | req handler | +----------------+ 三种实现方式：\n单线程模式。 accept()、read()、write()以及connect()操作 都在同一线程。 工作者线程池模式。非 I/O 操作交给线程池处理 多线程模式。主Reactor (master) ，负责网络监听 ， 子Reactor(worker) 读写网络数据。 读写操作流程：\n应用注册读写就绪事件和相关联的事件处理器 事件分离器等待事件发生 当发生读写就绪事件，事件分离器调用已注册的事件处理器 事件处理器执行读写操作 参与者：\n描述符（handle）：操作系统提供的资源，识别 socket等。 同步事件多路分离器。开启事件循环，等待事件的发生。封装了 多路复用函数 select/poll/epoll等。 事件处理器。提供回调函数，用于描述与应用程序相关的某个事件的操作。 具体的事件处理器。事件处理器接口的具体实现。使用描述符来识别事件和程序提供的服务。 Reactor 管理器。事件处理器的调度核心。分离每个事件，调度事件管理器，调用具体的函数处理某个事件。 补充资料 事件驱动及其设计模式\n从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个事件处理器组成。\n事件循环器的实现\n事件循环器不断接受来自客户端（Client）的请求，事件循环器把请求转交给注册了某类事件的工作线程（Worker）处理。\n根据实现的方式不同，在网络编程中基于事件驱动主要有两种设计模式：Reactor和Proactor。\nReactor模式框架\n使用Reactor模型，必备的几个组件：事件源、Reactor框架、事件多路复用机制和事件处理程序，先来看看Reactor模型的整体框架，接下来再对每个组件做逐一说明。\n1）事件源：Linux上是文件描述符，Windows上就是Socket或者Handle了，这里统一称为“句柄集”；程序在指定的句柄上注册关心的事件，比如I/O事件。\n2）事件多路复用机制：由操作系统提供的I/O多路复用机制，比如select和epoll。程序首先将其关心的句柄（事件源）及其事件注册到多路复用机制上。当有事件到达时，事件多路复用机制会发出通知“在已经注册的句柄集中，一个或多个句柄的事件已经就绪”。程序收到通知后，就可以在非阻塞的情况下对事件进行处理了。\n3） Reactor。是事件管理的接口，内部使用事件多路复用机制注册、注销事件；并运行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。\n4）事件处理程序。事件处理程序提供了一组接口，每个接口对应了一种类型的事件，供Reactor在相应的事件发生时调用，执行相应的事件处理。通常它会绑定一个有效的句柄。\n使用Reactor模式后，事件控制流是什么样子呢？可以参见下面的序列图。\n我们分别以读操作和写操作为例来看看Reactor中的具体步骤：\n应用程序注册读就绪事件和相关联的事件处理器；\n事件分离器等待事件的发生；\n当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器；\n事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理。\n写入操作类似于读取操作，只不过第一步注册的是写就绪事件。\nProactor\n我们来看看Proactor模式中读取操作和写入操作的过程：\n应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。\n事件分离器等待读取操作完成事件。\n在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作（异步I/O都是操作系统负责将数据读写到应用传递进来的缓冲区供应用程序操作），并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点。\n事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。\nProactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。\n从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是由谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的I/O设备。\nepoll代码实践 参见rust-epoll-example。\nReactor代码实践 参见rust-reactore-executor-example。\nMiniMio代码实践 epoll只支持在Linux系统下使用，而minimio实现了跨平台。\n会将各个平台的命令拿出来。比如Selector做了抽象，每个平台实际上不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #[cfg(target_os = \u0026#34;windows\u0026#34;)] mod windows; #[cfg(target_os = \u0026#34;windows\u0026#34;)] pub use windows::{Event, Registrator, Selector, TcpStream}; #[cfg(target_os = \u0026#34;macos\u0026#34;)] mod macos; #[cfg(target_os = \u0026#34;macos\u0026#34;)] pub use macos::{Event, Registrator, Selector, TcpStream}; #[cfg(target_os = \u0026#34;linux\u0026#34;)] mod linux; #[cfg(target_os = \u0026#34;linux\u0026#34;)] pub use linux::{Event, Registrator, Selector, TcpStream}; 在lib.rs中抽象出跨平台的结构Poll。代表事件队列。\n1 2 3 4 5 #[derive(Debug)] pub struct Poll { registry: Registry, is_poll_dead: Arc\u0026lt;AtomicBool\u0026gt;, } Poll有一个轮询方法poll。在实际调用时已经实现了跨平台。\n1 2 3 pub fn poll(\u0026amp;mut self, events: \u0026amp;mut Events, timeout_ms: Option\u0026lt;i32\u0026gt;) -\u0026gt; io::Result\u0026lt;usize\u0026gt;{ // ... } Mio代码实践 生产环境中的多路复用跨平台代码mio。\n其中抽象出了Poll结构体。\n1 2 3 pub struct Poll { registry: Registry, } 这里用到了设计模式——外观模式，外观模式相关知识见这里。\n外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。\n这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。\n异步编程模型概要 让我们先从建立异步编程模型的整体概念框架开始，先不深入细节。\nRust 提供的异步并发相比于其他语言有什么特点？\nRust 语言只是提供一个零成本的异步编程抽象，而不内置运行时。 基于 Generator 实现的 Future，在 Future 基础上 提供 async/await 语法糖。本质是一个状态机。 查看 README 和其他编程语言比较的图示。\n为什么需要异步？\n对极致性能的追求。 对编程体验的追求。 异步编程模型发展阶段：\nCallback Promise/Future async/await 可在项目 README 查看回调地狱示例图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 A +------+ | | | | | +-------------------+ | | | | | | | | Bv +------+ +-----+ | | | | | | | do1 | | | | | | | +-----+ | | | | | | | do2 | | | +-+---+ | | | | | | | A | | +------+ | | | | | | | | | | | | \u0026lt;----------------+ | | | | | | +------+ 早期 Rust 异步写法示意：\n1 2 3 4 5 6 7 let future = id_rpc(\u0026amp;my_server).and_then(|id| { get_row(id) }).map(|row| { json::encode(row) }).and_then(|encoded| { write_string(my_socket, encoded) }); 这样写会存在大量内嵌 Future，开发体验不好。\n引入 async/await 之后：\n1 2 3 4 let id = id_rpc(\u0026amp;my_server).await; let row = get_row(id).await; let encoded = json::encode(row); write_string(my_socket, encoded).await; 拥有了和同步代码一致的体验。\n异步任务可看作是一种绿色线程\n查看 README 相关图示\n可以说，异步任务的行为是模仿 线程 来抽象。\n线程在进程内，异步任务在线程内。 线程可被调度切换（Linux默认抢占式），异步任务也可以被调度（协作式而非抢占式）。区别在于，异步任务只在用户态，没有线程的上下文切换开销。 线程有上下文信息，异步任务也有上下文信息。 线程间可以通信，异步任务之间也可以通信。 线程间有竞争，异步任务之间也有竞争。 整个异步编程概念，包括异步语法、异步运行时都是围绕如何建立这种「绿色线程」抽象而成的。\n什么是绿色线程？\n在计算机程序设计中，绿色线程是一种由运行环境或虚拟机调度，而不是由本地底层操作系统调度的线程。绿色线程并不依赖底层的系统功能，模拟实现了多线程的运行，这种线程的管理调配发生在用户空间而不是内核空间，所以它们可以在没有原生线程支持的环境中工作。\nFuture和Futures-rs介绍 Future：提供了异步计算。\nFuture trait：\n1 2 3 4 5 pub trait Future { type Output; fn poll(self: Pin\u0026lt;\u0026amp;mut Self\u0026gt;, cx: \u0026amp;mut Context\u0026lt;\u0026#39;_\u0026gt;) -\u0026gt; Poll\u0026lt;Self::Output\u0026gt;; } 其中poll方法很重要，尝试去将future得到一个最终的值。如果最终的值没有准备好，也不会进行阻塞。\ntask：可以理解为创建绿色线程。\n其中重要的是Enum std::task::Poll\n1 2 3 4 pub enum Poll\u0026lt;T\u0026gt; { Ready(T), Pending, } futures-rs：对future做了扩展。\n编写异步echo服务 什么是文件描述符？\n文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。\n文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。\n代码见async-echo-server。\n流程图：\n先看看文件的结构：\nmain epoll tcp_listener executor reactor util tcp_listener:\n这里主要是几个异步计算的实现，也就是AccpectFuture、ReadFuture、WriteFuture。\nepoll：Linux下epoll的封装。\n主要就是调用系统调用，重要的是epoll的三个方法epoll_create、epoll_ctl、epoll_wait。\nexecutor：执行器，怎样调度这些绿色线程，如何执行任务。\nreactor：添加事件，检测到事件后唤醒事件，让执行器去执行。\n深入理解异步Task模型 回顾 Rust 异步 task 模型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 +------------------------------------------------------------------+ | | | +--------------------------------------------------------+ | | | | | | | +-------------------------------------------------+ | | | | |-------------+ +----------+ +--------------+ | | | | | || futureobj | | futureobj| | futureobj | | | | | | +-------------+ +----------+ +--------------+ | | | | | | 协 程 task | | | | | +-------------------------------------------------+ | | | | | | | | 线 程 | | | +--------------------------------------------------------+ | | | | | | +--------------------------------------------------------+ | | | +--------------------------------------------------+ | | | | | | | | | | | +------------+ +-------------------------------+ | | | | | | futureobj | | futureobj || futureobj || | | | | | +------------+ +-------------------------------+ | | | | | 协 程 task | | | | | +--------------------------------------------------+ | | | | 线 程 | | | +--------------------------------------------------------+ | | | | 进 程 | +------------------------------------------------------------------+ 什么是协程？\n协程（英语：coroutine）是计算机程序的一类组件，推广了协作式多任务的子例程，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道。\n同线程的比较\n协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务的。这意味着协程提供并发性而非并行性。协程超过线程的好处是它们可以用于硬性实时的语境（在协程之间的切换不需要涉及任何系统调用或任何阻塞调用），这里不需要用来守卫关键区段的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。有可能以一种对调用代码透明的方式，使用抢占式调度的线程实现协程，但是会失去某些利益（特别是对硬性实时操作的适合性和相对廉价的相互之间切换）。\n线程是协作式多任务的轻量级线程，本质上描述了同协程一样的概念。其区别，如果一定要说有的话，是协程是语言层级的构造，可看作一种形式的控制流，而线程是系统层级的构造，可看作恰巧没有并行运行的线程。这两个概念谁有优先权是争议性的：线程可看作为协程的一种实现[6]，也可看作实现协程的基底[7]。\n理解 leaf-futures vs Non-leaf-futures (async/await) 叶子futures：像代码示例中的AccpectFuture、ReadFuture、WriteFuture，要和Reactor打交道，比较底层。 非叶子futures：用async或者await实现，业务层面的。 理解 Waker： 当事件源注册该Future将在某个事件上等待时，它必须存储唤醒程序，以便以后可以调用唤醒来开始唤醒阶段。 为了引入并发性，能够同时等待多个事件非常重要，因此唤醒器不可能由单个事件源唯一拥有。 结果，Waker类型需要是实现 Clone 的。\nStruct std::task::Waker\n1 2 3 4 5 #[repr(transparent)] #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] pub struct Waker { waker: RawWaker, } Waker 可以唤醒一个任务，通过通知执行器。\nWaker实现了一些trait。\n1 2 3 4 5 6 #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] impl Unpin for Waker {} #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] unsafe impl Send for Waker {} #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] unsafe impl Sync for Waker {} 1 2 3 4 5 6 7 8 9 10 11 12 #[derive(PartialEq, Debug)] #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] pub struct RawWaker { /// A data pointer, which can be used to store arbitrary data as required /// by the executor. This could be e.g. a type-erased pointer to an `Arc` /// that is associated with the task. /// The value of this field gets passed to all functions that are part of /// the vtable as the first parameter. data: *const (), /// Virtual function pointer table that customizes the behavior of this waker. vtable: \u0026amp;\u0026#39;static RawWakerVTable, } 这里Rawwaker有两个内容，一个data可以保存上下文，一个vtable是虚表。\n理解并发（waker 并发 和 poll 并发） 深入 Futures-rs:\nFuture and task futures-rs futures-lite async-await语法背后 历史 处理异步事件的三种方式：\nCallback Promise/Future async/await async/await 是目前体验最好的方式，Rust 要支持它并不容易。\nasync/await 语法介绍 参考：Asynchronous Programming in Rust\nasync 两种用法：async fn 函数 和 async {} 块。\n1 2 3 4 5 6 7 8 9 10 11 // async 函数，真正会返回 `Future\u0026lt;Output = u8\u0026gt;`，而不是表面看上去的 `u8` async fn foo() -\u0026gt; u8 { 5 } // async 块用法，返回 `impl Future\u0026lt;Output = u8\u0026gt;` fn bar() -\u0026gt; impl Future\u0026lt;Output = u8\u0026gt; { // 这里 `async` 块返回 `impl Future\u0026lt;Output = u8\u0026gt;` async { let x: u8 = foo().await; x + 5 } } await 将暂停当前函数的执行，直到执行者将 Future 结束为止。这为其他 Future 任务提供了计算的机会。\n生成器 Future 底层实现依赖于 生成器。 async/await 对应底层生成器 resume/yield 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #![feature(generators, generator_trait)] use std::ops::Generator; use std::pin::Pin; fn main() { let mut gen = || { yield 1; yield 2; yield 3; return 4; }; // for _ in 0..4 { // // 为了给嵌入式支持异步，多传入了一个空的unit给resume方法 // let c = Pin::new(\u0026amp;mut gen).resume(()); // println!(\u0026#34;{:?}\u0026#34;, c); // } let c = Pin::new(\u0026amp;mut gen).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); let c = Pin::new(\u0026amp;mut gen).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); let c = Pin::new(\u0026amp;mut gen).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); let c = Pin::new(\u0026amp;mut gen).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); } 生成等价代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #![allow(unused)] #![feature(generators, generator_trait)] use std::ops::{Generator, GeneratorState}; use std::pin::Pin; enum __Gen { // (0) 初始状态 Start, // (1) resume方法执行以后 State1(State1), // (2) resume方法执行以后 State2(State2), // (3) resume方法执行以后 State3(State3), // (4) resume方法执行以后，正好完成 Done } struct State1 { x: u64 } struct State2 { x: u64 } struct State3 { x: u64 } impl Generator for __Gen { type Yield = u64; type Return = u64; fn resume(self: Pin\u0026lt;\u0026amp;mut Self\u0026gt;, _: ()) -\u0026gt; GeneratorState\u0026lt;u64, u64\u0026gt; { let mut_ref = self.get_mut(); match std::mem::replace(mut_ref, __Gen::Done) { __Gen::Start =\u0026gt; { *mut_ref = __Gen::State1(State1{x: 1}); GeneratorState::Yielded(1) } __Gen::State1(State1{x: 1}) =\u0026gt; { *mut_ref = __Gen::State2(State2{x: 2}); GeneratorState::Yielded(2) } __Gen::State2(State2{x: 2}) =\u0026gt; { *mut_ref = __Gen::State3(State3{x: 3}); GeneratorState::Yielded(3) } __Gen::State3(State3{x: 3}) =\u0026gt; { *mut_ref = __Gen::Done; GeneratorState::Complete(4) } _ =\u0026gt; { panic!(\u0026#34;generator resumed after completion\u0026#34;) } } } } fn main(){ let mut gen = { __Gen::Start }; for _ in 0..4 { println!(\u0026#34;{:?}\u0026#34;, unsafe{ Pin::new(\u0026amp;mut gen).resume(())}); } } 生成器基本用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #![allow(unused)] #![feature(generators, generator_trait)] use std::pin::Pin; use std::ops::Generator; pub fn up_to(limit: u64) -\u0026gt; impl Generator\u0026lt;Yield = u64, Return = u64\u0026gt; { move || { for x in 0..limit { yield x; } return limit; } } fn main(){ let a = 10; let mut b = up_to(a); unsafe { for _ in 0..=10{ let c = Pin::new(\u0026amp;mut b).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); } } } 生成器变身为迭代器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #![allow(unused)] #![feature(generators, generator_trait)] use std::pin::Pin; use std::ops::{Generator, GeneratorState}; pub fn up_to() -\u0026gt; impl Generator\u0026lt;Yield = u64, Return = ()\u0026gt; { move || { let mut x = 0; loop { x += 1; yield x; } return (); } } fn main(){ let mut gen = up_to(); unsafe { for _ in 0..10{ match Pin::new(\u0026amp;mut gen).resume(()) { GeneratorState::Yielded(i) =\u0026gt; println!(\u0026#34;{:?}\u0026#34;, i), _ =\u0026gt; println!(\u0026#34;Completed\u0026#34;), } } } } 生成器变身为 Future:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #![allow(unused)] #![feature(generators, generator_trait)] use std::ops::{Generator, GeneratorState}; use std::pin::Pin; pub fn up_to(limit: u64) -\u0026gt; impl Generator\u0026lt;Yield = (), Return = Result\u0026lt;u64, ()\u0026gt;\u0026gt; { move || { for x in 0..limit { yield (); } return Ok(limit); } } fn main(){ let limit = 2; let mut gen = up_to(limit); unsafe { for i in 0..=limit{ match Pin::new(\u0026amp;mut gen).resume(()) { GeneratorState::Yielded(v) =\u0026gt; println!(\u0026#34;resume {:?} : Pending\u0026#34;, i), GeneratorState::Complete(v) =\u0026gt; println!(\u0026#34;resume {:?} : Ready\u0026#34;, i), } } } } 在标准库Future内部，可以从Generator转换为Future。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #[lang = \u0026#34;from_generator\u0026#34;] #[doc(hidden)] #[unstable(feature = \u0026#34;gen_future\u0026#34;, issue = \u0026#34;50547\u0026#34;)] #[rustc_const_unstable(feature = \u0026#34;gen_future\u0026#34;, issue = \u0026#34;50547\u0026#34;)] #[inline] pub const fn from_generator\u0026lt;T\u0026gt;(gen: T) -\u0026gt; impl Future\u0026lt;Output = T::Return\u0026gt; where T: Generator\u0026lt;ResumeTy, Yield = ()\u0026gt;, { #[rustc_diagnostic_item = \u0026#34;gen_future\u0026#34;] struct GenFuture\u0026lt;T: Generator\u0026lt;ResumeTy, Yield = ()\u0026gt;\u0026gt;(T); // We rely on the fact that async/await futures are immovable in order to create // self-referential borrows in the underlying generator. impl\u0026lt;T: Generator\u0026lt;ResumeTy, Yield = ()\u0026gt;\u0026gt; !Unpin for GenFuture\u0026lt;T\u0026gt; {} impl\u0026lt;T: Generator\u0026lt;ResumeTy, Yield = ()\u0026gt;\u0026gt; Future for GenFuture\u0026lt;T\u0026gt; { type Output = T::Return; fn poll(self: Pin\u0026lt;\u0026amp;mut Self\u0026gt;, cx: \u0026amp;mut Context\u0026lt;\u0026#39;_\u0026gt;) -\u0026gt; Poll\u0026lt;Self::Output\u0026gt; { // SAFETY: Safe because we\u0026#39;re !Unpin + !Drop, and this is just a field projection. let gen = unsafe { Pin::map_unchecked_mut(self, |s| \u0026amp;mut s.0) }; // Resume the generator, turning the `\u0026amp;mut Context` into a `NonNull` raw pointer. The // `.await` lowering will safely cast that back to a `\u0026amp;mut Context`. match gen.resume(ResumeTy(NonNull::from(cx).cast::\u0026lt;Context\u0026lt;\u0026#39;static\u0026gt;\u0026gt;())) { GeneratorState::Yielded(()) =\u0026gt; Poll::Pending, GeneratorState::Complete(x) =\u0026gt; Poll::Ready(x), } } } GenFuture(gen) } no-std异步生态介绍 futures-micro 对futures的最小的实现 embassy 嵌入式生态 executor for no-std no-std的执行器，可以用在嵌入式及WebAssembly上 一个异步缓存代码实现 代码见retainer。\n下面分析下代码结构，首先是 entry.rs。\n缓存的entry结构：\n1 2 3 4 5 #[derive(Debug)] pub struct CacheEntry\u0026lt;V\u0026gt; { pub(crate) value: V, pub(crate) expiration: Option\u0026lt;CacheExpiration\u0026gt;, } 有相应的值value以及过期时间expiration，这里过期时间是一个Option，因为有的可以没有过期时间。\nCacheExpiration：\n1 2 3 4 #[derive(Debug)] pub struct CacheExpiration { instant: Instant, } 代表缓存中的过期时间，这里对Instant有一个包装，方便实现一些方法。\n1 2 3 4 5 #[derive(Debug)] pub struct CacheEntryReadGuard\u0026lt;\u0026#39;a, V\u0026gt; { pub(crate) entry: *const CacheEntry\u0026lt;V\u0026gt;, pub(crate) marker: PhantomData\u0026lt;\u0026amp;\u0026#39;a CacheEntry\u0026lt;V\u0026gt;\u0026gt;, } 对底层缓存结构的引用的一个读保护。当使用锁的时候，这个结构可以返回一个指向内部缓存 entries 的引用，也就是一个指针。同时CacheEntryReadGuard实现了Send和Sync。\n1 2 3 // Stores a raw pointer to `T`, so if `T` is `Sync`, the lock guard over `T` is `Send`. unsafe impl\u0026lt;V\u0026gt; Send for CacheEntryReadGuard\u0026lt;\u0026#39;_, V\u0026gt; where V: Sized + Sync {} unsafe impl\u0026lt;V\u0026gt; Sync for CacheEntryReadGuard\u0026lt;\u0026#39;_, V\u0026gt; where V: Sized + Send + Sync {} cache.rs\n缓存结构：\n1 2 3 4 pub struct Cache\u0026lt;K, V\u0026gt; { store: RwLock\u0026lt;BTreeMap\u0026lt;K, CacheEntry\u0026lt;V\u0026gt;\u0026gt;\u0026gt;, label: String, } 监控是否有过期缓存：\n1 2 3 4 5 6 7 pub async fn monitor(\u0026amp;self, sample: usize, threshold: f64, frequency: Duration) { let mut interval = Interval::platform_new(frequency); loop { interval.as_mut().await; self.purge(sample, threshold).await; } } 可以看到 purge 函数最终实现异步清理。\n这里说下Redis的缓存过期处理方式：\n惰性删除。当查找一个key，过期时删除。 定期删除。每隔一段时间，随机取一定数量的key，看看缓存中是否存在，如果到达一定的阈值比如20%已经过期了，则进行删除，如果没有到达该阈值，则不删除。 关于Redis缓存，参见Redis缓存总结：淘汰机制、缓存雪崩、数据不一致\u0026hellip;.。\n异步运行时生态 tokio 和rust异步标准有些差异，成熟 async-std 让开发者顺利编写异步，对标准库的异步 smol 轻量级，比较通用 glommio 生产级应用 bastion 高可用分布式容错框架 smol运行时 先看看smol中的Cargo.toml。\n1 2 3 4 5 6 7 8 9 10 11 [dependencies] async-channel = \u0026#34;1.4.2\u0026#34; async-executor = \u0026#34;1.3.0\u0026#34; async-fs = \u0026#34;1.3.0\u0026#34; async-io = \u0026#34;1.1.2\u0026#34; async-lock = \u0026#34;2.3.0\u0026#34; async-net = \u0026#34;1.4.3\u0026#34; async-process = \u0026#34;1.0.0\u0026#34; blocking = \u0026#34;1.0.0\u0026#34; futures-lite = \u0026#34;1.11.0\u0026#34; once_cell = \u0026#34;1.4.1\u0026#34; smol对这些组件做了一个整合，这些组件也可以单独使用。\nsmol文档 Modules\nName Description channel An async multi-producer multi-consumer channel. fs Async filesystem primitives. future Combinators for the Future trait. io Tools and combinators for I/O. lock Async synchronization primitives. net Async networking primitives for TCP/UDP/Unix communication. prelude Traits Future, Stream, AsyncRead, AsyncWrite, AsyncBufRead, AsyncSeek, and their extensions. process Async interface for working with processes. stream Combinators for the Stream trait. Structs\nName Description Async Async adapter for I/O types. 异步适配器，可以将阻塞IO变为非阻塞IO。 Executor An async executor. 异步执行器。 LocalExecutor A thread-local executor. 单线程执行器。 Task A spawned task. 任务。 Timer A future that expires at a point in time. Unblock Runs blocking I/O on a thread pool. smol源码 src/spawn.rs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 use once_cell::sync::Lazy; /// 将异步任务加入到 task 中，交给 Global 执行器 pub fn spawn\u0026lt;T: Send + \u0026#39;static\u0026gt;(future: impl Future\u0026lt;Output = T\u0026gt; + Send + \u0026#39;static) -\u0026gt; Task\u0026lt;T\u0026gt; { static GLOBAL: Lazy\u0026lt;Executor\u0026lt;\u0026#39;_\u0026gt;\u0026gt; = Lazy::new(|| { let num_threads = { // Parse SMOL_THREADS or default to 1. std::env::var(\u0026#34;SMOL_THREADS\u0026#34;) .ok() .and_then(|s| s.parse().ok()) .unwrap_or(1) }; for n in 1..=num_threads { thread::Builder::new() .name(format!(\u0026#34;smol-{}\u0026#34;, n)) .spawn(|| loop { // catch_unwind 方法 // 可以捕获栈展开，运行panic线程存活并继续运行。使用标准库中的std::panic::catch_unwind()函数。 catch_unwind(|| block_on(GLOBAL.run(future::pending::\u0026lt;()\u0026gt;()))).ok(); }) .expect(\u0026#34;cannot spawn executor thread\u0026#34;); } Executor::new() }); GLOBAL.spawn(future) } 聊天框例子 chat-server 聊天框服务器的事件：\n1 2 3 4 5 6 7 8 9 10 11 /// An event on the chat server. enum Event { /// A client has joined. Join(SocketAddr, Arc\u0026lt;Async\u0026lt;TcpStream\u0026gt;\u0026gt;), /// A client has left. Leave(SocketAddr), /// A client sent a message. Message(SocketAddr, String), } 向客户端分发事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /// Dispatches events to clients. async fn dispatch(receiver: Receiver\u0026lt;Event\u0026gt;) -\u0026gt; io::Result\u0026lt;()\u0026gt; { // Currently active clients. let mut map = HashMap::\u0026lt;SocketAddr, Arc\u0026lt;Async\u0026lt;TcpStream\u0026gt;\u0026gt;\u0026gt;::new(); // Receive incoming events. while let Ok(event) = receiver.recv().await { // Process the event and format a message to send to clients. let output = match event { Event::Join(addr, stream) =\u0026gt; { map.insert(addr, stream); format!(\u0026#34;{} has joined\\n\u0026#34;, addr) } Event::Leave(addr) =\u0026gt; { map.remove(\u0026amp;addr); format!(\u0026#34;{} has left\\n\u0026#34;, addr) } Event::Message(addr, msg) =\u0026gt; format!(\u0026#34;{} says: {}\\n\u0026#34;, addr, msg), }; // Display the event in the server process. print!(\u0026#34;{}\u0026#34;, output); // Send the event to all active clients. for stream in map.values_mut() { // Ignore errors because the client might disconnect at any point. stream.write_all(output.as_bytes()).await.ok(); } } Ok(()) } 服务端 main 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 fn main() -\u0026gt; io::Result\u0026lt;()\u0026gt; { smol::block_on(async { // Create a listener for incoming client connections. let listener = Async::\u0026lt;TcpListener\u0026gt;::bind(([127, 0, 0, 1], 6000))?; // Intro messages. println!(\u0026#34;Listening on {}\u0026#34;, listener.get_ref().local_addr()?); println!(\u0026#34;Start a chat client now!\\n\u0026#34;); // Spawn a background task that dispatches events to clients. // 通过 channel 实现消息传递 let (sender, receiver) = bounded(100); // detach 函数 // 分离任务，让它在后台运行 smol::spawn(dispatch(receiver)).detach(); loop { // Accept the next connection. let (stream, addr) = listener.accept().await?; let client = Arc::new(stream); let sender = sender.clone(); // Spawn a background task reading messages from the client. smol::spawn(async move { // Client starts with a `Join` event. sender.send(Event::Join(addr, client.clone())).await.ok(); // Read messages from the client and ignore I/O errors when the client quits. read_messages(sender.clone(), client).await.ok(); // Client ends with a `Leave` event. sender.send(Event::Leave(addr)).await.ok(); }) .detach(); } }) } chat-client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn main() -\u0026gt; io::Result\u0026lt;()\u0026gt; { smol::block_on(async { // Connect to the server and create async stdin and stdout. let stream = Async::\u0026lt;TcpStream\u0026gt;::connect(([127, 0, 0, 1], 6000)).await?; let stdin = Unblock::new(std::io::stdin()); let mut stdout = Unblock::new(std::io::stdout()); // Intro messages. println!(\u0026#34;Connected to {}\u0026#34;, stream.get_ref().peer_addr()?); println!(\u0026#34;My nickname: {}\u0026#34;, stream.get_ref().local_addr()?); println!(\u0026#34;Type a message and hit enter!\\n\u0026#34;); let reader = \u0026amp;stream; let mut writer = \u0026amp;stream; // Wait until the standard input is closed or the connection is closed. future::race( async { let res = io::copy(stdin, \u0026amp;mut writer).await; println!(\u0026#34;Quit!\u0026#34;); res }, async { let res = io::copy(reader, \u0026amp;mut stdout).await; println!(\u0026#34;Server disconnected!\u0026#34;); res }, ) .await?; Ok(()) }) } futures_lite 文档：futures_lite，futures库的轻量版。\nModules\nName Description future Combinators for the Future trait. io Tools and combinators for I/O. prelude Traits Future, Stream, AsyncRead, AsyncWrite, AsyncBufRead, AsyncSeek, and their extensions. stream Combinators for the Stream trait. 主要就是上述四个模块。\nasync_io 文档：async_io\n在async_io/lib.rs中定义了两个结构体，一个是Timer，另一个是Async。\nTimer: 在某个时间点到期的 Future。 Async: 在异步编程中在标准网络类型（还有许多其他类型的）中使用的一个适配器。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #[derive(Debug)] pub struct Timer { /// This timer\u0026#39;s ID and last waker that polled it. /// /// When this field is set to `None`, this timer is not registered in the reactor. id_and_waker: Option\u0026lt;(usize, Waker)\u0026gt;, /// The next instant at which this timer fires. when: Instant, /// The period. period: Duration, } #[derive(Debug)] pub struct Async\u0026lt;T\u0026gt; { /// A source registered in the reactor. source: Arc\u0026lt;Source\u0026gt;, /// The inner I/O handle. io: Option\u0026lt;T\u0026gt;, } 这里用到了polling crate。这个库实现了跨平台的poll，提供了很多接口。\nPortable interface to epoll, kqueue, event ports, and wepoll. Supported platforms:\nepoll : Linux, Android kqueue : macOS, iOS, FreeBSD, NetBSD, OpenBSD, DragonFly BSD event ports : illumos, Solaris poll : VxWorks, Fuchsia, other Unix systems wepoll : Windows 下面看看 async_io/reactor.rs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 pub(crate) struct Reactor { /// Portable bindings to epoll/kqueue/event ports/wepoll. /// /// This is where I/O is polled, producing I/O events. poller: Poller, /// Ticker bumped before polling. /// /// This is useful for checking what is the current \u0026#34;round\u0026#34; of `ReactorLock::react()` when /// synchronizing things in `Source::readable()` and `Source::writable()`. Both of those /// methods must make sure they don\u0026#39;t receive stale I/O events - they only accept events from a /// fresh \u0026#34;round\u0026#34; of `ReactorLock::react()`. ticker: AtomicUsize, /// Registered sources. sources: Mutex\u0026lt;Slab\u0026lt;Arc\u0026lt;Source\u0026gt;\u0026gt;\u0026gt;, /// Temporary storage for I/O events when polling the reactor. /// /// Holding a lock on this event list implies the exclusive right to poll I/O. events: Mutex\u0026lt;Vec\u0026lt;Event\u0026gt;\u0026gt;, /// An ordered map of registered timers. /// /// Timers are in the order in which they fire. The `usize` in this type is a timer ID used to /// distinguish timers that fire at the same time. The `Waker` represents the task awaiting the /// timer. timers: Mutex\u0026lt;BTreeMap\u0026lt;(Instant, usize), Waker\u0026gt;\u0026gt;, /// A queue of timer operations (insert and remove). /// /// When inserting or removing a timer, we don\u0026#39;t process it immediately - we just push it into /// this queue. Timers actually get processed when the queue fills up or the reactor is polled. timer_ops: ConcurrentQueue\u0026lt;TimerOp\u0026gt;, } 还有 async_io/driver.rs，其中有main_loop函数，对async_io线程进行主要的循环，另外还有block_on函数，在有异步任务时阻塞当前的线程，在空闲的时候处理IO事件。\nasync_task 文档： async_task\nTask abstraction for building executors.\nTo spawn a future onto an executor, we first need to allocate it on the heap and keep some state attached to it. The state indicates whether the future is ready for polling, waiting to be woken up, or completed. Such a stateful future is called a task.\nAll executors have a queue that holds scheduled tasks:\n1 let (sender, receiver) = flume::unbounded(); 这里用到了第三方库flume。它比 crossbeam-channel 更加轻量，实现了mpmc。\n接着来看 async_task 的函数：\nspawn\t创建一个新任务。 spawn_local 创建一个新的本地任务。 spawn_unchecked⚠\tCreates a new task without Send, Sync, and \u0026lsquo;static bounds. async_task 的结构：\nFallibleTask:\tA spawned task with a fallible response. Runnable:\tA handle to a runnable task. Task:\tA spawned task. 在 async_task/raw.rs 中定义了底层的TaskVTable、TaskLayout、RawTask。\n在 async_task/header.rs 中定义了结构体Header。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 pub(crate) struct Header { /// Current state of the task. /// /// Contains flags representing the current state and the reference count. pub(crate) state: AtomicUsize, /// The task that is blocked on the `Task` handle. /// /// This waker needs to be woken up once the task completes or is closed. pub(crate) awaiter: UnsafeCell\u0026lt;Option\u0026lt;Waker\u0026gt;\u0026gt;, /// The virtual table. /// /// In addition to the actual waker virtual table, it also contains pointers to several other /// methods necessary for bookkeeping the heap-allocated task. pub(crate) vtable: \u0026amp;\u0026#39;static TaskVTable, } 相当于做一些任务的处理，提供了notify、take、register三个函数。\n这里面任务的状态state是在state.rs中定义的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /// Set if the task is scheduled for running. pub(crate) const SCHEDULED: usize = 1 \u0026lt;\u0026lt; 0; /// Set if the task is running. pub(crate) const RUNNING: usize = 1 \u0026lt;\u0026lt; 1; /// Set if the task has been completed. pub(crate) const COMPLETED: usize = 1 \u0026lt;\u0026lt; 2; /// Set if the task is closed. pub(crate) const CLOSED: usize = 1 \u0026lt;\u0026lt; 3; /// Set if the `Task` still exists. pub(crate) const TASK: usize = 1 \u0026lt;\u0026lt; 4; /// Set if the `Task` is awaiting the output. pub(crate) const AWAITER: usize = 1 \u0026lt;\u0026lt; 5; /// Set if an awaiter is being registered. pub(crate) const REGISTERING: usize = 1 \u0026lt;\u0026lt; 6; /// Set if the awaiter is being notified. pub(crate) const NOTIFYING: usize = 1 \u0026lt;\u0026lt; 7; /// A single reference. pub(crate) const REFERENCE: usize = 1 \u0026lt;\u0026lt; 8; async_executor 异步执行器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 use async_executor::Executor; use futures_lite::future; // Create a new executor. let ex = Executor::new(); // Spawn a task. let task = ex.spawn(async { println!(\u0026#34;Hello world\u0026#34;); }); // Run the executor until the task completes. future::block_on(ex.run(task)); blocking 文档：blocking\n在异步程序里提供了一个线程池用于隔离阻塞的IO。\nunblock 函数：对阻塞的代码进行异步化。\nUnblock 类型：对阻塞的IO进行异步化。通过维护一个环形队列来进行处理。\nasync-fs 其中用到了 blocking 这个库。\nasync-std 文档：async_std，rust标准库的异步版本。\ntask的使用以及抽象出来的API接口类似线程，易于上手。\nasync_std 和 smol 运行时一些架构以及组件都是公用的，并且它提供了一个类似于线程的一个异步 task 的抽象，并且它还兼容 tokio。\ntokio github仓库地址：tokio\n官方网站：tokio.rs\n文档：tokio\n官方文档介绍：\nA runtime for writing reliable network applications without compromising speed.\nTokio is an event-driven, non-blocking I/O platform for writing asynchronous applications with the Rust programming language. At a high level, it provides a few major components:\nTools for working with asynchronous tasks, including synchronization primitives and channels and timeouts, sleeps, and intervals. APIs for performing asynchronous I/O, including TCP and UDP sockets, filesystem operations, and process and signal management. A runtime for executing asynchronous code, including a task scheduler, an I/O driver backed by the operating system’s event queue (epoll, kqueue, IOCP, etc…), and a high performance timer. Remark: loom 模块用来检测异步并发，也可以检测同步并发。\nmini-redis github仓库地址：mini-redis Redis教程\n#[tokio::main]宏，定义在tokio-macros/lib.rs中。\n1 2 3 4 #[tokio::main] async fn main() { println!(\u0026#34;Hello world\u0026#34;); } 宏展开之后为：\n1 2 3 4 5 6 7 8 9 fn main() { tokio::runtime::Builder::new_multi_thread() .enable_all() .build() .unwrap() .block_on(async { println!(\u0026#34;Hello world\u0026#34;); }) } 1 2 3 4 5 #[proc_macro_attribute] #[cfg(not(test))] // Work around for rust-lang/rust#62127 pub fn main(args: TokenStream, item: TokenStream) -\u0026gt; TokenStream { entry::main(args, item, true) } 在entry.rs中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #[cfg(not(test))] // Work around for rust-lang/rust#62127 pub(crate) fn main(args: TokenStream, item: TokenStream, rt_multi_thread: bool) -\u0026gt; TokenStream { // If any of the steps for this macro fail, we still want to expand to an item that is as close // to the expected output as possible. This helps out IDEs such that completions and other // related features keep working. let input: syn::ItemFn = match syn::parse(item.clone()) { Ok(it) =\u0026gt; it, Err(e) =\u0026gt; return token_stream_with_error(item, e), }; let config = if input.sig.ident == \u0026#34;main\u0026#34; \u0026amp;\u0026amp; !input.sig.inputs.is_empty() { let msg = \u0026#34;the main function cannot accept arguments\u0026#34;; Err(syn::Error::new_spanned(\u0026amp;input.sig.ident, msg)) } else { AttributeArgs::parse_terminated .parse(args) .and_then(|args| build_config(input.clone(), args, false, rt_multi_thread)) }; match config { Ok(config) =\u0026gt; parse_knobs(input, false, config), Err(e) =\u0026gt; token_stream_with_error(parse_knobs(input, false, DEFAULT_ERROR_CONFIG), e), } } 还有一个select宏，官方教程参见Select。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 use tokio::sync::oneshot; #[tokio::main] async fn main() { let (tx1, rx1) = oneshot::channel(); let (tx2, rx2) = oneshot::channel(); tokio::spawn(async { let _ = tx1.send(\u0026#34;one\u0026#34;); }); tokio::spawn(async { let _ = tx2.send(\u0026#34;two\u0026#34;); }); tokio::select! { val = rx1 =\u0026gt; { println!(\u0026#34;rx1 completed first with {:?}\u0026#34;, val); } val = rx2 =\u0026gt; { println!(\u0026#34;rx2 completed first with {:?}\u0026#34;, val); } } } tokio的运行时是通过Builder来创建的。tokio中分两种线程，core线程专门处理异步，blocking线程处理同步。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 pub struct Builder { /// Runtime type kind: Kind, /// Whether or not to enable the I/O driver enable_io: bool, /// Whether or not to enable the time driver enable_time: bool, /// Whether or not the clock should start paused. start_paused: bool, /// The number of worker threads, used by Runtime. /// /// Only used when not using the current-thread executor. worker_threads: Option\u0026lt;usize\u0026gt;, // core 线程 /// Cap on thread usage. max_blocking_threads: usize, // blocking线程最大数量 /// Name fn used for threads spawned by the runtime. pub(super) thread_name: ThreadNameFn, /// Stack size used for threads spawned by the runtime. pub(super) thread_stack_size: Option\u0026lt;usize\u0026gt;, /// Callback to run after each thread starts. pub(super) after_start: Option\u0026lt;Callback\u0026gt;, /// To run before each worker thread stops pub(super) before_stop: Option\u0026lt;Callback\u0026gt;, /// To run before each worker thread is parked. pub(super) before_park: Option\u0026lt;Callback\u0026gt;, /// To run after each thread is unparked. pub(super) after_unpark: Option\u0026lt;Callback\u0026gt;, /// Customizable keep alive timeout for BlockingPool pub(super) keep_alive: Option\u0026lt;Duration\u0026gt;, /// How many ticks before pulling a task from the global/remote queue? pub(super) global_queue_interval: u32, /// How many ticks before yielding to the driver for timer and I/O events? pub(super) event_interval: u32, #[cfg(tokio_unstable)] pub(super) unhandled_panic: UnhandledPanic, } tokio/park：\n有事件唤醒线程让它去spawn task，如果没有的话就等待 park。\ntokio中的任务队列tokio/src/runtime/thread_pool/worker.rs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /// A scheduler worker pub(super) struct Worker { /// Reference to shared state shared: Arc\u0026lt;Shared\u0026gt;, /// Index holding this worker\u0026#39;s remote state index: usize, /// Used to hand-off a worker\u0026#39;s core to another thread. core: AtomicCell\u0026lt;Core\u0026gt;, } /// Core data struct Core { /// Used to schedule bookkeeping tasks every so often. tick: u32, /// When a task is scheduled from a worker, it is stored in this slot. The /// worker will check this slot for a task **before** checking the run /// queue. This effectively results in the **last** scheduled task to be run /// next (LIFO). This is an optimization for message passing patterns and /// helps to reduce latency. lifo_slot: Option\u0026lt;Notified\u0026gt;, // 后进先出队列，做了优化 /// The worker-local run queue. run_queue: queue::Local\u0026lt;Arc\u0026lt;Shared\u0026gt;\u0026gt;, // 本地队列 /// True if the worker is currently searching for more work. Searching /// involves attempting to steal from other workers. is_searching: bool, /// True if the scheduler is being shutdown is_shutdown: bool, /// Parker /// /// Stored in an `Option` as the parker is added / removed to make the /// borrow checker happy. park: Option\u0026lt;Parker\u0026gt;, /// Batching metrics so they can be submitted to RuntimeMetrics. metrics: MetricsBatch, /// Fast random number generator. rand: FastRand, /// How many ticks before pulling a task from the global/remote queue? global_queue_interval: u32, /// How many ticks before yielding to the driver for timer and I/O events? event_interval: u32, } 提供了一个方法block_in_place，可以将当前线程变为阻塞线程。\n1 2 3 4 5 6 pub(crate) fn block_in_place\u0026lt;F, R\u0026gt;(f: F) -\u0026gt; R where F: FnOnce() -\u0026gt; R, { ... } 流处理 文档参考：tokio_util::codec。\nAdaptors from AsyncRead/AsyncWrite to Stream/Sink\nRaw I/O objects work with byte sequences, but higher-level code usually wants to batch these into meaningful chunks, called “frames”.\nThis module contains adapters to go from streams of bytes, AsyncRead and AsyncWrite, to framed streams implementing Sink and Stream. Framed streams are also known as transports.\ntokio-stream抽象了一种帧结果，也提供相应的适配器进行异步读写。如果想更好的进行异步读写，可以使用抽象的codec，也可以使用更底层的Sink/Stream进行处理。\ntonic：实现gRPC客户端和服务端，自己实现Stream，从而来进行异步读写。\nwrap：实现文件上传，也是通过自己实现Stream。\nredis-rs：redis library。这里用到了解析器组合子combine。\n扩展资料 Tokio Internals - 源码解析和设计分析 参考资料 张汉东的Rust实战课\n张汉东的Rust实战课视频课程代码示例\n","date":"2022-07-07T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/07/Rust-async/","title":"Rust异步编程"},{"content":"记录了学习《Programming Rust》笔记。\nChapter 3. Fundamental Types Rust有类型推断 函数可以是泛型的 Rust的类型\nType Description i8,i16,i32,i64,i128,u8,u16,u32,u64,u128 isize,usize f32,f64 bool char (char, u8, i32) 元组 () struct S { x: f32, y:f32 } 结构体 struct T (i32, char); Tuple-like struct struct E; Unit-like struct; has no fields enum Attend { OnTime, Late(u32) } Box\u0026lt;Attend\u0026gt; \u0026amp;i32,\u0026amp;mut i32 String \u0026amp;str [f64; 4], [u8; 256] Vec\u0026lt;f64\u0026gt; \u0026amp;[u8], \u0026amp;mut [u8] Option\u0026lt;\u0026amp;str\u0026gt; Result\u0026lt;u64, Error\u0026gt; \u0026amp;dyn Any, \u0026amp;mut dyn Read fn(\u0026amp;str) -\u0026gt; bool (Clousure types have no written form) Clousure Fixed-Width Numerical Types 如果需要任意精度表示的一些数值，可以查看 num 包。\nInteger Types 不像C和C++，Rust将字符看作是和数值不同的类型，一个 char 不是 u8，也不是 u32（尽管字符是32位长的）。\nRust要求数组的索引必须是 usize 类型的值。\n在Rust整数可以带一个后缀来表示它们的类型，比如42u8。如果没有给整数指定具体的类型，Rust会将值存放在一个特定的类型中，传给函数期望的参数，比较另一个有别的特定类型的值，最后，如果有多个可能，而 i32是其中一个的话，就默认是 i32类型，否则就会报错。\n前缀0x，0o和0b表示十六进制、八进制和二进制。\n为了更清楚地表示很长的数字，还可以给数字加下划线，比如4_294_967_295。有前缀和后缀的数字依然可以加下划线。\n尽管Rust中数字和字符是不同的类型，但是也提供了 字节字面量（ byte literals），即用类字符字面量表示u8值：b'X'代表的ASCII编码的字符X，它是一个u8值。比如，由于字符A的ASCII编码是65，因此b'A'等价于65u8。字节字面量中只能出现在ASCII编码的字符。\n特殊的ACSII编码的字符\nCharacter Byte literal 单引号 b'\\'' 反斜杠 b'\\\\' 换行 b'\\n' 回车 b'\\r' 制表符 b'\\t' 对于一些ASCII编码的字符可以用十六进制来表示，这样更容易阅读。比如b'\\x1b'。\n整数类型之间转换可以用 as 操作符。比如 10_i8 as u16。\n整数的一些方法，参见 std::i32。\n1 2 3 assert_eq!(2_u16.pow(4), 16); assert_eq!((-4_i32).abs(), 4); assert_eq!(0b101101_u8.count_ones(), 4); 看下面这段代码\n1 println!(\u0026#34;{}\u0026#34;, (-4).abs()); 这里没有给出数值的类型，是不是默认 i32 呢？但其实会报错：\n1 error: can\u0026#39;t call method `abs` on ambiguous numeric type `{integer}` 为什么会这样子呢？因为Rust想要在调用一个类型自己的方法之前明确地知道一个值的整数类型。i32 的默认值仅适用于在所有方法调用都已解决后类型仍然不明确的情况，在这里就太晚了，因此会报错。换句话说，就是这里我要先调用 abs()方法，这个时候需要确定类型，还没等推断出默认类型，就已经报错了。解决方案：\n1 2 println!(\u0026#34;{}\u0026#34;, (-4_i32).abs()); println!(\u0026#34;{}\u0026#34;, i32::abs(-4)); 注意方法调用会发生在一元前缀操作符之前，所以处理负数的时候要当心。比如-4_i32.abs()，这里没有括号，会先调用函数4_i32.abs()，然后再取负号，最终结果为-4。\nChecked, Wrapping, Saturating, and Overflowing Arithmetic 在Debug模式下，如果整数数值操作溢出，会报错。但是在发布模式构建的时候，会 wraps。\nIn a release build, the operation wraps around: it produces the value equivalent to the mathematically correct result modulo the range of the value. (In neither case is overflow undefined behavior, as it is in C and C++.)\n上述是默认的，如果这不是你想要的，可以调用一些方法，主要有四类。\nChecked operations return an Option of the result: Some(v) if the mathematically correct result can be represented as a value of that type, or None if it cannot. Wrapping operations return the value equivalent to the mathematically correct result modulo the range of the value. Saturating operations return the representable value that is closest to the mathematically correct result. In other words, the result is “clamped” to the maximum and minimum values the type can represent. Overflowing operations return a tuple (result, overflowed), where result is what the wrapping version of the function would return, and overflowed is a bool indicating whether an overflow occurred. Operation Name suffix Example Addition add 100_i8.checked_add(27) == Some(127) Subtraction sub 10_u8.checked_sub(11) == None Multiplication mul 128_u8.saturating_mul(3) == 255 Division div 64_u16.wrapping_div(8) == 8 Remainder rem (-32768_i16).wrapping_rem(-1) == 0 Negation neg (-128_i8).checked_neg() == None Absolute value abs (-32768_i16).wrapping_abs() == -32768 Exponentiation pow 3_u8.checked_pow(4) == Some(81) Bitwise left shift shl 10_u32.wrapping_shl(34) == 40 Bitwise right shift shr 40_u64.wrapping_shr(66) == 10 Floating-Point Types 整数部分后的分数部分，指数或者类型后缀至少包含一个，来区别于整数字面量。5.整数部分之后只有一个小数点，也是一个有效的浮点数常数。\n浮点数默认类型是 f64 。\n为了类型推断的目的，Rust中整数和浮点数之间不会进行相互推断。\nf32和f64都有一些特殊值，如 INFINITY，NEG_INFINITY，NAN（that not-a-number value），MIN和MAX。\nstd::f32和std::f64提供了很多方法。\nstd::f32::consts和std::f64::consts提供一些数学常量。\nRust是没有数值的隐式转换的，所以如果传入的参数类型和函数的参数类型不一致，这里不会发生隐式转换，因此会报错。想要转换只能显式地用 as 操作符。\nThe bool Type 在Rust中，bool类型的值为 true 和 false。\nRust中在要求一个Boolean值的上下文中是非常严格的。控制结构if和while要求条件必须是 bool 表达式， 短路逻辑操作符 \u0026amp;\u0026amp; 和 || 也要求必须是 bool 表达式。必须 if x!= 0 { ... }这样写，而不能简单地写为 if x { ... }。\nRust可以用 as 操作符将 bool 值转换为数字，但是不能反过来将数值转换为 bool 值。\n1 2 assert_eq!(false as i32, 0); assert_eq!(true as i32, 1); 虽然可以只有一位就表示 bool 值，但是Rust底层用一整个字节来存储 bool 值，这样的话就可以创建一个指针来指向它。\nCharacters char 类型表示单个Unicode字符，占 32 位。\n字符可以用十六进制来表示或者\\u{}来表示。\n如果字符编码在ASCII编码范围内，可以用十六进制。例如'\\xHH'。 也可以用\\u{}来表示任何的Unicode编码字符。例如'\\u{HHHHHH}'。 字符必须在有效的 Unicode 码点范围内。\nchar 和其他类型之间没有隐式地转换。当然可以显式用 as 操作符将 char 类型转换成一个整数类型，如果类型小于32位，会进行截断。相反地，只有 u8 类型能用 as 操作符显式地转换为 char 类型。这一点也很自然，Rust要保证可靠，其他数值类型转换成 char 类型时，可能是无效的字符。不过std::char::from_u32可以将任何 u32 类型的值转换，返回的是 Option\u0026lt;char\u0026gt;。\nchar(primitive type)文档有相关的方法。\nTuples 元组可以将不同类型的值组合在一起，可以用在返回多个不同类型的值的函数中。\n用 a.0可以来获取具体的元素。\n元组的索引必须是常数，不可以是变量，比如t[i]或者t.i就是错误的。\n可以用模式匹配得到元组对应的值。在指定变量值或者函数返回多个值时很有用。用元组来表示相关的变量是很清晰的，比如宽和高，可以用一个元组把它们放在一起，语义更加清晰。\nunit type ()可以用于函数的返回类型，表示什么也不返回。\n可以在元组的最后加上逗号，容易看出列表删除或添加了元素。如果是单个值，(\u0026quot;lonely hearts\u0026quot;,)相比 (\u0026quot;lonely hearts\u0026quot;)更加清晰，可以判断是元组而不是括号表达式。\nPointer Types References \u0026amp;x 产生了对 x 的一个引用，用Rust的术语来说是向 x 借了一个引用。\n在Rust中，引用始终不为空。Rust会跟踪值的所有权和生命周期，在编译时期会检查出悬垂指针，二次释放以及指针无效的错误。\n\u0026amp; T：不可变的共享引用 \u0026amp;mut T：可变的独占引用 将不可变引用和可变引用看作单个读-写者和多个读者。\nBoxes 用于堆分配的指针类型。\n1 2 let t = (12, \u0026#34;eggs\u0026#34;); let b = Box::new(t); // 在堆上分配内存，类型为 Box\u0026lt;(i32, \u0026amp;str)\u0026gt; Raw Pointers *const T *mut T 只能在 unsafe 块中对原始指针解引用。\nArrays, Vectors, and Slices 有三种类型表示内存中连续的一块数据。\n[T; N]表示数组。数组的长度必须要在编译时期就确定。 Vec\u0026lt;T\u0026gt; 表示 T 类型的向量。动态分配的，元素存放在堆上。 \u0026amp;[T]和\u0026amp;mut [T] 称为 T 的共享切片或可变切片。可以把切片看作是一个胖指针，指向第一个元素，同时还包含可以访问到的元素的个数。 一些方法：\nv.len() 返回元素的个数。 v[i] 表示 v 的第 i 个元素，注意这里索引 i 必须是 usize 类型的。Rust总是会去检查 i 有没有在有效的范围内。 Arrays 直接用方括号生成数组，或者[T; N]生成数组，Rust不提供未初始化的数组。\n数组的长度必须在编译时就确定，不可以用变量，比如[true; n] 这就是错误的。如果想在运行期间获得数组的长度，应该用向量。\n在调用一些数组的方法时，Rust会隐式地将一个数组的引用转换为切片，这样可以直接在一个数组上使用任何切片的方法。\n1 2 3 let mut chaos = [3, 5, 4, 1, 2]; chaos.sort(); // 这里隐式地转换为 \u0026amp;mut [i32]，调用了切片的 sort 方法 assert_eq!(chaos, [1, 2, 3, 4, 5]); 关于这一点，官方文档是这样说的。\n数组强制转换为 slices ([T]) ，因此可以在数组上调用 slice 方法。实际上，这提供了用于处理数组的大多数 API。 切片具有动态大小，并且不强制转换为数组。\nVectors 在堆上分配的容器。\n可以用 vec!或者Vec::new()来生成新的 vector。\n可以动态添加元素:\n1 2 let mut primes = vec![2, 3, 5, 7]; primes.push(11); 可以用重复表达式来创建 vector：\n1 2 3 fn new_pixel_buffer(rows: usize, cols: usize) -\u0026gt; Vec\u0026lt;u8\u0026gt; { vec![0; rows * cols] } 迭代器构造：\n1 2 let v: Vec\u0026lt;i32\u0026gt; = (0..5).collect(); // 这里必须指定 v 的类型，因为 collect 方法有很多种 assert_eq!(v, [0, 1, 2, 3, 4]); 和数组一样，向量也会在调用一些方法时隐式地转换为切片类型。\n一个 Vec\u0026lt;T\u0026gt; 包含三个值：指向元素的堆 buffer 的指针，这个是被 Vec\u0026lt;T\u0026gt; 所创建和拥有的； buffer 中的容量；包含元素的个数，也就是长度。\n知道向量的容量，可以用Vec::with_capacity来创建。提升效率，减少重新分配空间。\ncapacity方法返回向量不需要再分配时向量的容量。\n一些方法：\ninsert remove pop 可以用 for 在向量上进行迭代。\nSlices 切片，直接指向引用的数据，看作一个胖指针，指向第一个元素，以及包含 len。\nString Types String Literals 字符串字面量在双引号内。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 空格和换行照样输出 println!(\u0026#34;In the room the women come and go, Singing of Mount Abora\u0026#34;); // 去掉换行 println!(\u0026#34;It was a bright, cold day in April, and \\ there were four of us—\\ more or less.\u0026#34;) // raw strings let default_win_install_path = r\u0026#34;C:\\Program Files\\Gorillas\u0026#34;; let pattern = Regex::new(r\u0026#34;\\d+(\\.\\d+)*\u0026#34;); // 包含双引号 println!(r###\u0026#34; This raw string started with \u0026#39;r###\u0026#34;\u0026#39;. Therefore it does not end until we reach a quote mark (\u0026#39;\u0026#34;\u0026#39;) followed immediately by three pound signs (\u0026#39;###\u0026#39;): \u0026#34;###); Byte Strings 带有 b 前缀的是一个字节字面量。\n1 2 let method = b\u0026#34;GET\u0026#34;; // \u0026amp;[u8; 3] 类型 assert_eq!(method, \u0026amp;[b\u0026#39;G\u0026#39;, b\u0026#39;E\u0026#39;, b\u0026#39;T\u0026#39;]); Strings in Memory 内存中以UTF-8编码存储。\n1 2 3 let noodles = \u0026#34;noodles\u0026#34;.to_string(); // String 底层是 Vec\u0026lt;u8\u0026gt; let oodles = \u0026amp;noodles[1..]; // \u0026amp;str let poodles = \u0026#34;ಠ_ಠ\u0026#34;; // \u0026amp;str 内存布局：\nString \u0026amp;str像\u0026amp;[T]，而 String像Vec\u0026lt;T\u0026gt;。\n创建 String:\n1 2 3 4 5 6 7 8 9 10 11 // to_string 方法 let error_message = \u0026#34;too many pets\u0026#34;.to_string(); // format! assert_eq!(format!(\u0026#34;{}°{:02}′{:02}′′N\u0026#34;, 24, 5, 23), \u0026#34;24°05′23′′N\u0026#34;.to_string()); // 数组、向量的 concat、join 方法 let bits = vec![\u0026#34;veni\u0026#34;, \u0026#34;vidi\u0026#34;, \u0026#34;vici\u0026#34;]; assert_eq!(bits.concat(), \u0026#34;venividivici\u0026#34;); assert_eq!(bits.join(\u0026#34;, \u0026#34;), \u0026#34;veni, vidi, vici\u0026#34;); Using Strings Strings support the == and != operators. Two strings are equal if they contain the same characters in the same order (regardless of whether they point to the same location in memory).\nOther String-Like Types Stick to String and \u0026amp;str for Unicode text. When working with filenames, use std::path::PathBuf and \u0026amp;Path instead. When working with binary data that isn’t UTF-8 encoded at all, use Vec\u0026lt;u8\u0026gt; and \u0026amp;[u8]. When working with environment variable names and command-line arguments in the native form presented by the operating system, use OsString and \u0026amp;OsStr. When interoperating with C libraries that use null-terminated strings, use std::ffi::CString and \u0026amp;CStr. Type Aliases 类型别名用 type ：\n1 type Bytes = Vec\u0026lt;u8\u0026gt;; Chapter 4. Ownership and Moves 管理内存，想达到的效果：\n当我们选择一个时间时，内存可以及时释放 内存释放后，不再有指针指向它 目前的内存管理方案：\nGC，垃圾回收。解决了悬垂指针的问题，但是会出现世界停时，也就是我们期望释放内存的时候，它还没有释放。 自己完全控制内存，比如C和C++。但是对程序员要求高，使用不当有时也会发生错误。 Rust是怎么解决这个问题的呢？秘密武器就是限制你的程序对指针的使用。给的这些限制会保证安全，但也不会丧失自由度。书中这样写道：\nRust’s radical wager, the claim on which it stakes its success and that forms the root of the language, is that even with these restrictions in place, you’ll find the language more than flexible enough for almost every task and that the benefits—the elimination of broad classes of memory management and concurrency bugs—will justify the adaptations you’ll need to make to your style. The authors of this book are bullish on Rust exactly because of our extensive experience with C and C++. For us, Rust’s deal is a no-brainer.\nOwnership 在Rust中，所有权的概念是内建在语言中的，并且会通过编译器检查强制执行。每个值都有一个所有者，这个所有者决定它的生命周期。当所有者被释放时，它所拥有的值也会被释放。\n1 2 3 4 5 { let point = Box::new((0.625, 0.5)); // point allocated here let label = format!(\u0026#34;{:?}\u0026#34;, point); // label allocated here , 这里返回 String assert_eq!(label, \u0026#34;(0.625, 0.5)\u0026#34;); }\t// both dropped here 内存布局：\n像变量会拥有它的值，结构体会拥有它们的字段，元组、数组以及向量会拥有它们的元素。\n再看一个复杂的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 struct Person { name: String, birth: i32 } let mut composers = Vec::new(); composers.push(Person { name: \u0026#34;Palestrina\u0026#34;.to_string(), birth: 1525 }); composers.push(Person { name: \u0026#34;Dowland\u0026#34;.to_string(), birth: 1563 }); composers.push(Person { name: \u0026#34;Lully\u0026#34;.to_string(), birth: 1632 }); for composer in \u0026amp;composers { println!(\u0026#34;{}, born {}\u0026#34;, composer.name, composer.birth); } 内存布局：\n每个值都有一个单独的所有者，这个所有者很容易来决定什么时候 drop 它所拥有的值。但是一个单独的值可能会拥有很多其他的值，如上面这个例子中的向量 composers。所有者和它们所拥有的值会形成一个树。在每个树的根部是一个变量，当这个变量离开它的作用范围，整棵树也会跟着离开。\nRust通常不会显式地 drop 它的值，而是通过：离开变量的作用域，从向量中删除一个元素，或者其他的。\nRust怎么在这些严格的限制下实现灵活性呢？如下列出了一些方式：\nYou can move values from one owner to another. This allows you to build, rearrange, and tear down the tree. Very simple types like integers, floating-point numbers, and characters are excused from the ownership rules. These are called Copy types. The standard library provides the reference-counted pointer types Rc and Arc, which allow values to have multiple owners, under some restrictions. You can “borrow a reference” to a value; references are non-owning pointers, with limited lifetimes. Moves In Rust, for most types, operations like assigning a value to a variable, passing it to a function, or returning it from a function don’t copy the value: they move it. The source relinquishes ownership of the value to the destination and becomes uninitialized; the destination now controls the value’s lifetime. Rust programs build up and tear down complex structures one value at a time, one move at a time.\n看看Python中的变量赋值。\n1 2 3 s = [\u0026#39;udon\u0026#39;, \u0026#39;ramen\u0026#39;, \u0026#39;soba\u0026#39;] t=s u=s 开始的内存布局：\n执行代码后的内存布局：\nPython has copied the pointer from s into t and u and updated the list’s reference count to 3. Assignment in Python is cheap, but because it creates a new reference to the object, we must maintain reference counts to know when we can free the value.\n来看看C++中的实现：\n1 2 3 4 using namespace std; vector\u0026lt;string\u0026gt; s = { \u0026#34;udon\u0026#34;, \u0026#34;ramen\u0026#34;, \u0026#34;soba\u0026#34; }; vector\u0026lt;string\u0026gt; t = s; vector\u0026lt;string\u0026gt; u = s; 开始的内存布局\n代码执行后的内存布局：\nDepending on the values involved, assignment in C++ can consume unbounded amounts of memory and processor time. The advantage, however, is that it’s easy for the program to decide when to free all this memory: when the variables go out of scope, everything allocated here gets cleaned up automatically.\nRust中的实现：\n1 2 3 let s = vec![\u0026#34;udon\u0026#34;.to_string(), \u0026#34;ramen\u0026#34;.to_string(), \u0026#34;soba\u0026#34;.to_string()]; let t = s; let u = s; 开始的内存分布：\n在let t = s;之后，s 的所有权就 move 到 t 上了。\n这时 s 变成未初始化状态，再执行 let u = s; 就会报错，因为使用了未初始化的变量。\nConsider the consequences of Rust’s use of a move here. Like Python, the assignment is cheap: the program simply moves the three-word header of the vector from one spot to another. But like C++, ownership is always clear: the program doesn’t need reference counting or garbage collection to know when to free the vector elements and string contents.\n如果想实现Python那样的引用计数，可以用 Rc 和 Arc，如果想实现C++那样的深拷贝，可以显式调用 clone() 方法。\nMore Operations That Move move语义的发生：\n给一个函数传递参数，会将所有权给参数 从函数返回一个值会将所有权给调用者 创建一个元组，会将值的所有权给元组 Moving values around like this may sound inefficient, but there are two things to keep in mind. First, the moves always apply to the value proper, not the heap storage they own. For vectors and strings, the value proper is the three-word header alone; the potentially large element arrays and text buffers sit where they are in the heap. Second, the Rust compiler’s code generation is good at “seeing through” all these moves; in practice, the machine code often stores the value directly where it belongs.\nMoves and Control Flow If it’s possible for a variable to have had its value moved away and it hasn’t definitely been given a new value since, it’s considered uninitialized.\nMoves and Indexed Content We’ve mentioned that a move leaves its source uninitialized, as the destination takes ownership of the value. But not every kind of value owner is prepared to become uninitialized.\n1 2 3 4 5 6 7 // Build a vector of the strings \u0026#34;101\u0026#34;, \u0026#34;102\u0026#34;, ... \u0026#34;105\u0026#34; let mut v = Vec::new(); for i in 101 .. 106 { v.push(i.to_string()); } // Pull out random elements from the vector. let third = v[2]; // error: Cannot move out of index of Vec let fifth = v[4]; // here too 要将 vector 看作一个整体，这里不能单独将 v[2] move 出来。如果确实想拿出其中的元素，有下面一些方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Build a vector of the strings \u0026#34;101\u0026#34;, \u0026#34;102\u0026#34;, ... \u0026#34;105\u0026#34; let mut v = Vec::new(); for i in 101 .. 106 { v.push(i.to_string()); } // 1. Pop a value off the end of the vector: let fifth = v.pop().expect(\u0026#34;vector empty!\u0026#34;); assert_eq!(fifth, \u0026#34;105\u0026#34;); // [\u0026#34;101\u0026#34;, \u0026#34;102\u0026#34;, \u0026#34;103\u0026#34;, \u0026#34;104\u0026#34;] // 2. Move a value out of a given index in the vector, // and move the last element into its spot: let second = v.swap_remove(1); assert_eq!(second, \u0026#34;102\u0026#34;); // [\u0026#34;101\u0026#34;, \u0026#34;104\u0026#34;, \u0026#34;103\u0026#34;] // 3. Swap in another value for the one we\u0026#39;re taking out: let third = std::mem::replace(\u0026amp;mut v[2], \u0026#34;substitute\u0026#34;.to_string()); assert_eq!(third, \u0026#34;103\u0026#34;); // [\u0026#34;101\u0026#34;, \u0026#34;104\u0026#34;, \u0026#34;substitute\u0026#34;] // Let\u0026#39;s see what\u0026#39;s left of our vector. assert_eq!(v, vec![\u0026#34;101\u0026#34;, \u0026#34;104\u0026#34;, \u0026#34;substitute\u0026#34;]); 来看看循环\n1 2 3 4 5 6 7 8 let v = vec![\u0026#34;liberté\u0026#34;.to_string(), \u0026#34;égalité\u0026#34;.to_string(), \u0026#34;fraternité\u0026#34;.to_string()]; for mut s in v { s.push(\u0026#39;!\u0026#39;); println!(\u0026#34;{}\u0026#34;, s); } 这里在for循环中，v 的所有权给了for循环，v 就变成未初始化的状态，然后 for 循环分离每一个元素，将所有权给每一个。因为 s 有所有权，就可以在内部修改字符串了。\n由于在循环中将 v 的所有权给了循环，因此后面就不能再使用 v 了，下面代码就会报错。\n1 2 3 4 5 6 7 8 9 let v = vec![\u0026#34;liberté\u0026#34;.to_string(), \u0026#34;égalité\u0026#34;.to_string(), \u0026#34;fraternité\u0026#34;.to_string()]; for mut s in v { s.push(\u0026#39;!\u0026#39;); println!(\u0026#34;{}\u0026#34;, s); } let _u = v; // error[E0382]: use of moved value: `v` 如果想得到结构体中的元素值，可以调用 std::mem::replace方法，将原来的值用None来占位。\n1 2 3 4 5 6 7 8 9 struct Person { name: Option\u0026lt;String\u0026gt;, birth: i32 } let mut composers = Vec::new(); composers.push(Person { name: Some(\u0026#34;Palestrina\u0026#34;.to_string()), birth: 1525 }); let first_name = std::mem::replace(\u0026amp;mut composers[0].name, None); // let first_name = composers[0].name.take(); // 和上述语句达到的效果一样 assert_eq!(first_name, Some(\u0026#34;Palestrina\u0026#34;.to_string())); assert_eq!(composers[0].name, None); Copy Types: The Exception to Moves Assigning a value of a Copy type copies the value, rather than moving it. The source of the assignment remains initialized and usable, with the same value it had before. Passing Copy types to functions and constructors behaves similarly.\nThe standard Copy types include all the machine integer and floating-point numeric types, the char and bool types, and a few others. A tuple or fixed-size array of Copy types is itself a Copy type.\nOnly types for which a simple bit-for-bit copy suffices can be Copy. As a rule of thumb, any type that needs to do something special when a value is dropped cannot be Copy.\n自定义的结构体或者枚举类型可以用属性宏实现 Copy trait。\n1 2 #[derive(Copy, Clone)] struct Label { number: u32 } In Rust, every move is a byte-for-byte, shallow copy that leaves the source uninitialized. Copies are the same, except that the source remains initialized.\nOne of Rust’s principles is that costs should be apparent to the programmer. Basic operations must remain simple. Potentially expensive operations should be explicit, like the calls to clone in the earlier example that make deep copies of vectors and the strings they contain.\nRc and Arc: Shared Ownership The Rc and Arc types are very similar; the only difference between them is that an Arc is safe to share between threads directly—the name Arc is short for atomic reference count—whereas a plain Rc uses faster non-thread-safe code to update its reference count.\n前面的例子用Rust实现Python中引用计数的效果：\n1 2 3 4 5 6 use std::rc::Rc; // Rust can infer all these types; written out for clarity let s: Rc\u0026lt;String\u0026gt; = Rc::new(\u0026#34;shirataki\u0026#34;.to_string()); let t: Rc\u0026lt;String\u0026gt; = s.clone(); let u: Rc\u0026lt;String\u0026gt; = s.clone(); 内存布局：\nRust’s memory and thread-safety guarantees depend on ensuring that no value is ever simultaneously shared and mutable. Rust assumes the referent of an Rc pointer might in general be shared, so it must not be mutable.\nHowever, Rust does provide ways to create mutable portions of otherwise immutable values; this is called interior mutability. 这可能造成循环引用。\n想要用Rc避免循环引用。You can sometimes avoid creating cycles of Rc pointers by using weak pointers, std::rc::Weak, for some of the links instead.\nChapter 5. References Rust also has non-owning pointer types called references, which have no effect on their referents’ lifetimes.\nIn fact, it’s rather the opposite: references must never outlive their referents. You must make it apparent in your code that no reference can possibly outlive the value it points to. To emphasize this, Rust refers to creating a reference to some value as borrowing the value: what you have borrowed, you must eventually return to its owner.\nReferences to Values A reference lets you access a value without affecting its ownership. References come in two kinds:\nA shared reference lets you read but not modify its referent. However, you can have as many shared references to a particular value at a time as you like. The expression \u0026amp;e yields a shared reference to e’s value; if e has the type T, then \u0026amp;e has the type \u0026amp;T, pronounced “ref T.” Shared references are Copy. If you have a mutable reference to a value, you may both read and modify the value. However, you may not have any other references of any sort to that value active at the same time. The expression \u0026amp;mut e yields a mutable reference to e’s value; you write its type as \u0026amp;mut T, which is pronounced “ref mute T.” Mutable references are not Copy. 1 2 3 4 5 6 7 8 fn show(table: \u0026amp;Table) { for (artist, works) in table { println!(\u0026#34;works by {}:\u0026#34;, artist); for work in works { println!(\u0026#34; {}\u0026#34;, work); } } } Iterating over a shared reference to a HashMap is defined to produce shared references to each entry’s key and value: artist has changed from a String to a \u0026amp;String, and works from a Vec\u0026lt;String\u0026gt; to a \u0026amp;Vec\u0026lt;String\u0026gt;.\nThe inner loop is changed similarly. Iterating over a shared reference to a vector is defined to produce shared references to its elements, so work is now a \u0026amp;String. No ownership changes hands anywhere in this function; it’s just passing around non-owning references.\nWhen we pass a value to a function in a way that moves ownership of the value to the function, we say that we have passed it by value. If we instead pass the function a reference to the value, we say that we have passed the value by reference.\nWorking with References Rust References Versus C++ References In Rust, references are created explicitly with the \u0026amp; operator, and dereferenced explicitly with the * operator.\nSince references are so widely used in Rust, the . operator implicitly dereferences its left operand, if needed.\n1 2 3 4 5 6 7 struct Anime { name: \u0026amp;\u0026#39;static str, bechdel_pass: bool }; let aria = Anime { name: \u0026#34;Aria: The Animation\u0026#34;, bechdel_pass: true }; let anime_ref = \u0026amp;aria; assert_eq!(anime_ref.name, \u0026#34;Aria: The Animation\u0026#34;); // Equivalent to the above, but with the dereference written out: assert_eq!((*anime_ref).name, \u0026#34;Aria: The Animation\u0026#34;); The println! macro used in the show function expands to code that uses the . operator.\nThe . operator can also implicitly borrow a reference to its left operand, if needed for a method call.\n1 2 3 let mut v = vec![1973, 1968]; v.sort(); // implicitly borrows a mutable reference to v (\u0026amp;mut v).sort(); // equivalent, but more verbose Assigning References 1 2 3 4 5 6 7 let x = 10; let y = 20; let mut r = \u0026amp;x; if b { r = \u0026amp;y; } assert!(*r == 10 || *r == 20); The reference r initially points to x. But if b is true, the code points it at y instead.\nReferences to References 1 2 3 4 5 struct Point { x: i32, y: i32 } let point = Point { x: 1000, y: 729 }; let r: \u0026amp;Point = \u0026amp;point; let rr: \u0026amp;\u0026amp;Point = \u0026amp;r; let rrr: \u0026amp;\u0026amp;\u0026amp;Point = \u0026amp;rr; The . operator follows as many references as it takes to find its target.\n1 assert_eq!(rrr.y, 729); So the expression rrr.y, guided by the type of rrr, actually traverses three references to get to the Point before fetching its y field.\nComparing References 1 2 3 4 5 6 7 8 9 10 11 let x = 10; let y = 10; let rx = \u0026amp;x; let ry = \u0026amp;y; let rrx = \u0026amp;rx; let rry = \u0026amp;ry; assert!(rrx \u0026lt;= rry); assert!(rrx == rry); 比较操作符和.操作符一样可以解引用到最终的目标值。\n可以用std::ptr::eq来比较地址是否相等：\n1 2 assert!(rx == ry); // their referents are equal assert!(!std::ptr::eq(rx, ry)); // but occupy different addresses 比较操作符两端的类型必须相同：\n1 2 assert!(rx == rrx); // error: type mismatch: `\u0026amp;i32` vs `\u0026amp;\u0026amp;i32` assert!(rx == *rrx); // this is okay References Are Never Null Rust references are never null. There is no default initial value for a reference (you can’t use any variable until it’s been initialized, regardless of its type) and Rust won’t convert integers to references (outside of unsafe code), so you can’t convert zero into a reference.\nIn Rust, if you need a value that is either a reference to something or not, use the type Option\u0026lt;\u0026amp;T\u0026gt;.\nBorrowing References to Arbitrary Expressions Rust lets you borrow a reference to the value of any sort of expression at all:\n1 2 3 4 5 6 7 fn factorial(n: usize) -\u0026gt; usize { (1..n+1).product() } let r = \u0026amp;factorial(6); // Arithmetic operators can see through one level of references. assert_eq!(r + \u0026amp;1009, 1729); Rust simply creates an anonymous variable to hold the expression’s value and makes the reference point to that. The lifetime of this anonymous variable depends on what you do with the reference:\nIf you immediately assign the reference to a variable in a let statement (or make it part of some struct or array that is being immediately assigned), then Rust makes the anonymous variable live as long as the variable the let initializes. Otherwise, the anonymous variable lives to the end of the enclosing statement. References to Slices and Trait Objects fat pointers:\nA reference to a slice is a fat pointer, carrying the starting address of the slice and its length. Rust’s other kind of fat pointer is a trait object, a reference to a value that implements a certain trait. A trait object carries a value’s address and a pointer to the trait’s implementation appropriate to that value, for invoking the trait’s methods. Reference Safety Borrowing a Local Variable You can’t borrow a reference to a local variable and take it out of the variable’s scope:\n1 2 3 4 5 6 7 8 { let r; { let x = 1; r = \u0026amp;x; } assert_eq!(*r, 1); // bad: reads memory `x` used to occupy } The variables r and x both have a lifetime, extending from the point at which they’re initialized until the point that the compiler can prove they are no longer in use. The third lifetime is that of a reference type: the type of the reference we borrow to x and store in r.\nWe say that the variable’s lifetime must contain or enclose that of the reference borrowed from it. 变量的生命周期必须包含或涵盖从它那里借来的引用的生命期。\nHere’s another kind of constraint: if you store a reference in a variable r, the reference’s type must be good for the entire lifetime of the variable, from its initialization until its last us.\nWe say that the reference’s lifetime must contain or enclose the variable’s. 引用的生命期必须包含或涵盖保存它的变量的生命期。\nThe first kind of constraint limits how large a reference’s lifetime can be, while the second kind limits how small it can be.\n下面的生命周期是正确的：\nFirst, understand the constraints arising from the way the program uses references; then, find lifetimes that satisfy them.\nReceiving References as Function Arguments Every static must be initialized. Mutable statics are inherently not thread-safe (after all, any thread can access a static at any time), and even in single-threaded programs, they can fall prey to other sorts of reentrancy problems. For these reasons, you may access a mutable static only within an unsafe block. In this example we’re not concerned with those particular problems, so we’ll just throw in an unsafe block and move on. fn f\u0026lt;'a\u0026gt;(p: \u0026amp;'a i32), we’re defining a function that takes a reference to an i32 with any given lifetime \u0026lsquo;a.\nIn other words, we were unable to write a function that stashed a reference in a global variable without reflecting that intention in the function’s signature. In Rust, a function’s signature always exposes the body’s behavior.\nIf we do see a function with a signature like g(p: \u0026amp;i32) (or with the lifetimes written out, g\u0026lt;'a\u0026gt;(p: \u0026amp;'a i32)), we can tell that it does not stash its argument p anywhere that will outlive the call.\nPassing References to Functions 1 2 3 4 5 6 // This could be written more briefly: fn g(p: \u0026amp;i32), // but let\u0026#39;s write out the lifetimes for now. fn g\u0026lt;\u0026#39;a\u0026gt;(p: \u0026amp;\u0026#39;a i32) { ... } let x = 10; g(\u0026amp;x); 从g的签名看，Rust知道它不会把p保存到超出调用生命周期的变量里；任何涵盖调用的生命周期都满足'a。\n1 2 3 4 fn f(p: \u0026amp;\u0026#39;static i32) { ... } let x = 10; f(\u0026amp;x); // error 这里 \u0026amp;x不能存活得比x长，而函数签名要求\u0026amp;x活得和\u0026amp;'static一样长，这就无法得到满足，因此报错。\nReturning References 1 2 3 4 5 6 7 8 // v should have at least one element. fn smallest(v: \u0026amp;[i32]) -\u0026gt; \u0026amp;i32 { let mut s = \u0026amp;v[0]; for r in \u0026amp;v[1..] { if *r \u0026lt; *s { s = r; } } s } 如果一个函数只有一个引用作为参数并返回一个引用，则它们拥有相同的生命周期。\nStructs Containing References 当引用类型出现在另一个类型的定义中时，必须写出其生命周期。\n1 2 3 struct S { r: \u0026amp;\u0026#39;static i32 // 这里 r 必须写上生命周期 } 或者\n1 2 3 struct S\u0026lt;\u0026#39;a\u0026gt;{ r: \u0026amp;\u0026#39;a i32 } 保存在r中的任何引用的生命周期最好包含'a，而'a也必须比保存在S的任何值都长寿。\nThe lifetime of any reference you store in r had better enclose \u0026lsquo;a, and \u0026lsquo;a must outlast the lifetime of wherever you store the S.\nThe assignment s = S { \u0026hellip; } stores this S in a variable whose lifetime extends to the end of the example, constraining \u0026lsquo;a to outlast the lifetime of s.\nAnd now Rust has arrived at the same contradictory constraints as before: \u0026lsquo;a must not outlive x, yet must live at least as long as s.\nDistinct Lifetime Parameters 1 2 3 4 struct S\u0026lt;\u0026#39;a\u0026gt; { x: \u0026amp;\u0026#39;a i32, y: \u0026amp;\u0026#39;a i32 } 如下代码：\n1 2 3 4 5 6 7 8 9 let x = 10; let r; { let y = 20; { let s = S { x: \u0026amp;x, y: \u0026amp;y }; r = s.x; } } println!(\u0026#34;{}\u0026#34;, r); If you work through the code carefully, you can follow its reasoning:\nBoth fields of S are references with the same lifetime \u0026lsquo;a, so Rust must find a single lifetime that works for both s.x and s.y. We assign r = s.x, requiring \u0026lsquo;a to enclose r’s lifetime. (r \u0026lt;= \u0026lsquo;a) We initialized s.y with \u0026amp;y, requiring \u0026lsquo;a to be no longer than y’s lifetime. (\u0026lsquo;a \u0026lt;= y) Omitting Lifetime Parameters 三条规则（见生命周期与引用有效性）：\n第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo\u0026lt;'a\u0026gt;(x: \u0026amp;'a i32)，有两个引用参数的函数有两个不同的生命周期参数，fn foo\u0026lt;'a, 'b\u0026gt;(x: \u0026amp;'a i32, y: \u0026amp;'b i32)，依此类推。\n第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo\u0026lt;'a\u0026gt;(x: \u0026amp;'a i32) -\u0026gt; \u0026amp;'a i32。\n第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 \u0026amp;self 或 \u0026amp;mut self，说明是个对象的方法(method)(译者注： 这里涉及 Rust 的面向对象参见 17 章), 那么所有输出生命周期参数被赋予 self 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。\nSharing Versus Mutation Throughout its lifetime, a shared reference makes its referent read-only: you may not assign to the referent or move its value elsewhere.\nShared access is read-only access.\nValues borrowed by shared references are read-only. Across the lifetime of a shared reference, neither its referent, nor anything reachable from that referent, can be changed by anything. There exist no live mutable references to anything in that structure, its owner is held read-only, and so on. It’s really frozen.\nMutable access is exclusive access.\nA value borrowed by a mutable reference is reachable exclusively via that reference. Across the lifetime of a mutable reference, there is no other usable path to its referent or to any value reachable from there. The only references whose lifetimes may overlap with a mutable reference are those you borrow from the mutable reference itself.\nTaking Arms Against a Sea of Objects Chapter 6. Expressions Rust中绝大多数都是表达式。\nAn Expression Language 在Rust中，if 和 match 都可以产生值。一个match表达式可以给一个函数或者宏来传参。 Rust 中没有三元操作符。 Rust中所有的控制流程工具是表达式。 Precedence and Associativity 闭包的优先级在最后。 All of the operators that can usually be chained are left-associative. 所有这些操作符在链式操作时都具有左关联性。 比较操作符，赋值操作符（assignment iperators）以及范围操作符（..range operators）不能链式链接。 Blocks and Semicolons block 的值是最后一个表达式的值。 let 声明必须要有分号。 如果 if 表达式没有 else，那么总是返回 ()。 Declarations let 声明必须要有分号。 let 声明可以只声明变量而不初始化它。 在没有初始化一个变量之前是不能使用它的。 变量遮蔽，可以是不同的类型。 一个块可以包含特性项（ item） declarations，就是指任何可以在程序或模块的全局中出现的声明，比如 fn，struct 或者 use。 嵌套的 fn 不能使用 scope 中的局部变量。 块中甚至可以包含一个完整的模块。 if and match if 表达式的 condition 必须是 bool 类型的，Rust 不会将数值或者指针隐式转换成 Boolean 类型。 在 if 表达式形式中，围绕条件的圆括号不是必需的。事实上，rustc在发现不必要的圆括号时会给出警告。但花括号是必需的。 一个只有 if 没有 else 的表达式相当于有一个 空的else 块。因此如果 if 表达式没有 else，那么总是返回 ()。 编译器可以用一个跳转表（ jump table ）来优化 match 表达式。如果 match 的每个分支都产生一个常量值，那么也可以应用同样的优化。此时，编译器会构建一个这些值的数组，而 match 会被编译为对数组的访问。除了边界检查，编译后的代码中根本没有分支。 Rust 禁止 match 表达式没有覆盖到所有情况。 一个 if 表达式的所有块必须产生相同类型的值，对于 match 表达式也是一样的，match 表达式的所有分支也都必须返回相同类型的值。 if let 1 2 3 4 5 if let pattern = expr { block1 } else { block2 } 等价于\n1 2 3 4 match expr { pattern =\u0026gt; { block1 } _ =\u0026gt; { block2 } } Loops 有四种 looping 表达式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 while condition { block } while let pattern = expr { block } loop { block } for pattern in iterable { block } while 和 for 的值一直都是 ()，循环的值是()。 用 loop 可以无限循环，除非遇到 break，return或者线程 panics。 for 循环每迭代一个值就会消耗一个值，有时候可以使用引用。 Control Flow in Loops break 只能在 loop 中，不能在 match 中。 可以给 break 一个表达式，这个表达式的值就是 loop 的值。 自然地，所有 break 表达式在一个循环中必须是相同类型的，并且这个类型就是 loop 的类型。 循环可以加上生命周期的标签，然后可以 break 这个标签，break 也可以同时带上值表达式。 标签同样可以用于 continue。 return Expressions return 表达式会退出当前函数，并且给调用者返回一个值。 可以将函数体看成一个块表达式。 return 可以放弃正在运行中的工作。 Why Rust Has loop Rust编译器分析你的程序的控制流程：\n检查返回类型 检查局部变量不会使用未初始化的值 警告不可到达的代码 以上这些称为流敏感（flow-sensitive）分析。\nRust追求简单，其流敏感分析压根不会检查循环条件，而只是假设程序中的任何条件不是true就是false。\n! 表示是一个发散函数。比如 break，return，panic!()，无穷循环，std::process::exit() ，它们都不以惯常的方式结束，这些可以跳过之前说的类型一致规则。\nFunction and Method Calls .location() 方法可能取 player 的值或者引用。 . 操作符可以自动的解引用 player或者借一个引用。可以接收值或引用。 静态方法Vec::new() ，非静态方法通过值调用：my_vec.len()。 对于泛型，函数或者方法调用要用比目鱼 turbofish 操作符，比如：return Vec::\u0026lt;i32\u0026gt;::with_capcity(1000); Fields and Elements 点操作符或者方括号的左侧是一个引用或者智能指针，那么它可以被自动地解引用，这样的表达式被称为 lvalues，它们可以出现在一个 assignment 的左侧。\n操作符：\n1 2 3 4 5 6 .. a .. .. b a .. b ..= b a ..= b Reference Operators \u0026amp; \u0026amp; mut *操作符可以用来解引用 Arithmetic, Bitwise, Comparsion, and Logical Operators 不能将-和+ 用到无符号的数值类型上。 %也可以用在浮点数上。 !表示按位非。 位操作符的优先级高于比较操作符的优先级。 比较操作符两端的类型必须都是 bool 类型。 Assignment Rust中可以有复合操作符：+= -= *= Rust不支持链式 assignment，比如 a = b = 3 Rust没有自增和自减操作符：++和--。 Type Casts 可以用 as 进行类型转换。几种类型转换是允许的：\n任何内置的数值之间可以转换。 bool、char 或者 C-like enum 类型可以转换为整数。u8 可能转换为 char 类型。 有些含有 unsafe 的指针类型的转换也是允许的。 一些自动转换，被称为解引用强制转换（deref coercions）：\n\u0026amp;String -\u0026gt; \u0026amp;str \u0026amp;Vec\u0026lt;i32\u0026gt; -\u0026gt; \u0026amp;[i32] \u0026amp;Box[Chessboard] -\u0026gt; \u0026amp;Chessboard 它们实现了内置的 Deref trait。\nClosures 1 let is_even = |x| x % 2 == 0; Rust自动推断类型。调用闭包就像调用一个函数那样：\n1 assert_eq!(is_even(14), true); Onward 表达式只是我们思考 running code。\nChapter 7. Error Handling Panic panic 是程序本身出现一个bug。比如：\n数组越界 整数除零 对于一个 Result调用.expect()。 断言失败 panic时要么展开栈，要么中止程序，展开栈是默认的。\nUnwinding panic发生：\n终端打印错误信息 运行 RUST_BACKTRACE=1会将栈展开。资源会关闭，会调用drop方法。 最后，线程退出。 panic不是崩溃，不是未定义行为。panic像Java中的运行时异常，其行为是明确定义的，只是不应该发生而已。\npanic是安全的，它不违反任何Rust的安全规则。不会在内存中导致悬空指针或初始化一半的值，Rust展开栈后，进程的其他部分还可以运行。\npanic是线程级别的。\n有一种方法可以捕获栈展开，运行panic线程存活并继续运行。使用标准库中的std::panic::catch_unwind()函数。\nAborting 如果.drop()方法触发了第二个panic当Rust在第一个panic后尝试 clean up，这会被当作是致命的。Rust会停止展开并且直接终止整个流程。 编译加上-C panic=abort，第一个 panic 就立马终止程序。 Result 如果不使用Result值，会得到一个警告。\nCatching Errors 用 match 来处理 error\n1 2 3 4 5 6 7 8 9 match get_weather(hometown) { Ok(report) =\u0026gt; { display_weather(hometown, \u0026amp;report); } Err(err) =\u0026gt; { println!(\u0026#34;error querying the weather: {}\u0026#34;, err); schedule_weather_retry(); } } 但是上面这种方式太冗长了。这里有一些方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1. 返回一个bool值 result.is_ok() result.is_err() // 2. 返回成功的值，返回 Option\u0026lt;T\u0026gt;, 成功就返回值，失败就返回 None result.ok() // 3. 返回失败的值 result.err() // 4. 返回成功的值，否则就返回 fallback，抛弃错误的值，只有在存在适当后备值的情况下才可以使用这个方法 result.unwrap_or(fallback) // 5. 返回成功的值，否则返回 fallback_fn，这里可以是一个函数或者闭包，这个方法适合计算 // 后备值如果用不上会浪费的情况。只有在返回错误结果时才会调用 fallback_fn result.unwrap_or_else(fallback_fn) // 6. 返回成功的值，否则就 panic result.unwrap() result.expect(message) // panic 时打印信息 // 7. 将 Result\u0026lt;T, E\u0026gt; 转换为 Result\u0026lt;\u0026amp;T, \u0026amp;E\u0026gt;，这对于还要用原来的 result 的值很有用 result.as_ref() // 8. 将 Result\u0026lt;T, E\u0026gt; 转换为 Result\u0026lt;\u0026amp;mut T, \u0026amp;mut E\u0026gt; result.as_mut() Result Type Aliases 在标准库 std::io 模块中有：\n1 pub type Result\u0026lt;T\u0026gt; = result::Result\u0026lt;T, Error\u0026gt;; 这里用了 type aliases。\nPrinting Errors std::io::Error、std::fmt::Error、std::str::Utf8Error等等实现了std::error::Error trait。一些公用的方法：\nprintln!()\n打印错误，用{}可以打印简短的错误信息，用{:?}的Debug模式打印出错误。\nerr.to_string()\n返回错误信息字符串。\nerr.source()\n返回一个Option，包含潜在的错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use std::error::Error; use std::io::{Write, stderr}; /// Dump an error message to `stderr`. /// /// If another error happens while building the error message or /// writing to `stderr`, it is ignored. fn print_error(mut err: \u0026amp;dyn Error) { let _ = writeln!(stderr(), \u0026#34;error: {}\u0026#34;, err); while let Some(source) = err.source() { let _ = writeln!(stderr(), \u0026#34;caused by: {}\u0026#34;, source); err = source; } } 想要展开错误，在Rust不稳定版本下，可以使用anyhow包。\nPropagating Errors 如果错误发生，我们希望调用者来处理。\n1 2 let weather = get_weather(hometown)?; let weather = try!(get_weather(hometown)); ?操作符的行为取决于这个函数的返回值：\n如果是成功结果，那么它会打开Result并取出其中的成功值。 如果是错误结果，那么它会立即从闭合函数中返回，将错误结果沿调用链向上传播。 ?操作符一样可以使用match表达式实现。\n?可以类似地用在Option类型的值上面。In a function that returns Option, you can use ? to unwrap a value and return early in the case of None.\nWorking with Multiple Error Types ?不能将std::num::ParseIntError转换为std::io::Error类型。 所有标准库中的错误都可以转成Box\u0026lt;dyn std::error::Error + Send + Sync + 'static'\u0026gt;类型。 1 2 type GenericError = Box\u0026lt;dyn std::error::Error + Send + Sync + \u0026#39;static\u0026gt;; type GenericResult = Result\u0026lt;T, GenericError\u0026gt;; ?会调用GenericError::from()方法来进行自动转换。\n如果想要其中一种特别的错误类型进行处理，其它的错误进行传播的话，可以用泛型方法error.downcast_ref::\u0026lt;ErrorType\u0026gt;() Dealing with Errors That \u0026ldquo;Can\u0026rsquo;t Happen\u0026rdquo; 当我们不想处理不会发生的错误时，用.unwrap()方法。 也可以用.expect(message)方法。 Ingoring Errors 1 let _ = writeln!(stderr(), \u0026#34;error: {}\u0026#34;, err); 用 let _ = ...用来禁止警告。\nHandling Errors in main() 一般情况下在 main 函数中不能用 ? ，因为 main() 函数的返回类型不是 Result。 最简单的方法是用 .expect()方法。发生错误时会 panic 并且返回一个非零的退出代码。 或者可以返回一个 Result 类型，这样就能用?，同时用debug {:?}方式打印出错误。 1 fn main() -\u0026gt; Result\u0026lt;(), TideCalcError\u0026gt; { } 或者自己处理相应的错误。用print_error()方法结合if let 打印简介的错误信息。 Declaring a Custom Error Type 可以自定义Error类型，用 struct 实现。Errors 应该实现fmt::Display和 std::error::Error trait。 或者直接用thiserror 中的，加上属性宏#[derive(Error)]。 1 2 3 4 5 6 7 8 use thiserror::Error; #[derive(Error, Debug)] #[error(\u0026#34;{message:} ({line:}, {column})\u0026#34;)] pub struct JsonError { message: String, line: usize, column: usize, } Why Results? 在代码中记录错误，对错误做出决定。 允许错误传播，传播路径可见。 每一个函数都有返回类型，这样更清楚函数可不可能失败。 Rust 会检查 Result 类型的值是否被使用。 因为 Result 是一个数据类型，因此更容易处理一系列成功或者失败的值，也更容易存储。 Chapter 8. Crates and Modules Crates Rust programs are made of crates. Each crate is a complete, cohesive unit: all the source code for a single library or executable, plus any associated tests, examples, tools, configuration, and other junk.\n要了解包是什么，以及它们如何协作，可以对一个使用了依赖的已有项目运行 cargo build 命令，同时加上 --verbose 标记。\nCargo 的依赖会形成 dependency graph 。\nCargo 会使用 --crate-type lib选项，会告诉 rustc 不要去找 main() 函数，而是生成一个 .rlib 文件，其中包含编译后的代码，可以供以后在创建库或者.rlib文件使用。\nWhen compiling libraries, Cargo uses the \u0026ndash; crate-type lib option. This tells rustc not to look for a main() function but instead to produce an .rlib file containing compiled code that can be used to create binaries and other .rlib files.\nCargo使用 --crate-type bin 选项，编译结果将是一个针对目标平台的二进制可执行文件。\n运行每个 rustc 命令时，Cargo会通过--extern选项给出当前包用到的每个库的文件名。这样，当rustc看到use image::png::PNGEncoder这行代码时，它就知道到磁盘的什么位置去找这个库编码后的代码了。Rust编译器需要访问.rlib文件，因为其中包含第三方库编译后的代码。Rust会将这些代码静态链接到最终的可执行文件上。.rlib文件也包含类型信息，Rust可以据此检查我们代码中用到的库特性确实在对应的包里存在，从而保证正确地使用它们。这个文件里还包含包的公共内联函数、泛型和宏的一个副本，这些特性直到Rust遇到调用它们的代码时才会编译为机器码。\ncargo build --release产生优化代码，优化代码的运行速度更快，但编译时间比较长，而且不会检查整型溢出，还会跳过debug_assert!()断言，另外它们针对 panic 生成的栈追踪信息一般不太可靠。\nEditions To evolve without breaking existing code, Rust uses editions. The 2015 edition of Rust is compatible with Rust 1.0. The 2018 edition changed async and await into keywords, streamlined the module system, and introduced various other language changes that are incompatible with the 2015 edition.\nRust promises that the compiler will always accept all extant editions of the language, and programs can freely mix crates written in different editions. It’s even fine for a 2015 edition crate to depend on a 2018 edition crate. In other words, a crate’s edition only affects how its source code is construed; edition distinctions are gone by the time the code has been compiled. This means there’s no pressure to update old crates just to continue to participate in the modern Rust ecosystem. Similarly, there’s no pressure to keep your crate on an older edition to avoid inconveniencing its users. You only need to change editions when you want to use new language features in your own code.\nIf you have a crate written in an older edition of Rust, the cargo fix command may be able to help you automatically upgrade your code to the newer edition. The Rust Edition Guide explains the cargo fix command in detail.\nBuild Profiles 构建分析\n命令行 Cargo.toml使用的区块 cargo build [profile.dev] cargo build \u0026ndash;realse [profile.realse] cargo test [profile.test] 想要同时启用优化和调试，可以这样设置：\n1 2 [profile.realse] debug = true # 在发布构建中启用调试标记 这里debug设置控制 rustc 中的 -g 选项。有了这个配置，再执行 cargo build --realse，就可以得到一个带有调试符号的二进制文件。优化设置不受影响。\nModules 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 mod spores { use cells::{Cell, Gene}; /// A cell made by an adult fern. It disperses on the wind as part of /// the fern life cycle. A spore grows into a prothallus -- a whole /// separate organism, up to 5mm across -- which produces the zygote /// that grows into a new fern. (Plant sex is complicated.) pub struct Spore { ... } /// Simulate the production of a spore by meiosis. pub fn produce_spore(factory: \u0026amp;mut Sporangium) -\u0026gt; Spore { ... } /// Extract the genes in a particular spore. pub(crate) fn genes(spore: \u0026amp;Spore) -\u0026gt; Vec\u0026lt;Gene\u0026gt; { ... } /// Mix genes to prepare for meiosis (part of interphase). fn recombine(parent: \u0026amp;mut Cell) { ... } ... } One function is marked pub(crate), meaning that it is available anywhere inside this crate, but isn’t exposed as part of the external interface. It can’t be used by other crates, and it won’t show up in this crate’s documentation.\nAnything that isn’t marked pub is private and can only be used in the same module in which it is defined, or any child modules.\nNested Modules mod可以嵌套。\nIt’s also possible to specifypub(super), making an item visible to the parent module only, and pub(in \u0026lt;path\u0026gt;), which makes it visible in a specific parent module and its descendants.\nModules in Separate Files These three options—modules in their own file, modules in their own directory with a mod.rs, and modules in their own file with a supplementary directory containing submodules—give the module system enough flexibility to support almost any project structure you might desire.\nPaths and Imports 用::操作符。\n1 2 3 if s1 \u0026gt; s2 { std::mem::swap(\u0026amp;mut s1, \u0026amp;mut s2); } 或者用use导入。\n1 2 3 4 5 use std::mem; if s1 \u0026gt; s2 { mem::swap(\u0026amp;mut s1, \u0026amp;mut s2); } 一次导入多个模块：\n1 2 3 use std::collections::{HashMap, HashSet}; // import both use std::fs::{self, File}; // import both `std::fs` and `std::fs::File`. use std::io::prelude::*; // import everything 导入时起别名\n1 2 3 4 5 use std::io::Result as IOResult; // This return type is just another way to write `std::io::Result\u0026lt;()\u0026gt;`: fn save_spore(spore: \u0026amp;Spore) -\u0026gt; IOResult\u0026lt;()\u0026gt; ... 模块不会自动从自己的父模块继承名字。关键字super是父模块的一个别名，self则是当前模块的一个别名，关键词 crate 表示包含当前模块的包。\n1 2 3 4 5 // proteins/synthesis.rs use crate::proteins::AminoAcid; // explicitly import relative to crate root pub fn synthesize(seq: \u0026amp;[AminoAcid]) // ok ... 使用相对于根的路径，这样当模块移动时，也是有效的。\nuse super::*可以让子模块获得父模块的私有项。\n绝对路径：\n1 2 3 4 // 外部 crate use ::image::Pixels; // the `image` crate\u0026#39;s `Pixels` // 自己定义的模块 use self::image::Sampler; // the `image` module\u0026#39;s `Sampler` The Standard Prelude Furthermore, a few particularly handy names, like Vec and Result, are included in the standard prelude and automatically imported. Rust behaves as though every module, including the root module, started with the following import:\n1 use std::prelude::v1::*; The standard prelude contains a few dozen commonly used traits and types.\n参考std::prelude。\nMaking use Declarations pub 1 2 3 4 // in plant_structures/mod.rs ... pub use self::leaves::Leaf; pub use self::roots::Root; This means that Leaf and Root are public items of the plant_structures module. They are still simple aliases for plant_structures::leaves::Leaf and plant_structures::roots::Root.\nMaking Struct Fields pub 1 2 3 4 pub struct Fern { pub roots: RootSet, pub stems: StemSet } Outside the module, only public fields are accessible.\nStatics and Constants 1 2 pub const ROOM_TEMPERATURE: f64 = 20.0; // degrees Celsius pub static ROOM_TEMPERATURE: f64 = 68.0; // degrees Fahrenheit A constant is a bit like a C++ #define: the value is compiled into your code every place it’s used. A static is a variable that’s set up before your program starts running and lasts until it exits. Use constants for magic numbers and strings in your code. Use statics for larger amounts of data, or any time you need to borrow a reference to the constant value.\nThere are no mut constants.\nTurning a Program into a Library The first step is to factor your existing project into two parts: a library crate, which contains all the shared code, and an executable, which contains the code that’s only needed for your existing command-line program.\nBy default, cargo build looks at the files in our source directory and figures out what to build. When it sees the file src/lib.rs, it knows to build a library. The code in src/lib.rs forms the root module of the library. Other crates that use our library can only access the public items of this root module.\nThe src/bin Directory We can keep our program and our library in the same crate, too. Put this code into a file named src/bin/efern.rs:\n1 2 3 4 5 6 7 8 9 use fern_sim::{Fern, run_simulation}; fn main() { let mut fern = Fern { size: 1.0, growth_rate: 0.001 }; run_simulation(\u0026amp;mut fern, 1000); println!(\u0026#34;final fern size: {}\u0026#34;, fern.size); } Because we’ve put this file into src/bin, Cargo will compile both the fern_sim library and this program the next time we run cargo build. We can run the efern program using cargo run \u0026ndash;bin efern. Here’s what it looks like, using \u0026ndash;verbose to show the commands Cargo is running.\n1 2 [dependencies] fern_sim = { path = \u0026#34;../fern_sim\u0026#34; } 可以将 fern_sim 作为一个单独的项目，然后在 Cargo.toml 上加上依赖。\nAttributes Rust程序中的任何 item 都可以用属性来修饰。\n#[allow(non_camel_case_types)] 可以不使用驼峰命名法。 #[cfg] 条件编译 #[inline] 内联函数。当出现一个函数或者一个方法定义在一个 crate 中，而我们在另一个 crate 中去调用，可以显式使用这个属性。 #[inline(always)] 要求函数在每一次调用的点都展开内联 #[inline(never)] 要求一个函数从不进行内联 #[cfg]和#[allow]可以用在一整个模块或者里面的任何东西，但是 #[inline] 和 #[test]只能用在单个项上面。 想在整个 crate 上面绑定属性，在main.rs或者lib.rs文件顶部中用#!。#!也可以用在函数，结构体中，但是它只能一贯地用在文件的开头，来绑定给整个模块或者 crate 绑定一个属性。而有的属性总是用 #!，因为它只能作用在整个 crate 上，比如 #![feature]。 #![feature] 用来表示 Rust 语言不稳定的 features，这些是实验性质的。当后面这个 feature 稳定之后，编译器就会警告，建议移除 #![feature]。 Tests and Documention #[test] 标记函数，表明这个是测试函数，用cargo test 可以测试所有测试函数，如果只想测试某一个，可以用cargo test name来测试具体的函数。 assert!(expr)：如果表达式为真就通过测试，否则 panic。 assert_eq!(v1, v2)：判别 v1 和 v2 是否相等。 如果只想在 debug 模式下检验是否相等，可以用 debug_assert! 和 debug_assert_eq!。 #[should_panic] 表示会 panic。或者返回Result\u0026lt;(), E\u0026gt;。 cargo build和cargo build --realse会跳过#[test]测试代码。 当运行 cargo test ，cargo 会编译两次代码。一次是常规的，还有一次是测试程序并启用测试套件。 #[cfg(test)]标记整个模块。 一般 cargo test 会启用多线程来一次运行多个测试，用 cargo test name 和 cargo test -- --test-threads 1来限制只用一个线程测试。 cargo test -- --no-capture：也输出那些通过的测试。 Integration Tests 集成测试，可以用来测试一些公共的API，站在用户的角度。 单独建立一个 tests的文件夹，放在和 src 同一个路径下，当运行 cargo test 的时候，集成测试和单元测试都会运行。如果只想运行集成测试，可以用命令cargo test --test unfurl来运行一个具体的集成测试。 Documentation 1 cargo doc --no-deps --open \u0026ndash;no-deps ：只生成自己的文档，不生成所有它依赖的 crates。 \u0026ndash;open：在浏览器中打开文档。 生成的文档放在 target/doc 目录下。 ///的文档注释类似#[doc]属性。而//!和#![doc]一样。 文档注释中markdown 的链接也可以链接到相应代码的文档。 One special feature of doc comments in Rust is that Markdown links can use Rust item paths, like leaves::Leaf, instead of relative URLs, to indicate what they refer to. 1 2 3 4 5 6 7 /// Create and return a [`VascularPath`] which represents the path of /// nutrients from the given [`Root`][r] to the given [`Leaf`](leaves::Leaf). /// /// [r]: roots::Root pub fn trace_path(leaf: \u0026amp;leaves::Leaf, root: \u0026amp;roots::Root) -\u0026gt; VascularPath { ... } You can also add search aliases to make it easier to find things using the built-in search feature.\n1 2 3 4 #[doc(alias = \u0026#34;route\u0026#34;)] pub struct VascularPath { ... } 文档中的代码：\n1 2 3 4 5 /// A block of code in a doc comment: /// ////\tif samples::everything().works() { ////\tprintln!(\u0026#34;ok\u0026#34;); ////\t} 或者用Markdown格式：\n1 2 3 4 5 6 7 /// Another snippet, the same code, but written differently: /// /// ``` /// if samples::everything().works() { /// println!(\u0026#34;ok\u0026#34;); /// } /// ``` Doc-Tests Rust 也会测试在文档注释中的代码，会隐式的加在 fn main() 函数里面。 The idea behind doc-tests is not to put all your tests into comments. Rather, you write the best possible documentation, and Rust makes sure the code samples in your documentation actually compile and run. To hide a line of a code sample, put a # followed by a space at the beginning of that line. rustdoc therefore treats any code block containing the exact string fn main as a complete program and doesn’t add anything to it. To tell Rust to compile your example, but stop short of actually running it, use a fenced code block with the no_run annotation. If the code isn’t even expected to compile, use ignore instead of no_run. Blocks marked with ignore don’t show up in the output of cargo run, but no_run tests show up as having passed if they compile. If the code block isn’t Rust code at all, use the name of the language, like c++ or sh, or text for plain text. Specifying Dependencies 用版本号：\n1 image = \u0026#34;0.6.1\u0026#34; Git仓库地址和修订版本号：\n1 image = { git = \u0026#34;https://github.com/Piston/image.git\u0026#34;, rev = \u0026#34;528f19c\u0026#34; } 可以指定使用哪个 rev、tag 或 branch。\n另一种方式是指定包含依赖包源代码的目录：\n1 image = { path = \u0026#34;vendor/image\u0026#34; } Versions 对于在 Cargo.toml 中写的 image = \u0026quot;0.6.1\u0026quot; ，Cargo 的解释并没有那么严格。它会使用与 0.6.1 版兼容的最新版本的 image 。\n兼容性的判断基本上遵循“语义化版本”的思想。\n以0.0开头的版本过于原始，Cargo不会假设它与任何其他版本兼容。 以0.x（基本x不是0）开头的版本，会被认为同其他以0.x开头的版本兼容。 如果项目达到1.0版，则只有新的主版本号才会破坏兼容性。 不同项目对依赖和版本有不同的需求。因此，指定版本时可以使用操作符。例如\u0026gt;、\u0026gt;=、\u0026lt;=。\n使用通配符*表示任何版本都可以，这个并不多见。\nCargo.lock 在第一次构建项目时，Cargo会输出一个Cargo.lock文件，记录它使用的每个包的确切的版本号。如果手动修改了Cargo.toml文件中的版本号或者运行cargo update时，会把新版本号保存到Cargo.lock文件中。\n对于保存在Git代码库的依赖也是类似的。\n如果你的项目是一个可执行文件，应该把Cargo.lock提交到版本控制系统。如果是一个普通的Rust库，就不用提交Cargo.lock了。如果恰好你的项目是一个共享库，没有这种下游的cargo用户，那就应该提供Cargo.lock。\nPublishing Crates to crates.io cargo package 让Cargo打包。会创建一个.crate文件，其中包含库的源文件以及Cargo.toml。\ncargo package --list可以查看其中包含什么文件。\n1 2 3 4 5 6 7 8 9 10 11 12 [package] name = \u0026#34;fern_sim\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2018\u0026#34; authors = [\u0026#34;You \u0026lt;you@example.com\u0026gt;\u0026#34;] license = \u0026#34;MIT\u0026#34; homepage = \u0026#34;https://fernsim.example.com/\u0026#34; repository = \u0026#34;https://gitlair.com/sporeador/fern_sim\u0026#34; documentation = \u0026#34;http://fernsim.example.com/docs\u0026#34; description = \u0026#34;\u0026#34;\u0026#34; Fern simulation, from the cellular level up. \u0026#34;\u0026#34;\u0026#34; 可以同时指定本地依赖和版本号，不过要保证二者同步：\n1 image = { path = \u0026#34;vendor/image\u0026#34;, version = \u0026#34;0.13.0\u0026#34; } 接着就是发布了：\n1 2 3 4 $ cargo login 5j0dV54BjlXBpUUbfIj7G9DvNl1vsWW1 $ cargo publish Updating registry `https://github.com/rust-lang/crates.io-index` Uploading fern_sim v0.1.0 (file:///.../fern_sim) Workspace 使用Cargo工作空间可以节省编译时间和磁盘空间。所谓工作空间，就是共享相同构建目录和Cargo.lock文件的一组包。\n要使用工作空间，只需在存储库的根目录下创建一个Cargo.toml文件，并把下面几行放进去：\n1 2 [workspace] members = [\u0026#34;fern_sim\u0026#34;, \u0026#34;fern_img\u0026#34;, \u0026#34;fern_video\u0026#34;] Here fern_sim etc. are the names of the subdirectories containing your crates. Delete any leftover Cargo.lock files and target directories that exist in those subdirectories.\nThe command cargo build --workspace builds all crates in the current workspace. cargo test and cargo doc accept the --workspace option as well.\nChapter 9. Structs Rust has three kinds of struct types, named-field, tuple-like, and unit-like, which differ in how you refer to their components: a named-field struct gives a name to each component, whereas a tuple- like struct identifies them by the order in which they appear. Unit-like structs have no components at all; these are not common, but more useful than you might think.\nNamed-Field Structs 1 2 3 4 5 /// A rectangle of eight-bit grayscale pixels. struct GrayscaleMap { pixels: Vec\u0026lt;u8\u0026gt;, size: (usize, usize) } 结构体的名字用驼峰命名法，其中的字段用蛇形拼写法。\nYou can use key: value syntax for some fields and shorthand for others in the same struct expression.\nTo access a struct’s fields, use the familiar . operator.\n可以将结构体设为pub，但是字段默认私有。这样可以通过一些公有的方法创建结构体或者修改它。\n使用.. EXPR，任何没有出现的字段都将从EXPR中取得自己的值，前提是EXPR必须为同一结构体类型的另一个值。\nTuple-Like Structs 类元组结构体：\n1 struct Bounds(usize, usize); 通过.操作符来访问。\n定义此结构体会隐式定义一个函数：\n1 fn Bounds(elem0: usize, elem1: usize) -\u0026gt; Bounds { ... } newtypes，即只包含一个要经过更严格类型检查的组件的结构体。\n1 struct Ascii(Vec\u0026lt;u8\u0026gt;); Unit-Like Structs 1 struct Onesuch; 这种类型的值不占任何内存，像()。\nRust doesn’t bother actually storing unit-like struct values in memory or generating code to operate on them, because it can tell everything it might need to know about the value from its type alone. But logically, an empty struct is a type with values like any other—or more precisely, a type of which there is only a single value.\nStruct Layout 1 2 3 4 struct GrayscaleMap { pixels: Vec\u0026lt;u8\u0026gt;, size: (usize, usize) } 一种可能的内存布局：\nRust不保证结构体的字段或元素在内存中会以某种顺序存储，但是保证把字段的值直接存储在结构体的内存块中。\nDefining Methods with impl Functions defined in an impl block are called associated functions, since they’re associated with a specific type. The opposite of an associated function is a free function, one that is not defined as an impl block’s item.\nself \u0026amp;self \u0026amp;mut self 当调用方法时，. 操作符会隐式转换，如果方法定义的是借用，就会隐式转换为引用。注意self会移动所有权。\nPassing Self as a Box, Rc, or Arc A method’s self argument can also be a Box\u0026lt;Self\u0026gt;, Rc\u0026lt;Self\u0026gt;, or Arc\u0026lt;Self\u0026gt;. Such a method can only be called on a value of the given pointer type. Calling the method passes ownership of the pointer to it.\n1 2 3 4 5 6 let mut bq = Box::new(Queue::new()); // `Queue::push` expects a `\u0026amp;mut Queue`, but `bq` is a `Box\u0026lt;Queue\u0026gt;`. // This is fine: Rust borrows a `\u0026amp;mut Queue` from the `Box` for the // duration of the call. bq.push(\u0026#39;■\u0026#39;); Rust automatically borrows a reference from pointer types like Box, Rc, and Arc, so \u0026amp;self and \u0026amp;mut self are almost always the right thing in a method signature, along with the occasional self.\n1 2 3 4 5 impl Node { fn append_to(self: Rc\u0026lt;Self\u0026gt;, parent: \u0026amp;mut Node) { parent.children.push(self); } } If the caller has an Rc\u0026lt;Node\u0026gt; at hand, it can call append_to directly, passing the Rc by value:\n1 2 let shared_node = Rc::new(Node::new(\u0026#34;first\u0026#34;)); shared_node.append_to(\u0026amp;mut parent); Again, for most methods, \u0026amp;self, \u0026amp;mut self, and self (by value) are all you need. But if a method’s purpose is to affect the ownership of the value, using other pointer types for self can be just the right thing.\nType-Associated Functions 1 2 3 4 5 impl Queue { pub fn new() -\u0026gt; Queue { Queue { older: Vec::new(), younger: Vec::new() } } } Separating a type’s methods from its definition may seem unusual, but there are several advantages to doing so:\nIt’s always easy to find a type’s data members. Pulling methods out into an impl block allows a single syntax for all three. In fact, Rust uses this same syntax for defining methods on types that are not structs at all, such as enum types and primitive types like i32. The same impl syntax also serves neatly for implementing traits, which we’ll go into in Chapter 11. Associated Consts 1 2 3 4 5 6 7 8 9 pub struct Vector2 { x: f32, y: f32, } impl Vector2 { const ZERO: Vector2 = Vector2 { x: 0.0, y: 0.0 }; const UNIT: Vector2 = Vector2 { x: 1.0, y: 0.0 }; } 使用：\n1 let scaled = Vector2::UNIT.scaled_by(2.0); // scaled_by() 方法需要自己定义，这里没有列出 Generic Structs 1 2 3 4 pub struct Queue\u0026lt;T\u0026gt; { older: Vec\u0026lt;T\u0026gt;, younger: Vec\u0026lt;T\u0026gt; } 相关方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 impl\u0026lt;T\u0026gt; Queue\u0026lt;T\u0026gt; { pub fn new() -\u0026gt; Queue\u0026lt;T\u0026gt; { Queue { older: Vec::new(), younger: Vec::new() } } pub fn push(\u0026amp;mut self, t: T) { self.younger.push(t); } pub fn is_empty(\u0026amp;self) -\u0026gt; bool { self.older.is_empty() \u0026amp;\u0026amp; self.younger.is_empty() } ... } 使用Self：\n1 2 3 pub fn new() -\u0026gt; Self { Queue { older: Vec::new(), younger: Vec::new() } } For associated function calls, you can supply the type parameter explicitly using the ::\u0026lt;\u0026gt; (turbofish) notation:\n1 let mut q = Queue::\u0026lt;char\u0026gt;::new(); Structs with Lifetime Parameters 1 2 3 4 5 6 7 8 9 10 fn find_extrema\u0026lt;\u0026#39;s\u0026gt;(slice: \u0026amp;\u0026#39;s [i32]) -\u0026gt; Extrema\u0026lt;\u0026#39;s\u0026gt; { let mut greatest = \u0026amp;slice[0]; let mut least = \u0026amp;slice[0]; for i in 1..slice.len() { if slice[i] \u0026lt; *least { least = \u0026amp;slice[i]; } if slice[i] \u0026gt; *greatest { greatest = \u0026amp;slice[i]; } } Extrema { greatest, least } } 当然这里生命周期参数也可以省略，因为可以根据三条规则进行推断。\nDeriving Common Traits for Struct Types 1 2 3 4 5 #[derive(Copy, Clone, Debug, PartialEq)] struct Point { x: f64, y: f64 } Interior Mutability 支持内部可变性，用Cell\u0026lt;T\u0026gt;和RefCell\u0026lt;T\u0026gt;，定义在std::cell模块中。\nCell\u0026lt;T\u0026gt;是只包含一个T类型私有值的结构体。Cell唯一特别的地方是不需要对其自身的mut引用，你也能取得或设置其私有字段的值。\nCell::new(value)：创建一个新Cell，将value转移到其中。 cell.get()：返回cell中值的副本。要求 cell 实现 Copy trait。 cell.set(value)：把value保存到cell，丢弃之间保存的值。 RefCell\u0026lt;T\u0026gt;是只包含一个T类型值的泛型类型。但与Cell不同，RefCell\u0026lt;T\u0026gt;支持借用它的T类型值的引用。\nRefCell::new(value)：创建一个新RefCell，将value转移到其中。 ref_cell.borrow()：返回一个Ref\u0026lt;T\u0026gt;，基本上是对 ref_cell 中值的共享引用。This method panics if the value is already mutably borrowed. ref_cell.borrow_mut(): Returns a RefMut\u0026lt;T\u0026gt;, essentially a mutable reference to the value in ref_cell. This method panics if the value is already borrowed. ref_cell.try_borrow(), ref_cell.try_borrow_mut() : Work just like borrow() and borrow_mut(), but return a Result. Instead of panicking if the value is already mutably borrowed, they return an Err value. This is a lot like how normal references work. The only difference is that normally, when you borrow a reference to a variable, Rust checks at compile time to ensure that you’re using the reference safely. If the checks fail, you get a compiler error. RefCell enforces the same rule using run-time checks. So if you’re breaking the rules, you get a panic (or an Err, for try_borrow and try_borrow_mut).\nThe other drawback is less obvious and more serious: cells—and any types that contain them—are not thread-safe.\n补充：参考RefCell 和内部可变性模式。\n因为 RefCell\u0026lt;T\u0026gt; 允许在运行时执行可变借用检查，所以我们可以在即便 RefCell\u0026lt;T\u0026gt; 自身是不可变的情况下修改其内部的值。 结构体是“与”的逻辑，而枚举是“或”的逻辑。\nChapter 10. Enums and Patterns Enums 1 2 3 4 5 enum Ordering { Less, Equal, Greater, } 这个是标准库中的，导入用use。也可以自己定义枚举，自己导入。\n1 2 3 4 5 6 7 enum Pet { Orca, Giraffe, ... } use self::Pet::*; In memory, values of C-style enums are stored as integers. Occasionally it’s useful to tell Rust which integers to use:\n1 2 3 4 5 6 enum HttpStatus { Ok = 200, NotModified = 304, NotFound = 404, ... } Otherwise Rust will assign the numbers for you, starting at 0.\nBy default, Rust stores C-style enums using the smallest built-in integer type that can accommodate them. Most fit in a single byte.\n#[repr]可以自己选择枚举的内存表示。\n可以将C式枚举转换为整数，但是反过来不可以。\n和结构体一样，可以给枚举加上属性，定义相关方法。\nEnums with Data 一个枚举可以同时包含三种变体：\n1 2 3 4 5 6 7 8 9 enum RelationshipStatus { Single, InARelationship, ItsComplicated(Option\u0026lt;String\u0026gt;), ItsExtremelyComplicated { car: DifferentialEquation, cdr: EarlyModernistPoem, }, } All constructors and fields of an enum share the same visibility as the enum itself.\nEnums in Memory 在内存中，带数据的每个构造式都需要一个小整数标签。\nRoughTime的每个构造式占用8个字节。\n为了方便优化，Rust并未对枚举的内存布局方式做出任何承诺。For instance, some generic structs can be stored without a tag at all, as we’ll see later.\nRich Data Structures Using Enums 1 2 3 4 5 6 7 8 9 10 use std::collections::HashMap; enum Json { Null, Boolean(bool), Number(f64), String(String), Array(Vec\u0026lt;Json\u0026gt;), Object(Box\u0026lt;HashMap\u0026lt;String, Json\u0026gt;\u0026gt;), } 内存布局：\n在内存中，Json类型的值占4个机器字。String和Vec值占3个机器字，Rust还会加一个标签字节。Null和Boolean值用不了那么多内存空间，但所有Json值的大小必须相同。\nBox\u0026lt;HashMap\u0026gt;只占一个机器字，因为它只是一个指向分配到堆内存数据的指针。\nGeneric Enums 1 2 3 4 5 6 7 8 9 enum Option\u0026lt;T\u0026gt; { None, Some(T), } enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } **如果类型T是引用或Box或其他智能指针类型，Rust就会省掉Option\u0026lt;T\u0026gt;的标签字段。**因此Option\u0026lt;Box\u0026lt;i32\u0026gt;\u0026gt;在内存中只用1个机器字节存储。0表示None，非零表示Some封装的值。\n1 2 3 4 5 6 7 8 9 10 11 12 // An ordered collection of `T`s. enum BinaryTree\u0026lt;T\u0026gt; { Empty, NonEmpty(Box\u0026lt;TreeNode\u0026lt;T\u0026gt;\u0026gt;), } // A part of a BinaryTree. struct TreeNode\u0026lt;T\u0026gt; { element: T, left: BinaryTree\u0026lt;T\u0026gt;, right: BinaryTree\u0026lt;T\u0026gt;, } 访问枚举数据唯一的方式是一种安全的方式：使用模式。\nPatterns 在枚举中不能直接通过.操作符访问枚举的字段。可以用match表达式来进行模式匹配。\n表达式产生值，模式消费值。\n模式匹配会从左到右对比模式的每个组件，依次检查当前值是否与之匹配。如果不匹配，就前进到下一个模式。\n模式类型 示例 说明 Literal Range Wildcard Variable ref variable Binding with subpattern Enum pattern Tuple pattern Array pattern Slice pattern Struct pattern Reference Multiple patterns `\u0026lsquo;a\u0026rsquo; \u0026lsquo;A\u0026rsquo;` Guard expression x if x * x \u0026lt;= r2 In match only (not valid in let, etc.) Literals, Variables, and Wildcards in Patterns 1 2 3 4 5 6 let calendar = match settings.get_string(\u0026#34;calendar\u0026#34;) { \u0026#34;gregorian\u0026#34; =\u0026gt; Calendar::Gregorian, \u0026#34;chinese\u0026#34; =\u0026gt; Calendar::Chinese, \u0026#34;ethiopian\u0026#34; =\u0026gt; Calendar::Ethiopian, other =\u0026gt; return parse_error(\u0026#34;calendar\u0026#34;, other), }; 可以使用通配符_。\n1 2 3 4 5 6 let caption = match photo.tagged_pet() { Pet::Tyrannosaur =\u0026gt; \u0026#34;RRRAAAAAHHHHHH\u0026#34;, Pet::Samoyed =\u0026gt; \u0026#34;*dog thoughts*\u0026#34;, _ =\u0026gt; \u0026#34;I\u0026#39;m cute, love me\u0026#34;, // generic caption, works for any pet }; 即便你非常确定其他情况不会发生，也必须至少加上一个后备的panic分支：\n1 2 3 4 5 6 7 8 // There are many Shapes, but we only support \u0026#34;selecting\u0026#34; // either some text, or everything in a rectangular area. // You can\u0026#39;t select an ellipse or trapezoid. match document.selection() { Shape::TextSpan(start, end) =\u0026gt; paint_text_selection(start, end), Shape::Rectangle(rect) =\u0026gt; paint_rect_selection(rect), _ =\u0026gt; panic!(\u0026#34;unexpected selection type\u0026#34;), } Tuple and Struct Patterns 元组模式匹配元组：\n1 2 3 4 5 6 7 8 9 10 11 fn describe_point(x: i32, y: i32) -\u0026gt; \u0026amp;\u0026#39;static str { use std::cmp::Ordering::*; match (x.cmp(\u0026amp;0), y.cmp(\u0026amp;0)) { (Equal, Equal) =\u0026gt; \u0026#34;at the origin\u0026#34;, (_, Equal) =\u0026gt; \u0026#34;on the x axis\u0026#34;, (Equal, _) =\u0026gt; \u0026#34;on the y axis\u0026#34;, (Greater, Greater) =\u0026gt; \u0026#34;in the first quadrant\u0026#34;, (Less, Greater) =\u0026gt; \u0026#34;in the second quadrant\u0026#34;, _ =\u0026gt; \u0026#34;somewhere else\u0026#34;, } } 结构体模式使用花括号：\n1 2 3 4 5 6 match balloon.location { Point { x: 0, y: height } =\u0026gt; println!(\u0026#34;straight up {} meters\u0026#34;, height), Point { x: x, y: y } =\u0026gt; println!(\u0026#34;at ({}m, {}m)\u0026#34;, x, y), } 在结构体模式匹配中，可以使用...来告诉Rust你并不关心其他字段：\n1 2 Some(Account { name, language, .. }) =\u0026gt; language.show_custom_greeting(name), Array and Slice Patterns 数组匹配：\n1 2 3 4 5 6 7 fn hsl_to_rgb(hsl: [u8; 3]) -\u0026gt; [u8; 3] { match hsl { [_, _, 0] =\u0026gt; [0, 0, 0], [_, _, 255] =\u0026gt; [255, 255, 255], ... } } 切片匹配：\n1 2 3 4 5 6 7 8 fn greet_people(names: \u0026amp;[\u0026amp;str]) { match names { [] =\u0026gt; { println!(\u0026#34;Hello, nobody.\u0026#34;) }, [a] =\u0026gt; { println!(\u0026#34;Hello, {}.\u0026#34;, a) }, [a, b] =\u0026gt; { println!(\u0026#34;Hello, {} and {}.\u0026#34;, a, b) }, [a, .., b] =\u0026gt; { println!(\u0026#34;Hello, everyone from {} to {}.\u0026#34;, a, b) } } } Reference Patterns 对于引用，Rust支持两种模式：ref模式和\u0026amp;模式。前者借用匹配值的元素，后者匹配引用。\n需要一种模式来借用而不move匹配的值。用关键字ref。\n1 2 3 4 5 6 match account { Account { ref name, ref language, .. } =\u0026gt; { ui.greet(name, language); ui.show_settings(\u0026amp;account); // ok } } 使用ref mut借用mut引用：\n1 2 3 4 5 6 7 match line_result { Err(ref err) =\u0026gt; log_error(err), // `err` is \u0026amp;Error (shared ref) Ok(ref mut line) =\u0026gt; { // `line` is \u0026amp;mut String (mut ref) trim_comments(line); // modify the String in place handle(line); } } 以\u0026amp;开头的模式匹配引用。\n1 2 3 match sphere.center() { \u0026amp;Point3d { x, y, z } =\u0026gt; ... // 这里 x, y, z 是值，实现了 Copy trait } 表达式和模式天生是相反的。表达式(x, y)用两个值创建一个新元组，模式(x, y)则相反：它匹配元组并破坏后取出两个值。对\u0026amp;而言也一样：表达式\u0026amp;创建引用，模式中的\u0026amp;匹配引用。匹配引用中，生命周期是必要条件。不能对共享引用采取mut操作。不能从引用（包括mut引用）中move出值。\n1 2 3 4 5 match friend.borrow_car() { Some(\u0026amp;Car { engine, .. }) =\u0026gt; // error: can\u0026#39;t move out of borrow 这里 engine 没有实现 Copy trait ... None =\u0026gt; {} } 修改：\n1 Some(\u0026amp;Car { ref engine, .. }) =\u0026gt; // ok, engine is a reference 可以使用\u0026amp;模式取得引用所指向的字符：\n1 2 3 4 match chars.peek() { // chars.peek() 返回 Option\u0026lt;\u0026amp;char\u0026gt; Some(\u0026amp;c) =\u0026gt; println!(\u0026#34;coming up: {:?}\u0026#34;, c), None =\u0026gt; println!(\u0026#34;end of chars\u0026#34;), } Match Guards 1 2 3 4 5 6 7 8 9 10 match point_to_hex(click) { None =\u0026gt; Err(\u0026#34;That\u0026#39;s not a game space.\u0026#34;), Some(hex) =\u0026gt; { if hex == current_hex { Err(\u0026#34;You are already there! You must click somewhere else\u0026#34;) } else { Ok(hex) } } } But Rust also provides match guards, extra conditions that must be true in order for a match arm to apply, written as if CONDITION, between the pattern and the arm’s =\u0026gt; token:\n1 2 3 4 5 6 match point_to_hex(click) { None =\u0026gt; Err(\u0026#34;That\u0026#39;s not a game space.\u0026#34;), Some(hex) if hex == current_hex =\u0026gt; Err(\u0026#34;You are already there! You must click somewhere else\u0026#34;), Some(hex) =\u0026gt; Ok(hex) } If the pattern matches, but the condition is false, matching continues with the next arm.\nMatching Multiple Possibilities 1 2 3 4 let at_end = match chars.peek() { Some(\u0026amp;\u0026#39;\\r\u0026#39;) | Some(\u0026amp;\u0026#39;\\n\u0026#39;) | None =\u0026gt; true, _ =\u0026gt; false, }; 或者\n1 2 3 4 5 6 match next_char { \u0026#39;0\u0026#39;..=\u0026#39;9\u0026#39; =\u0026gt; self.read_number(), \u0026#39;a\u0026#39;..=\u0026#39;z\u0026#39; | \u0026#39;A\u0026#39;..=\u0026#39;Z\u0026#39; =\u0026gt; self.read_word(), \u0026#39; \u0026#39; | \u0026#39;\\t\u0026#39; | \u0026#39;\\n\u0026#39; =\u0026gt; self.skip_whitespace(), _ =\u0026gt; self.handle_punctuation(), } Binding with @ Patterns x @ pattern匹配给定的 pattern，但成功之后，不是基于匹配值的元素来创建变量，而是把匹配值整个移动或复制到一个变量 x 中。\n1 2 3 rect @ Shape::Rect(..) =\u0026gt; { optimized_paint(\u0026amp;rect) } @ patterns are also useful with ranges:\n1 2 3 4 match chars.next() { Some(digit @ \u0026#39;0\u0026#39;..=\u0026#39;9\u0026#39;) =\u0026gt; read_number(digit, chars), ... }, Where Patterns Are Allowed The meaning is always the same: instead of just storing a value in a single variable, Rust uses pattern matching to take the value apart.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ...unpack a struct into three new local variables let Track { album, track_number, title, .. } = song; // ...unpack a function argument that\u0026#39;s a tuple fn distance_to((x, y): (f64, f64)) -\u0026gt; f64 { ... } // ...iterate over keys and values of a HashMap for (id, document) in \u0026amp;cache_map { println!(\u0026#34;Document #{}: {}\u0026#34;, id, document.title); } // ...automatically dereference an argument to a closure // (handy because sometimes other code passes you a reference // when you\u0026#39;d rather have a copy) let sum = numbers.fold(0, |a, \u0026amp;num| a + num); 上面的都是 irrefutable patterns，下面的是refutable pattern。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // ...handle just one enum variant specially if let RoughTime::InTheFuture(_, _) = user.date_of_birth() { user.set_time_traveler(true); } // ...run some code only if a table lookup succeeds if let Some(document) = cache_map.get(\u0026amp;id) { return send_cached_response(document); } // ...repeatedly try something until it succeeds while let Err(err) = present_cheesy_anti_robot_task() { log_robot_attempt(err); // let the user try again (it might still be a human) } // ...manually loop over an iterator while let Some(_) = lines.peek() { read_paragraph(\u0026amp;mut lines); } Populating a Binary Tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 enum BinaryTree\u0026lt;T\u0026gt; { Empty, NonEmpty(Box\u0026lt;TreeNode\u0026lt;T\u0026gt;\u0026gt;), } struct TreeNode\u0026lt;T\u0026gt; { element: T, left: BinaryTree\u0026lt;T\u0026gt;, right: BinaryTree\u0026lt;T\u0026gt;, } impl\u0026lt;T: Ord\u0026gt; BinaryTree\u0026lt;T\u0026gt; { fn add(\u0026amp;mut self, value: T) { match *self { BinaryTree::Empty =\u0026gt; *self = BinaryTree::NonEmpty(Box::new(TreeNode{ element: value, left: BinaryTree::Empty, right: BinaryTree::Empty, })), BinaryTree::NonEmpty(ref mut node) =\u0026gt; if value \u0026lt;= node.element { node.left.add(value); } else { node.right.add(value); } } } } fn main() { let mut tree = BinaryTree::Empty; tree.add(\u0026#34;Mercury\u0026#34;); tree.add(\u0026#34;Venus\u0026#34;); } Chapter 11. Traits and Generics Rust supports polymorphism with two related features: traits and generics.\nGenerics and traits are closely related: generic functions use traits in bounds to spell out what types of arguments they can be applied to. So we’ll also talk about how \u0026amp;mut dyn Write and \u0026lt;T: Write\u0026gt; are similar, how they’re different, and how to choose between these two ways of using traits.\nUsing Traits A value that implements std::io::Write can write out bytes. A value that implements std::iter::Iterator can produce a sequence of values. A value that implements std::clone::Clone can make clones of itself in memory. A value that implements std::fmt::Debug can be printed using println!() with the {:?} format specifier. trait本身必须在作用域中。否则，trait的所有方法都是隐藏的。\nBut since Rust makes you import the traits you plan to use, crates are free to take advantage of this superpower. To get a conflict, you’d have to import two traits that add a method with the same name to the same type. This is rare in practice. (If you do run into a conflict, you can spell out what you want using fully qualified method syntax, covered later in the chapter.)\nThe reason Clone and Iterator methods work without any special imports is that they’re always in scope by default: they’re part of the standard prelude, names that Rust automatically imports into every module.\nTrait Objects Rust doesn’t permit variables of type dyn Write:\n1 2 3 4 use std::io::Write; let mut buf: Vec\u0026lt;u8\u0026gt; = vec![]; let writer: dyn Write = buf; // error: `Write` does not have a constant size A variable’s size has to be known at compile time, and types that implement Write can be any size.\n1 2 let mut buf: Vec\u0026lt;u8\u0026gt; = vec![]; let writer: \u0026amp;mut dyn Write = \u0026amp;mut buf; // ok A reference to a trait type, like writer, is called a trait object. Like any other reference, a trait object points to some value, it has a lifetime, and it can be either mut or shared.\nTrait object layout In memory, a trait object is a fat pointer consisting of a pointer to the value, plus a pointer to a table representing that value’s type. Each trait object therefore takes up two machine words.\nIn Rust, as in C++, the vtable is generated once, at compile time, and shared by all objects of the same type. Everything shown in the darker shade in Figure 11-1, including the vtable, is a private implementation detail of Rust. Again, these aren’t fields and data structures that you can access directly. Instead, the language automatically uses the vtable when you call a method of a trait object, to determine which implementation to call.\nRust automatically converts ordinary references into trait objects when needed.\n1 2 let mut local_file = File::create(\u0026#34;hello.txt\u0026#34;)?; say_hello(\u0026amp;mut local_file)?; Likewise, Rust will happily convert a Box\u0026lt;File\u0026gt; to a Box\u0026lt;dyn Write\u0026gt;, a value that owns a writer in the heap:\n1 let w: Box\u0026lt;dyn Write\u0026gt; = Box::new(local_file); This kind of conversion is the only way to create a trait object. What the compiler is actually doing here is very simple. At the point where the conversion happens, Rust knows the referent’s true type (in this case, File), so it just adds the address of the appropriate vtable, turning the regular pointer into a fat pointer.\nGeneric Functions and Type Parameters 1 2 fn say_hello(out: \u0026amp;mut dyn Write) // plain function fn say_hello\u0026lt;W: Write\u0026gt;(out: \u0026amp;mut W) // generic function 1 2 3 4 fn say_hello\u0026lt;W: Write\u0026gt;(out: \u0026amp;mut W) // generic function say_hello(\u0026amp;mut local_file)?; // calls say_hello::\u0026lt;File\u0026gt; say_hello(\u0026amp;mut bytes)?; // calls say_hello::\u0026lt;Vec\u0026lt;u8\u0026gt;\u0026gt; This process is known as monomorphization, and the compiler handles it all automatically.\n1 2 3 // calling a generic method collect\u0026lt;C\u0026gt;() that takes no arguments let v1 = (0 .. 1000).collect(); // error: can\u0026#39;t infer type let v2 = (0 .. 1000).collect::\u0026lt;Vec\u0026lt;i32\u0026gt;\u0026gt;(); // ok 1 2 3 4 fn run_query\u0026lt;M, R\u0026gt;(data: \u0026amp;DataSet, map: M, reduce: R) -\u0026gt; Results where M: Mapper + Serialize, R: Reducer + Serialize { ... } 生命周期参数：\n1 2 3 4 5 6 7 /// Return a reference to the point in `candidates` that\u0026#39;s /// closest to the `target` point. fn nearest\u0026lt;\u0026#39;t, \u0026#39;c, P\u0026gt;(target: \u0026amp;\u0026#39;t P, candidates: \u0026amp;\u0026#39;c [P]) -\u0026gt; \u0026amp;\u0026#39;c P where P: MeasureDistance { ... } 生命周期不会对机器码有任何影响。\nAll the features introduced in this section—bounds, where clauses, lifetime parameters, and so forth—can be used on all generic items, not just functions.\nWhich to Use 1 2 3 4 5 6 7 trait Vegetable { ... } struct Salad\u0026lt;V: Vegetable\u0026gt; { veggies: Vec\u0026lt;V\u0026gt; } 沙拉结构体用泛型函数实现，但是只能放一种蔬菜。\n考虑到蔬菜值的大小可能差别比较大，不能直接用 Vec。\n1 2 3 4 struct Salad { veggies: Vec\u0026lt;dyn Vegetable\u0026gt; // error: `dyn Vegetable` does // not have a constant size } 可以这样实现：\n1 2 3 struct Salad { veggies: Vec\u0026lt;Box\u0026lt;dyn Vegetable\u0026gt;\u0026gt; } Another possible reason to use trait objects is to reduce the total amount of compiled code.\n那么在不考虑沙拉或者low-resource environments这两种情况下，选择泛型函数有三个优点：\nThe first advantage is speed. 会通过静态分发的方式，消除动态查找的时间。 The second advantage of generics is that not every trait can support trait objects. The third advantage of generics is that it’s easy to bound a generic type parameter with several traits at once, as our top_ten function did when it required its T parameter to implement Debug + Hash + Eq. Trait objects can’t do this: types like \u0026amp;mut (dyn Debug + Hash + Eq) aren’t supported in Rust. (You can work around this with subtraits, defined later in this chapter, but it’s a bit involved.) Defining and Implementing Traits 定义trait：\n1 2 3 4 5 6 7 8 /// A trait for characters, items, and scenery - /// anything in the game world that\u0026#39;s visible on screen. trait Visible { /// Render this object on the given canvas. fn draw(\u0026amp;self, canvas: \u0026amp;mut Canvas); /// Return true if clicking at (x, y) should /// select this object. fn hit_test(\u0026amp;self, x: i32, y: i32) -\u0026gt; bool; } 实现trait，用impl TraitName for Type。\nEverything defined in a trait impl must actually be a feature of the trait.\n不在trait里的辅助方法要单独放在impl Type里面实现。而且实现trait时也可以调用这个辅助方法。\nDefault Methods trait的默认实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 trait Write { fn write(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;usize\u0026gt;; fn flush(\u0026amp;mut self) -\u0026gt; Result\u0026lt;()\u0026gt;; fn write_all(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;()\u0026gt; { let mut bytes_written = 0; while bytes_written \u0026lt; buf.len() { bytes_written += self.write(\u0026amp;buf[bytes_written..])?; } Ok(()) } ... } Traits and Other People’s Types Rust lets you implement any trait on any type, as long as either the trait or the type is introduced in the current crate.\nThe sole purpose of this particular trait is to add a method to an existing type, char. This is called an extension trait.\n1 2 3 4 5 6 7 8 9 10 11 trait IsEmoji { fn is_emoji(\u0026amp;self) -\u0026gt; bool; } /// Implement IsEmoji for the built-in character type. impl IsEmoji for char { fn is_emoji(\u0026amp;self) -\u0026gt; bool { ... } } assert_eq!(\u0026#39;$\u0026#39;.is_emoji(), false); You can even use a generic impl block to add an extension trait to a whole family of types at once.\n1 2 3 4 5 6 /// You can write HTML to any std::io writer. impl\u0026lt;W: Write\u0026gt; WriteHtml for W { fn write_html(\u0026amp;mut self, html: \u0026amp;HtmlDocument) -\u0026gt; io::Result\u0026lt;()\u0026gt; { ... } } We said earlier that when you implement a trait, either the trait or the type must be new in the current crate. This is called the orphan rule. It helps Rust ensure that trait implementations are unique.\nSelf in Traits 1 2 3 4 pub trait Clone { fn clone(\u0026amp;self) -\u0026gt; Self; ... } Self作为返回类型意味着x.clone()的类型就是x的类型，不管具体什么类型。\n使用Self类型的trait与trait objects不能共存。\n1 2 3 4 5 6 7 8 9 pub trait Spliceable { fn splice(\u0026amp;self, other: \u0026amp;Self) -\u0026gt; Self; } // error: the trait `Spliceable` cannot be made into an object fn splice_anything(left: \u0026amp;dyn Spliceable, right: \u0026amp;dyn Spliceable) { let combo = left.splice(right); // ... } Rust rejects this code because it has no way to type-check the call left.splice(right). The whole point of trait objects is that the type isn’t known until run time. Rust has no way to know at compile time if left and right will be the same type, as required.\n1 2 3 pub trait MegaSpliceable { fn splice(\u0026amp;self, other: \u0026amp;dyn MegaSpliceable) -\u0026gt; Box\u0026lt;dyn MegaSpliceable\u0026gt;; } There’s no problem type-checking calls to this .splice() method because the type of the argument other is not required to match the type of self, as long as both types are MegaSpliceable.\nSubtraits 1 2 3 4 5 6 7 /// Someone in the game world, either the player or some other /// pixie, gargoyle, squirrel, ogre, etc. trait Creature: Visible { fn position(\u0026amp;self) -\u0026gt; (i32, i32); fn facing(\u0026amp;self) -\u0026gt; Direction; ... } Here, we say that Creature is a subtrait of Visible, and that Creature is Visible’s supertrait.\nBut in Rust, a subtrait does not inherit the associated items of its supertrait; each trait still needs to be in scope if you want to call its methods.\nIn fact, Rust’s subtraits are really just a shorthand for a bound on Self. A definition of Creature like this is exactly equivalent to the one shown earlier:\n1 2 3 trait Creature where Self: Visible { ... } Type-Associated Functions Traits can include type-associated functions, Rust’s analog to static methods:\n1 2 3 4 5 6 7 8 9 10 11 12 13 trait StringSet { /// Return a new empty set. fn new() -\u0026gt; Self; // 没有 self 参数 /// Return a set that contains all the strings in `strings`. fn from_slice(strings: \u0026amp;[\u0026amp;str]) -\u0026gt; Self; // 没有 self 参数 /// Find out if this set contains a particular `value`. fn contains(\u0026amp;self, string: \u0026amp;str) -\u0026gt; bool; /// Add a string to this set. fn add(\u0026amp;mut self, string: \u0026amp;str); } If you want to use \u0026amp;dyn StringSet trait objects, you must change the trait, adding the bound where Self: Sized to each associated function that doesn’t take a self argument by reference:\n1 2 3 4 5 6 7 8 9 10 11 trait StringSet { fn new() -\u0026gt; Self where Self: Sized; fn from_slice(strings: \u0026amp;[\u0026amp;str]) -\u0026gt; Self where Self: Sized; fn contains(\u0026amp;self, string: \u0026amp;str) -\u0026gt; bool; fn add(\u0026amp;mut self, string: \u0026amp;str); } With these additions, StringSet trait objects are allowed; they still don’t support new or from_slice, but you can create them and use them to call .contains() and .add().\nFully Qualified Method Calls 1 2 3 4 5 6 7 \u0026#34;hello\u0026#34;.to_string() str::to_string(\u0026#34;hello\u0026#34;) ToString::to_string(\u0026#34;hello\u0026#34;) \u0026lt;str as ToString\u0026gt;::to_string(\u0026#34;hello\u0026#34;) // a fully qualified method call With fully qualified calls, you can say exactly which method you mean, and that can help in a few odd cases:\nWhen two methods have the same name. 1 2 3 4 outlaw.draw(); // error: draw on screen or draw pistol? Visible::draw(\u0026amp;outlaw); // ok: draw on screen HasPistol::draw(\u0026amp;outlaw); // ok: corral When the type of the self argument can’t be inferred: 1 2 3 4 5 6 let zero = 0; // type unspecified; could be `i8`, `u8`, ... zero.abs(); // error: can\u0026#39;t call method `abs` // on ambiguous numeric type i64::abs(zero); // ok When using the function itself as a function value: 1 2 3 4 let words: Vec\u0026lt;String\u0026gt; = line.split_whitespace() // iterator produces \u0026amp;str values .map(ToString::to_string) // ok .collect(); When calling trait methods in macros. Traits That Define Relationships Between Types Traits can also be used in situations where there are multiple types that have to work together. They can describe relationships between types.\nAssociated Types (or How Iterators Work) 1 2 3 4 5 pub trait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; ... } The first feature of this trait, type Item;, is an associated type.\n1 2 3 4 5 6 use std::fmt::Debug; fn dump\u0026lt;I\u0026gt;(iter: I) where I: Iterator, I::Item: Debug { ... } trait object:\n1 2 3 4 5 fn dump(iter: \u0026amp;mut dyn Iterator\u0026lt;Item=String\u0026gt;) { for (index, s) in iter.enumerate() { println!(\u0026#34;{}: {:?}\u0026#34;, index, s); } } Generic Traits (or How Operator Overloading Works) 1 2 3 4 5 6 7 8 /// std::ops::Mul, the trait for types that support `*`. pub trait Mul\u0026lt;RHS\u0026gt; { /// The resulting type after applying the `*` operator type Output; /// The method for the `*` operator fn mul(self, rhs: RHS) -\u0026gt; Self::Output; } The type parameter here means the same thing that it means on a struct or function: Mul is a generic trait, and its instances Mul\u0026lt;f64\u0026gt;, Mul\u0026lt;String\u0026gt;, Mul\u0026lt;Size\u0026gt;, etc., are all different traits.\nGeneric traits get a special dispensation when it comes to the orphan rule: you can implement a foreign trait for a foreign type, so long as one of the trait’s type parameters is a type defined in the current crate.\n1 2 3 pub trait Mul\u0026lt;RHS=Self\u0026gt; { ... } The syntax RHS=Self means that RHS defaults to Self. If I write impl Mul for Complex, without specifying Mul’s type parameter, it means impl Mul\u0026lt;Complex\u0026gt; for Complex. In a bound, if I write where T: Mul, it means where T: Mul\u0026lt;T\u0026gt;.\nimpl Trait 1 2 3 4 5 6 use std::iter; use std::vec::IntoIter; fn cyclical_zip(v: Vec\u0026lt;u8\u0026gt;, u: Vec\u0026lt;u8\u0026gt;) -\u0026gt; iter::Cycle\u0026lt;iter::Chain\u0026lt;IntoIter\u0026lt;u8\u0026gt;, IntoIter\u0026lt;u8\u0026gt;\u0026gt;\u0026gt; { v.into_iter().chain(u.into_iter()).cycle() } 这种写法太繁琐，可以这样写：\n1 2 3 fn cyclical_zip(v: Vec\u0026lt;u8\u0026gt;, u: Vec\u0026lt;u8\u0026gt;) -\u0026gt; Box\u0026lt;dyn Iterator\u0026lt;Item=u8\u0026gt;\u0026gt; { Box::new(v.into_iter().chain(u.into_iter()).cycle()) } 但是这是动态分发，影响效率。可以使用 impl Trait。\n1 2 3 fn cyclical_zip(v: Vec\u0026lt;u8\u0026gt;, u: Vec\u0026lt;u8\u0026gt;) -\u0026gt; impl Iterator\u0026lt;Item=u8\u0026gt; { v.into_iter().chain(u.into_iter()).cycle() } 1 2 3 4 5 6 7 fn make_shape(shape: \u0026amp;str) -\u0026gt; impl Shape { match shape { \u0026#34;circle\u0026#34; =\u0026gt; Circle::new(), \u0026#34;triangle\u0026#34; =\u0026gt; Triangle::new(), // error: incompatible types \u0026#34;shape\u0026#34; =\u0026gt; Rectangle::new(), } } It’s important to note that Rust doesn’t allow trait methods to use impl Trait return values.\n1 2 3 4 5 6 7 fn print\u0026lt;T: Display\u0026gt;(val: T) { println!(\u0026#34;{}\u0026#34;, val); } fn print(val: impl Display) { println!(\u0026#34;{}\u0026#34;, val); } There is one important exception. Using generics allows callers of the function to specify the type of the generic arguments, like print::\u0026lt;i32\u0026gt;(42), while using impl Trait does not.\nAssociated Consts 1 2 3 4 trait Greet { const GREETING: \u0026amp;\u0026#39;static str = \u0026#34;Hello\u0026#34;; fn greet(\u0026amp;self) -\u0026gt; String; } 1 2 3 4 5 6 7 fn fib\u0026lt;T: Float + Add\u0026lt;Output=T\u0026gt;\u0026gt;(n: usize) -\u0026gt; T { match n { 0 =\u0026gt; T::ZERO, 1 =\u0026gt; T::ONE, n =\u0026gt; fib::\u0026lt;T\u0026gt;(n - 1) + fib::\u0026lt;T\u0026gt;(n - 2) } } Reverse-Engineering Bounds 和编译器做斗争，加上 Bounds。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std::ops::{Add, Mul}; fn dot\u0026lt;N\u0026gt;(v1: \u0026amp;[N], v2: \u0026amp;[N]) -\u0026gt; N where N: Add\u0026lt;Output=N\u0026gt; + Mul\u0026lt;Output=N\u0026gt; + Default + Copy { let mut total = N::default(); for i in 0 .. v1.len() { total = total + v1[i] * v2[i]; } total } #[test] fn test_dot() { assert_eq!(dot(\u0026amp;[1, 2, 3, 4], \u0026amp;[1, 1, 1, 1]), 10); assert_eq!(dot(\u0026amp;[53.0, 7.0], \u0026amp;[1.0, 5.0]), 88.0); } 或者用第三方库num。\n1 2 3 4 5 6 7 8 9 use num::Num; fn dot\u0026lt;N: Num + Copy\u0026gt;(v1: \u0026amp;[N], v2: \u0026amp;[N]) -\u0026gt; N { let mut total = N::zero(); for i in 0 .. v1.len() { total = total + v1[i] * v2[i]; } total } Rust为什么要这样设计呢？为什么不模仿“鸭子类型”？这样设计的优点是：\n可以让泛型代码具有向前兼容的能力。 你能通过编译器保存就知道要解决的麻烦在哪里。 或许，明确写出绑定最重要的好处是它们在代码和文档里都存在。 Traits as a Foundation Traits are one of the main organizing features in Rust, and with good reason. There’s nothing better to design a program or library around than a good interface.\nChapter 12. Operator Overloading The traits for operator overloading fall into a few categories depending on what part of the language they support.\n类别 Trait 操作符 Unary operators std::ops::Neg -x std::ops::Not !x Arithmetic operators std::ops::Add x + y std::ops::Sub x - y std::ops::Mul x * y std::ops::Div x / y std::ops::Rem x % y Bitwise operators std::ops::BitAnd x \u0026amp; y std::ops::BitOr `x std::ops::BitXor x ^ y std::ops::Shl x \u0026lt;\u0026lt; y std::ops::Shr x \u0026gt;\u0026gt; y Compound assignment std::ops::AddAssign x += y arithmetic operators std::ops::SubAssign x -= y std::ops::MulAssign x *= y std::ops::DivAssign x /= y std::ops::RemAssign x %= y Compound assignment std::ops::BitAddAssign x \u0026amp;= y bitwise operators std::ops::BitOrAssign `x std::ops::BitXorAssign x ^= y std::ops::ShlAssign x \u0026lt;\u0026lt;= y std::ops::ShrAssign x \u0026gt;\u0026gt;= y Comparison std::cmp::PartialEq x == y, x != y std::cmp::PartialOrd x \u0026lt; y, x \u0026lt;= y, x \u0026gt; y, x \u0026gt;= y Indexing std::ops::Index x[y]、\u0026amp;x[y] std::ops::IndexMut x[y] = z、\u0026amp;mut x[y] Arithmetic and Bitwise Operators std::ops::Add定义：\n1 2 3 4 trait Add\u0026lt;Rhs = Self\u0026gt; { type Output; fn add(self, rhs: Rhs) -\u0026gt; Self::Output; } 实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 use std::ops::Add; impl\u0026lt;T\u0026gt; Add for Complex\u0026lt;T\u0026gt; where T: Add\u0026lt;Output = T\u0026gt;, { type Output = Self; fn add(self, rhs: Self) -\u0026gt; Self { Complex { re: self.re + rhs.re, im: self.im + rhs.im, } } } 混合实现，加法的左边和右边不要求是同一类型：\n1 2 3 4 5 6 7 8 9 10 11 12 use std::ops::Add; impl\u0026lt;L, R\u0026gt; Add\u0026lt;Complex\u0026lt;R\u0026gt;\u0026gt; for Complex\u0026lt;L\u0026gt; where L: Add\u0026lt;R\u0026gt;, { type Output = Complex\u0026lt;L::Output\u0026gt;; fn add(self, rhs: Complex\u0026lt;R\u0026gt;) -\u0026gt; Self::Output { Complex { re: self.re + rhs.re, im: self.im + rhs.im, } } } Unary Operators Note that ! complements bool values and performs a bitwise complement (that is, flips the bits) when applied to integers; it plays the role of both the ! and ~ operators from C and C++.\n1 2 3 4 5 6 7 8 9 trait Neg { type Output; fn neg(self) -\u0026gt; Self::Output; } trait Not { type Output; fn not(self) -\u0026gt; Self::Output; } 复数的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 use std::ops::Neg; impl\u0026lt;T\u0026gt; Neg for Complex\u0026lt;T\u0026gt; where T: Neg\u0026lt;Output = T\u0026gt;, { type Output = Complex\u0026lt;T\u0026gt;; fn neg(self) -\u0026gt; Complex\u0026lt;T\u0026gt; { Complex { re: -self.re, im: -self.im, } } } Binary Operators All of Rust’s numeric types implement the arithmetic operators. Rust’s integer types and bool implement the bitwise operators. There are also implementations that accept references to those types as either or both operands.\nYou can use the + operator to concatenate a String with a \u0026amp;str slice or another String. However, Rust does not permit the left operand of + to be a \u0026amp;str, to discourage building up long strings by repeatedly concatenating small pieces on the left. (This performs poorly, requiring time quadratic in the final length of the string.)\nCompound Assignment Operators A compound assignment expression is one like x += y or x \u0026amp;= y: it takes two operands, performs some operation on them like addition or a bitwise AND, and stores the result back in the left operand. In Rust, the value of a compound assignment expression is always (), never the value stored.\nMany languages have operators like these and usually define them as shorthand for expressions like x = x + y or x = x \u0026amp; y. However, Rust doesn’t take that approach. Instead, x += y is shorthand for the method call x.add_assign(y), where add_assign is the sole method of the std::ops::AddAssign trait:\n1 2 3 trait AddAssign\u0026lt;Rhs = Self\u0026gt; { fn add_assign(\u0026amp;mut self, rhs: Rhs); } The built-in trait for a compound assignment operator is completely independent of the built-in trait for the corresponding binary operator.\nEquivalence Comparisons 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 pub trait PartialEq\u0026lt;Rhs: ?Sized = Self\u0026gt; { /// This method tests for `self` and `other` values to be equal, and is used /// by `==`. #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn eq(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool; /// This method tests for `!=`. #[inline] #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[default_method_body_is_const] fn ne(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { !self.eq(other) } } 用属性快速实现：\n1 2 3 4 #[derive(Clone, Copy, Debug, PartialEq)] struct Complex\u0026lt;T\u0026gt; { ... } Rust’s automatically generated implementation is essentially identical to our hand-written code, comparing each field or element of the type in turn.\nThis means that comparing non-Copy values like Strings, Vecs, or HashMaps doesn’t cause them to be moved, which would be troublesome:\n1 2 3 4 5 6 let s = \u0026#34;d\\x6fv\\x65t\\x61i\\x6c\u0026#34;.to_string(); let t = \u0026#34;\\x64o\\x76e\\x74a\\x69l\u0026#34;.to_string(); assert!(s == t); // s and t are only borrowed... // ... so they still have their values here. assert_eq!(format!(\u0026#34;{} {}\u0026#34;, s, t), \u0026#34;dovetail dovetail\u0026#34;); Why is this trait called PartialEq? The traditional mathematical definition of an equivalence relation, of which equality is one instance, imposes three requirements. For any values x and y:\n对称性：If x == y is true, then y == x must be true as well. In other words, swapping the two sides of an equality comparison doesn’t affect the result.\n传递性：If x == y and y == z, then it must be the case thatx == z. Given any chain of values, each equal to the next, each value in the chain is directly equal to every other. Equality is contagious.\n自反性：It must always be true that x == x.\nPartialEq只实现了前两条，自反性不保证，比如f32和f64就不满足。0.0/0.0会产生非数字的值NaN。\n1 2 3 4 5 6 7 8 assert!(f64::is_nan(0.0 / 0.0)); assert_eq!(0.0 / 0.0 == 0.0 / 0.0, false); assert_eq!(0.0 / 0.0 != 0.0 / 0.0, true); assert_eq!(0.0 / 0.0 \u0026lt; 0.0 / 0.0, false); assert_eq!(0.0 / 0.0 \u0026gt; 0.0 / 0.0, false); assert_eq!(0.0 / 0.0 \u0026lt;= 0.0 / 0.0, false); assert_eq!(0.0 / 0.0 \u0026gt;= 0.0 / 0.0, false); Eq Trait：\n1 trait Eq: PartialEq\u0026lt;Self\u0026gt; {} 也可以用属性来快速实现：\n1 2 3 4 #[derive(Clone, Copy, Debug, Eq, PartialEq)] struct Complex\u0026lt;T\u0026gt; { ... } Ordered Comparisons std::cmp::PartialOrd：\n1 2 3 4 5 6 7 8 9 10 11 trait PartialOrd\u0026lt;Rhs = Self\u0026gt;: PartialEq\u0026lt;Rhs\u0026gt; where Rhs: ?Sized, { fn partial_cmp(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; Option\u0026lt;Ordering\u0026gt;; fn lt(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { ... } fn le(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { ... } fn gt(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { ... } fn ge(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { ... } } 1 2 3 4 5 6 7 8 9 10 11 pub enum Ordering { /// An ordering where a compared value is less than another. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] Less = -1, /// An ordering where a compared value is equal to another. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] Equal = 0, /// An ordering where a compared value is greater than another. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] Greater = 1, } But if partial_cmp returns None, that means self and other are unordered with respect to each other: neither is greater than the other, nor are they equal. Among all of Rust’s primitive types, only comparisons between floating-point values ever return None: specifically, comparing a NaN (not-a-number) value with anything else returns None.\nIf you know that values of two types are always ordered with respect to each other, then you can implement the stricter std::cmp::Ord trait:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 pub trait Ord: Eq + PartialOrd\u0026lt;Self\u0026gt; { /// This method returns an [`Ordering`] between `self` and `other`. /// /// By convention, `self.cmp(\u0026amp;other)` returns the ordering matching the expression /// `self \u0026lt;operator\u0026gt; other` if true. /// /// # Examples /// /// ``` /// use std::cmp::Ordering; /// /// assert_eq!(5.cmp(\u0026amp;10), Ordering::Less); /// assert_eq!(10.cmp(\u0026amp;5), Ordering::Greater); /// assert_eq!(5.cmp(\u0026amp;5), Ordering::Equal); /// ``` #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn cmp(\u0026amp;self, other: \u0026amp;Self) -\u0026gt; Ordering; // ... } Almost all types that implement PartialOrd should also implement Ord. In the standard library, f32 and f64 are the only exceptions to this rule.\n排序应该同时实现 Partial Ord 和 Ord 。You might want to sort by upper bound, for instance, and it’s easy to do that with sort_by_key:\n1 intervals.sort_by_key(|i| i.upper); The Reverse wrapper type takes advantage of this by implementing Ord with a method that simply inverts any ordering.\n1 2 use std::cmp::Reverse; intervals.sort_by_key(|i| Reverse(i.lower)); Index and IndexMut On any other type, the expression a[i] is normally shorthand for *a.index(i), where index is a method of the std::ops::Index trait. However, if the expression is being assigned to or borrowed mutably, it’s instead shorthand for *a.index_mut(i), a call to the method of the std::ops::IndexMut trait.\n1 2 3 4 5 6 7 8 trait Index\u0026lt;Idx\u0026gt; { type Output: ?Sized; fn index(\u0026amp;self, index: Idx) -\u0026gt; \u0026amp;Self::Output; } trait IndexMut\u0026lt;Idx\u0026gt;: Index\u0026lt;Idx\u0026gt; { fn index_mut(\u0026amp;mut self, index: Idx) -\u0026gt; \u0026amp;mut Self::Output; } You can refer to a subslice with an expression like a[i..j] because they also implement Index\u0026lt;Range\u0026lt;usize\u0026gt;\u0026gt;. That expression is shorthand for:\n1 *a.index(std::ops::Range { start: i, end: j }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use std::collections::HashMap; let mut m = HashMap::new(); // HashMap\u0026lt;\u0026amp;str, i32\u0026gt;, 实现了 Index\u0026lt;\u0026amp;str\u0026gt; trait m.insert(\u0026#34;十\u0026#34;, 10); m.insert(\u0026#34;百\u0026#34;, 100); m.insert(\u0026#34;千\u0026#34;, 1000); m.insert(\u0026#34;万\u0026#34;, 1_0000); m.insert(\u0026#34;億\u0026#34;, 1_0000_0000); assert_eq!(m[\u0026#34;十\u0026#34;], 10); assert_eq!(m[\u0026#34;千\u0026#34;], 1000); // 等价于 use std::ops::Index; assert_eq!(*m.index(\u0026#34;十\u0026#34;), 10); assert_eq!(*m.index(\u0026#34;千\u0026#34;), 1000); The Index trait’s associated type Output specifies what type an indexing expression produces: for our HashMap, the Index implementation’s Output type is i32.\nRust automatically selects index_mut when the indexing expression occurs in a context where it’s necessary.\n1 2 3 4 let mut desserts = vec![\u0026#34;Howalon\u0026#34;.to_string(), \u0026#34;Soan papdi\u0026#34;.to_string()]; desserts[0].push_str(\u0026#34; (fictional)\u0026#34;); desserts[1].push_str(\u0026#34; (real)\u0026#34;); 后两行和下面的代码一样：\n1 2 use std::ops::IndexMut; (*desserts.index_mut(0)).push_str(\u0026#34; (fictional)\u0026#34;); (*desserts.index_mut(1)).push_str(\u0026#34; (real)\u0026#34;); One limitation of IndexMut is that, by design, it must return a mutable reference to some value.\nThe most common use of indexing is for collections.\nThis is how Index and IndexMut implementations are supposed to behave: out-of-bounds access is detected and causes a panic, the same as when you index an array, slice, or vector out of bounds.\nOther Operators Not all operators can be overloaded in Rust. As of Rust 1.50, the error-checking ? operator works only with Result and Option values, though work is in progress to expand this to user-defined types as well. Similarly, the logical operators \u0026amp;\u0026amp; and || are limited to Boolean values only. The .. and ..= operators always create a struct representing the range’s bounds, the \u0026amp; operator always borrows references, and the = operator always moves or copies values. None of them can be overloaded.\nRust does not support overloading the function call operator, f(x). Instead, when you need a callable value, you’ll typically just write a closure.\nChapter 13. Utility Traits Language extension traits\nDrop, Deref and DerefMut From and Into Marker traits\nSized Copy Public vocabulary traits\nDefault AsRef, AsMut, Borrow and BorrowMut TryFrom and TryInto ToOwned Trait Description Drop Destructors. Cleanup code that Rust runs automatically whenever a value is dropped. Sized Marker trait for types with a fixed size known at compile time, as opposed to types (such as slices) that are dynamically sized. Clone Types that support cloning values. Copy Marker trait for types that can be cloned simply by making a byte-for-byte copy of the memory containing the value. Deref and DerefMut Traits for smart pointer types. Default Types that have a sensible “default value.” AsRef and AsMut Conversion traits for borrowing one type of reference from another. Borrow and BorrowMut Conversion traits, like AsRef/AsMut, but additionally guaranteeing consistent hashing, ordering, and equality. From and Into Conversion traits for transforming one type of value into another. TryFrom and TryInto Conversion traits for transforming one type of value into another, for transformations that might fail. ToOwned Conversion trait for converting a reference to an owned value. Drop std::ops::Drop trait\n1 2 3 trait Drop { fn drop(\u0026amp;mut self); } This implicit invocation of drop is the only way to call that method; if you try to invoke it explicitly yourself, Rust flags that as an error.\nIf a variable’s value gets moved elsewhere, so that the variable is uninitialized when it goes out of scope, then Rust will not try to drop that variable: there is no value in it to drop. Although a value may be moved from place to place, Rust drops it only once.\nYou usually won’t need to implement std::ops::Drop unless you’re defining a type that owns resources Rust doesn’t already know about.\nIf a type implements Drop, it cannot implement the Copy trait. If a type is Copy, that means that simple byte-for-byte duplication is sufficient to produce an independent copy of the value. But it is typically a mistake to call the same drop method more than once on the same data.\nThe standard prelude includes a function to drop a value, drop, but its definition is anything but magical:\n1 fn drop\u0026lt;T\u0026gt;(_x: T) { } 从调用者那里获得所有权，然后什么也不做。Rust会在超出作用域时清楚_x的值，跟清除其他变量的值一样。\nSized A sized type is one whose values all have the same size in memory.\nAll sized types implement the std::marker::Sized trait, which has no methods or associated types. Rust implements it automatically for all types to which it applies; you can’t implement it yourself. The only use for Sized is as a bound for type variables: a bound like T: Sized requires T to be a type whose size is known at compile time. Traits of this sort are called marker traits, because the Rust language itself uses them to mark certain types as having characteristics of interest.\nRust can’t store unsized values in variables or pass them as arguments. You can only deal with them through pointers like \u0026amp;str or Box\u0026lt;dyn Write\u0026gt;, which themselves are sized.\nIn fact, this is necessary so often that it is the implicit default in Rust: if you write struct S\u0026lt;T\u0026gt; { ... }, Rust understands you to mean struct S\u0026lt;T: Sized\u0026gt; { ... }. If you do not want to constrain T this way, you must explicitly opt out, writing struct S\u0026lt;T: ?Sized\u0026gt; { ... }. The ?Sized syntax is specific to this case and means “not necessarily Sized.” For example, if you write struct S\u0026lt;T: ?Sized\u0026gt; { b: Box\u0026lt;T\u0026gt; }, then Rust will allow you to write S\u0026lt;str\u0026gt; and S\u0026lt;dyn Write\u0026gt;, where the box becomes a fat pointer, as well as S\u0026lt;i32\u0026gt; and S\u0026lt;String\u0026gt;, where the box is an ordinary pointer.\nAside from slices and trait objects, there is one more kind of unsized type. A struct type’s last field (but only its last) may be unsized, and such a struct is itself unsized.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;Rc\u0026#34;)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_insignificant_dtor] pub struct Rc\u0026lt;T: ?Sized\u0026gt; { ptr: NonNull\u0026lt;RcBox\u0026lt;T\u0026gt;\u0026gt;, phantom: PhantomData\u0026lt;RcBox\u0026lt;T\u0026gt;\u0026gt;, } // This is repr(C) to future-proof against possible field-reordering, which // would interfere with otherwise safe [into|from]_raw() of transmutable // inner types. #[repr(C)] struct RcBox\u0026lt;T: ?Sized\u0026gt; { strong: Cell\u0026lt;usize\u0026gt;, weak: Cell\u0026lt;usize\u0026gt;, value: T, } Clone std::clone::Clone\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 pub trait Clone: Sized { /// Returns a copy of the value. /// /// # Examples /// /// ``` /// # #![allow(noop_method_call)] /// let hello = \u0026#34;Hello\u0026#34;; // \u0026amp;str implements Clone /// /// assert_eq!(\u0026#34;Hello\u0026#34;, hello.clone()); /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[must_use = \u0026#34;cloning is often expensive and is not expected to have side effects\u0026#34;] fn clone(\u0026amp;self) -\u0026gt; Self; /// Performs copy-assignment from `source`. /// /// `a.clone_from(\u0026amp;b)` is equivalent to `a = b.clone()` in functionality, /// but can be overridden to reuse the resources of `a` to avoid unnecessary /// allocations. #[inline] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[default_method_body_is_const] #[cfg_attr(not(bootstrap), allow(drop_bounds))] // FIXME remove `~const Drop` and this attr when bumping fn clone_from(\u0026amp;mut self, source: \u0026amp;Self) where Self: ~const Drop + ~const Destruct, { *self = source.clone() } } clone_from方法将self修改为source的一个副本。这个方法的默认定义知识简单地克隆了source，然后将副本转移到*self中。语句s = t.clone();必须先克隆t，清除s原来的值，然后再将克隆的值转移到s中。这涉及一次堆分配和一次堆释放。在泛型代码中，应该尽可能使用clone_from，从而在可能的情况下应用这种优化。\n加上#[derive(Clone)]实现。\n没有实现Clone：std::sync::Mutex、stf::file::File（但是提供了一个try_clone()方法）。\nCopy A type is Copy if it implements the std::marker::Copy marker trait, which is defined as follows:\n1 2 3 pub trait Copy: Clone { // Empty. } But because Copy is a marker trait with special meaning to the language, Rust permits a type to implement Copy only if a shallow byte-for-byte copy is all it needs. Types that own any other resources, like heap buffers or operating system handles, cannot implement Copy. Any type that implements the Drop trait cannot be Copy. Rust presumes that if a type needs special cleanup code, it must also require special copying code and thus can’t be Copy.\nAs with Clone, you can ask Rust to derive Copy for you, using #[derive(Copy)]. You will often see both derived at once, with #[derive(Copy, Clone)].\nDeref and DerefMut std::ops::Deref\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #[lang = \u0026#34;deref\u0026#34;] #[doc(alias = \u0026#34;*\u0026#34;)] #[doc(alias = \u0026#34;\u0026amp;*\u0026#34;)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_diagnostic_item = \u0026#34;Deref\u0026#34;] pub trait Deref { /// The resulting type after dereferencing. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_diagnostic_item = \u0026#34;deref_target\u0026#34;] #[lang = \u0026#34;deref_target\u0026#34;] type Target: ?Sized; /// Dereferences the value. #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_diagnostic_item = \u0026#34;deref_method\u0026#34;] fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target; } std::ops::DerefMut\n1 2 3 4 5 6 7 8 #[lang = \u0026#34;deref_mut\u0026#34;] #[doc(alias = \u0026#34;*\u0026#34;)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] pub trait DerefMut: Deref { /// Mutably dereferences the value. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn deref_mut(\u0026amp;mut self) -\u0026gt; \u0026amp;mut Self::Target; } Since the methods return a reference with the same lifetime as \u0026amp;self, self remains borrowed for as long as the returned reference lives.\n由于deref接收\u0026amp;self引用并返回\u0026amp;Self::Target引用，因此Rust会利用这一点自动将前一种类型的引用转换为后一种类型的引用。换一句话说，如果插入一次deref调用可以防止类型错配，那Rust会为你插入一次。实现DerefMut可以实现对可修改引用的类型转换。这种类型转换称为解引用强制转型(deref coercion)，即一种类型被“强制”表现出另一种类型的行为。\n使用解引用强制类型转换很方便：\nRc\u0026lt;T\u0026gt;实现了Deref\u0026lt;Target=T\u0026gt; String实现了Deref\u0026lt;Target=str\u0026gt; Vec\u0026lt;T\u0026gt;实现了Deref\u0026lt;Target=[T]\u0026gt; 必要情况下，Rust会连续多次应用解引用强制转换。\nDeref和DerefMut trait的设计初衷是为了实现智能指针类型（如Box、Rc和Arc），以及某些频繁通过引用来使用的类型的所有者版本（如Vec\u0026lt;T\u0026gt;和String就是[T]和str的所有者版本）。\nRust通过应用解引用强制转换来解决类型冲突，但不会应用它来满足类型变量的绑定。\n1 2 use std::fmt::Display; fn show_it_generic\u0026lt;T: Display\u0026gt;(thing: T) { println!(\u0026#34;{}\u0026#34;, thing); } show_it_generic(\u0026amp;s); // error Rust不会在满足类型变量的绑定时应用解引用强制类型转换，所以检查失败。\n1 2 3 4 // 解决这个问题 show_it_generic(\u0026amp;s as \u0026amp;str); // Or show_it_generic(\u0026amp;*s); Default std::default::Default\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;Default\u0026#34;)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] pub trait Default: Sized { /// Returns the \u0026#34;default value\u0026#34; for a type. /// /// Default values are often some kind of initial value, identity value, or anything else that /// may make sense as a default. /// /// # Examples /// /// Using built-in default values: /// /// ``` /// let i: i8 = Default::default(); /// let (x, y): (Option\u0026lt;String\u0026gt;, f64) = Default::default(); /// let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default(); /// ``` /// /// Making your own: /// /// ``` /// # #[allow(dead_code)] /// enum Kind { /// A, /// B, /// C, /// } /// /// impl Default for Kind { /// fn default() -\u0026gt; Self { Kind::A } /// } /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn default() -\u0026gt; Self; } 1 2 3 4 5 6 7 use std::collections::HashSet; let squares = [4, 9, 16, 25, 36, 49, 64]; let (powers_of_two, impure): (HashSet\u0026lt;i32\u0026gt;, HashSet\u0026lt;i32\u0026gt;) = squares.iter().partition(|\u0026amp;n| n \u0026amp; (n-1) == 0); assert_eq!(powers_of_two.len(), 3); assert_eq!(impure.len(), 4); But of course, partition isn’t specific to HashSets; you can use it to produce any sort of collection you like, as long as the collection type implements Default, to produce an empty collection to start with, and Extend\u0026lt;T\u0026gt;, to add a T to the collection. String implements Default and Extend\u0026lt;char\u0026gt;, so you can write:\n1 2 3 4 let (upper, lower): (String, String) = \u0026#34;Great Teacher Onizuka\u0026#34;.chars().partition(|\u0026amp;c| c.is_uppercase()); assert_eq!(upper, \u0026#34;GTO\u0026#34;); assert_eq!(lower, \u0026#34;reat eacher nizuka\u0026#34;); Another common use of Default is to produce default values for structs that represent a large collection of parameters, most of which you won’t usually need to change.\n1 2 3 4 5 6 7 let params = glium::DrawParameters { line_width: Some(0.02), point_size: Some(0.02), .. Default::default() }; target.draw(..., \u0026amp;params).unwrap(); If a type T implements Default, then the standard library implements Default automatically for Rc\u0026lt;T\u0026gt;, Arc\u0026lt;T\u0026gt;, Box\u0026lt;T\u0026gt;, Cell\u0026lt;T\u0026gt;, RefCell\u0026lt;T\u0026gt;, Cow\u0026lt;T\u0026gt;, Mutex\u0026lt;T\u0026gt;, and RwLock\u0026lt;T\u0026gt;. The default value for the type Rc\u0026lt;T\u0026gt;, for example, is an Rc pointing to the default value for type T.\n如果元组类型的所有类型都实现了Default，且该该元组类型也实现了Default，那么这个元组默认会持有每个元素的默认值。\nRust does not implicitly implement Default for struct types, but if all of a struct’s fields implement Default, you can implement Default for the struct automatically using # [derive(Default)].\nAsRef and AsMut std::convert::AsRef\n1 2 3 4 5 6 7 #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;AsRef\u0026#34;)] pub trait AsRef\u0026lt;T: ?Sized\u0026gt; { /// Converts this type into a shared reference of the (usually inferred) input type. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn as_ref(\u0026amp;self) -\u0026gt; \u0026amp;T; } std::convert::RefMut\n1 2 3 4 5 6 7 #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;AsMut\u0026#34;)] pub trait AsMut\u0026lt;T: ?Sized\u0026gt; { /// Converts this type into a mutable reference of the (usually inferred) input type. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn as_mut(\u0026amp;mut self) -\u0026gt; \u0026amp;mut T; } So, for example, Vec\u0026lt;T\u0026gt; implements AsRef\u0026lt;[T]\u0026gt;, and String implements AsRef\u0026lt;str\u0026gt;. You can also borrow a String’s contents as an array of bytes, so String implements AsRef\u0026lt;[u8]\u0026gt; as well.\nBut this can’t be the whole story. A string literal is a \u0026amp;str, but the type that implements AsRef\u0026lt;Path\u0026gt; is str, without an \u0026amp;. And as we explained in “Deref and DerefMut”, Rust doesn’t try deref coercions to satisfy type variable bounds, so they won’t help here either.\nFortunately, the standard library includes the blanket implementation:\n1 2 3 4 5 6 7 8 impl\u0026lt;\u0026#39;a, T, U\u0026gt; AsRef\u0026lt;U\u0026gt; for \u0026amp;\u0026#39;a T where T: AsRef\u0026lt;U\u0026gt;, T: ?Sized, U: ?Sized { fn as_ref(\u0026amp;self) -\u0026gt; \u0026amp;U { (*self).as_ref() } } In other words, for any types T and U, if T: AsRef\u0026lt;U\u0026gt;, then \u0026amp;T: AsRef\u0026lt;U\u0026gt; as well: simply follow the reference and proceed as before.\nYou might assume that if a type implements AsRef, it should also implement AsMut. However, there are cases where this isn’t appropriate.\nBorrow and BorrowMut The std::borrow::Borrow trait is similar to AsRef: if a type implements Borrow\u0026lt;T\u0026gt;, then its borrow method efficiently borrows a \u0026amp;T from it. But Borrow imposes more restrictions: a type should implement Borrow only when a \u0026amp;T hashes and compares the same way as the value it’s borrowed from. (Rust doesn’t enforce this; it’s just the documented intent of the trait.) This makes Borrow valuable in dealing with keys in hash tables and trees or when dealing with values that will be hashed or compared for some other reason.\n1 2 3 4 5 6 #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_diagnostic_item = \u0026#34;Borrow\u0026#34;] pub trait Borrow\u0026lt;Borrowed: ?Sized\u0026gt; { #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn borrow(\u0026amp;self) -\u0026gt; \u0026amp;Borrowed; } Borrow is designed to address a specific situation with generic hash tables and other associative collection types.\n1 2 3 4 5 6 7 impl\u0026lt;K, V\u0026gt; HashMap\u0026lt;K, V\u0026gt; where K: Eq + Hash { fn get\u0026lt;Q: ?Sized\u0026gt;(\u0026amp;self, key: \u0026amp;Q) -\u0026gt; Option\u0026lt;\u0026amp;V\u0026gt; where K: Borrow\u0026lt;Q\u0026gt;, Q: Eq + Hash { ... } } Vec and [T: N] implement Borrow\u0026lt;[T]\u0026gt;. Every string-like type allows borrowing its corresponding slice type: String implements Borrow, PathBuf implements Borrow, and so on. And all the standard library’s associative collection types use Borrow to decide which types can be passed to their lookup functions.\nThe standard library includes a blanket implementation so that every type T can be borrowed from itself: T: Borrow. This ensures that \u0026amp;K is always an acceptable type for looking up entries in a HashMap\u0026lt;K, V\u0026gt;.\nstd::borrow::BorrowMut\n1 2 3 trait BorrowMut\u0026lt;Borrowed: ?Sized\u0026gt;: Borrow\u0026lt;Borrowed\u0026gt; { fn borrow_mut(\u0026amp;mut self) -\u0026gt; \u0026amp;mut Borrowed; } From and Into The std::convert::From and std::convert::Into traits represent conversions that consume a value of one type and return a value of another.\n1 2 3 4 5 6 trait Into\u0026lt;T\u0026gt;: Sized { fn into(self) -\u0026gt; T; } trait From\u0026lt;T\u0026gt;: Sized { fn from(other: T) -\u0026gt; Self; } The standard library automatically implements the trivial conversion from each type to itself: every type T implements From\u0026lt;T\u0026gt; and Into\u0026lt;T\u0026gt;.\nYou generally use Into to make your functions more flexible in the arguments they accept.\nThe from method serves as a generic constructor for producing an instance of a type from some other single value.\nGiven an appropriate From implementation, the standard library automatically implements the corresponding Into trait.\nHowever, cheap conversions are not part of Into and From’s contract. Whereas AsRef and AsMut conversions are expected to be cheap, From and Into conversions may allocate, copy, or otherwise process the value’s contents.\nThe ? operator uses From and Into to help clean up code in functions that could fail in multiple ways by automatically converting from specific error types to general ones when needed.\n1 2 3 4 5 6 type GenericError = Box\u0026lt;dyn std::error::Error + Send + Sync + \u0026#39;static\u0026gt;; type GenericResult\u0026lt;T\u0026gt; = Result\u0026lt;T, GenericError\u0026gt;; fn parse_i32_bytes(b: \u0026amp;[u8]) -\u0026gt; GenericResult\u0026lt;i32\u0026gt; Ok(std::str::from_utf8(b)?.parse::\u0026lt;i32\u0026gt;()?) }\t1 2 3 4 5 6 impl\u0026lt;\u0026#39;a, E: Error + Send + Sync + \u0026#39;a\u0026gt; From\u0026lt;E\u0026gt; for Box\u0026lt;dyn Error + Send + Sync + \u0026#39;a\u0026gt; { fn from(err: E) -\u0026gt; Box\u0026lt;dyn Error + Send + Sync + \u0026#39;a\u0026gt; { Box::new(err) } } From and Into are infallible traits—their API requires that conversions will not fail.\nTryFrom and TryInto Instead, i32 implements TryFrom. TryFrom and TryInto are the fallible cousins of From and Into and are similarly reciprocal; implementing TryFrom means that TryInto is implemented as well.\n1 2 3 4 5 6 7 8 9 pub trait TryFrom\u0026lt;T\u0026gt;: Sized { type Error; fn try_from(value: T) -\u0026gt; Result\u0026lt;Self, Self::Error\u0026gt;; } pub trait TryInto\u0026lt;T\u0026gt;: Sized { type Error; fn try_into(self) -\u0026gt; Result\u0026lt;T, Self::Error\u0026gt;; } Where From and Into relate types with simple conversions, TryFrom and TryInto extend the simplicity of From and Into conversions with the expressive error handling afforded by Result. These four traits can be used together to relate many types in a single crate.\nToOwned The std::borrow::ToOwned trait provides a slightly looser way to convert a reference to an owned value:\n1 2 3 4 trait ToOwned { type Owned: Borrow\u0026lt;Self\u0026gt;; fn to_owned(\u0026amp;self) -\u0026gt; Self::Owned; } Borrow and ToOwned at Work: The Humble Cow But in some cases you cannot decide whether to borrow or own until the program is running ; the std::borrow::Cow type (for “clone on write”) provides one way to do this.\n1 2 3 4 5 6 enum Cow\u0026lt;\u0026#39;a, B: ?Sized\u0026gt; where B: ToOwned { Borrowed(\u0026amp;\u0026#39;a B), Owned(\u0026lt;B as ToOwned\u0026gt;::Owned), } A Cow\u0026lt;B\u0026gt; either borrows a shared reference to a B or owns a value from which we could borrow such a reference. Since Cow implements Deref, you can call methods on it as if it were a shared reference to a B: if it’s Owned, it borrows a shared reference to the owned value; and if it’s Borrowed, it just hands out the reference it’s holding.\nYou can also get a mutable reference to a Cow’s value by calling its to_mut method, which returns a \u0026amp;mut B. If the Cow happens to be Cow::Borrowed, to_mut simply calls the reference’s to_owned method to get its own copy of the referent, changes the Cow into a Cow::Owned, and borrows a mutable reference to the newly owned value. This is the “clone on write” behavior the type’s name refers to.\nOne common use for Cow is to return either a statically allocated string constant or a computed string.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use std::path::PathBuf; use std::borrow::Cow; fn describe(error: \u0026amp;Error) -\u0026gt; Cow\u0026lt;\u0026#39;static, str\u0026gt; { match *error { Error::OutOfMemory =\u0026gt; \u0026#34;out of memory\u0026#34;.into(), Error::StackOverflow =\u0026gt; \u0026#34;stack overflow\u0026#34;.into(), Error::MachineOnFire =\u0026gt; \u0026#34;machine on fire\u0026#34;.into(), Error::Unfathomable =\u0026gt; \u0026#34;machine bewildered\u0026#34;.into(), Error::FileNotFound(ref path) =\u0026gt; { format!(\u0026#34;file not found: {}\u0026#34;, path.display()).into() } } } Chapter 14. Closures It’s more concise to write the helper function as a closure, an anonymous function expression:\n1 2 3 fn sort_cities(cities: \u0026amp;mut Vec\u0026lt;City\u0026gt;) { cities.sort_by_key(|city| - city.population); } Capturing Variables A closure can use data that belongs to an enclosing function.\n1 2 3 fn sort_cities(cities: \u0026amp;mut Vec\u0026lt;City\u0026gt;) { cities.sort_by_key(|city| - city.population); } Closures That Borrow In this case, when Rust creates the closure, it automatically borrows a reference to stat. It stands to reason: the closure refers to stat, so it must have a reference to it.\nIn short, Rust ensures safety by using lifetimes instead of garbage collection. Rust’s way is faster: even a fast GC allocation will be slower than storing stat on the stack, as Rust does in this case.\nClosures That Steal 1 2 3 4 5 6 7 8 9 10 fn start_sorting_thread(mut cities: Vec\u0026lt;City\u0026gt;, stat: Statistic) -\u0026gt; thread::JoinHandle\u0026lt;Vec\u0026lt;City\u0026gt;\u0026gt; { let key_fn = move |city: \u0026amp;City| -\u0026gt; i64 { -city.get_statistic(stat) }; thread::spawn(move || { cities.sort_by_key(key_fn); cities }) } The only thing we’ve changed is to add the move keyword before each of the two closures. The move keyword tells Rust that a closure doesn’t borrow the variables it uses: it steals them.\nRust thus offers two ways for closures to get data from enclosing scopes: moves and borrowing.\nWe get something important by accepting Rust’s strict rules: thread safety. It is precisely because the vector is moved, rather than being shared across threads, that we know the old thread won’t free the vector while the new thread is modifying it.\nFunction and Closure Types 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// Given a list of cities and a test function, /// return how many cities pass the test. fn count_selected_cities(cities: \u0026amp;Vec\u0026lt;City\u0026gt;, test_fn: fn(\u0026amp;City) -\u0026gt; bool) -\u0026gt; usize { let mut count = 0; for city in cities { if test_fn(city) { count += 1; } } count } /// An example of a test function. Note that the type of /// this function is `fn(\u0026amp;City) -\u0026gt; bool`, the same as /// the `test_fn` argument to `count_selected_cities`. fn has_monster_attacks(city: \u0026amp;City) -\u0026gt; bool { city.monster_attack_risk \u0026gt; 0.0 } // How many cities are at risk for monster attack? let n = count_selected_cities(\u0026amp;my_cities, has_monster_attacks); 1 2 3 4 5 6 7 8 9 10 fn count_selected_cities\u0026lt;F\u0026gt;(cities: \u0026amp;Vec\u0026lt;City\u0026gt;, test_fn: F) -\u0026gt; usize where F: Fn(\u0026amp;City) -\u0026gt; bool { let mut count = 0; for city in cities { if test_fn(city) { count += 1; } } count } 1 2 fn(\u0026amp;City) -\u0026gt; bool // fn type (functions only) Fn(\u0026amp;City) -\u0026gt; bool // Fn trait (both functions and closures) In fact, every closure you write has its own type, because a closure may contain data: values either borrowed or stolen from enclosing scopes. This could be any number of variables, in any combination of types. So every closure has an ad hoc type created by the compiler, large enough to hold that data. No two closures have exactly the same type. But every closure implements an Fn trait; the closure in our example implements Fn(\u0026amp;City) -\u0026gt; i64.\nClosure Performance As the figure shows, these closures don’t take up much space. But even those few bytes are not always needed in practice. Often, the compiler can inline all calls to a closure, and then even the small structs shown in this figure are optimized away.\nClosures and Safety Closures That Kill 1 2 3 4 5 let my_str = \u0026#34;hello\u0026#34;.to_string(); let f = || drop(my_str); f(); // ok f(); // error: use of moved value A closure that can be called only once may seem like a rather extraordinary thing, but we’ve been talking throughout this book about ownership and lifetimes. The idea of values being used up (that is, moved) is one of the core concepts in Rust. It works the same with closures as with everything else.\nFnOnce The first time you call a FnOnce closure, the closure itself is used up. It’s as though the two traits, Fn and FnOnce, were defined like this:\n1 2 3 4 5 6 7 8 // Pseudocode for `Fn` and `FnOnce` traits with no arguments. trait Fn() -\u0026gt; R { fn call(\u0026amp;self) -\u0026gt; R; } trait FnOnce() -\u0026gt; R { fn call_once(self) -\u0026gt; R; } Just as an arithmetic expression like a + b is shorthand for a method call, Add::add(a, b), Rust treats closure() as shorthand for one of the two trait methods shown in the preceding example. For an Fn closure, closure() expands to closure.call(). This method takes self by reference, so the closure is not moved. But if the closure is only safe to call once, then closure() expands to closure.call_once(). That method takes self by value, so the closure is used up.\nFnMut Therefore, Rust has one more category of closure, FnMut, the category of closures that write. FnMut closures are called by mut reference, as if they were defined like this:\n1 2 3 4 5 6 7 8 9 10 11 12 // Pseudocode for `Fn`, `FnMut`, and `FnOnce` traits. trait Fn() -\u0026gt; R { fn call(\u0026amp;self) -\u0026gt; R; } trait FnMut() -\u0026gt; R { fn call_mut(\u0026amp;mut self) -\u0026gt; R; } trait FnOnce() -\u0026gt; R { fn call_once(self) -\u0026gt; R; } Any closure that requires mut access to a value, but doesn’t drop any values, is an FnMut closure.\nFn is the family of closures and functions that you can call multiple times without restriction. This highest category also includes all fn functions. FnMut is the family of closures that can be called multiple times if the closure itself is declared mut. FnOnce is the family of closures that can be called once, if the caller owns the closure. Copy and Clone for Closures Just as Rust automatically figures out which closures can be called only once, it can figure out which closures can implement Copy and Clone, and which cannot.\nA non-move closure that doesn’t mutate variables holds only shared references, which are both Clone and Copy, so that closure is both Clone and Copy as well.\nOn the other hand, a non-move closure that does mutate values has mutable references within its internal representation. Mutable references are neither Clone nor Copy, so neither is a closure that uses them.\nFor a move closure, the rules are even simpler. If everything a move closure captures is Copy, it’s Copy. If everything it captures is Clone, it’s Clone.\nCallbacks Closures have unique types because each one captures different variables, so among other things, they’re each a different size. If they don’t capture anything, though, there’s nothing to store. By using fn pointers in functions that take callbacks, you can restrict a caller to use only these noncapturing closures, gaining some perfomance and flexibility within the code using callbacks at the cost of flexibility for the users of your API.\nUsing Closures Effectively MVC\n替代方案：\nChapter 15. Iterators 1 2 3 4 5 6 7 fn triangle(n: i32) -\u0026gt; i32 { let mut sum = 0; for i in 1..=n { sum += i; } sum } 这里1..=n是一个RangeInclusive\u0026lt;i32\u0026gt;的值。A RangeInclusive\u0026lt;i32\u0026gt; is an iterator that produces the integers from its start value to its end value (both inclusive), so you can use it as the operand of the for loop to sum the values from 1 to n.\n也可以用闭包写，更简洁和优雅：\n1 2 3 fn triangle(n: i32) -\u0026gt; i32 { (1..=n).fold(0, |sum, item| sum + item) } The Iterator and IntoIterator Traits std::iter::Iterator\n1 2 3 4 5 trait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; ... // many default methods } std::iter::IntoIterator\n1 2 3 4 5 trait IntoIterator where Self::IntoIter: Iterator\u0026lt;Item=Self::Item\u0026gt; { type Item; type IntoIter: Iterator; fn into_iter(self) -\u0026gt; Self::IntoIter; } 这个表示可迭代的，可以调用 into_iter() 方法产生一个迭代器。\n1 2 3 4 5 println!(\u0026#34;There\u0026#39;s:\u0026#34;); let v = vec![\u0026#34;antimony\u0026#34;, \u0026#34;arsenic\u0026#34;, \u0026#34;aluminum\u0026#34;, \u0026#34;selenium\u0026#34;]; for element in \u0026amp;v { println!(\u0026#34;{}\u0026#34;, element); } 等价于\n1 2 3 4 let mut iterator = (\u0026amp;v).into_iter(); while let Some(element) = iterator.next() { println!(\u0026#34;{}\u0026#34;, element); } Although a for loop always calls into_iter on its operand, you can also pass iterators to for loops directly; this occurs when you loop over a Range, for example. All iterators automatically implement IntoIterator, with an into_iter method that simply returns the iterator.\nCreating Iterators iter and iter_mut Methods Most collection types provide iter and iter_mut methods that return the natural iterators over the type, producing a shared or mutable reference to each item.\n1 2 3 4 5 6 7 8 let v = vec![4, 20, 12, 8, 6]; let mut iterator = v.iter(); assert_eq!(iterator.next(), Some(\u0026amp;4)); assert_eq!(iterator.next(), Some(\u0026amp;20)); assert_eq!(iterator.next(), Some(\u0026amp;12)); assert_eq!(iterator.next(), Some(\u0026amp;8)); assert_eq!(iterator.next(), Some(\u0026amp;6)); assert_eq!(iterator.next(), None); This iterator’s item type is \u0026amp;i32: each call to next produces a reference to the next element, until we reach the end of the vector.\nFor example, there is no iter method on the \u0026amp;str string slice type. Instead, if s is a \u0026amp;str, then s.bytes() returns an iterator that produces each byte of s, whereas s.chars() interprets the contents as UTF-8 and produces each Unicode character.\nIntoIterator Implementations Most collections actually provide several implementations of IntoIterator, for shared references (\u0026amp;T), mutable references (\u0026amp;mut T), and moves (T):\nGiven a shared reference to the collection, into_iter returns an iterator that produces shared references to its items. For example, in the preceding code, (\u0026amp;favorites).into_iter() would return an iterator whose Item type is \u0026amp;String. Given a mutable reference to the collection, into_iter returns an iterator that produces mutable references to the items. For example, if vector is some Vec, the call (\u0026amp;mut vector).into_iter() returns an iterator whose Item type is \u0026amp;mut String. When passed the collection by value, into_iter returns an iterator that takes ownership of the collection and returns items by value; the items’ ownership moves from the collection to the consumer, and the original collection is consumed in the process. For example, the call favorites.into_iter() in the preceding code returns an iterator that produces each string by value; the consumer receives ownership of each string. When the iterator is dropped, any elements remaining in the BTreeSet are dropped too, and the set’s now-empty husk is disposed of. The general principle is that iteration should be efficient and predictable, so rather than providing implementations that are expensive or could exhibit surprising behavior (for example, rehashing modified HashSet entries and potentially encountering them again later in the iteration), Rust omits them entirely.\n用在泛型上：\n1 2 3 4 5 6 7 8 9 10 use std::fmt::Debug; fn dump\u0026lt;T, U\u0026gt;(t: T) where T: IntoIterator\u0026lt;Item=U\u0026gt;, U: Debug { for u in t { println!(\u0026#34;{:?}\u0026#34;, u); } } from_fn and successors std::iter::from_fn\n1 2 3 4 5 6 7 8 pub fn from_fn\u0026lt;T, F\u0026gt;(f: F) -\u0026gt; FromFn\u0026lt;F\u0026gt; where F: FnMut() -\u0026gt; Option\u0026lt;T\u0026gt;, impl\u0026lt;T, F\u0026gt; Iterator for FromFn\u0026lt;F\u0026gt; where F: FnMut() -\u0026gt; Option\u0026lt;T\u0026gt;, type Item = T; 1 2 3 4 5 6 7 8 9 10 11 use rand::random; // In Cargo.toml dependencies: rand = \u0026#34;0.7\u0026#34; use std::iter::from_fn; // Generate the lengths of 1000 random line segments whose endpoints // are uniformly distributed across the interval [0, 1]. (This isn\u0026#39;t a // distribution you\u0026#39;re going to find in the `rand_distr` crate, but // it\u0026#39;s easy to make yourself.) let lengths: Vec\u0026lt;f64\u0026gt; = from_fn(|| Some((random::\u0026lt;f64\u0026gt;() - random::\u0026lt;f64\u0026gt;()).abs())) .take(1000) .collect(); If each item depends on the one before, std::iter::successors.\n1 2 3 4 5 6 7 8 pub fn successors\u0026lt;T, F\u0026gt;(first: Option\u0026lt;T\u0026gt;, succ: F) -\u0026gt; Successors\u0026lt;T, F\u0026gt;ⓘ where F: FnMut(\u0026amp;T) -\u0026gt; Option\u0026lt;T\u0026gt;, impl\u0026lt;T, F\u0026gt; Iterator for Successors\u0026lt;T, F\u0026gt; where F: FnMut(\u0026amp;T) -\u0026gt; Option\u0026lt;T\u0026gt;, type Item = T; 1 2 3 4 5 6 7 8 9 10 11 use num::Complex; use std::iter::successors; fn escape_time(c: Complex\u0026lt;f64\u0026gt;, limit: usize) -\u0026gt; Option\u0026lt;usize\u0026gt; { let zero = Complex { re: 0.0, im: 0.0 }; successors(Some(zero), |\u0026amp;z| { Some(z * z + c) }) .take(limit) .enumerate() .find(|(_i, z)| z.norm_sqr() \u0026gt; 4.0) .map(|(i, _z)| i) } 斐波那契数列\n1 2 3 4 5 6 7 8 9 10 fn fibonacci() -\u0026gt; impl Iterator\u0026lt;Item=usize\u0026gt; { let mut state = (0, 1); std::iter::from_fn(move || { state = (state.1, state.0 + state.1); Some(state.0) }) } assert_eq!(fibonacci().take(8).collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(), vec![1, 1, 2, 3, 5, 8, 13, 21]); drain Methods Many collection types provide a drain method that takes a mutable reference to the collection and returns an iterator that passes ownership of each element to the consumer. However, unlike the into_iter() method, which takes the collection by value and consumes it, drain merely borrows a mutable reference to the collection, and when the iterator is dropped, it removes any remaining elements from the collection and leaves it empty.\n1 2 3 4 use std::iter::FromIterator; let mut outer = \u0026#34;Earth\u0026#34;.to_string(); let inner = String::from_iter(outer.drain(1..4)); assert_eq!(outer, \u0026#34;Eh\u0026#34;); assert_eq!(inner, \u0026#34;art\u0026#34;); Other Iterator Sources 省略\nIterator Adapters map and filter The Iterator trait’s map adapter lets you transform an iterator by applying a closure to its items. The filter adapter lets you filter out items from an iterator, using a closure to decide which to keep and which to drop.\n1 2 3 4 5 let text = \u0026#34; ponies \\n giraffes\\niguanas \\nsquid\u0026#34;.to_string(); let v: Vec\u0026lt;\u0026amp;str\u0026gt; = text.lines() .map(str::trim) .collect(); assert_eq!(v, [\u0026#34;ponies\u0026#34;, \u0026#34;giraffes\u0026#34;, \u0026#34;iguanas\u0026#34;, \u0026#34;squid\u0026#34;]); 1 2 3 4 5 let text = \u0026#34; ponies \\n giraffes\\niguanas \\nsquid\u0026#34;.to_string(); let v: Vec\u0026lt;\u0026amp;str\u0026gt; = text.lines() .map(str::trim) .filter(|s| *s != \u0026#34;iguanas\u0026#34;) .collect(); assert_eq!(v, [\u0026#34;ponies\u0026#34;, \u0026#34;giraffes\u0026#34;, \u0026#34;squid\u0026#34;]); 1 2 3 4 5 6 7 // 标准库中返回的是 std::iter::Map fn map\u0026lt;B, F\u0026gt;(self, f: F) -\u0026gt; impl Iterator\u0026lt;Item=B\u0026gt; where Self: Sized, F: FnMut(Self::Item) -\u0026gt; B; // 标准库中返回的是 std::iter::Filter fn filter\u0026lt;P\u0026gt;(self, predicate: P) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized, P: FnMut(\u0026amp;Self::Item) -\u0026gt; bool; First, simply calling an adapter on an iterator doesn’t consume any items; it just returns a new iterator, ready to produce its own items by drawing from the first iterator as needed. In a chain of adapters, the only way to make any work actually get done is to call next on the final iterator.\nThe term “lazy” in the error message is not a disparaging term; it’s just jargon for any mechanism that puts off a computation until its value is needed. It is Rust’s convention that iterators should do the minimum work necessary to satisfy each call to next; in the example, there are no such calls at all, so no work takes place.\nThe second important point is that iterator adapters are a zero-overhead abstraction.\nfilter_map and flat_map 1 2 fn filter_map\u0026lt;B, F\u0026gt;(self, f: F) -\u0026gt; impl Iterator\u0026lt;Item=B\u0026gt; where Self: Sized, F: FnMut(Self::Item) -\u0026gt; Option\u0026lt;B\u0026gt;; 1 2 3 4 5 6 7 use std::str::FromStr; let text = \u0026#34;1\\nfrond .25 289\\n3.1415 estuary\\n\u0026#34;; for number in text .split_whitespace() .filter_map(|w| f64::from_str(w).ok()) { println!(\u0026#34;{:4.2}\u0026#34;, number.sqrt()); } 1 2 fn flat_map\u0026lt;U, F\u0026gt;(self, f: F) -\u0026gt; impl Iterator\u0026lt;Item=U::Item\u0026gt; where F: FnMut(Self::Item) -\u0026gt; U, U: IntoIterator; 1 2 3 4 5 6 7 8 use std::collections::HashMap; let mut major_cities = HashMap::new(); major_cities.insert(\u0026#34;Japan\u0026#34;, vec![\u0026#34;Tokyo\u0026#34;, \u0026#34;Kyoto\u0026#34;]); major_cities.insert(\u0026#34;The United States\u0026#34;, vec![\u0026#34;Portland\u0026#34;, \u0026#34;Nashville\u0026#34;]); major_cities.insert(\u0026#34;Brazil\u0026#34;, vec![\u0026#34;São Paulo\u0026#34;, \u0026#34;Brasília\u0026#34;]); major_cities.insert(\u0026#34;Kenya\u0026#34;, vec![\u0026#34;Nairobi\u0026#34;, \u0026#34;Mombasa\u0026#34;]); major_cities.insert(\u0026#34;The Netherlands\u0026#34;, vec![\u0026#34;Amsterdam\u0026#34;, \u0026#34;Utrecht\u0026#34;]); let countries = [\u0026#34;Japan\u0026#34;, \u0026#34;Brazil\u0026#34;, \u0026#34;Kenya\u0026#34;]; for \u0026amp;city in countries.iter().flat_map(|country| \u0026amp;major_cities[country]) { println!(\u0026#34;{}\u0026#34;, city); } 运行结果：\n1 2 3 4 5 6 Tokyo Kyoto São Paulo Brasília Nairobi Mombasa flatten 1 2 3 4 5 6 7 8 9 10 11 12 13 use std::collections::BTreeMap; // A table mapping cities to their parks: each value is a vector. let mut parks = BTreeMap::new(); parks.insert(\u0026#34;Portland\u0026#34;, vec![\u0026#34;Mt. Tabor Park\u0026#34;, \u0026#34;Forest Park\u0026#34;]); parks.insert(\u0026#34;Kyoto\u0026#34;, vec![\u0026#34;Tadasu-no-Mori Forest\u0026#34;, \u0026#34;Maruyama Koen\u0026#34;]); parks.insert(\u0026#34;Nashville\u0026#34;, vec![\u0026#34;Percy Warner Park\u0026#34;, \u0026#34;Dragon Park\u0026#34;]); // Build a vector of all parks. `values` gives us an iterator producing // vectors, and then `flatten` produces each vector\u0026#39;s elements in turn. let all_parks: Vec\u0026lt;_\u0026gt; = parks.values().flatten().cloned().collect(); assert_eq!(all_parks, vec![\u0026#34;Tadasu-no-Mori Forest\u0026#34;, \u0026#34;Maruyama Koen\u0026#34;, \u0026#34;Percy Warner Park\u0026#34;, \u0026#34;Dragon Park\u0026#34;, \u0026#34;Mt. Tabor Park\u0026#34;, \u0026#34;Forest Park\u0026#34;]); 1 2 fn flatten(self) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item::Item\u0026gt; where Self::Item: IntoIterator; take and take_while The Iterator trait’s take and take_while adapters let you end an iteration after a certain number of items or when a closure decides to cut things off.\n1 2 3 4 fn take(self, n: usize) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized; fn take_while\u0026lt;P\u0026gt;(self, predicate: P) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized, P: FnMut(\u0026amp;Self::Item) -\u0026gt; bool; 1 2 3 4 5 6 7 8 let message = \u0026#34;To: jimb\\r\\n\\ From: superego \u0026lt;editor@oreilly.com\u0026gt;\\r\\n\\ \\r\\n\\ Did you get any writing done today?\\r\\n\\ When will you stop wasting time plotting fractals?\\r\\n\u0026#34;; for header in message.lines().take_while(|l| !l.is_empty()) { println!(\u0026#34;{}\u0026#34; , header); } 结果：\n1 2 To: jimb From: superego \u0026lt;editor@oreilly.com\u0026gt; skip and skip_while The Iterator trait’s skip and skip_while methods are the complement of take and take_while: they drop a certain number of items from the beginning of an iteration, or drop items until a closure finds one acceptable, and then pass the remaining items through unchanged.\n1 2 3 4 fn skip(self, n: usize) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized; fn skip_while\u0026lt;P\u0026gt;(self, predicate: P) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized, P: FnMut(\u0026amp;Self::Item) -\u0026gt; bool; 1 2 3 4 5 for body in message.lines() .skip_while(|l| !l.is_empty()) .skip(1) { println!(\u0026#34;{}\u0026#34; , body); } 输出结果为：\n1 2 Did you get any writing done today? When will you stop wasting time plotting fractals? peekable A peekable iterator lets you peek at the next item that will be produced without actually consuming it. You can turn any iterator into a peekable iterator by calling the Iterator trait’s peekable method:\n1 2 fn peekable(self) -\u0026gt; std::iter::Peekable\u0026lt;Self\u0026gt; where Self: Sized; Here, Peekable\u0026lt;Self\u0026gt; is a struct that implements Iterator\u0026lt;Item=Self::Item\u0026gt;, and Self is the type of the underlying iterator.\nfuse fuse 适配器可以将任何适配器转换为第一次返回None之后始终继续返回None的迭代器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Flaky(bool); impl Iterator for Flaky { type Item = \u0026amp;\u0026#39;static str; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.0 { self.0 = false; Some(\u0026#34;totally the last item\u0026#34;) } else { self.0 = true; // D\u0026#39;oh! None } } } let mut flaky = Flaky(true); assert_eq!(flaky.next(), Some(\u0026#34;totally the last item\u0026#34;)); assert_eq!(flaky.next(), None); assert_eq!(flaky.next(), Some(\u0026#34;totally the last item\u0026#34;)); let mut not_flaky = Flaky(true).fuse(); assert_eq!(not_flaky.next(), Some(\u0026#34;totally the last item\u0026#34;)); assert_eq!(not_flaky.next(), None); assert_eq!(not_flaky.next(), None); Reversible Iterators and rev 从序列两端取得项。实现std::iter::DoubleEndedIterator trait。\n1 2 3 trait DoubleEndedIterator: Iterator { fn next_back(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; } 1 2 3 4 5 6 7 8 9 let bee_parts = [\u0026#34;head\u0026#34;, \u0026#34;thorax\u0026#34;, \u0026#34;abdomen\u0026#34;]; let mut iter = bee_parts.iter(); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;head\u0026#34;)); assert_eq!(iter.next_back(), Some(\u0026amp;\u0026#34;abdomen\u0026#34;)); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;thorax\u0026#34;)); assert_eq!(iter.next_back(), None); assert_eq!(iter.next(), None); If an iterator is double-ended, you can reverse it with the rev adapter:\n1 2 fn rev(self) -\u0026gt; impl Iterator\u0026lt;Item=Self\u0026gt; where Self: Sized + DoubleEndedIterator; The returned iterator is also double-ended: its next and next_back methods are simply exchanged:\n1 2 3 4 5 6 7 let meals = [\u0026#34;breakfast\u0026#34;, \u0026#34;lunch\u0026#34;, \u0026#34;dinner\u0026#34;]; let mut iter = meals.iter().rev(); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;dinner\u0026#34;)); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;lunch\u0026#34;)); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;breakfast\u0026#34;)); assert_eq!(iter.next(), None); inspect 1 2 3 4 5 6 let upper_case: String = \u0026#34;große\u0026#34;.chars() .inspect(|c| println!(\u0026#34;before: {:?}\u0026#34;, c)) .flat_map(|c| c.to_uppercase()) .inspect(|c| println!(\u0026#34; after: {:?}\u0026#34;, c)) .collect(); assert_eq!(upper_case, \u0026#34;GROSSE\u0026#34;); chain 将一个迭代器加到另一个迭代器后面。\n1 2 fn chain\u0026lt;U\u0026gt;(self, other: U) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized, U: IntoIterator\u0026lt;Item=Self::Item\u0026gt;; In other words, you can chain an iterator together with any iterable that produces the same item type.\n1 2 let v: Vec\u0026lt;i32\u0026gt; = (1..4).chain(vec![20, 30, 40]).collect(); assert_eq!(v, [1, 2, 3, 20, 30, 40]); enumerate 1 2 3 4 for (i, band) in bands.into_iter().enumerate() { let top = band_rows * i; // start a thread to render rows `top..top + band_rows` ... } You can think of the (index, item) pairs that enumerate produces as analogous to the (key, value) pairs that you get when iterating over a HashMap or other associative collection. If you’re iterating over a slice or vector, the index is the “key” under which the item appears.\nzip The zip adapter combines two iterators into a single iterator that produces pairs holding one value from each iterator, like a zipper joining its two sides into a single seam. The zipped iterator ends when either of the two underlying iterators ends.\n1 2 let v: Vec\u0026lt;_\u0026gt; = (0..).zip(\u0026#34;ABCD\u0026#34;.chars()).collect(); assert_eq!(v, vec![(0, \u0026#39;A\u0026#39;), (1, \u0026#39;B\u0026#39;), (2, \u0026#39;C\u0026#39;), (3, \u0026#39;D\u0026#39;)]); The argument to zip doesn’t need to be an iterator itself; it can be any iterable:\n1 2 3 4 5 6 7 8 9 use std::iter::repeat; let endings = vec![\u0026#34;once\u0026#34;, \u0026#34;twice\u0026#34;, \u0026#34;chicken soup with rice\u0026#34;]; let rhyme: Vec\u0026lt;_\u0026gt; = repeat(\u0026#34;going\u0026#34;) .zip(endings) .collect(); assert_eq!(rhyme, vec![(\u0026#34;going\u0026#34;, \u0026#34;once\u0026#34;), (\u0026#34;going\u0026#34;, \u0026#34;twice\u0026#34;), (\u0026#34;going\u0026#34;, \u0026#34;chicken soup with rice\u0026#34;)]); by_ref An iterator’s by_ref method borrows a mutable reference to the iterator so that you can apply adapters to the reference. When you’re done consuming items from these adapters, you drop them, the borrow ends, and you regain access to your original iterator.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let message = \u0026#34;To: jimb\\r\\n\\ From: id\\r\\n\\ \\r\\n\\ Oooooh, donuts!!\\r\\n\u0026#34;; let mut lines = message.lines(); println!(\u0026#34;Headers:\u0026#34;); for header in lines.by_ref().take_while(|l| !l.is_empty()) { println!(\u0026#34;{}\u0026#34; , header); } println!(\u0026#34;\\nBody:\u0026#34;); for body in lines { println!(\u0026#34;{}\u0026#34; , body); } cloned, copied The cloned adapter takes an iterator that produces references and returns an iterator that produces values cloned from those references, much like iter.map(|item| item.clone()). Naturally, the referent type must implement Clone.\n1 2 3 4 let a = [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;∞\u0026#39;]; assert_eq!(a.iter().next(), Some(\u0026amp;\u0026#39;1\u0026#39;)); assert_eq!(a.iter().cloned().next(), Some(\u0026#39;1\u0026#39;)); The copied adapter is the same idea, but more restrictive: the referent type must implement Copy. A call like iter.copied() is roughly the same as iter.map(|r| *r).\ncycle The cycle adapter returns an iterator that endlessly repeats the sequence produced by the underlying iterator. The underlying iterator must implement std::clone::Clone so that cycle can save its initial state and reuse it each time the cycle starts again.\n1 2 3 4 5 6 7 8 let dirs = [\u0026#34;North\u0026#34;, \u0026#34;East\u0026#34;, \u0026#34;South\u0026#34;, \u0026#34;West\u0026#34;]; let mut spin = dirs.iter().cycle(); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;North\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;East\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;South\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;West\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;North\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;East\u0026#34;)); Consuming Iterators Simple Accumulation: count, sum, product 1 2 3 4 5 6 7 8 9 10 fn count(self) -\u0026gt; usize where Self: Sized, { self.fold( 0, #[rustc_inherit_overflow_checks] |count, _| count + 1, ) } The count method draws items from an iterator until it returns None and tells you how many it got.\nThe sum and product methods compute the sum or product of the iterator’s items, which must be integers or floating-point numbers.\nmax, min std::iter::Iterator\n1 2 3 4 5 6 7 fn max(self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, Self::Item: Ord, { self.max_by(Ord::cmp) } max_by, min_by 1 2 3 4 fn max_by\u0026lt;F\u0026gt;(self, compare: F) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, F: FnMut(\u0026amp;Self::Item, \u0026amp;Self::Item) -\u0026gt; Ordering, 1 2 3 4 5 6 7 8 9 10 11 12 13 use std::cmp::Ordering; // Compare two f64 values. Panic if given a NaN. fn cmp(lhs: \u0026amp;f64, rhs: \u0026amp;f64) -\u0026gt; Ordering { lhs.partial_cmp(rhs).unwrap() } let numbers = [1.0, 4.0, 2.0]; assert_eq!(numbers.iter().copied().max_by(cmp), Some(4.0)); assert_eq!(numbers.iter().copied().min_by(cmp), Some(1.0)); let numbers = [1.0, 4.0, std::f64::NAN, 2.0]; assert_eq!(numbers.iter().copied().max_by(cmp), Some(4.0)); // panics max_by_key, min_by_key 1 2 3 4 5 6 7 8 9 fn max_by_key\u0026lt;B: Ord, F\u0026gt;(self, f: F) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, F: FnMut(\u0026amp;Self::Item) -\u0026gt; B, fn min_by_key\u0026lt;B: Ord, F\u0026gt;(self, f: F) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, F: FnMut(\u0026amp;Self::Item) -\u0026gt; B, 1 2 3 4 5 6 7 8 9 10 11 12 13 use std::collections::HashMap; let mut populations = HashMap::new(); populations.insert(\u0026#34;Portland\u0026#34;, 583_776); populations.insert(\u0026#34;Fossil\u0026#34;, 449); populations.insert(\u0026#34;Greenhorn\u0026#34;, 2); populations.insert(\u0026#34;Boring\u0026#34;, 7_762); populations.insert(\u0026#34;The Dalles\u0026#34;, 15_340); assert_eq!(populations.iter().max_by_key(|\u0026amp;(_name, pop)| pop), Some((\u0026amp;\u0026#34;Portland\u0026#34;, \u0026amp;583_776))); assert_eq!(populations.iter().min_by_key(|\u0026amp;(_name, pop)| pop), Some((\u0026amp;\u0026#34;Greenhorn\u0026#34;, \u0026amp;2))); Comparing Item Sequences Iterators provide the eq and ne methods for equality comparisons, and lt, le, gt, and ge methods for ordered comparisons. The cmp and partial_cmp methods behave like the corresponding methods of the Ord and PartialOrd traits.\nany and all 1 2 3 4 5 6 7 8 9 fn any\u0026lt;F\u0026gt;(\u0026amp;mut self, f: F) -\u0026gt; bool where Self: Sized, F: FnMut(Self::Item) -\u0026gt; bool, fn all\u0026lt;F\u0026gt;(\u0026amp;mut self, f: F) -\u0026gt; bool where Self: Sized, F: FnMut(Self::Item) -\u0026gt; bool, position, rposition, and ExactSizeIterator The position method applies a closure to each item from the iterator and returns the index of the first item for which the closure returns true.\nThe rposition method is the same, except that it searches from the right.\n1 2 3 4 fn rposition\u0026lt;P\u0026gt;(\u0026amp;mut self, predicate: P) -\u0026gt; Option\u0026lt;usize\u0026gt; where P: FnMut(Self::Item) -\u0026gt; bool, Self: ExactSizeIterator + DoubleEndedIterator, 1 2 3 4 trait ExactSizeIterator: Iterator { fn len(\u0026amp;self) -\u0026gt; usize { ... } // 返回剩余项数 fn is_empty(\u0026amp;self) -\u0026gt; bool { ... }\t// 在迭代完成时返回 true } fold and rfold 1 2 3 4 fn fold\u0026lt;B, F\u0026gt;(self, init: B, f: F) -\u0026gt; B where Self: Sized, F: FnMut(B, Self::Item) -\u0026gt; B, fold方法是一个通用工具，可以对迭代器产生项的整个序列执行某些累计操作。这个方法接收一个名为累加器的初始值和一个闭包，然后对当前累加器和迭代器的下一项重复应用闭包。每次闭包的返回值都会成为累加器的新值，然后再和迭代器的下一项一块传给闭包。累加器的最终值也是fold方法返回的值。如果序列是空的，则fold返回累加器的初始值。\n1 2 3 4 5 let a = [5, 6, 7, 8, 9, 10]; assert_eq!(a.iter().fold(0, |n, _| n+1), 6); // count assert_eq!(a.iter().fold(0, |n, i| n+i), 45); // sum assert_eq!(a.iter().fold(1, |n, i| n*i), 151200);\t// product assert_eq!(a.iter().cloned().fold(i32::min_value(), std::cmp::max), 10); // max 累加器的值会转移到闭包中再转移出来，因此可以对非Copy类型的累加器使用fold：\n1 2 3 4 5 6 7 8 let a = [\u0026#34;Pack\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;box\u0026#34;, \u0026#34;with\u0026#34;, \u0026#34;five\u0026#34;, \u0026#34;dozen\u0026#34;, \u0026#34;liquor\u0026#34;, \u0026#34;jugs\u0026#34;]; // See also: the `join` method on slices, which won\u0026#39;t // give you that extra space at the end. let pangram = a.iter() .fold(String::new(), |s, w| s + w + \u0026#34; \u0026#34;); assert_eq!(pangram, \u0026#34;Pack my box with five dozen liquor jugs \u0026#34;); The rfold method is the same as fold, except that it requires a double-ended iterator, and processes its items from last to first.\ntry_fold and try_rfold The try_fold method is the same as fold, except that the process of iteration can exit early, without consuming all the values from the iterator. The closure you pass to try_fold must return a Result: if it returns Err(e), try_fold returns immediately with Err(e) as its value. Otherwise, it continues folding with the success value. The closure can also return an Option: returning None exits early, and the result is an Option of the folded value.\n1 2 3 4 5 fn try_fold\u0026lt;B, F, R\u0026gt;(\u0026amp;mut self, init: B, f: F) -\u0026gt; R where Self: Sized, F: FnMut(B, Self::Item) -\u0026gt; R, R: Try\u0026lt;Output = B\u0026gt;, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use std::error::Error; use std::io::prelude::*; use std::str::FromStr; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn Error\u0026gt;\u0026gt; { let stdin = std::io::stdin(); let sum = stdin.lock() .lines() .try_fold(0, |sum, line| -\u0026gt; Result\u0026lt;u64, Box\u0026lt;dyn Error\u0026gt;\u0026gt; { Ok(sum + u64::from_str(\u0026amp;line?.trim())?) })?; println!(\u0026#34;{}\u0026#34;, sum); Ok(()) } 1 2 3 4 5 6 7 8 fn all\u0026lt;P\u0026gt;(\u0026amp;mut self, mut predicate: P) -\u0026gt; bool where P: FnMut(Self::Item) -\u0026gt; bool, Self: Sized { self.try_fold((), |_, item| { if predicate(item) { Some(()) } else { None } }).is_some() } nth, nth_back 1 fn nth(\u0026amp;mut self, n: usize) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; last 1 fn last(self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; This consumes all the iterator’s items starting from the front, even if the iterator is reversible. If you have a reversible iterator and don’t need to consume all its items, you should instead just write iter.next_back().\nfind, rfind, and find_map 1 2 3 4 fn find\u0026lt;P\u0026gt;(\u0026amp;mut self, predicate: P) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, P: FnMut(\u0026amp;Self::Item) -\u0026gt; bool, 1 2 3 4 assert_eq!(populations.iter().find(|\u0026amp;(_name, \u0026amp;pop)| pop \u0026gt; 1_000_000), None); assert_eq!(populations.iter().find(|\u0026amp;(_name, \u0026amp;pop)| pop \u0026gt; 500_000), Some((\u0026amp;\u0026#34;Portland\u0026#34;, \u0026amp;583_776))); 1 2 3 4 fn find_map\u0026lt;B, F\u0026gt;(\u0026amp;mut self, f: F) -\u0026gt; Option\u0026lt;B\u0026gt; where Self: Sized, F: FnMut(Self::Item) -\u0026gt; Option\u0026lt;B\u0026gt;, Building Collections: collect and FromIterator 1 2 3 4 5 6 fn collect\u0026lt;B: FromIterator\u0026lt;Self::Item\u0026gt;\u0026gt;(self) -\u0026gt; B where Self: Sized, { FromIterator::from_iter(self) } 1 2 3 trait FromIterator\u0026lt;A\u0026gt;: Sized { fn from_iter\u0026lt;T: IntoIterator\u0026lt;Item=A\u0026gt;\u0026gt;(iter: T) -\u0026gt; Self; } 分配时提高效率：\n1 2 3 4 5 6 trait Iterator { ... fn size_hint(\u0026amp;self) -\u0026gt; (usize, Option\u0026lt;usize\u0026gt;) { (0, None) } } This method returns a lower bound and optional upper bound on the number of items the iterator will produce. The default definition returns zero as the lower bound and declines to name an upper bound, saying, in effect, “I have no idea,” but many iterators can do better than this. An iterator over a Range, for example, knows exactly how many items it will produce, as does an iterator over a Vec or HashMap. Such iterators provide their own specialized definitions for size_hint.\nThe Extend Trait If a type implements the std::iter::Extend trait, then its extend method adds an iterable’s items to the collection.\n1 2 3 4 trait Extend\u0026lt;A\u0026gt; { fn extend\u0026lt;T\u0026gt;(\u0026amp;mut self, iter: T) where T: IntoIterator\u0026lt;Item=A\u0026gt;; } partition The partition method divides an iterator’s items among two collections, using a closure to decide where each item belongs.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 fn partition\u0026lt;B, F\u0026gt;(self, f: F) -\u0026gt; (B, B) where Self: Sized, B: Default + Extend\u0026lt;Self::Item\u0026gt;, F: FnMut(\u0026amp;Self::Item) -\u0026gt; bool, { #[inline] fn extend\u0026lt;\u0026#39;a, T, B: Extend\u0026lt;T\u0026gt;\u0026gt;( mut f: impl FnMut(\u0026amp;T) -\u0026gt; bool + \u0026#39;a, left: \u0026amp;\u0026#39;a mut B, right: \u0026amp;\u0026#39;a mut B, ) -\u0026gt; impl FnMut((), T) + \u0026#39;a { move |(), x| { if f(\u0026amp;x) { left.extend_one(x); } else { right.extend_one(x); } } } let mut left: B = Default::default(); let mut right: B = Default::default(); self.fold((), extend(f, \u0026amp;mut left, \u0026amp;mut right)); (left, right) } Other languages offer partition operations that just split the iterator into two iterators, instead of building two collections. But this isn’t a good fit for Rust: items drawn from the underlying iterator but not yet drawn from the appropriate partitioned iterator would need to be buffered somewhere; you would end up building a collection of some sort internally, anyway.\nfor_each and try_for_each The for_each method simply applies a closure to each item.\n1 2 3 4 5 6 7 8 9 10 11 12 fn for_each\u0026lt;F\u0026gt;(self, f: F) where Self: Sized, F: FnMut(Self::Item), { #[inline] fn call\u0026lt;T\u0026gt;(mut f: impl FnMut(T)) -\u0026gt; impl FnMut((), T) { move |(), item| f(item) } self.fold((), call(f)); } 1 2 3 4 5 6 7 8 9 10 [\u0026#34;doves\u0026#34;, \u0026#34;hens\u0026#34;, \u0026#34;birds\u0026#34;].iter() .zip([\u0026#34;turtle\u0026#34;, \u0026#34;french\u0026#34;, \u0026#34;calling\u0026#34;].iter()) .zip(2..5) .rev() .map(|((item, kind), quantity)| { format!(\u0026#34;{} {} {}\u0026#34;, quantity, kind, item) }) .for_each(|gift| { println!(\u0026#34;You have received: {}\u0026#34;, gift); }); 打印输出：\n1 2 3 You have received: 4 calling birds You have received: 3 french hens You have received: 2 turtle doves If your closure needs to be fallible or exit early, you can use try_for_each.\n1 2 3 4 ... .try_for_each(|gift| { writeln!(\u0026amp;mut output_file, \u0026#34;You have received: {}\u0026#34;, gift) })?; Implementing Your Own Iterators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 use std::iter::Iterator; struct I32Range { start: i32, // 当前的值 end: i32 // 迭代结束的值 } impl Iterator for I32Range { type Item = i32; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;i32\u0026gt; { if self.start \u0026gt;= self.end { return None; } let result = Some(self.start); self.start += 1; result } } fn main() { let mut pi = 0.0; let mut numerator = 1.0; for k in (I32Range { start: 0, end: 14}) { pi += numerator / (2*k + 1) as f64; numerator /= -3.0; } pi *= f64::sqrt(12.0); // IEEE 754 specifies this result exactly assert_eq!(pi as f32, std::f32::consts::PI); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 use crate::BinaryTree::NonEmpty; enum BinaryTree\u0026lt;T\u0026gt; { Empty, NonEmpty(Box\u0026lt;TreeNode\u0026lt;T\u0026gt;\u0026gt;) } struct TreeNode\u0026lt;T\u0026gt; { element: T, left: BinaryTree\u0026lt;T\u0026gt;, right: BinaryTree\u0026lt;T\u0026gt; } impl\u0026lt;T: Ord\u0026gt; BinaryTree\u0026lt;T\u0026gt; { fn add(\u0026amp;mut self, value: T) { match *self { BinaryTree::Empty =\u0026gt; *self = BinaryTree::NonEmpty(Box::new(TreeNode{ element: value, left: BinaryTree::Empty, right: BinaryTree::Empty, })), BinaryTree::NonEmpty(ref mut node) =\u0026gt; if value \u0026lt;= node.element { node.left.add(value); } else { node.right.add(value); } } } } struct TreeIter\u0026lt;\u0026#39;a, T\u0026gt; { // A stack of references to tree nodes. Since we use `Vec`\u0026#39;s // `push` and `pop` methods, the top of the stack in the end of the // vector. // // The node the iterator will visit next is at the top of the stack, // with those ancestors still unvisited below it. If the stack is empty, // the iteration is over. unvisited: Vec\u0026lt;\u0026amp;\u0026#39;a TreeNode\u0026lt;T\u0026gt;\u0026gt; } impl\u0026lt;\u0026#39;a, T: \u0026#39;a\u0026gt; TreeIter\u0026lt;\u0026#39;a, T\u0026gt; { fn push_left_edge(\u0026amp;mut self, mut tree: \u0026amp;\u0026#39;a BinaryTree\u0026lt;T\u0026gt;) { while let NonEmpty(ref node) = *tree { self.unvisited.push(node); tree = \u0026amp;node.left; } } } impl\u0026lt;T\u0026gt; BinaryTree\u0026lt;T\u0026gt; { fn iter(\u0026amp;self) -\u0026gt; TreeIter\u0026lt;T\u0026gt; { let mut iter = TreeIter{ unvisited: Vec::new() }; iter.push_left_edge(self); iter } } impl\u0026lt;\u0026#39;a, T: \u0026#39;a\u0026gt; IntoIterator for \u0026amp;\u0026#39;a BinaryTree\u0026lt;T\u0026gt; { type Item = \u0026amp;\u0026#39;a T; type IntoIter = TreeIter\u0026lt;\u0026#39;a, T\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter { self.iter() } } impl\u0026lt;\u0026#39;a, T\u0026gt; Iterator for TreeIter\u0026lt;\u0026#39;a, T\u0026gt; { type Item = \u0026amp;\u0026#39;a T; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;\u0026amp;\u0026#39;a T\u0026gt; { // Find the node this iteration must produce, // or finish the iteration. (Use the `?` operator // to return immediately if it\u0026#39;s `None`.) let node = self.unvisited.pop()?; // After `node`, the next thing we produce must be the leftmost // child in `node`\u0026#39;s right subtree, so push the path from here // down. Our helper method turns out to be just what we need. self.push_left_edge(\u0026amp;node.right); // Produce a reference to this node\u0026#39;s value. Some(\u0026amp;node.element) } } fn main() { // Build a small tree. let mut tree = BinaryTree::Empty; tree.add(\u0026#34;jaeger\u0026#34;); tree.add(\u0026#34;robot\u0026#34;); tree.add(\u0026#34;droid\u0026#34;); tree.add(\u0026#34;mecha\u0026#34;); // Iterate over it. let mut v = Vec::new(); for kind in \u0026amp;tree { v.push(*kind); } assert_eq!(v, [\u0026#34;droid\u0026#34;, \u0026#34;jaeger\u0026#34;, \u0026#34;mecha\u0026#34;, \u0026#34;robot\u0026#34;]); assert_eq!(tree.iter() .map(|name| format!(\u0026#34;mega-{}\u0026#34;, name)) .collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(), vec![\u0026#34;mega-droid\u0026#34;, \u0026#34;mega-jaeger\u0026#34;, \u0026#34;mega-mecha\u0026#34;, \u0026#34;mega-robot\u0026#34;]); } Chapter 19. Concurrency 惯用的多线程代码写法：\n一个后台线程只负责一件事，而且周期性“醒来”去做这件事。 通用线程池通过任务队列与客户端通信。 管道将数据从一个线程导入到另一个线程，每个线程只做一小部分工作。 数据并行假设（不管正确与否）整个计算机主要用于一项大型计算，这个大型计算进而又拆分成n个小任务，在n个线程上执行，希望所有n个机器的核心同时工作。 同步对象海中多个线程拥有同一个数据权限，使用基于互斥量等低级原语的临时锁方案避免争用。 原子整数操作允许多核心通过一个机器字大小的字段传递信息而实现通信。（除非要交换的数据就是整数值，否则这种方法比其他手段更难以保证正确。这通常意味着传递指针。） Fork-Join Parallelism Fork-join parallelism 有如下优点：\n非常简单。 避免瓶颈。 性能计算直观。 容易推断程序是否正确。 Fork-join 的主要缺点是要求工作单元隔离。\nspawn and join std::thread::spawn 创建一个新的线程：\n1 2 3 4 5 use std::thread; thread::spawn(|| { println!(\u0026#34;hello from a child thread\u0026#34;); }); 它接收一个参数，一个 FnOnce 闭包或者函数。\n用 spawn 来实现前面的 process_file 函数的并行版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 use std::{thread, io}; fn process_file_in_parallel(filename: Vec\u0026lt;String\u0026gt;) -\u0026gt; io::Result\u0026lt;()\u0026gt; { // Divide the work into several chunks. const NTHREADS: usize = 8; let worklists = split_vec_into_chunks(filename, NTHREADS); // Fork: Spawn a thread to handle each chunck. let mut thread_handles = vec![]; for worklist in worklists { thread_handles.push( // worklist move 进闭包中。 // spawn move 闭包到子线程中，当然也包括 worklist vec。 thread::spawn(move || process_files(worklist)) ); } // Join: Wait for all threads to finish. // 每一个 handle 是一个 JoinHandle。 for handle in thread_handles { handle.join().unwrap()?; } // 循环结束，8个子线程都已经成功完成。 Ok(()) } spawn 函数定义：\n1 2 3 4 pub fn spawn\u0026lt;F, T\u0026gt;(f: F) -\u0026gt; JoinHandle\u0026lt;T\u0026gt; where F: FnOnce() -\u0026gt; T, F: Send + \u0026#39;static, T: Send + \u0026#39;static, 因此 thread::spawn(move || process_files(worklist)) 会返回 JoinHandle ，并将它们放进一个 vector 中。\nError Handling Across Threads 1 handle.join().unwrap()?; 这个.join()方法做了两件事情。\n首先，handle.join()返回一个 std::thread::Result。\n其次，handle.join() 把子线程返回的值传给了父线程。handle.join() 返回的完整类型是std::thread::Result\u0026lt;std::io::Result\u0026lt;()\u0026gt;\u0026gt;。其中thread::Result 是 spawn/join API的一部分，而 io::Result 是我们应用的相关类型。\n在Rust中，错误是一种 Result 值（数据）而不是异常（控制流）。可以像任何值一样跨线程传送它们。\nSharing Immutable Data Across Threads 1 2 3 4 5 // before fn process_files(filename: Vec\u0026lt;String\u0026gt;) // after fn process_files(filename: Vec\u0026lt;String\u0026gt;, glossary: \u0026amp;GigabyteMap) 如果像之前那样传进线程会报错。\n1 2 3 4 5 6 7 8 9 fn process_file_in_parallel(filename: Vec\u0026lt;String\u0026gt;, glossary: \u0026amp;GigabyteMap) -\u0026gt; io::Result\u0026lt;()\u0026gt; { ... for worklist in worklists { thread_handles.push( thread::spawn(move || process_files(worklist, glossary)) // error ); } ... } 会抱怨 spawn 中闭包的生命周期不是 'static。spawn 会启动一个独立的线程。Rust无法知道一个子线程会允许多长时间，因此它假设一种最坏的情况，即子线程可能会在父线程已经完成且父线程中所有的值都消失之后继续运行。\n可以使用 Arc 来解决这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use std::sync::Arc; fn process_file_in_parallel(filename: Vec\u0026lt;String\u0026gt;, glossary: Arc\u0026lt;GigabyteMap\u0026gt;) -\u0026gt; io::Result\u0026lt;()\u0026gt; { ... for worklist in worklists { // This call to .clone() only clones the Arc and bumps the // reference count. It does not clone the GigabyteMap. let glossary_for_child = glossary.clone(); thread_handles.push( thread::spawn(move || process_files(worklist, \u0026amp;glossary_for_child)) ); } ... } 调用glossary.clone()后，会创建Arc智能指针而不是整个 GigabyteMap 的一个副本。这相当于增加一次引用计数。\n这样修改之后，程序就可以编译通过并运行了。因为它不再依赖引用的生命周期。只要有任何线程拥有 Arc\u0026lt;GigabyteMap\u0026gt; ，映射就不会释放，即使父线程早就退出了。因为 Arc 中的数据是不可修改的，所以也不会出现任何数据争用。\nRayon Rayon 库：\n1 2 3 4 5 6 7 8 9 use rayon::prelude::*; // \u0026#34;do 2 things in parallel\u0026#34; let (v1, v2) = rayon::join(fn1, fn2); // \u0026#34;do N things in parallel\u0026#34; giant_vector.par_iter().for_each(|value| { do_thing_with_value(value); }); rayon::join(fn1, fn2) 就是调用两个函数并返回两个结果。而.par_iter() 方法会创建一个 ParallelIterator ，这个值有 map、filter和其他方法，非常类似于Rust的Iterator。\n下图展示了两种理解 giant_vector.par_iter().for_each(...) 调用的方式。(a) 表面上看，Rayon会为向量中的每个元素都启动一个线程。(b)在后台，Rayon会让每个工作线程对应一个CPU核心，这样效率更高。这个工作线程池由程序的所有线程共享。在同时数千个任务时，Rayon会自动拆分工作。\n用Rayon写process_files_in_parallel。\n1 2 3 4 5 6 7 8 9 10 11 use rayon::prelude::*; fn process_files_in_parallel(filenames: Vec\u0026lt;String\u0026gt;, glossary: \u0026amp;GiabyteMap) -\u0026gt; io::Result\u0026lt;()\u0026gt; { filenames.par_iter() .map(|filename| process_file(filename, glossary)) .reduce_with(|r1, r2| { if r1.is_err() { r1 } else { r2 } }) .unwrap_or(Ok(())) } First, we use filenames.par_iter() to create a parallel iterator.\n.map() 对每个文件名调用 process_file。这样会得到 io::Result\u0026lt;()\u0026gt;值的一个 ParallelIterator。\n然后用 .reduce_with() 组合结果。在这里，我们保留第一个错误（如果有的话），然后丢弃其他错误。\nThe .reduce_with() method is also handy when you pass a .map() closure that returns a useful value on success. Then you can pass .reduce_with() a closure that knows how to combine two success results.\nreduce_with returns an Option that is None only if filenames was empty. We use the Option’s .unwrap_or() method to make the result Ok(()) in that case.\nChannels A channel is a one-way conduit for sending values from one thread to another. In other words, it’s a thread-safe queue.\n图片中应该有误，下面一个线程应该是 thread 2。\nRust channels are faster than Unix pipes. Sending a value moves it rather than copying it, and moves are fast even when you’re moving data structures that contain many megabytes of data.\nSending Values The code to start our file-reading thread looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std::{fs, thread}; use std::sync::mpsc; let (sender, receiver) = mpsc::channel(); let handle = thread::spawn(move || { for filename in documents { let text = fs::read_to_string(filename)?; // 将 text 值 move 进 channel， // 最终，它会再次 move 到接收到这个值的地方。 if sender.send(text).is_err() { break; } } Ok(()) }); Whether text contains 10 lines of text or 10 megabytes, this operation copies three machine words (the size of a String struct), and the corresponding receiver.recv() call will also copy three machine words.\nThe send and recv methods both return Results, but these methods fail only if the other end of the channel has been dropped.\nIn our code, sender.send(text) will fail only if the receiver’s thread has exited early. This is typical for code that uses channels. Whether that happened deliberately or due to an error, it’s OK for our reader thread to quietly shut itself down.\n1 2 3 4 5 6 7 8 9 10 11 fn start_file_reader_thread(documents: Vec\u0026lt;PathBuf\u0026gt;) -\u0026gt; (mpsc::Receiver\u0026lt;String\u0026gt;, thread::JoinHandle\u0026lt;io::Result\u0026gt;) { let (sender, receiver) = mpsc::channel(); let handle = thread::spawn(move || { ... }); (receiver, handle) } Receiving Values 1 2 3 while let Ok(text) = receiver.recv() { do_something_with(text); } 等价于\n1 2 3 for text in receiver { do_something_with(text); } The loop will exit normally when the channel is empty and the Sender has been dropped.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fn start_file_indexing_thread(texts: mpsc::Receiver\u0026lt;String\u0026gt;) -\u0026gt; (mpsc::Receiver\u0026lt;InMemoryIndex\u0026gt;, thread::JoinHandle\u0026lt;()\u0026gt;) { let (sender, receiver) = mpsc::channel(); let handle = thread::spawn(move || { for (doc_id, text) in texts.into_iter().enumerate() { let index = InMemoryIndex::from_single_document(doc_id, text); if sender.send(index).is_err() { break; } } }); (receiver, handle) } Running the Pipeline Stage3:\n1 2 fn start_in_memory_merge_thread(file_indexs: mpsc::Receiver\u0026lt;InMemoryIndex\u0026gt;) -\u0026gt; (mpsc::Receiver\u0026lt;InMemoryIndex\u0026gt;, thread::JoinHandle\u0026lt;()\u0026gt;) Stage 4:\n1 2 fn start_index_writer_thread(big_indexs: mpsc::Receiver\u0026lt;InMemoryIndex\u0026gt;, output_dir: \u0026amp;Path) -\u0026gt; (mpsc::Receiver\u0026lt;PathBuf\u0026gt;, thread::JoinHandle\u0026lt;io::Result\u0026lt;()\u0026gt;\u0026gt;) Stage 5:\n1 2 fn merge_index_files(files: mpsc::Receiver\u0026lt;PathBuf\u0026gt;, output_dir: \u0026amp;Path) -\u0026gt; io::Result\u0026lt;()\u0026gt; 最终运行代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn run_pipeline(documents: Vec\u0026lt;PathBuf\u0026gt;, output_dir: PathBuf) -\u0026gt; io::Result\u0026lt;()\u0026gt; { // Launch all five stages of the pipeline. let (texts, h1) = start_file_reader_thread(documents); let (pints, h2) = start_file_indexing_thread(texts); let (gallons, h3) = start_in_memory_merge_thread(pints); let (files, h4) = start_index_writer_thread(gallons, \u0026amp;output_dir); let result = merge_index_files(files, \u0026amp;output_dir); // Wait for threads to finish, holding on to any errors that they encounter. let r1 = h1.join().unwrap(); h2.join().unwrap(); h3.join().unwrap(); let r4 = h4.join().unwrap(); // Return the first error encountered, if any. // (As it happens, h2 and h3 can\u0026#39;t fail: those threads // are pure in-memory data processing.) r1?; r4?; result } Channel Features and Performance std::sync::mpsc 就是 \u0026ldquo;multiproducer, single-consumer\u0026rdquo;。\nSender\u0026lt;T\u0026gt; implements the Clone trait. To get a channel with multiple senders, simply create a regular channel and clone the sender as many times as you like. You can move each Sender value to a different thread.\nA Receiver\u0026lt;T\u0026gt; can’t be cloned, so if you need to have multiple threads receiving values from the same channel, you need a Mutex.\nRust通道是经过认真优化的。在刚创建通道时，Rust使用“一次性”队列实现。如果只是用这个通道发送一个对象，那可以保证开销最小。如果再发送第二个值，Rust则会切换到一个不同的队列实现。这个实现会从长远考虑，准备让通道传输很多值，同时又保持分配开销最小化。如果你选择克隆 Sender ，Rust则必须回退到另外一个实现，该实现可以保证多个线程同时发送值时的安全。不过即使是这3个实现中最慢的实现也是没有锁的队列，因此发送和接收值最多只是几个原子操作，涉及一次堆内存分配，外加转移自身。只有在队列为空且接收线程需要休眠时才需要系统调用。当然，此时经过通道的流量无论如何也不是最大的。\n发送至的速度超过接收和处理值的速度。这会导致通道内部的值越积越多。Rust借用Unix管道。Unix使用 backpressure ，从而强迫快速发送端放慢速度。Unix系统的每个管道都有固定大小，如果一个进程尝试向随时可能满的管道写入数据，系统就会直接阻塞该进程，直至管道中有了空间。Rust中的等价机制加 synchronous channel:\n1 2 3 use std::sync::mpsc; let (sender, receiver) = mpsc::sync_channel(1000); 同步通道就像常规通道一样，只是在创建时需要指定它可以保存多少值。对于同步通道而言，sender.send(value) 是一个潜在的阻塞操作。\nThread Safety: Send and Sync This is mostly true, but Rust’s full thread safety story hinges on two built-in traits, std::marker::Send and std::marker::Sync.\nTypes that implement Send are safe to pass by value to another thread. They can be moved across threads. Types that implement Sync are safe to pass by non-mut reference to another thread. They can be shared across threads. By safe here, we mean the same thing we always mean: free from data races and other undefined behavior.\nThe few types that are neither Send nor Sync are mostly those that use mutability in a way that isn’t thread-safe. For example, consider std::rc::Rc\u0026lt;T\u0026gt;, the type of reference-counting smart pointers.\nPiping Almost Any Iterator to a Channel 统一迭代器管道和线程管道。\n1 2 3 4 5 6 7 documents.into_iter() .map(read_whole_file) .errors_to(error_sender) // filter out error results .off_thread() // spawn a thread for the above work .map(make_single_file_index) .off_thread() // spawn another thread for stage 2 ... 可以定义一个 trait。\n1 2 3 4 5 6 7 8 use std::sync::mpsc; pub trait OffThreadExt: Iterator { /// Transform this iterator into an off-thread iterator: the /// `next()` calls happen to a separate worker thread, so the /// iterator and the body of your loop run concurrently. fn off_thread(self) -\u0026gt; mpsc::IntoIter\u0026lt;Self::Item\u0026gt;; } 然后为这个迭代器实现这个 trait。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 use std::thread; impl\u0026lt;T\u0026gt; OffThreadExt for T where T: Iterator + Send + \u0026#39;static, T::Item: Send + \u0026#39;static { fn off_thread(self) -\u0026gt; mpsc::IntoIter\u0026lt;Self::Item\u0026gt; { // Create a channel to transfer items from the worker thread. let (sender, receiver) = mpsc::sync_channel(1024); // Move this iterator to a new worker thread and run it there. thread::spawn(move || { for item in self { if sender.send(item).is_err() { break; } } }); // Return an iterator that pulls values from the channel. receiver.into_iter() } } Beyond Pipelines 通道不仅在管道中有用，它们也是在相同进程中为其他线程提供异步服务的快速而简单的方式。\n通道也适用于一个线程向另一个线程发送请求并期待得到某种响应的情形。\nShared Mutable State What Is a Mutex? 互斥量（或者叫锁）用于强制多线程依次访问特定的数据。\n互斥量保护数据。互斥量的作用体现在以下几方面。\n防止 data races，即避免多个线程并发读写同一块内存。 即使没有数据争用，即使所有读写在程序中都是顺序执行，如果没有互斥量，不同线程的操作也可能以任意方式相互交错。 互斥量支持通过 invariant 编程，即受保护数据由你负责初始化但每个临界区来维护的规则。 Mutex\u0026lt;T\u0026gt; 因为等待列表既是共享的也是可修改的，所以必须由一个 Mutex 来提供保护：\n1 2 3 4 5 6 7 8 use std::sync::Mutex; /// All threads have shared access to this big contex struct. struct FernEmpireApp { ... waiting_list: Mutex\u0026lt;WaitingList\u0026gt;, ... } 创建 Mutex 代码：\n1 2 3 4 5 6 7 use std::sync::Arc; let app = Arc::new(FernEmpireApp { ... waiting_list: Mutex::new(vec![]), ... }); 创建一个新的 Mutex 就像创建一个新 Box 或 Arc，但 Box 和 Arc 都意味着堆分配，而 Mutex 就是单纯的一种锁。如果想把 Mutex 分配在堆上，则必须明确地表示出来，就像这里使用 Arc::new 创建整个应用，而使用 Mutex::new 只是为了保护数据一样。这两个类型经常一块使用， Arc 方便跨线程共享数据，而 Mutex 方便跨线程共享可修改数据。\n使用 Mutex ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 impl FernEmpireApp { /// Add a player to the waiting list for the next game. /// Start a new game immediately if enough players are waiting. fn join_waiting_list(\u0026amp;self, player: PlayerId) { // Lock the mutex and gain access to the data inside. // The scope of `guard` is a critical section. let mut guard = self.waiting_list.lock().unwrap(); // Now do the game logic. guard.push(player); if guard.len() == GAME_SIZE { let players = guard.split_off(0); self.start_game(players); } } } 取得数据的唯一方法是调用 .lock() 方法：\n1 let mut guard = self.waiting_list.lock().unwrap(); self.waiting_list.lock() 会一直阻塞到可以再次获得互斥量。这个方法调用返回的 MutexGuard\u0026lt;WaitingList\u0026gt; 值是对 \u0026amp;mut WaitingList 的一个简单封装。借助 Deref 类型转换，可以直接在这个 guard 上调用 WaitingList 方法：\n1 guard.push(player); 这个 guard 甚至还允许我们直接引用底层数据。Rust的生命周期系统保证这些引用的寿命比不会超出 guard 自身。如果没有拿到锁，则不可能在 Mutex 中访问数据。\n在 guard 被清除后，锁也会被释放。通常这会在阻塞结束时发生，但也可以手工清除：\n1 2 3 4 5 if guard.len() == GAME_SIZE { let players = guard.split_off(0); drop(guard); // don\u0026#39;t keep the list locked while starting a game self.start_game(players); } mut and Mutex 在Rust中，\u0026amp;mut 意味着 exclusive access。Plain \u0026amp; means shared access.\nBut Mutex does have a way: the lock. In fact, a mutex is little more than a way to do exactly this, to provide exclusive (mut) access to the data inside, even though many threads may have shared (non-mut) access to the Mutex itself.\nRust’s type system is telling us what Mutex does. It dynamically enforces exclusive access, something that’s usually done statically, at compile time, by the Rust compiler.\n(You may recall that std::cell::RefCell does the same, except without trying to support multiple threads. Mutex and RefCell are both flavors of interior mutability, which we covered .)\nWhy Mutexes Are Not Always a Good Idea However, threads that use mutexes are subject to some other problems that Rust doesn’t fix for you:\nValid Rust programs can’t have data races, but they can still have other race conditions— situations where a program’s behavior depends on timing among threads and may therefore vary from run to run. Some race conditions are benign. Some manifest as general flakiness and incredibly hard-to-fix bugs. Using mutexes in an unstructured way invites race conditions. It’s up to you to make sure they’re benign. Shared mutable state also affects program design. Where channels serve as an abstraction boundary in your code, making it easy to separate isolated components for testing, mutexes encourage a “just-add-a-method” way of working that can lead to a monolithic blob of interrelated code. Lastly, mutexes are just not as simple as they seem at first, as the next two sections will show. All of these problems are inherent in the tools. Use a more structured approach when you can; use a Mutex when you must.\nDeadlock 1 2 let mut guard1 = self.waiting_list.lock().unwrap(); let mut guard2 = self.waiting_list.lock().unwrap(); // deadlock Suppose the first call to self.waiting_list.lock() succeeds, taking the lock. The second call sees that the lock is held, so it blocks, waiting for it to be released. It will be waiting forever. The waiting thread is the one that’s holding the lock.\nTo put it another way, the lock in a Mutex is not a recursive lock.\nRust’s borrow system can’t protect you from deadlock. The best protection is to keep critical sections small: get in, do your work, and get out.\nIt’s also possible to get deadlock with channels.\nPoisoned Mutexes If a thread panics while holding a Mutex, Rust marks the Mutex as poisoned. Any subsequent attempt to lock the poisoned Mutex will get an error result. Our .unwrap() call tells Rust to panic if that happens, propagating panic from the other thread to this one.\nMulticonsumer Channels Using Mutexes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 pub mod shared_channel { use std::sync::{Arc, Mutex}; use std::sync::mpsc::{channel, Sender, Receiver}; /// A thread-safe wrapper around a `Receiver`. #[derive(Clone)] pub struct SharedReceiver\u0026lt;T\u0026gt;(Arc\u0026lt;Mutex\u0026lt;Receiver\u0026lt;T\u0026gt;\u0026gt;\u0026gt;); impl\u0026lt;T\u0026gt; Iterator for SharedReceiver\u0026lt;T\u0026gt; { type Item = T; /// Get the next item from the wrapped receiver. fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;T\u0026gt; { let guard = self.0.lock().unwrap(); guard.recv().ok() } } /// Create a new channel whose receiver can be shared across threads. /// This returns a sender and a receiver, just like the stdlib\u0026#39;s /// `channel()`, and sometimes works as a drop-in replacement. pub fn shared_channel\u0026lt;T\u0026gt;() -\u0026gt; (Sender\u0026lt;T\u0026gt;, SharedReceiver\u0026lt;T\u0026gt;) { let (sender, receiver) = channel(); (sender, SharedReceiver(Arc::new(Mutex::new(receiver)))) } } Read/Write Locks(RwLock\u0026lt;T\u0026gt;) Whereas a mutex has a single lock method, a read/write lock has two locking methods, read and write. The RwLock::write method is like Mutex::lock. It waits for exclusive, mut access to the protected data. The RwLock::read method provides non-mut access, with the advantage that it is less likely to have to wait, because many threads can safely read at once. With a mutex, at any given moment, the protected data has only one reader or writer (or none). With a read/write lock, it can have either one writer or many readers, much like Rust references generally.\nCondition Variables (Condvar) In Rust, the std::sync::Condvar type implements condition variables. A Condvar has methods .wait() and .notify_all(); .wait() blocks until some other thread calls .notify_all().\nAtomics The std::sync::atomic module contains atomic types for lock-free concurrent programming. These types are basically the same as Standard C++ atomics, with some extras:\nAtomicIsize and AtomicUsize are shared integer types corresponding to the single- threaded isize and usize types.\nAtomicI8, AtomicI16, AtomicI32, AtomicI64, and their unsigned variants like AtomicU8 are shared integer types that correspond to the single-threaded types i8, i16, etc.\nAn AtomicBool is a shared bool value.\nAn AtomicPtr\u0026lt;T\u0026gt; is a shared value of the unsafe pointer type *mut T.\nGlobal Variables The simplest way to support incrementing PACKETS_SERVED, while keeping it thread-safe, is to make it an atomic integer:\n1 2 3 use std::sync::atomic::AtomicUsize; static PACKETS_SERVED: AtomicUsize = AtomicUsize::new(0); Once this static is declared, incrementing the packet count is straightforward:\n1 2 3 use std::sync::atomic::Ordering; PACKETS_SERVED.fetch_add(1, Ordering::SeqCst); Atomic globals are limited to simple integers and Booleans. Still, creating a global variable of any other type amounts to solving two problems.\nFirst, the variable must be made thread-safe somehow, because otherwise it can’t be global: for safety, static variables must be both Sync and non-mut. Fortunately, we’ve already seen the solution for this problem. Rust has types for safely sharing values that change: Mutex, RwLock, and the atomic types. These types can be modified even when declared as non-mut. It’s what they do. (See “mut and Mutex”.)\nSecond, static initializers can only call functions specifically marked as const, which the compiler can evaluate during compile time. Put another way, their output is deterministic; it depends only on their arguments, not any other state or I/O. That way, the compiler can embed the results of that computation as a compile-time constant. This is similar to C++ constexpr.\nRust limits what const functions can do to a small set of operations, which are enough to be useful while still not allowing any nondeterministic results. const functions can’t take types as generic arguments, only lifetimes, and it’s not possible to allocate memory or operate on raw pointers, even in unsafe blocks. We can, however, use arithmetic operations (including wrapping and saturating arithmetic), logical operations that don’t short-circuit, and other const functions. For example, we can create convenience functions to make defining statics and consts easier and reduce code duplication:\n1 2 3 4 5 6 7 8 9 10 const fn mono_to_rgba(level: u8) -\u0026gt; Color { Color { red: level, green: level, blue: level, alpha: 0xFF } } const WHITE: Color = mono_to_rgba(255); const BLACK: Color = mono_to_rgba(000); Combining these techniques, we might be tempted to write:\n1 2 3 4 static HOSTNAME: Mutex\u0026lt;String\u0026gt; = Mutex::new(String::new()); // error: calls in statics are limited to // constant functions, tuple structs, and // tuple variants Unfortunately, while AtomicUsize::new() and String::new() are const fn, Mutex::new() is not. In order to get around these limitations, we need to use the lazy_static crate.\nWe can declare a global Mutex-controlled HashMap with lazy_static like this:\n1 2 3 4 5 6 use lazy_static::lazy_static; use std::sync::Mutex; lazy_static! { static ref HOSTNAME: Mutex\u0026lt;String\u0026gt; = Mutex::new(String::new()); } Using lazy_static! imposes a tiny performance cost on each access to the static data. The implementation uses std::sync::Once, a low-level synchronization primitive designed for one-time initialization. Behind the scenes, each time a lazy static is accessed, the program executes an atomic load instruction to check that initialization has already occurred. (Once is rather special purpose, so we will not cover it in detail here. It is usually more convenient to use lazy_static! instead. However, it is handy for initializing non-Rust libraries; for an example, see “A Safe Interface to libgit2”.)\nWhat Hacking Concurrent Code in Rust Is Like Rust insists on safety, so from the moment you decide to write a multithreaded program, the focus is on building safe, structured communication. Keeping threads mostly isolated is a good way to convince Rust that what you’re doing is safe. It happens that isolation is also a good way to make sure what you’re doing is correct and maintainable. Again, Rust guides you toward good programs.\nChapter 20. Asynchronous Programming Asynchronous tasks are similar to threads, but are much quicker to create, pass control amongst themselves more efficiently, and have memory overhead an order of magnitude less than that of a thread.\nFrom Synchronous to Asynchronous 文中举了同步的获得HTTP请求再返回的例子，可以看到大部分时间都花在等待上了。\nFutures std::future::Future\n1 2 3 4 pub trait Future { type Output; fn poll(self: Pin\u0026lt;\u0026amp;mut Self\u0026gt;, cx: \u0026amp;mut Context\u0026lt;\u0026#39;_\u0026gt;) -\u0026gt; Poll\u0026lt;Self::Output\u0026gt;; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pub enum Poll\u0026lt;T\u0026gt; { /// Represents that a value is immediately ready. #[lang = \u0026#34;Ready\u0026#34;] #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] Ready(#[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] T), /// Represents that a value is not ready yet. /// /// When a function returns `Pending`, the function *must* also /// ensure that the current task is scheduled to be awoken when /// progress can be made. #[lang = \u0026#34;Pending\u0026#34;] #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] Pending, } A Future represents an operation that you can test for completion. A future’s poll method never waits for the operation to finish: it always returns immediately. If the operation is complete, poll returns Poll::Ready(output), where output is its final result. Otherwise, it returns Pending. If and when the future is worth polling again, it promises to let us know by invoking a waker, a callback function supplied in the Context. We call this the “piñata model” of asynchronous programming: the only thing you can do with a future is whack it with a poll until a value falls out.\nChapter 21. Macros 在编译期间，在类型检查和机器码生成之前，宏会进行展开。联系rust编译过程图理解。\nMacro Basics 用 macro_rules! 定义的声明宏，通过模式匹配来工作。 在 pattern 或者 template 中，可以用方括号或者花括号代替圆括号。它们没有什么区别。 1 2 3 assert_eq!(gcd(6, 10), 2); assert_eq![gcd(6, 10), 2)]; assert_eq!{gcd(6, 10), 2}\t// 注意结尾这里分号是可选的，也可以加上 对于宏的调用也是一样的。按照惯例，调用 assert_eq! 用圆括号，调用 vec! 用方括号，对于 macro_rules! 用花括号。 Basics of Macro Expansion 在编译期间，Rust展开宏非常早。在宏定义之前是不能调用它的，因为Rust会展开每一个宏调用，这发生在查看程序剩余代码之前。 正则表达式是在字符集上操作，而 pattern 是在 token 上操作。正则表达式和宏模式另一个重要的区别是在Rust中圆括号、块总是成对出现的。在宏展开之前就会进行检查。 注解和空白不是 token ，所以不会影响模式匹配。 一般可能会有一些错误，在参数部分用 $left:expr 而不是 $left。Rust不会立刻发现这个错误，它会将 $left 当作一个替换，直到调用这个宏的时候会发生错误。 Unintended Consenquences 正确的 assert_eq! 宏的定义是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 标准库中的定义 macro_rules! assert_eq { ($left:expr, $right:expr $(,)?) =\u0026gt; { match (\u0026amp;$left, \u0026amp;$right) {\t// 这里用的是引用 (left_val, right_val) =\u0026gt; { if !(*left_val == *right_val) { let kind = $crate::panicking::AssertKind::Eq; // The reborrows below are intentional. Without them, the stack slot for the // borrow is initialized even before the values are compared, leading to a // noticeable slow down. $crate::panicking::assert_failed(kind, \u0026amp;*left_val, \u0026amp;*right_val, $crate::option::Option::None); } } } }; } 为什么不这样写呢？\n1 2 3 4 if !($left == $right) { panic!(\u0026#34;assertion failed: `(left == right)` \\ (left: `{:?}`, right: `{:?}`)\u0026#34;, $left, $right) } 如果 assert_eq!(letters.pop(), Some('z')) 这样调用，由于 letters.pop() 会从一个 vector 中移除一个值，那么当第二次调用的时候就会产生一个不同的值，这也就是为什么实际宏当中 $left 和 $right 只会保存一次它们的值。\n那为什么宏里面要用引用，不能这样写吗？\n1 2 3 4 5 6 7 8 9 10 11 macro_rules! bad_assert_eq { ($left:expr, $right:expr) =\u0026gt; { match ($left, $right) {\t// 这里不用引用 (left_val, right_val) =\u0026gt; { if !(left_val == right_val) { panic!(\u0026#34;assertion failed\u0026#34; /* ... */); } } } }; } 如果传入的参数是 String ，那么就会移动所有权到变量里面。因此这里要使用引用。\nIn short, macros can do surprising things.\nRepetition 标准库中 vec! 宏\n1 2 3 4 5 6 7 8 9 10 11 macro_rules! vec { () =\u0026gt; ( $crate::__rust_force_expr!($crate::vec::Vec::new()) ); ($elem:expr; $n:expr) =\u0026gt; ( $crate::__rust_force_expr!($crate::vec::from_elem($elem, $n)) ); ($($x:expr),+ $(,)?) =\u0026gt; ( $crate::__rust_force_expr!(\u0026lt;[_]\u0026gt;::into_vec(box [$($x),+])) ); } $( PATTERN ), * 用来匹配任何用 , 分隔的立标，在列表中每个匹配一个 PATTERN。 Pattern Meaning $( \u0026hellip; )* Match 0 or more times with no separator $( \u0026hellip; ),* Match 0 or more times, separated by commas $( \u0026hellip; );* Match 0 or more times, separated by semicolons $( \u0026hellip; )+ Match 1 or more times with no separator $( \u0026hellip; ),+ Match 1 or more times, separated by commas $( \u0026hellip; );+ Match 1 or more times, separated by semicolons $( \u0026hellip; )? Match 0 or 1 times with no separator $( \u0026hellip; ),? Match 0 or 1 times, separated by commas $( \u0026hellip; );? Match 0 or 1 times, separated by semicolons 总结一下啦：\n* 匹配0次或多次 + 至少匹配一次 ? 最多匹配一次 理解理解这个复杂的鬼东西\n1 \u0026lt;[_]\u0026gt;::into_vec(box [$($x),+]) 创建一个 boxed 数组然后用 [T]::into_vec 方法将 boxed 数组转换成一个 vector 。 \u0026lt;[_]\u0026gt; 是一个非常规的写法，用来表示一些类型的切片（\u0026ldquo;slice of something\u0026rdquo;）。像 fn(),\u0026amp;str,或者[_]，没有明确的类型，就必须包在尖括号\u0026lt;\u0026gt;里面。 Built-In Macros 下面的这些宏是内置的，硬编码在 rustc 中。\nfile!(), line!(), column!() stringingfy!(...tokens...) concat!(str0, str1, ...) Chapter 22. Unsafe Code ","date":"2022-07-05T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/05/Programming-Rust/","title":"Programming Rust"},{"content":"元编程技术大概分为：\n简单文本替换 类型模板 反射 语法扩展 代码自动生成 Rust语言通过反射和AST语法扩展两种手段来支持元编程。\n反射 反射机制一般是指程序自我访问、检测和修改其自身状态或行为的能力。Rust标准库提供了std::any::Any来支持运行时反射。可以先看下代码结构：\nAny定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;Any\u0026#34;)] pub trait Any: \u0026#39;static { /// Gets the `TypeId` of `self`. /// /// # Examples /// /// ``` /// use std::any::{Any, TypeId}; /// /// fn is_string(s: \u0026amp;dyn Any) -\u0026gt; bool { /// TypeId::of::\u0026lt;String\u0026gt;() == s.type_id() /// } /// /// assert_eq!(is_string(\u0026amp;0), false); /// assert_eq!(is_string(\u0026amp;\u0026#34;cookie monster\u0026#34;.to_string()), true); /// ``` #[stable(feature = \u0026#34;get_type_id\u0026#34;, since = \u0026#34;1.34.0\u0026#34;)] fn type_id(\u0026amp;self) -\u0026gt; TypeId; } #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] impl\u0026lt;T: \u0026#39;static + ?Sized\u0026gt; Any for T { fn type_id(\u0026amp;self) -\u0026gt; TypeId { TypeId::of::\u0026lt;T\u0026gt;() } } 该 trait 加上了'static 生命周期限定，意味着该 trait 不能被非静态生命周期的类型实现。 impl\u0026lt;T: 'static + ?Sized\u0026gt; Any for T 表示 Rust 中满足 'static 生命周期的类型均实现了它。 type_id方法返回 TypeId 类型，代表 Rust 中某个类型的全局唯一标识，它是在编译时生成的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] pub struct TypeId { t: u64, } impl TypeId { /// Returns the `TypeId` of the type this generic function has been /// instantiated with. /// /// # Examples /// /// ``` /// use std::any::{Any, TypeId}; /// /// fn is_string\u0026lt;T: ?Sized + Any\u0026gt;(_s: \u0026amp;T) -\u0026gt; bool { /// TypeId::of::\u0026lt;String\u0026gt;() == TypeId::of::\u0026lt;T\u0026gt;() /// } /// /// assert_eq!(is_string(\u0026amp;0), false); /// assert_eq!(is_string(\u0026amp;\u0026#34;cookie monster\u0026#34;.to_string()), true); /// ``` #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_const_unstable(feature = \u0026#34;const_type_id\u0026#34;, issue = \u0026#34;77125\u0026#34;)] pub const fn of\u0026lt;T: ?Sized + \u0026#39;static\u0026gt;() -\u0026gt; TypeId { TypeId { t: intrinsics::type_id::\u0026lt;T\u0026gt;() } } } 每个 TypeId 都是一个“黑盒”，不能检查其内部内容，但是允许复制、比较、打印等操作。TypeId 当前仅适用于归因于 'static 的类型，但是可以在 future 中消除此限制。 通过 is 函数判断类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 impl dyn Any { /// Returns `true` if the inner type is the same as `T`. /// /// # Examples /// /// ``` /// use std::any::Any; /// /// fn is_string(s: \u0026amp;dyn Any) { /// if s.is::\u0026lt;String\u0026gt;() { /// println!(\u0026#34;It\u0026#39;s a string!\u0026#34;); /// } else { /// println!(\u0026#34;Not a string...\u0026#34;); /// } /// } /// /// is_string(\u0026amp;0); /// is_string(\u0026amp;\u0026#34;cookie monster\u0026#34;.to_string()); /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[inline] pub fn is\u0026lt;T: Any\u0026gt;(\u0026amp;self) -\u0026gt; bool { // Get `TypeId` of the type this function is instantiated with. let t = TypeId::of::\u0026lt;T\u0026gt;(); // Get `TypeId` of the type in the trait object (`self`). let concrete = self.type_id(); // Compare both `TypeId`s on equality. t == concrete } } 因为 Any 是一个 trait ，所以这里的 is方法的 \u0026amp;self 必然是一个 trait 对象。 TypeId::of 函数用来获取类型 T 的全局唯一标识符 t 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //! 代码清单 12-3: Any 中实现 is 方法源码示意 //! 《Rust编程之道》P436 use std::any::{Any, TypeId}; enum E { H, He, Li } struct S { x: u8, y: u8, z: u16 } #[test] fn main() { let v1 = 0xc0ffee_u32; let v2 = E::He; let v3 = S { x: 0xde, y: 0xad, z: 0xbeef }; let v4 = \u0026#34;rust\u0026#34;; let mut a: \u0026amp;dyn Any; a = \u0026amp;v1; assert!(a.is::\u0026lt;u32\u0026gt;()); println!(\u0026#34;{:?}\u0026#34;, TypeId::of::\u0026lt;u32\u0026gt;()); a = \u0026amp;v2; assert!(a.is::\u0026lt;E\u0026gt;()); println!(\u0026#34;{:?}\u0026#34;, TypeId::of::\u0026lt;E\u0026gt;()); a = \u0026amp;v3; assert!(a.is::\u0026lt;S\u0026gt;()); println!(\u0026#34;{:?}\u0026#34;, TypeId::of::\u0026lt;S\u0026gt;()); a = \u0026amp;v4; assert!(a.is::\u0026lt;\u0026amp;str\u0026gt;()); println!(\u0026#34;{:?}\u0026#34;, TypeId::of::\u0026lt;\u0026amp;str\u0026gt;()); } 输出结果：\n1 2 3 4 TypeId { t: 18349839772473174998 } TypeId { t: 5500635625788377815 } TypeId { t: 4485408004367722735 } TypeId { t: 13307641874416792075 } TypeId 是一个结构体，其字段 t 存储了一串数字，这就是全局唯一类型标识符，实际上是 u64 类型。代表唯一标识符的这串数字，在不同的编译环境中，产生的结果是不同的。所以在实际开发中，最好不要将 TypeId 暴露到外部接口中被当作依赖。 转换到具体类型 Any 提供了 downcast_ref 和 downcast_mut 两个成对的泛型方法，用于将泛型T向下转换为具体的类型，返回值分别是 Option\u0026lt;\u0026amp;T\u0026gt; 和 Option\u0026lt;\u0026amp;mut T\u0026gt; 类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 impl dyn Any { /// Returns some reference to the inner value if it is of type `T`, or /// `None` if it isn\u0026#39;t. /// /// # Examples /// /// ``` /// use std::any::Any; /// /// fn print_if_string(s: \u0026amp;dyn Any) { /// if let Some(string) = s.downcast_ref::\u0026lt;String\u0026gt;() { /// println!(\u0026#34;It\u0026#39;s a string({}): \u0026#39;{}\u0026#39;\u0026#34;, string.len(), string); /// } else { /// println!(\u0026#34;Not a string...\u0026#34;); /// } /// } /// /// print_if_string(\u0026amp;0); /// print_if_string(\u0026amp;\u0026#34;cookie monster\u0026#34;.to_string()); /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[inline] pub fn downcast_ref\u0026lt;T: Any\u0026gt;(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;T\u0026gt; { if self.is::\u0026lt;T\u0026gt;() { // SAFETY: just checked whether we are pointing to the correct type, and we can rely on // that check for memory safety because we have implemented Any for all types; no other // impls can exist as they would conflict with our impl. unsafe { Some(self.downcast_ref_unchecked()) } } else { None } } /// Returns some mutable reference to the inner value if it is of type `T`, or /// `None` if it isn\u0026#39;t. /// /// # Examples /// /// ``` /// use std::any::Any; /// /// fn modify_if_u32(s: \u0026amp;mut dyn Any) { /// if let Some(num) = s.downcast_mut::\u0026lt;u32\u0026gt;() { /// *num = 42; /// } /// } /// /// let mut x = 10u32; /// let mut s = \u0026#34;starlord\u0026#34;.to_string(); /// /// modify_if_u32(\u0026amp;mut x); /// modify_if_u32(\u0026amp;mut s); /// /// assert_eq!(x, 42); /// assert_eq!(\u0026amp;s, \u0026#34;starlord\u0026#34;); /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[inline] pub fn downcast_mut\u0026lt;T: Any\u0026gt;(\u0026amp;mut self) -\u0026gt; Option\u0026lt;\u0026amp;mut T\u0026gt; { if self.is::\u0026lt;T\u0026gt;() { // SAFETY: just checked whether we are pointing to the correct type, and we can rely on // that check for memory safety because we have implemented Any for all types; no other // impls can exist as they would conflict with our impl. unsafe { Some(self.downcast_mut_unchecked()) } } else { None } } } 非静态生命周期类型 1 2 3 4 5 6 7 8 9 10 //! 代码清单 12-9: 非静态生命周期类型没有实现 Any use std::any::Any; struct Unstatic\u0026lt;\u0026#39;a\u0026gt; { x: \u0026amp;\u0026#39;a i32 } #[test] fn main() { let a = 42; let v = Unstatic { x: \u0026amp;a }; let mut any: \u0026amp;dyn Any; // any = \u0026amp;v; // 编译错误 } 带引用字段的结构体 Unstatic\u0026lt;'a\u0026gt; ，其生命周期不是静态的，编译会报错。 修改：\n1 2 3 4 5 6 7 8 9 10 #![allow(unused)] use std::any::Any; struct UnStatic\u0026lt;\u0026#39;a\u0026gt; { x: \u0026amp;\u0026#39;a i32 } static ANSWER: i32 = 42; fn main() { let v = UnStatic { x: \u0026amp;ANSWER }; let mut a: \u0026amp;dyn Any; a = \u0026amp;v; assert!(a.is::\u0026lt;UnStatic\u0026gt;()); } Any 的应用 oso库应用 bevy_reflect库应用 Remark 在2018 Edition 中，以下语句不会报错：\n1 2 let mut a: \u0026amp;Any; // 2018 Edition Ok let mut a: \u0026amp;dyn Any; // 2018 Edition Ok 但是在2021 Edition中，必须加上 dyn 。\n1 2 let mut a: \u0026amp;Any; // 2021 Edition Error: trait objects must include the `dyn` keyword let mut a: \u0026amp;dyn Any; // 2021 Edition Ok 宏系统 Rust编译过程：\n声明宏 宏展开命令： cargo rustc – -Z unstable-options –pretty=expanded\n示例1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #![allow(unused)] macro_rules! unless { ($arg:expr, $branch:expr) =\u0026gt; ( if !$arg { $branch };); } fn cmp(a: i32, b: i32) { unless!( a \u0026gt; b, { println!(\u0026#34;{} \u0026lt; {}\u0026#34;, a, b); }); } fn main() { let (a, b) = (1, 2); cmp(a, b); } 支持token类型：\n1 2 3 4 5 6 7 8 9 10 11 12 item — an item, like a function, struct, module, etc. block — a block (i.e. a block of statements and/or an expression, surrounded by braces) stmt — a statement pat — a pattern expr — an expression ty — a type ident — an identifier 标识符 path — a path (e.g., foo, ::std::mem::replace, transmute::\u0026lt;_, int\u0026gt;, …) meta — a meta item; the things that go inside #[...] and #![...] attributes tt — a single token tree vis — a possibly empty Visibility qualifier lifetime — 指代声明周期参数 hashmap 1.0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 macro_rules! hashmap { ($($key:expr =\u0026gt; $value:expr), *) =\u0026gt; { { let mut _map = ::std::collections::HashMap::new(); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2 // \u0026#34;c\u0026#34; =\u0026gt; 3, // 会报错，不支持结尾有逗号 }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } hashmap 2.0：可以匹配结尾有逗号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 macro_rules! hashmap { ($($key:expr =\u0026gt; $value:expr,)*) =\u0026gt; { hashmap!($($key =\u0026gt; $value),*) }; ($($key:expr =\u0026gt; $value:expr),*) =\u0026gt; { { let mut _map = ::std::collections::HashMap::new(); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2, \u0026#34;c\u0026#34; =\u0026gt; 3, }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } hashmap 3.0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 macro_rules! hashmap { ($($key:expr =\u0026gt; $value:expr),* $(,)*) =\u0026gt; { { let mut _map = ::std::collections::HashMap::new(); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2, \u0026#34;c\u0026#34; =\u0026gt; 3, }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } hashmap 4.0 ： 节省存储空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 macro_rules! unit { ($($x:tt)*) =\u0026gt; (()); } macro_rules! count { ($($key:expr),*) =\u0026gt; (\u0026lt;[()]\u0026gt;::len(\u0026amp;[$(unit!($key)),*])); } macro_rules! hashmap { ($($key:expr =\u0026gt; $value:expr),* $(,)*) =\u0026gt; { { let _cap = count!($($key),*); let mut _map = ::std::collections::HashMap::with_capacity(_cap); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2, \u0026#34;c\u0026#34; =\u0026gt; 3, }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } hashmap 5.0：将声明宏放在一起\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 macro_rules! hashmap { (@unit $($x:tt)*) =\u0026gt; (()); (@count $($rest:expr),*) =\u0026gt; (\u0026lt;[()]\u0026gt;::len(\u0026amp;[$(hashmap!(@unit $rest)),*])); ($($key:expr =\u0026gt; $value:expr),* $(,)*) =\u0026gt; { { let _cap = hashmap!(@count $($key),*); let mut _map = ::std::collections::HashMap::with_capacity(_cap); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2, \u0026#34;c\u0026#34; =\u0026gt; 3, }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } 示例：\n1 2 3 4 5 6 7 8 9 10 macro_rules! sum { ($e:expr) =\u0026gt; ({ let a = 2; $e + a }) } fn main(){ // error[E0425]: cannot find value `a` in this scope let four = sum!(a); } 注意这里会报错，宏里面的 a 变量是局部的。 过程宏 过程宏三件套：\nsyn quote proc-macro2 介绍：\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. 将 token 流转换成语法树。 quote: This crate provides the quote! macro for turning Rust syntax tree data structures into tokens of source code. 将语法树转换成 token 源码。 proc-macro2 比 proc-macro 更加的灵活。TokenStream API接口。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 // find_by_or!{ Person -\u0026gt; people::[name:String || company_name:String] } use super::*; pub struct DbOpByOrBy { pub model: Type, pub table: Ident, pub bracket_token: token::Bracket, pub content: FieldContentOr, } pub struct FieldContentOr { pub name1: Ident, pub ty1: Type, pub name2: Ident, pub ty2: Type, } impl Parse for DbOpByOrBy { fn parse(input: ParseStream) -\u0026gt; Result\u0026lt;Self\u0026gt; { let content; let model: Type = input.parse()?; input.parse::\u0026lt;Token![-\u0026gt;]\u0026gt;()?; let table: Ident = input.parse()?; input.parse::\u0026lt;Token![::]\u0026gt;()?; let bracket_token = bracketed!(content in input); let content = content.parse()?; Ok(DbOpByOrBy { model, table, bracket_token, content, }) } } impl Parse for FieldContentOr { fn parse(input: ParseStream) -\u0026gt; Result\u0026lt;Self\u0026gt; { let name1: Ident = input.parse()?; input.parse::\u0026lt;Token![:]\u0026gt;()?; let ty1: Type = input.parse()?; input.parse::\u0026lt;Token![||]\u0026gt;()?; let name2: Ident = input.parse()?; input.parse::\u0026lt;Token![:]\u0026gt;()?; let ty2: Type = input.parse()?; Ok(FieldContentOr { name1, ty1, name2, ty2, }) } } // in lib.rs // find_by_or!{ Person -\u0026gt; people::[name:String || company_name:String] } #[proc_macro] pub fn find_by_or(input: TokenStream) -\u0026gt; TokenStream { let DbOpByOrBy { model, table, bracket_token, content, } = parse_macro_input!(input as DbOpByOrBy); let (name1, name2) = (content.name1, content.name2); let (ty1, ty2) = (content.ty1, content.ty2); let fn_name = format!(\u0026#34;find_by_{}_or_{}\u0026#34;, name1, name2); let fn_name = Ident::new(\u0026amp;fn_name, proc_macro2::Span::call_site()); let expanded = quote! { impl #model { pub fn #fn_name(conn: \u0026amp;PgConnection, #name1: #ty1, #name2: #ty2) -\u0026gt; QueryResult\u0026lt;#model\u0026gt; { #table::table .filter(#table::dsl::#name1.eq(#name1)) .or_filter(#table::dsl::#name2.eq(#name2)) .get_result(conn) } } }; TokenStream::from(expanded) } 参考资料 《Rust编程之道》 ","date":"2022-07-05T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/05/Rust-meta-programming/","title":"Rust元编程"},{"content":"第1章 引论 1.1 什么是操作系统 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。 操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。 操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。 1.5 操作系统概念 1.5.1 进程 进程本质上是正在执行的一个程序。\n地址空间\n第2章 进程与线程 进程是对正在运行程序的一个抽象。\n2.1 进程 严格来说，在某一个时刻，CPU只能运行一个进程。但在1秒钟内，它可能运行多个进程，这样就产生并行的错觉。\n2.1.1 进程模型 一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。\n每个进程执行其运算速度是不确定的，所以，在对进程编程时决不能对时序作任何想当然的假设。\n进程和程序有微妙的区别。做蛋糕的食谱就是程序，进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列操作的总和。\n一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。\n2.1.2 进程的创建 4种主要事件会导致进程的创建： 系统初始化 正在运行的程序执行了创建进程的系统调用 用户请求创建一个新进程 一个批处理作业的初始化 守护进程： 停留在后台处理的进程。 新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。 在UNIX系统中，只有一个系统调用可以用来创建新进程：fork。 2.1.3 进程的终止 通常由下列条件引起进程的终止：\n正常退出（自愿的） 出错退出（自愿的） 严重错误（非自愿） 被其他进程杀死（非自愿） 2.1.4 进程的层次结构 进程只有一个父进程（但是可以有零个、一个、两个或多个子进程）。 在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组。 在UNIX中，所有的进程都属于以 init 为根的一棵树。 Windows中没有进程层次的概念，所有的进程都是地位相同的。 2.1.5 进程的状态 当一个进程在逻辑上不能继续运行时，它就会被阻塞。\nP52 图2-2\n2.1.6 进程的实现 为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表。每个进程占用一个进程表项。 与每一I/O类关联的是一个称作中断向量的位置（靠近内存底部的固定区域）。它包含终端服务程序的入口地址。 2.1.7 多道程序设计模型 采用多道程序设计可以提高CPU的利用率，不过也要考虑进程等待I/O操作的时间。\n2.2 线程 在传统操作系统中，每个进程有一个地址空间和一个控制线程。\n不过，经常存在在同一个地址空间中准并行运行多个控制线程的情形。\n2.2.1 线程的使用 引进线程的原因：\n通过将一些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。并行实体拥有共享同一个地址空间和所有可用数据的能力。对于进程来讲，它们具有的是不同的地址空间，因此需要引入线程这样的模型和概念。 线程比进程更轻量级，所以它们比进程更容易（即更快）创建，也更容易撤销。 性能方面。如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。 在多CPU系统中，多线程是有益的。 一些典型的例子来理解引入线程的好处：\n字处理软件 一个线程与用户交互 一个线程在后台重新进行格式处理 第三个线程可以处理磁盘备份 这个例子用三个不同的进程不能做到，因为三个线程会对同一个文件进行操作，多个线程可以共享公共内存。 万维网服务器 分派程序 工作线程 高速缓存 线程较好地改善了Web服务器的性能，而且每个线程是按通常方式顺序编程的。 第三种可能的设计：有限状态机 三种方案的比较，见P57 图2-10 必须处理极大量数据的应用 一个输入线程 一个处理线程 一个输出线程 2.2.2 经典的线程模型 进程模型基于两种独立的概念：资源分组处理与执行。 理解进程的一个角度是：用某种方法把相关的资源集中在一起。 进程拥有一个执行的线程，通常简写为线程。 进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。 线程给进程模型增加了一项内容，即在同一个进程环境下，允许彼此之间有较大独立性的多个线程执行。 在同一个进程中运行多个线程，多个线程共享同一个地址空间和其他资源，而在同一个计算机上运行多个进程，多个进程共享物理内存、磁盘、打印机和其他资源，因此线程也被称为轻量级进程。 当多线程进程在单CPU系统中运行时，线程轮流运行。CPU在线程之间的快速切换，制造了线程并行运行的假象。 所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或甚至清楚另一个线程的堆栈。线程之间是没有保护的。 线程概念试图实现的是，共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。 线程可以处于若干状态的任何一个：运行、阻塞、就绪或终止。线程状态之间的转换和进程状态之间的转换似乎一样的。 认识到每个线程有自己的堆栈很重要。每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。在该栈帧中存放了相应过程的局部变量以及过程调用完之后使用的返回地址。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史。 进程通常会从当前的单个线程开始，这个线程有能力通过调用一个库函数（如 thread_create ）创建新的线程。不论线程之间有无层次关系，创建线程通常都返回一个线程标识符，该标识符就是新线程的名字。 线程退出：thread_exit thread_join：一个线程可以等待一个（特定）线程退出。 thread_yield：允许线程自动放弃CPU从而让另一个线程运行。这样一个调用是很重要的，因为不同于进程，（线程库）无法利用时钟中断强制线程让出CPU。 2.2.3 POSIX线程 线程包 pthread。\npthread_create pthread_exit pthread_join pthread_yield pthread_attr_init：创建并初始化一个线程的属性结构 pthread_attr_destroy：删除一个线程的属性结构 2.2.4 在用户空间中实现线程 优点\n用户级线程可以在不支持多线程的操作系统上实现。 进行线程切换比陷入内核要快一个数量级（或许更多）。 保存线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。另一方面，不需要陷入内核，不需要上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。 它运行每个进程有自己定制的调度算法。 用户级线程还有较好的扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间，如果内核线程的数量非常大，就会出现问题。 在用户空间实现多线程，线程在一个运行时系统的上层运行，该运行时系统是一个管理线程的过程的集合。 在用户空间管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。 用户级线程出现的问题\n如何实现阻塞系统调用。替代方案是提前通知。 如果一个线程开始运行，那么在该进程中的其他线程就不能运行。 2.2.5 在内核中实现线程 在内核中有用来记录系统中所有线程的线程表。 内核的线程表保存了每个线程的寄存器、状态和其他信息。 所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。 由于在内核中创建和撤销线程的代价比较大，某些系统采取“环保”的处理方式，回收其线程。 内核线程不需要任何新的、非阻塞系统调用。 2.2.6 混合实现 一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。 2.2.7 调度程序激活机制 调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。 由于避免了在用户空间和内核空间之间的不必要转换，从而提高了效率。 当使用调度程序激活机制时，内核给每个进程安排一定数量的虚拟处理器，并且让（用户空间）运行时系统将线程分配到处理器上。 2.2.8 弹出式线程 一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。\n2.2.9 使单线程代码多线程化 略\n2.3 进程间通信 进程间通信：Inter Process Communication, IPC。\n进程间通信主要要解决三个问题：\n一个进程如何把信息传递给另一个。 确保两个或更多的进程在关键活动中不会出现交叉。 与正确的顺序有关。 2.3.1 竞争条件 竞争条件：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。例如书中举的脱机打印的例子。\n2.3.2 临界区 避免竞争条件需要互斥，即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。 对共享内存进行访问的程序片段称作临界区域或临界区。如果我们能够适当地安排，使得两个进程不可能同时处于临界区中，就能避免竞争条件。 一个好的解决方案，需要满足以下四个条件： 任何两个进程不能同时处于其临界区。 不应对CPU的速度和数量做任何假设。 临界区外运行的进程不得阻塞其他进程。 不得使进程无限期等待进入临界区。 2.3.3 忙等待的互斥 1.屏蔽中断 在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。 这个方法并不好。屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。 2.锁变量 设想有一个共享（锁）变量，其初始值为0。0就表示临界区内没有进程，1表示已经有某个进程进入临界区。 疏漏之处：一个进程读出锁变量的值为0，在将它设为1之前，另一个进程被调度运行，将该锁变量设置为1。第一个进程再次运行，将锁变量设置为1，这样就有两个进程在临界区中。 3.严格轮换法 对于编写操作系统而言，C语言是强大、有效、可预知和有特性的语言。 连续测试一个变量直到某个值出现为止，称为忙等待。 由于这种方式浪费CPU时间，所以通常应该避免。只有在有理由认为等待时间非常短的情形下，才使用忙等待。用于忙等待的锁，称为自旋锁。 缺点：在一个进程比另一个慢了很多的情况下，轮流进入临界区并不是一个好办法。这种情况违反了前面叙述的条件3:进程0被一个临界区之外的进程阻塞。 4.Peterson解法 略\n5. TSL指令 1 TSL RX,LOCK 这条指令称为测试并加锁（test and set lock），它将一个内存字lock读到寄存器RX中，然后在该内存地址上存一个非零值。执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存。\n锁住存储总线不同于屏蔽中断。事实上，在处理器1上屏蔽中断对处理器2根本没有任何影响。让处理器2远离内存直到处理器1完成的唯一方法就是锁住总线，这需要一个特殊的硬件设施。 为了使用TSL指令，要使用一个共享变量lock来协调对共享内存的访问。 进程在进入临界区之前先调用enter_region，这将导致忙等待，直到锁空闲为止，随后它获得该锁并返回。在进程从临界区返回时它调用leave_region，这将把lock设置为0。进程必须在正确的时间调用enter_region和leave_region，解法才能奏效。 一个可替代TSL指令的是XCHG，它原子性地交换了两个位置的内容。 2.3.4 睡眠与唤醒 Peterson解法和TSL或XCHG解法都是正确的，但是它们都有忙等待的缺点。这些解法的本质：当一个进程想进入临界区，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。考虑优先级反转问题。 进程间通信原语：sleep和wakeup。 生产者-消费者问题 两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息。 问题在于当缓冲区已满，而此时生产者还想向其中放入一个新的数据项的情况。其解决办法是让生产者睡眠，待消费者从缓冲区中取出一个或多个数据项时再唤醒它。同样地，当消费者试图从缓冲区中取数据而发现缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。 这里有可能会出现竞争条件，其原因是对count的访问未加限制。 问题的实质在于发给一个（尚）未睡眠进程的wakeup信号丢失了。快速弥补的方法是修改规则，加上一个唤醒等待位。唤醒等待位实际上就是wakeup信号的一个小仓库。但原则上，这并没有从根本上解决问题。 2.3.5 信号量 使用一个整型变量来累计唤醒次数，供以后使用，称作信号量。 设立两个操作down (P操作) 和up (V操作)（分别为一般化后的sleep和wakeup）。 检查数值、修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的原子操作完成。 所谓原子操作，是指一组相关联的操作要么不间断地执行，要么都不执行。 up操作对信号量的值增1。 如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作，则由系统选择其中的一个（如随机挑选）并允许该进程完成它的down操作。 用信号量解决生产者-消费者问题 为确保信号量能正确工作，最重要的是要采用一种不可分割的方式来实现它。 该方案使用了三个信号量： full：用来记录充满的缓冲槽数目； empty：记录空的缓冲槽的数目； mutex：用来确保生产者和消费者不会同时访问缓冲区。如果每个进程在进入临界区前都执行一个down操作，并在刚刚退出时执行一个up操作，就能够实现互斥。该信号量用户互斥，保证任一时刻只有一个进程读写缓冲区和相关变量。 full和empty用来保证某种事件的顺序发生或不发生。 2.3.6 互斥量 互斥量仅仅适用于管理共享资源或一小段代码。 互斥量是一个可以处于两态之一的变量：解锁和加锁。 常常使用一个整型量，0表示解锁，而其他所有的值则表示加锁。 当一个线程（或进程）需要访问临界区时，它调用mutex_lock。如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区。另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用mutex_unlock。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。 2.3.7 管程 同步原语：管程。一个管程是一个由过程、变量以及数据结构等组成的集合，它们组成一个特殊的模块或软件包。进程可在任何需要的时候调用管程中的过程，但它们不能在管程之外声明的过程中直接访问管程内的数据结构。 管程有一个很重要的特性，即任一时刻管程中只能有一个活跃的进程，这一特性使管程能有效地完成互斥。 编译器调用管程时的典型处理方法是，当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果有，调用进程将被挂起，直到另一个进程离开管程将其唤醒。如果没有活跃进程在使用管程，则该调用进程可以进入。 进入管程时的互斥由编译器负责，但通常的做法是用一个互斥量或二元信号量。 实现阻塞，引入条件变量以及相关的两个操作：wait和signal。当一个管程过程发现它无法继续运行时，它会在某个条件变量上执行wait操作。另一个进程，比如消费者，可以唤醒正在睡眠的伙伴进程，这可以通过对其伙伴正在等待的一个条件变量执行signal完成。 Brinch Hansen 建议执行signal的进程必须立即退出管程，即signal语句只可能作为一个管程过程的最后一个语句。 sleep和wakeup之所以失败是因为当一个进程想睡眠时另一个进程试图去唤醒它。使用管程则不会发生这种情况。如果管程过程中的生产者发现缓冲区满，它将能够完成wait操作而不用担心调度程序可能会在wait完成之前切换到消费者。甚至，在wait执行完成而且把生产者标志为不可运行之前，根本不会允许消费者进入管程。 信号量太低级了，而管程在少数几种编程语言之外无法使用，并且，这些原语均未提供机器间的信息交换方法。所以还需要其他的方法，也就是消息传递。\n2.3.8 消息传递 消息传递的两条原语send和receive。\n如果没有消息可用，则接收者可能被阻塞，直到一条消息的到达，或者，带着一个错误码立即返回。\n1. 消息传递系统的设计要点 为了防止消息丢失，一旦接收到信息，接收方马上回送一条特殊的确认消息。如果发送方在一段时间间隔内未收到确认，则重发消息。\n对于接收者来说，如何区分新的消息和一条重发的老消息是非常重要的。通常采用在每条原始消息中嵌入一个连续的序号来解决此问题。\n消息系统还需要解决进程命名的问题，在send和receive调用中所指定的进程必须是没有二义性的。身份认证也是一个问题。还有性能问题。\n2. 用消息传递解决生产者-消费者问题 在该解决方案中共使用N条消息，类似于一个共享内存缓冲区中的N个槽。当生产者向消费者传递一个数据项时，它取走一条空消息并送回一条填充了内容的消息。\n如何对消息进行编址。一种方法是为每个进程分配一个唯一的地址，让消息按进程的地址编址。另一种方法是引入信箱，是一个用来对一定数量的消息进行缓冲的地方。\n2.3.9 屏障 屏障可用于一组进程同步。执行barrier原语。\n2.3.10 避免锁：读-复制-更新 最快的锁是根本没有锁。\n然而，在某些情况下，我们可以允许写操作来更新数据结构，即便还有其他的进程正在使用它。窍门在于确保每个读操作要么读取旧的数据版本，要么读取新的数据版本，但绝不能是新旧数据的一些奇怪组合。\n读-复制-更新，将更新过程中的移除和再分配过程分离开来。\n2.4 调度 2.4.1 调度简介 1. 进程行为 当一个进程等待外部设备完成工作而被阻塞时，才是I/O活动。\n计算密集型和I/O密集型。随着CPU变得越来越快，更多的进程倾向为I/O密集型。\n2. 何时调度 第一，在创建一个新进程之后，需要决定的是运行父进程还是运行子进程。\n第二，在一个进程退出时必须做出调度决策。\n第三，当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。\n第四，在一个I/O中断发生时，必须做出调度决策。\n根据如何处理时钟中断，可以把调度算法分为两类：\n非抢占式 抢占式 3. 调度算法分类 三种环境：\n批处理。非抢占式算法。 交互式。抢占是必需的，服务器也归于此类。 实时。抢占有时是不需要的。 实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。\n4. 调度算法的目标 所有系统\n公平——给每个进程公平的CPU份额 策略强制执行——保证规定的策略被执行 平衡——保持系统的所有部分都忙碌 批处理系统\n吞吐量——每小时最大作业数 周转时间——从提交到终止间的最小时间 CPU利用率——保持CPU始终忙碌，CPU利用率并不是一个好的度量参数。真正有价值的是，系统每小时可完成多少作业（吞吐量），以及完成作业需要多长时间（周转时间）。 交互式系统\n响应时间——快速响应请求 均衡性——满足用户的期望 实时系统\n满足截止时间——避免丢失数据 可预测性——在多媒体系统中避免品质降低 2.4.2 批处理系统中的调度 1. 先来先服务 最简单的是非抢占式的先来先服务算法。\n当在被阻塞的进程变为就绪时，就像一个新来到的作业一样，排到就绪队列的末尾，即排在所有进程最后。\n主要优点是易于理解并且便于在程序中运行。缺点很明显。例如一个一次运行1秒钟的计算密集型进程和很少使用CPU但是每个都要进行1000次磁盘读操作才能完成的大量I/O密集型进程存在。\n2. 最短作业优先 适用于运行时间可以预知的另一个非抢占式的批处理调度算法。\n只有在所有作业都可同时运行的情形下，最短作业优先算法才是最优的。\n3. 最短剩余时间优先 最短作业优先的抢占式版本是最短剩余时间优先算法。\n调度程序总是选择剩余运行时间最短的那个进程运行。再次提醒，有关的运行时间必须提前掌握。\n这种方式可以使新的短作业获得良好的服务。\n2.4.3 交互式系统中的调度 1. 轮转调度 一种最古老、最简单、最公平且使用最广的算法是轮转调度。每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。\n时间片轮转调度中唯一有趣的一点是时间片的长度。涉及到上下文切换。\n时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为20ms～50ms通常是一个比较合理的折中。\n2. 优先级调度 优先级调度的基本思想是：每个进程被赋予一个优先级，运行优先级最高的可运行进程线运行。\n为了防止高优先级进程无休止地运行下去，调度程序可能在每个时钟滴答（即每个时钟中断）降低当前进程的优先级。如果这一行为导致该进程的优先级低于次高优先级的进程，则进行进程切换。另一种方法是，给每个进程赋予一个允许运行的最大时间片，当用完这个时间片时，次高优先级的进程便获得运行机会。\n优先级可以静态赋予或动态赋予。\n为达到某种目的，优先级可以由系统动态确定。使I/O密集型进程获得较好服务的一种简单算法是，将其优先级设为1/f，f为该进程在上一时间片中所占的部分。\n如果不偶尔对优先级进行调整，则低优先级进程很可能会产生饥饿现象。\n3. 多级队列 属于最高优先级类的进程运行一个时间片，属于次高优先级类的进程运行2个时间片，再次一级运行4个时间片，以此类推。当一个进程用完分配的时间片后，它被移动到下一类。\n随着进程优先级的不断降低，它的运行频度逐渐放慢，从而为短的交互进程让出CPU。\n对于那些刚开始运行一段长时间，而后来又需要交互的进程，为了防止其永远处于被惩罚状态，可以采取下面的策略。只要终端上有回车键按下，则属于该终端的所有进程就都被移到最高优先级，这样做的原因是假设此时进程即将需要交互。\n4. 最短进程优先 首先运行最短的作业来使响应时间最短。\n如何从当前可运行进程中找出最短的那一个进程。一种办法是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。\n老化技术，假设某个终端上某条命令的估计运行时间为$T_0$。现在假设测量到其下一次运行时间为$T_1$。可以用这两个值加权和来改进估计时间，即$aT_0+(1-a)T_1$。可以根据需要选择$a$的值。\n5. 保证调度 向用户作出明确的性能保证，然后去实现它。若用户工作时有$n$个用户登录，则用户将获得CPU处理能力的$1/n$。\n系统必须跟踪各个进程自创建以来已使用了多少CPU时间。然后它计算各个进程应获得的CPU时间，即自创建以来的时间除以$n$。该算法转向比率最低的进程。\n6. 彩票调度 其基本思想是为进程提供各种系统资源（如CPU时间）的彩票。一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得资源。在应用到CPU调度时，系统可以掌握每秒钟50次的一种彩票，作为奖励每个获奖者可以得到20ms的CPU时间。\n所有进程是平等的，但是某些进程更平等一些。拥有彩票$f$份额的进程大约得到系统资源的$f$份额。\n彩票调度是反应迅速的。\n彩票调度可以用来解决其他方法很难解决的问题，例如视频服务器提供视频流，每个视频流的帧速率都不相同。\n7. 公平分享调度 考虑谁拥有进程这一因素。\n2.4.4 实时系统中的调度 实时系统通常可以分为硬实时和软实时。前者的含义是必须满足绝对的截止时间，后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。\n实时系统的调度算法可以是静态或动态的。\n2.4.5 策略和机制 解决问题的方法是将调度机制与调度策略分离这个一贯的原则。\n2.4.6 线程调度 用户级线程：运行时系统使用调度算法可以是上面介绍的算法中的任意一种，常用轮转调度和优先级调度。\n内核级线程。\n用户级线程和内核级线程之间的差别在于性能。用户级线程的线程切换需要少量的机器指令，而内核级线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这导致了若干数量级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在I/O上就不需要像在用户级线程中那样将整个进程挂起。\n用户级线程可以使用专为应用程序定制的线程调度程序。而在内核级线程中，内核从来不了解每个线程的作用。一般而言，应用定制的线程调度程序能够比内核更好地满足应用的需要。\n2.5 经典的IPC问题 2.5.1 哲学家就餐问题 一种没有死锁，而且对于任意位哲学家的情况都能获得最大的并行度。使用一个数组state跟踪每一个哲学家是在进餐、思考还是饥饿状态（正在试图拿叉子）。一个哲学家只有在两个邻居都没有进餐时才允许进入到进餐状态。\n2.5.2 读者-写者问题 为数据库访问建立了一个模型。\n第3章 内存管理 分层存储器体系 操作系统中管理分层存储器体系的部分称为存储管理器。它的任务是有效地管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。 3.1 无存储器抽象 最简单的存储器抽象就是根本没有抽象，其模型就是简单的物理内存。 在不使用存储器抽象的情况下运行多个程序\n操作系统只需要把当前内存中所有内容保存到磁盘文件中，然后把下一个程序读入到内存中再运行即可。只要在某一个时间内存中只有一个程序，那么就不会发生冲突。 用内存键的方式并发地运行多个程序的缺陷：会出现对内存地址的不正确访问，问题的关键是两个程序都引用了绝对物理地址。 3.2 一种存储器抽象：地址空间 把物理地址暴露给进程的几个问题：\n用户程序可以很容易地破坏操作系统，从而使系统慢慢地停止运行。 想要同时运行多个程序是很困难的。 3.2.1 地址空间的概念 要使多个应用程序同时处于内存中并且互不影响，需要解决两个问题：保护和重定位。 地址空间为程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。 地址空间概念举例 电话号码的地址空间是从 0 000 000 到 9 999 999 x86的I/O端口的地址空间从0到16 383 以“.com”结尾的网络域名的集合也是地址空间 基址寄存器与界限寄存器\n动态重定位，简单地把每个进程的地址空间映射到物理内存的不同部分。 当使用基址寄存器和界限寄存器时，程序装载到内存中连续的空闲位置且装载期间无须重定位。当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。 每次一个进程访问内存，取一条指令，读或写一个数据字，CPU硬件会把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。同时，它检查程序提供的地址是否等于或大于界限寄存器里的值，如果访问的地址超出了界限，会产生错误并中止访问。 使用基址寄存器和界限寄存器是给每个进程提供私有地址空间的非常容易的方法，因为每个内存地址在送到内存之前，都会自动先加上基址寄存器的内容。 使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算。比较运算可以做得很快，但是加法运算由于进位传递时间的问题，在没有特殊电路的情况下会显得很慢。 3.2.2 交换技术 所有进程所需要的RAM数量总和通常要远远超出存储器能够支持的范围。 有两种处理内存超载的通用方法 交换技术，即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以当它们不运行时就不会占用内存。 虚拟内存，该策略甚至能使程序在只有一部分被调入内存的情况下运行。 交换在内存中产生了多个空闲区，通过把所有放入进程尽可能向下移动，有可能将这些小的空闲区合成一大块。该技术称为内存紧缩。通常不进行这个操作，因为它要耗费大量的CPU时间。 如果大部分进程在运行时都要增长，为了减少因内存区域不够而引起的进程交换和移动所产生的开销，一种可用的方法是，当换入或移动进程时为它分配一些额外的内存。然而，当进程被换出到磁盘上时，应该只交换进程实际上使用的内存中的内容，将额外的内存交换出去是一种浪费。 如果进程有两个可增长的段，在两者之间的内存可供两个段使用。 3.2.3 空闲内存管理 一般而言，有两种方法跟踪内存使用情况：位图和空闲区链表。\n1. 使用位图的存储管理\n使用位图方法时，内存可能被划分成小到几个字或大到几千字节的分配单位。每个分配单元对应于位图中的一位，0表示空闲，1表示占有（或者相反）， 分配单元的大小是一个重要的设计因素。分配单元越小，位图越大。若选择比较大的分配单元，则位图更小。但若进程的大小不是分配单元的整数倍，那么在最后一个分配单元中就会有一定数量的内存被浪费了。 这种方法的主要问题是，在决定把一个占k个分配单元的进程掉入内存时，存储管理器必须搜索位图，在位图中找出有k个连续0的串。查找位图中指定长度的连续0串是耗时的操作（因为在位图中该串可能跨越字的边界），这是位图的缺点。 2. 使用链表的存储管理\n维护一个记录已分配内存段和空闲内存段的链表。其中链表中的一个结点或者包含一个进程，或者是两个进程间的一块空闲区。 链表中的每一个结点都包含以下域：空闲区（H）或进程（P）的指示标志、起始地址、长度和指向下一结点的指针。 当按照地址顺序在链表中存放进程和空闲区时，几种算法可以用来为创建的进程分配内存。\n首次适配算法。存储管理器沿着段链表进行搜索，直到找到一个足够大的空闲区，除非空闲区大小和分配的空间大小正好一样，否则将该空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区。 下次适配算法。它的工作方式和首次适配算法相同，不同点是每次找到合适的空闲区时都记录当时的位置，以便在下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次适配算法那样每次都从头开始。仿真程序表明下次适配算法性能略低于首次适配算法。 最佳适配算法。搜索整个链表（从开始到结束），找出能够容纳进程的最小的空闲区。最佳适配算法试图找出最接近实际需要的空闲区，以最好地匹配请求和可用空闲区，而不是拆分一个以后可能会用到的大的空闲区。 因为每次调用最佳适配算法时都要搜索整个链表，所以它要比首次适配算法慢。让人感到有点意外的是，它比首次适配算法或下次适配算法浪费更多的内存，因为它会产生大量无用的小空闲区。一般情况下，首次适配算法生成的空闲区更大一些。 最差适配算法。总是分配最大的可用空闲区，使新的空闲区比较大从而可以继续使用。仿真程序表明最差适配算法也不是一个好主意。 如果进程和空闲区使用不同的链表，则可以按照大小对空闲区链表排序，以便提高最佳适配算法的速度。空闲区链表按大小排序时，首次适配算法与最佳适配算法一样快，而下次适配算法在这里则毫无意义。\n快速适配算法，它为那些常用大小的空闲区维护单独的链表。快速适配算法寻找一个指定大小的空闲区是十分快速的，但它和所有将空闲区按大小排序的方案一样，都有一个共同的缺点，即在一个进程终止或被换出时，寻找它的相邻块并查看是否可以合并的过程是非常耗时的。如果不进行合并，内存将会很快分裂出大量的进程无法利用的小空闲区。\n3.3 虚拟内存 还有另外一个问题需要解决：管理软件的膨胀。 程序大于内存，一种解决方法是把程序分割成许多片段，称为覆盖。但是把一个程序分割成小的、模块化的片段是非常费时和枯燥的，并且容易出错。很少程序员擅长使用覆盖技术。 虚拟内存技术。其基本思想是：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立即执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。 从某个角度来讲，虚拟内存是对基址寄存器和界限寄存器的一种综合。 3.3.1 分页 由程序产生的这些地址称为虚拟地址，它们构成了一个虚拟地址空间。在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元（Memory Management Unit, MMU），MMU把虚拟地址映射为物理内存地址。 虚拟地址空间按照固定大小划分成被称为页面的若干单元。在物理内存中对应的单元称为页框。页面和页框的大小通常是一样的。RAM和磁盘之间的交换总是以整个页面为单元进行的。 通过恰当地设置MMU，可以把16个虚拟页面映射到8个页框中的任何一个。 MMU注意到该页面没有被映射，于是使CPU陷入到操作系统，这个陷阱称为缺页中断或缺页错误。操作系统找到一个很少使用的页框且把它的内容写入到磁盘（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。 MMU内部结构，了解为什么我们选用的页面大小都是2的整数次幂。输入的16位虚拟地址被分为4位的页号和12位的偏移量。可用页号座位页表的索引，以得出对应于该虚拟页面的页框号。如果“在/不在”位为1，则将在页表中查到的页框号复制到输出寄存器的高3位中，再加上输入虚拟地址中的低12位偏移量，如此就构成了15位的物理地址。输出寄存器的内容随即可被作为物理地址送到内存总线。 3.3.2 页表 虚拟地址到物理地址的一种简单实现可以概括为：虚拟地址被分为虚拟页号（高位部分）和偏移量（低位部分）两部分。 虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成送往内存的物理地址。 页表的目的是把虚拟页面映射到页框。从数学角度说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。通过这个函数可以把虚拟地址中的虚拟页面域替换成页框域，从而形成物理地址。 页表项的结构\n页框号 “在/不在”位 保护位指出一个页允许什么类型的访问。 为了记录页面的使用状况，引入了修改位和访问位。 不论是读还是写，系统都会在该页面被访问时设置访问位。它的值被用来帮助操作系统在发生缺页中断时选择要被淘汰的页面。不再使用的页面要比正在使用的页面更适合淘汰。 最后一位用于禁止该页面被高速缓存。 应该注意的是，若某个页面不在内存中，用于保护该页面的磁盘地址不是页表的组成部分。\n虚拟内存本质上是用来创造一个新的抽象概念——地址空间，这个概念是对物理内存的抽象，类似于进程是对物理处理器（CPU）的抽象。虚拟内存的实现，是将虚拟地址空间分解成页，并将每一页映射到物理内存的某个页框或者（暂时）解除映射。\n3.3.3 加速分页过程 在任何分页系统中，都需要考虑两个主要问题：\n虚拟地址到物理地址的映射必须非常快。 如果虚拟地址空间很大，页表也会很大。 第一个问题是由于每次访问内存都需要进行虚拟地址到物理地址的映射，所有的指令最终都必须来自内存，并且很多指令也会访问内存中的操作数。\n第二个问题来自现代计算机使用至少32位的虚拟地址，而且64位变得越来越普遍。\n对大而快速的页映射的需求称为构建计算机的重要约束。一种简单的设计是使用“快速硬件寄存器”，这个方法的优势是简单并且在映射过程中不需要访问内存。而缺点是在页表很大时，代价高昂。而且每一次上下文切换都必须装载整个页表，这样会降低性能。另一种极端的方法是，整个页表都在内存中。这种做法的缺陷是在执行每条指令时，都需要一次或多次内存访问来完成页表项的读入，速度非常慢。\n1. 转换检测缓冲区\n有了分页机制后，会因为要访问页表而引起更多次的内存访问。\n一种解决方案的建立基于这样一种观察：大多数程序总是对少量的页面进行多次的访问，而不是相反。因此，只有很少的页表项会被反复读取，而其他的页表项很少被访问。\n为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。这种设备称为转换检测缓冲区（Translation Lookaside Buffer, TLB），有时又称为相联存储器或快表。它通常在MMU中，每个表项记录了一个页面的相关信息，包括虚拟页号、页面的修改位、保护码（读/写/执行权限）和该页所对应的物理页框。\n如果发现了一个有效的匹配并且要进行的访问操作并不违反保护位，则将页框号直接从TLB中取出而不必再访问页表。如果虚拟页号确实是在TLB中，但指令试图在一个只读页面上进行写操作，则会产生一个保护错误，就像对页表进行非法访问一样。如果MMU检测到没有有效的匹配项，就会进行正常的页表查询。接着从TLB中淘汰一个表项，然后用新找到的页表项代替它。当一个表项被清除出TLB时，将修改位复制到内存中的页表项，而除了访问位，其他的值不变。当页表项从页表装入TLB中时，所有的值都来自内存。\n2. 软件TLB管理\n许多现代的RISC机器，几乎所有的页面管理都是在软件中实现的。当发生TLB访问失效时，不再由MMU到页表中查找并取出需要的页表项，而是生成一个TLB失效并将问题交给操作系统解决。\n如果TLB大到（如64个表项）可以减少失效率时，TLB的软件管理就会变得足够有效。\n无论是用硬件还是软件来处理TLB失效，常见方法都是找到页表并执行索引操作以定位将要访问的页面。可以通过在内存中的固定位置维护一个大的（如4KB）TLB表项的软件高速缓存来减少TLB失效。\n当一个页面访问在内存中而不在TLB中时，将产生软失效。当页面本身不在内存中（当然也不在TLB中）时，将产生硬失效。\n引发缺页错误的几种情况：\n次要缺页错误 严重缺页错误 段错误 3.3.4 针对大内存的页表 1. 多级页表\n引入多级页表的原因是避免把全部页表一直保存在内存中。特别是那些从不需要的页表就不应该保留。\n多理解书中的例子。\n2. 倒排页表\n在这种设计中，实际内存中的每个页框对应一个表项，而不是每个虚拟页面对应一个表项，但它也有严重的不足：从虚拟地址到物理地址的转换会变得很困难。\n可以使用TLB。实现搜索的一个可行的方法是建立一张散列表，用虚拟地址来散列。如果散列表中的槽数与机器中物理页面数一样多，那么散列表的冲突链的平均长度会是一个表项的长度，这将会大大提高映射速度。一旦页框号被找到，新的（虚拟页号，物理页框号）对就会被装载到TLB中。\n倒排页表在64位机器中很常见。\n3.4 页面置换算法 当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘上的副本；如果该页面没有被修改过（如一个包含程序正文的页面），那么它在磁盘上的副本已经是最新的，不需要回写。直接用调入的页面覆盖被淘汰的页面就可以了。\n当需要从内存中换出某个页面时，它是否只能是缺页进程自己的页面？这个要换出的页面是否可以属于另外一个进程？在前一种情况下，可以有效地将每一个进程限定在固定的页面数目内；后一种情况则不能。\n3.4.1 最优页面置换算法 算法工作原理：在缺页中断发生时，有些页面在内存中，其中有一个页面（包含紧接着的下一条指令的那个页面）将很快被访问，其他页面则可能要到10、100或1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记。\n最优页面置换算法规定应该置换标记最大的页面。\n这个算法唯一的问题就是它是无法实现的。当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。用这种方式，可以通过最优页面置换算法对其他可实现算法的性能进行比较。\n为了避免混淆，必须清楚以上页面访问情况的记录只针对刚刚被测试过的程序和它的一个特定的输入。\n3.4.2 最近未使用页面置换算法 系统为每一页面设置了两个状态位。当页面被访问（读或写）时设置R位；当页面被写入（即修改）时设置M位。一旦设置某位为1，它就一直保持1直到操作系统将它复位。\n如果硬件没有这些位，则可以使用操作系统的缺页中断和时钟中断机制进行模拟。\n可以用R位和M位来构造一个简单的页面置换算法：当启动一个进程时，它的所有页面的两个位都由操作系统设置为0，R位被定期地（比如在每次时钟中断时）清零，以区别最近没有被访问的页面和被访问的页面。\n4类：\n第0类：没有被访问，没有被修改。 第1类：没有被访问，已被修改。 第2类：已被访问，没有被修改。 第3类：已被访问，已被修改。 NRU算法随即地从类编号最小的非空类中挑选一个页面淘汰。NRU算法的主要优点是易于理解和能够有效地被实现，虽然它的性能不是最好的，但是已经够用了。\n3.4.3 先进先出页面置换算法 由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早进入的页面放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加入到表尾。\n3.4.4 第二次机会页面置换算法 第二次机会算法对先进先出页面置换算法做了一个简单的修改：检查最老页面的R位。如果R位为0，那么这个页面既老又没有被使用，可以立刻被置换掉；如果是1，就将R位清0，并把该页面放到链表的尾端，修改它的装入时间使它像刚装入的一样，然后继续搜索。\n第二次机会算法就是寻找一个在最近的时钟间隔内没有被访问过的页面。\n3.4.5 时钟页面置换算法 第二次机会算法经常要在链表中移动页面，既降低了效率又不是很有必要。一个更好的办法是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。\n3.4.6 最近最少使用页面置换算法 对最优算法的一个很好的近似是基于这样的观察：在前面几条指令中频繁使用的页面很可能在后面的几条指令中被使用。\n在缺页中断发生时，置换未使用时间最长的页面。这个策略称为LRU（Least Recently Used, 最近最少使用）页面置换算法。\n3.4.7 用软件模拟LRU NFU（Not Frequently Used，最不常用）算法。该算法将每个页面与一个软件计数器相关联，计数器的初值为0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的R位（它的值是0或1）加到它的计算器上。这个计算器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面。这个算法的问题是它从来不忘记任何事情。\n老化算法：首先，在R位被加进之前先将计数器右移一位；其次，将R位加到计数器最左端的位而不是最右端的位。\n3.4.8 工作集页面置换算法 请求调页，因为页面是在需要时被调入的，而不是预先装入。\n局部性访问行为，即在进程运行的任何阶段，它都只访问较少的一部分页面。\n一个进程当前正在使用的页面的集合称为它的工作集。若每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了颠簸。\n不少分页系统都会设法跟踪进程的工作集，以确保在让进程运行之前，它的工作集就已在内存中了。该方法称为工作集模型，其目的在于大大减少缺页中断率。在进程运行前预先装入其工作集页面也称为预先调页。\n在任一时刻t，都存在一个集合，它包含所有最近k次内存访问所访问过的页面。这个集合w(k,t)就是工作集。\n事实上大多数程序会任意访问一小部分页面，但是这个集合会随着时间而缓慢变化，这个事实也解释了为什么一开始曲线快速地上升而k较大时上升会变慢。预先调页就是在程序继续运行之前预先装入推测出的工作集的页面。\n页面置换算法：当发生缺页中断时，淘汰一个不在工作集的页面。根据定义，工作集就是最近k次内存访问所使用过的页面的集合。\n作为替代，一种能够常见的近似方法就是，不是向后找最近k次的内存访问，而是考虑其执行时间。一个进程从它开始执行到当前实际使用的CPU时间总数通常称作当前实际运行时间。通过这个近似的方法，进程的工作集可以被称为过去的$\\tau$秒实际运行时间中它所访问过的页面的集合。\n扫描所有页面检查R位：\n若 (R==1)：设置上次使用时间为当前实际时间 若(R == 0 且生存时间 \u0026gt; $\\tau$) ：移出这个页面 若(R == 0 且生存时间 \u0026lt;= $\\tau$) ：记住最小时间 3.4.9 工作集时钟页面置换算法 与时钟算法一样，所需的数据结构是一个以页框为元素的循环表。\n如果R位被置为1，该页面在当前时钟滴答中就被使用过，那么该页面就不适合淘汰。然后把该页面的R位置为0，指针指向下一个页面，并重复该算法。\n如果R位被置为0。如果页面的生存时间大于$\\tau$并且该页面是干净的，申请此页框，并把新页面放在其中。另一方面，如果此页面被修改过，就不能立即申请页框，指针继续向前走。\n原则上，所有的页面都有可能因为磁盘I/O在某个时钟周期被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回n个页面。一旦达到该限制，就不允许调度新的写操作。\n3.4.10 页面置换算法小结 算法 注释 最优算法 不可实现，但可用作基准 NRU（最近未使用）算法 LRU的很粗糙的近似 FIFO（先进先出）算法 可能抛弃重要页面 第二次机会算法 比FIFO有较大的改善 时钟算法 现实的 LRU（最近最少使用）算法 很优秀，但很难实现 NFU（最不经常使用）算法 LRU的相对粗略的近似 老化算法 非常近似LRU的有效算法 工作集算法 实现起来开销很大 工作集时钟算法 好的有效算法 3.7 分段 编译器的例子。一个直观并且通用的方法是在机器上提供多个互相独立的称为段的地址空间。每个段由一个从0到最大的线性地址序列构成。各个段的长度可以是0到某个允许的最大值之间的任何一个值。不同段的长度可以不同，并且通常情况下也都不相同。段的长度在运行期间可以动态改变。\n段当然有可能会被装满，但通常情况下段都很大，因此这种情况发生的可能性很小。程序必须提供两部分地址，一个段号和一个段内地址。\n段是一个逻辑实体。一个段可能包括一个过程、一个数组、一个堆栈、一组数组变量，但一般它不会同时包含多种不同类型的内容。\n如果每个过程都位于一个独立的段中并且起始地址是0，那么把单独编译好的过程链接起来的操作就可以得到很大的简化。\n分段也有助于在几个进程之间共享过程和数据。\n因为每个段是一个为程序员所知道的逻辑实体，比如一个过程或一个数组，故不同的段可以有不同种类的保护。\n考查点 分页 分段 需要程序员了解正在使用的这种技术吗？ 否 是 存在多少线性地址空间？ 1 许多 整个地址空间可以超出物理存储器的大小吗？ 是 是 过程和数据可以被区分并分别被保护吗？ 否 是 其大小浮动的表可以很容易提供吗？ 否 是 用户过程的共享方便吗？ 否 是 为什么发明这种技术？ 为了得到大的线性地址空间而不必购买更大的物理存储器 为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护 3.7.1 纯分段的实现 分段和分页的实现本质上是不同的：页面是定长的而段不是。\n在系统运行一段时间后内存被划分为许多块，一些块包含着段，一些则成了空闲区，这种现象称为棋盘形碎片或外部碎片。空闲区的存在使内存被浪费了，而这可以通过内存紧缩来解决。\n3.7.2 分段和分页结合：MULTICS 如果一个段比较大，把它整个保存在内存中可能很不方便甚至是不可能的，因此产生了对它进行分页的想法。这样，只有那些真正需要的页面才会被调入内存。\nMULTICS的设计者决定把每个段都看作一个虚拟内存并对它进行分页，以结合分页的优点（统一的页面大小和只在使用段的一部分时不用把它全部调入内存）和分段的优点（易于编程、模块化、保护和共享）。\n每个MULTICS程序都有一个段表，每个段对应一个描述符。段表本身也是一个段并被分页。一个段描述符包含了一个段是否在内存中的标记，只要一个段的任何一部分在内存中这个段就被认为是在内存中，并且它的页表也会在内存中。\n每个段都是一个普通的虚拟地址空间。\nMULTICS中的一个地址由两部分构成：段号和段内地址。段内地址又进一步分为页号和页内的字。算法如下：\n根据段号找到段描述符。 检查该段的页表是否在内存中。如果在，则找到它的位置；如果不在，则产生一个段错误。如果访问违反了段的保护要求就发出一个越界错误（陷阱）。 检查所请求的虚拟页面的页表项，如果该页面不在内存中则产生一个缺页中断，如果在内存就从页表项中取出这个页面在内存中的起始地址。 把偏移量加到页面的起始地址上，得到要访问的字在内存中的地址。 最后进行读或写操作。 实际上，MULTICS硬件包含了16个字的高速TLB。\n3.7.3 分段和分页结合：Intel x86 x86处理器中虚拟内存的核心是两张表，即LDT（局部描述符表）和GDT（全局描述符表）。LDT描述局部于每个程序的段，包括其代码、数据、堆栈等；GDT描述系统段，包括操作系统本身。\n为了访问一个段，一个x86程序必须把这个段的选择子装入机器的6个段寄存器的某一个中。\n在选择子被装入段寄存器时，对应的描述符被从LDT或GDT中取出装入微程序寄存器中，以便快速地访问。一个描述符由8个字节构成，包括段的基址、大小和其他信息。\n假设段在内存中并且偏移量也在范围内，x86处理器接着把描述符中32位的基址和偏移量相加形成线性地址。\n线性地址被分为三个域：目录、页面和偏移量。\nx86处理器和MULTICS一样，也有一个小的TLB把最近使用过的“目录-页面”二元组映射为页框的物理地址。\n第6章 死锁 软硬件资源都有可能出现死锁。\n6.1 资源 需要排他性使用的对象称为资源。\n6.1.1 可抢占资源和不可抢占资源 资源分为两类：可抢占的和不可抢占的。\n可抢占资源可以从拥有它的进程中抢占而不会产生任何副作用，存储器就是一类可抢占的资源。\n不可抢占资源是指在不引起相关的计算失败的情况下，无法把它从占有它的进程抢占过来。\n某个资源是否可抢占取决于上下文环境。\n总的来说，死锁与不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解。\n使用一个资源所需要的事件顺序可以用抽象的形式表示如下：\n请求资源 使用资源 释放资源 在后面的讨论中，我们假设：如果某个进程请求资源失败，那么它就进入休眠状态。\n6.1.2 资源获取 死锁是非常容易发生的。\n","date":"2022-07-01T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/01/Operating-System/","title":"现代操作系统笔记"},{"content":"任务 这是梁博云实习的第一个项目，发现负面新闻。\n实习目标\n学习和掌握json代码的解析和生成 学习一种http服务的方式 学习如何使用开放API 第一步、学习和利用现有一个情感计算API http://www.pullword.com/baobian/\n调用样例：Linux命令行下执行\n1 curl -X POST \u0026#39;http://baobianapi.pullword.com:9091/get.php\u0026#39; -d\u0026#39;十一月再见，十二月你好，2021年最后一个月总会有不期而遇的温暖，和生生不息的希望\u0026#39; –compressed 返回的json结果要能解析，大于0.5表示正面情感，小于-0.5表明负面情感。或者使用其他自己熟悉的API也可以。推荐使用梁博公开的服务。\n第二步，学习提供http服务的工具\nC语言选手可以通过搜狗工作流开源工具实现。不会C和C++的同学可以用php代码或者其他自己熟悉的语言实现。\n第三步，学习和了解数据源 http://news.baidu.com/\n从百度新闻首页获得当天热门新闻，用curl或者wget命令采集首页。然后提取其中的新闻标题和URL\n第四步，将今日新闻标题调用情感计算API得到正负面评价，提取负面结果的新闻标题和URL，通过第二步掌握的http服务工具以json格式对外展示。展示的内容包括标题和URL的列表。在自己的linux机器上能访问即可，有公网服务器的可以开放公网URL供我们检查，没有公网服务器的截图即可。\n爬取百度新闻 打开百度新闻，F12查看页面源码，可以看到热点新闻的class=mod-tab-pane active。 用如下方法得到新闻标题和链接：\n1 2 3 4 5 6 // 获取热点新闻HTML代码 Elements hotNews = doc.select(\u0026#34;[class=mod-tab-pane active]\u0026#34;).select(\u0026#34;a\u0026#34;); // 获取新闻标题及链接 for (int i = 0; i \u0026lt; hotNews.size(); i++) { news.put(hotNews.get(i).text(), hotNews.get(i).attr(\u0026#34;href\u0026#34;)); } 程序的完整逻辑是先得到百度新闻的HTML文件，再从class筛选得到相应的标题和链接，这里Elements类是实现了List\u0026lt;Element\u0026gt;接口，因此是可以遍历的，在遍历时加入存放新闻的标题和链接的哈希表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package com.jinjin.news.controller; import org.jsoup.Jsoup; import org.jsoup.nodes.Document; import org.jsoup.select.Elements; import java.io.IOException; import java.util.HashMap; /** * @author 文进 * @version 1.0 */ public class News { /** * * @param url 访问路径 * @return */ public Document getDocument (String url){ try { //5000是设置连接超时时间，单位ms return Jsoup.connect(url).timeout(5000).get(); } catch (IOException e) { e.printStackTrace(); } return null; } /** * @param url 访问网站的url * @return 返回热点新闻的标题和链接 */ public HashMap getNews (String url) { Document doc = getDocument(url); HashMap\u0026lt;String, String\u0026gt; news = new HashMap\u0026lt;\u0026gt;(); // 获取热点新闻HTML代码 Elements hotNews = doc.select(\u0026#34;[class=mod-tab-pane active]\u0026#34;).select(\u0026#34;a\u0026#34;); // 获取新闻标题及链接 for (int i = 0; i \u0026lt; hotNews.size(); i++) { news.put(hotNews.get(i).text(), hotNews.get(i).attr(\u0026#34;href\u0026#34;)); // System.out.println(hotNews.get(i).text() + \u0026#34; \u0026#34; + hotNews.get(i).attr(\u0026#34;href\u0026#34;)); } return news; } } 参考资料：Java爬取网页内容的简单例子\n使用情感计算API 情感计算API链接是：http://www.pullword.com/baobian/\n我们要做的是将爬取到的新闻标题用POST方法向上述链接发请求，最后得到一个json结果，提取其中的情感数值，将负的情感值对应的新闻标题保存下来，由于之前存取的新闻是HashMap，因此得到负面新闻的URL也不是难事了。\n参考java向指定URL发送GET或POST请求，我们用到了UrlUtils工具类，我们需要用的是public static String sendPost(String url, String param){}这个带参数的发送POST请求的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 package com.jinjin.news.controller; import com.sun.org.slf4j.internal.Logger; import com.sun.org.slf4j.internal.LoggerFactory; import java.io.*; import java.net.URL; import java.net.URLConnection; import java.util.Iterator; import java.util.List; import java.util.Map; /** * @author 文进 * @version 1.0 */ public class UrlUtils { private static final Logger log = LoggerFactory.getLogger(UrlUtils.class); /** * 向指定URL发送GET方法的请求 * * @param url 发送请求的URL * @param param 请求参数，请求参数应该是 name1=value1\u0026amp;name2=value2 的形式。 * @return URL 所代表远程资源的响应结果 */ public static String sendGet(String url, String param) { String result = \u0026#34;\u0026#34;; BufferedReader in = null; try { String urlNameString = url + \u0026#34;?\u0026#34; + param; URL realUrl = new URL(urlNameString); // 打开和URL之间的连接 URLConnection connection = realUrl.openConnection(); // 设置通用的请求属性 connection.setRequestProperty(\u0026#34;accept\u0026#34;, \u0026#34;*/*\u0026#34;); connection.setRequestProperty(\u0026#34;connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;); connection.setRequestProperty(\u0026#34;user-agent\u0026#34;, \u0026#34;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\u0026#34;); // 建立实际的连接 connection.connect(); // 获取所有响应头字段 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = connection.getHeaderFields(); // 遍历所有的响应头字段 // for (String key : map.keySet()) { // System.out.println(key + \u0026#34;---\u0026gt;\u0026#34; + map.get(key)); // } // 定义 BufferedReader输入流来读取URL的响应 in = new BufferedReader(new InputStreamReader( connection.getInputStream())); String line; while ((line = in.readLine()) != null) { result += line; } } catch (Exception e) { log.error(\u0026#34;发送GET请求出现异常！\u0026#34; + e); e.printStackTrace(); } // 使用finally块来关闭输入流 finally { try { if (in != null) { in.close(); } } catch (Exception e2) { e2.printStackTrace(); } } return result; } /** * 向指定 URL 发送POST方法的请求 * * @param url 发送请求的 URL * @param paramMap 请求参数 * @return 所代表远程资源的响应结果 */ public static String sendPost(String url, Map\u0026lt;String, ?\u0026gt; paramMap) { PrintWriter out = null; BufferedReader in = null; String result = \u0026#34;\u0026#34;; String param = \u0026#34;\u0026#34;; Iterator\u0026lt;String\u0026gt; it = paramMap.keySet().iterator(); while (it.hasNext()) { String key = it.next(); param += key + \u0026#34;=\u0026#34; + paramMap.get(key) + \u0026#34;\u0026amp;\u0026#34;; } try { URL realUrl = new URL(url); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty(\u0026#34;accept\u0026#34;, \u0026#34;*/*\u0026#34;); conn.setRequestProperty(\u0026#34;connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;); conn.setRequestProperty(\u0026#34;Accept-Charset\u0026#34;, \u0026#34;utf-8\u0026#34;); conn.setRequestProperty(\u0026#34;user-agent\u0026#34;, \u0026#34;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\u0026#34;); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader(new InputStreamReader(conn.getInputStream(), \u0026#34;UTF-8\u0026#34;)); String line; while ((line = in.readLine()) != null) { result += line; } } catch (Exception e) { log.error(e.getMessage(), e); } //使用finally块来关闭输出流、输入流 finally { try { if (out != null) { out.close(); } if (in != null) { in.close(); } } catch (IOException ex) { ex.printStackTrace(); } } return result; } /** * 发送post请求 json格式 * * @param url * @param param json字符串 * @return */ public static String sendPost(String url, String param) { PrintWriter out = null; BufferedReader in = null; StringBuilder result = new StringBuilder(); try { URL realUrl = new URL(url); // // 忽略https功能，普通使用可以删除 // if (\u0026#34;https\u0026#34;.equalsIgnoreCase(realUrl.getProtocol())) { // // SslUtils.ignoreSsl(); // } // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty(\u0026#34;accept\u0026#34;, \u0026#34;*/*\u0026#34;); conn.setRequestProperty(\u0026#34;connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;); conn.setRequestProperty(\u0026#34;Accept-Charset\u0026#34;, \u0026#34;utf-8\u0026#34;); conn.setRequestProperty(\u0026#34;user-agent\u0026#34;, \u0026#34;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\u0026#34;); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 //out = new PrintWriter(conn.getOutputStream()); out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), \u0026#34;UTF-8\u0026#34;)); // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader(new InputStreamReader(conn.getInputStream(), \u0026#34;UTF-8\u0026#34;)); String line; while ((line = in.readLine()) != null) { //result += line; result.append(line); } } catch (Exception e) { System.out.println(\u0026#34;发送 POST 请求出现异常!\u0026#34; + e); e.printStackTrace(); } //使用finally块来关闭输出流、输入流 finally { try { if (out != null) { out.close(); } if (in != null) { in.close(); } } catch (IOException ex) { ex.printStackTrace(); } } //log.info(\u0026#34;url返回: \u0026#34; +result); return result.toString(); } } 创建Spring Boot项目 上述模块都测试好之后，最后就是返回JSON数据格式，参考\u0026lt;后端初学者\u0026gt;Spring Boot 返回 JSON 数据及数据封装，有多种方法，其中一种用Spring Boot中的@RestController注解来返回JSON数据，那么我们创建一个Spring Boot项目，再把上述模块的代码迁移过来就好啦。\n创建Spring Boot项目的步骤参考2020入门教程macOS 使用Intellj IDEA 创建spring boot项目。\n返回JSON数据格式 首先为了方便返回JSON数据格式，我们先将NegativeNews封装成一个类，其主要的属性就两个：新闻的标题title和对应的url。剩下的就是常见的构造器以及get、set方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.jinjin.news.controller; /** * @author 文进 * @version 1.0 */ public class NegativeNews { private String title; private String url; public NegativeNews(String title, String url) { this.title = title; this.url = url; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } } 返回JSON数据格式可以选择多种形式，这里由于要返回的新闻有多条，因此我们返回一个List\u0026lt;NegativeNews\u0026gt;。\n在返回JSON数据格式方法的前面加上注解@RequestMapping(\u0026quot;/negativeNews\u0026quot;)，在请求该页面时，就会执行其中的代码，因此我们将上述爬取百度新闻标题，向情感计算API发送POST请求，得到负面新闻，综合到该方法中一起执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package com.jinjin.news.controller; import com.sun.net.httpserver.HttpServer; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.io.IOException; import java.net.InetSocketAddress; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * @author 文进 * @version 1.0 */ @RestController public class HttpServers { @RequestMapping(\u0026#34;/negativeNews\u0026#34;) public List\u0026lt;NegativeNews\u0026gt; returnJson( ) { // 获取百度新闻中热点新闻的标题和链接 HashMap\u0026lt;String, String\u0026gt; news = new News().getNews(\u0026#34;http://news.baidu.com/\u0026#34;); // 负面新闻 HashMap\u0026lt;String, String\u0026gt; negativeNews = new HashMap\u0026lt;\u0026gt;(); // 通过新闻标题得到的情感值，将负面新闻添加到 negativeNews 中 for (Map.Entry\u0026lt;String, String\u0026gt; entry : news.entrySet()) { // 得到情感API返回的结果，例如 data = {\u0026#34;result\u0026#34;:0.739306} String data = UrlUtils.sendPost(\u0026#34;http://baobianapi.pullword.com:9091/get.php\u0026#34;, entry.getKey()); // 提取结果中的分数值 data = {\u0026#34;result\u0026#34;: score} String score = data.substring(10, data.length() - 1); // 将分数值 score 转换成double数值，方便找到负面情绪的新闻 double emotion = Double.parseDouble(score); // 将负面新闻添加到 negativeNews 中 if (emotion \u0026lt; -0.5) { negativeNews.put(entry.getKey(), entry.getValue()); } } // 返回 JSON 数据格式 List\u0026lt;NegativeNews\u0026gt; negativeNewsList = new ArrayList\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;String, String\u0026gt; entry : negativeNews.entrySet()) { NegativeNews nNews = new NegativeNews(entry.getKey(), entry.getValue()); negativeNewsList.add(nNews); } return negativeNewsList; } } 部署到服务器 部署到服务器有两种方式，参考：\nspring boot 项目部署到服务器 两种方式 SpringBoot 项目部署到服务器的两种方式 maven项目打包 我们选择打包成jar包，其中，有可能遇到发生一些类找不到的错误，需要将本地jar包打包进去，参考maven项目引入本地jar包史上最详细实践方法。\n解决如下类找不到的情况：\n1 2 import com.sun.org.slf4j.internal.Logger; import com.sun.org.slf4j.internal.LoggerFactory; 经过跟踪，这两个都在rt.jar类中，用引入本地jar包的方法还是不成功，最终参考Idea本地maven打包，程序包不存在解决了，将rt.jar复制到jdk/jre/lib/ext中。\n引入org.json，从中获取相应版本的依赖代码，添加到pom.xml配置文件中。\n1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;!-- jsoup HTML parser library @ http://jsoup.org/ --\u0026gt; \u0026lt;groupId\u0026gt;org.jsoup\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsoup\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 添加后，在maven中按刷新按钮，如下图：\n打包好后现在本地测试一下，终端进入到jar所在的路径，运行如下代码：\n1 java -jar 包名.jar Linux上运行 参考在Linux上运行springboot项目。\n为了让服务端关闭SSH连接后依然运行，运行时执行如下命令：\n1 nohup java -jar 包名.jar \u0026amp; 杀掉运行中的进程，首先查看：\n1 ps aux|grep getCimiss-surf.jar 接着杀掉进程：\n1 kill -9 30768 MacOS上查看对应端口的进程：\n1 lsof -i tcp:端口号 杀掉对应进程：\n1 kill -9 PID号 代码及公网地址 至此整个过程就完成了:)\n代码：negativeNews 公网地址：http://139.155.0.15/negativeNews 公网请求负面新闻截图： ","date":"2022-05-08T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/08/liangbo-negative-news/","title":"发现负面新闻"},{"content":"滑动窗口 滑动窗口模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int left = 0, right = 0; while (right \u0026lt; s.size()) { // 增大窗口 window.add(s[right]); right++; while (window needs shrink) { // 缩小窗口 window.remove(s[left]); left++; } } 209.长度最小的子数组 这道题HotStar一面考到了，用滑动窗口解决。这里写的是前缀和数组和滑动窗口来解决， 其实也可以降低空间复杂度，直接用滑动窗口解决，一个变量来记子数组的和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { // 前缀和数组 + 滑动窗口 public int minSubArrayLen(int target, int[] nums) { int[] preSum = new int[nums.length]; int sum = 0; for (int i = 0; i \u0026lt; nums.length; i++) { sum += nums[i]; preSum[i] = sum; } int left = 0, right = 0; int length = Integer.MAX_VALUE; while (left \u0026lt;= right \u0026amp;\u0026amp; right \u0026lt; nums.length) { while (right \u0026lt; nums.length \u0026amp;\u0026amp; preSum[right] - preSum[left] + nums[left] \u0026lt; target) { right++; } System.out.println(right); length = Math.min(length, right - left + 1); System.out.println(length); left++; } return preSum[nums.length - 1] \u0026lt; target ? 0 : length; } } 3.无重复字符的最长子串 直接上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { // 滑动窗口 public int lengthOfLongestSubstring(String s) { if (s.length() == 0) return 0; int left = 0, right = 0; int length = 1; Set\u0026lt;Character\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); while (left \u0026lt;= right \u0026amp;\u0026amp; right \u0026lt; s.length()) { while (right \u0026lt; s.length() \u0026amp;\u0026amp; !set.contains(s.charAt(right))) { set.add(s.charAt(right)); right++; } // System.out.println(\u0026#34;left \u0026#34; + left + \u0026#34; right \u0026#34; + right); length = Math.max(length, right - left); set.remove(s.charAt(left)); left++; } return length; } } 这里和模板有所区别，不过思路都是一样的。这里是不停的在移动右指针，一旦不满足条件，就调节左指针。\n76.最小覆盖子串 这道题需要好好想一下，什么时候收缩窗口，我们知道肯定是窗口中已经包含了整个字符串t中的所有字符，但是这个逻辑如何去实现呢？下面假设String s = \u0026quot;ADOBECODEBANC\u0026quot;，String t = \u0026quot;ABC\u0026quot;。\n首先根据字符串t构造一个哈希表subStringMap。 滑动窗口内的哈希表记为curMap，但是这个哈希表不存储滑动窗口内所有的字符和相应出现的次数，我们只关心那些在subStringMap中包含的字符。 设置一个变量valid，记录窗口内的有效字符的个数。如果当前窗口中A出现的次数达到了subStringMap中A出现的次数，valid++，也就是滑动窗口内覆盖了字符A，这也是为了后面好判断窗口收缩条件，也就是valid == subStringMap.size()，满足这个条件说明滑动窗口内刚好覆盖了子串。这一步思路最为关键。 窗口收缩后，更新相应变量的值，curMap要变，valid也需要更新。 最后为了返回最小的覆盖子串，用len和start两个变量来记录结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { // 滑动窗口 public String minWindow(String s, String t) { if (t.length() \u0026gt; s.length()) return \u0026#34;\u0026#34;; HashMap\u0026lt;Character, Integer\u0026gt; subStringMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; t.length(); i++) { subStringMap.put(t.charAt(i), subStringMap.getOrDefault(t.charAt(i), 0) + 1); } HashMap\u0026lt;Character, Integer\u0026gt; curMap = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0; int valid = 0; int start = 0, len = Integer.MAX_VALUE; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (subStringMap.containsKey(c)) { curMap.put(c, curMap.getOrDefault(c, 0) + 1); if (curMap.get(c).equals(subStringMap.get(c))) { valid++; } } while (valid == subStringMap.size()) { // 更新最小字符串 if (right - left \u0026lt; len) { start = left; len = right - left; } char d = s.charAt(left); left++; if (subStringMap.containsKey(d)) { if (subStringMap.get(d).equals(curMap.get(d))) { valid--; } curMap.put(d, curMap.getOrDefault(d, 0) - 1); } } } return len == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(start, start + len); } } 参考资料 我写了首诗，把滑动窗口算法算法变成了默写题 ","date":"2022-05-07T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/07/Algorithms-sliding-window/","title":"滑动窗口相关算法"},{"content":"JDK 1.7 构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { // 检查输入参数的合法性 if (!(loadFactor \u0026gt; 0) || initialCapacity \u0026lt; 0 || concurrencyLevel \u0026lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel \u0026gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // MAX_SEGMENTS = 1 \u0026lt;\u0026lt; 16, 即 2 ^ 16 // Find power-of-two sizes best matching arguments // sshift 是 ssize 从 1 向左移位的次数 int sshift = 0; // segments 的长度，是 2 的 N 次方 int ssize = 1; // 计算出一个大于等于 concurrencyLevel 的最小的 2 的 N 次方的值作为 segments 的长度 while (ssize \u0026lt; concurrencyLevel) { ++sshift; ssize \u0026lt;\u0026lt;= 1; } // segmentShift 用于定位参与散列运算的位数 this.segmentShift = 32 - sshift; // 散列运算的掩码 this.segmentMask = ssize - 1; if (initialCapacity \u0026gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; /* cap 是 segment 里 HashEntry 数组的长度， cap 等于 initialCapacity 除以 sszie 的倍数 c ， 如果 c 大于 2，就会取大于等于 c 的 2 的 N 次方值， 所以 cap 不是 2，就是 2 的 N 次方。 */ int c = initialCapacity / ssize; if (c * ssize \u0026lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; // MIN_SEGMENT_TABLE_CAPACITY = 2 while (cap \u0026lt; c) cap \u0026lt;\u0026lt;= 1; // create segments and segments[0] Segment\u0026lt;K,V\u0026gt; s0 = new Segment\u0026lt;K,V\u0026gt;(loadFactor, (int)(cap * loadFactor), (HashEntry\u0026lt;K,V\u0026gt;[])new HashEntry[cap]); Segment\u0026lt;K,V\u0026gt;[] ss = (Segment\u0026lt;K,V\u0026gt;[])new Segment[ssize]; // 把 s0 存到 Segment 数组中，仅仅创建了一个 Segment 用来作原型对象。 UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; } put()方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Map 的 put 方法 public V put(K key, V value) { Segment\u0026lt;K,V\u0026gt; s; // value 不能为空 if (value == null) throw new NullPointerException(); // 计算 hash 值 int hash = hash(key); /* j 为 Segment 中的下标 默认情况下 segmentShift 为 28，segmentMask 为 15 hash \u0026gt;\u0026gt;\u0026gt; segmentShift 向右无符号移动 28 位，意思是让高 4 位参与到散列运算中 然后和掩码 segmentMask 做与运算，得到的值一定是 0000 ～ 1111 范围内的值，即 0 ～ 15 */ int j = (hash \u0026gt;\u0026gt;\u0026gt; segmentShift) \u0026amp; segmentMask; if ((s = (Segment\u0026lt;K,V\u0026gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j \u0026lt;\u0026lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false); } 补充上述源码中的右移与无符号右移的区别：\n右移\u0026raquo; ：该数对应的二进制码整体右移，左边的用原有标志位补充，右边超出的部分舍弃。 无符号右移\u0026raquo;\u0026gt; ：不管正负标志位为0还是1，将该数的二进制码整体右移，左边部分总是以0填充，右边部分舍弃。 在上述put()方法中，hash方法为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private int hash(Object k) { /* A randomizing value associated with this instance that is applied to hash code of keys to make hash collisions harder to find. private transient final int hashSeed = randomHashSeed(this); */ int h = hashSeed; if ((0 != h) \u0026amp;\u0026amp; (k instanceof String)) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h \u0026lt;\u0026lt; 15) ^ 0xffffcd7d; h ^= (h \u0026gt;\u0026gt;\u0026gt; 10); h += (h \u0026lt;\u0026lt; 3); h ^= (h \u0026gt;\u0026gt;\u0026gt; 6); h += (h \u0026lt;\u0026lt; 2) + (h \u0026lt;\u0026lt; 14); return h ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 再散列的目的是减少散列冲突，使元素能够均匀地分布在不同的Segment中，从而提高容器的存取效率。\nSegment中的put方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // Segment 中的 put 方法 final V put(K key, int hash, V value, boolean onlyIfAbsent) { HashEntry\u0026lt;K,V\u0026gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { HashEntry\u0026lt;K,V\u0026gt;[] tab = table; int index = (tab.length - 1) \u0026amp; hash; HashEntry\u0026lt;K,V\u0026gt; first = entryAt(tab, index); for (HashEntry\u0026lt;K,V\u0026gt; e = first;;) { if (e != null) { K k; if ((k = e.key) == key || (e.hash == hash \u0026amp;\u0026amp; key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { if (node != null) node.setNext(first); else node = new HashEntry\u0026lt;K,V\u0026gt;(hash, key, value, first); int c = count + 1; if (c \u0026gt; threshold \u0026amp;\u0026amp; tab.length \u0026lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { unlock(); } return oldValue; } 参考资料 我就知道面试官接下来要问我 ConcurrentHashMap 底层原理了 java中右移运算符\u0026raquo;和无符号右移运算符\u0026raquo;\u0026gt;的区别 ","date":"2022-05-06T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/06/ConcurrentHashMap/","title":"ConcurrentHashMap源码分析"},{"content":"面试问题：\n自我介绍 数学专业为什么转计算机？ 本科专业是应用数学，为什么有计算机相关课程。 用过MySQL吗？熟悉事务吗？ 这个我没答上来，不太会。 对SpringBoot了解吗？ 呜呜呜，还没学到那里。 讲下HashMap。 对计算机网络的了解。 TCP和UDP的区别。 下面就是发个链接开始写代码，题目是209.长度最小的子数组。\n我开始想到子数组求和，就要用到前缀和数组，然后用双指针来遍历，但是双指针遍历逻辑有问题。面试官提醒了用滑动窗口，讲了下实现的逻辑，然后让我实现，实现的时候还出错了，报下标越界错误，是判断位置加错了。最后加了一个特判，就结束了。写完后问了复杂度。\n写代码这块大概花了一个多小时，是我太菜了。下面就是反问环节。\n我问了在编程中会用到哪些数学知识吗？面试官说这边核心代码基本开发完了，如果后面想要深入了解也是可以的，对代码理解还是有帮助的。\n问了对Hotstar的了解，哈哈，我了解的不多。面试官就介绍了下。\n面试体验超棒，面试官问问题感觉很温柔，算法题也会引导。\n呜呜呜，收到了感谢信:(\n革命尚未成功，同志仍需努力！\n","date":"2022-05-06T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/06/interview-hotstar1/","title":"Hotstar一面"},{"content":"图的遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 记录被遍历过的节点 boolean[] visited; // 记录从起点到当前节点的路径 boolean[] onPath; /* 图遍历框架 */ void traverse(Graph graph, int s) { if (visited[s]) return; // 经过节点 s，标记为已遍历 visited[s] = true; // 做选择：标记节点 s 在路径上 onPath[s] = true; for (int neighbor : graph.neighbors(s)) { traverse(graph, neighbor); } // 撤销选择：节点 s 离开路径 onPath[s] = false; } 图中判断是否存在环 207.课程表 首先将课程表的依赖关系转换为图，接着如果图中存在环，就返回false，否则返回true。\n深度优先搜索方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { onPath = new boolean[numCourses]; visited = new boolean[numCourses]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); for (int i = 0; i \u0026lt; numCourses; i++) { traverse(graph, i); } return !hasCycle; } boolean[] onPath; // 记录路径 boolean[] visited; // 记录访问的节点 boolean hasCycle; // 图中是否有环 // 回溯，深度优先搜索 private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; } if (hasCycle || visited[s]) { // 已经找到环或者已经遍历过了 return; } // 前序代码位置 onPath[s] = true; visited[s] = true; for (int t : graph[s]) { traverse(graph, t); } // 后序代码位置 onPath[s] = false; } // 建图 private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; // 修完 edge[1] 课程后才能修 edge[0] graph[from].add(to); } return graph; } } 时间复杂度：$O(n+m)$，$n$为课程数，$m$为先修课程的要求数。\n空间复杂度：$O(n+m)$。\n广度优先搜索方法，首先要建立一个入度的数组，如果入度为0就加入到队列中，接着广度搜索有依赖的节点，并将这些节点的入度减一，如果最后遍历的节点个数与numCourses相同，则说明没有形成环。因为如果形成环的话，环中的节点的入度不会减少到0，肯定不会加入到队列中，也就不会遍历到。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 方法二：广度优先搜索 public boolean canFinish(int numCourses, int[][] prerequisites) { // 建图 List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); // 构建入度数组 int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; // 节点 to 的入度加一 indegree[to]++; } // 根据入度初始化队列 Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { // 如果入度为0，则加入队列 q.offer(i); } } int count = 0; // 记录遍历的节点的个数 while (!q.isEmpty()) { // 弹出节点并将它指向的节点的入度减一 int cur = q.poll(); count++; for (int next : graph[cur]) { indegree[next]--; // 如果入度为0，则加入队列中 if (indegree[next] == 0) { q.offer(next); } } } // 如果所有节点都遍历过，则说明没有形成环 return count == numCourses; } 拓扑排序 210.课程表II 拓扑排序就是反转后序遍历的结果。注意这里的依赖关系依然是先修完edge[1]课程再修edge[0]课程，图中edge[1] -\u0026gt; edge[0]。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { onPath = new boolean[numCourses]; visited = new boolean[numCourses]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); for (int i = 0; i \u0026lt; numCourses; i++) { traverse(graph, i); } if (hasCycle) { // 如果存在环 return new int[]{}; } // 逆后序遍历的结果就是拓扑排序的结果 Collections.reverse(postorder); // 这里直接调用Collections的接口 int[] res = new int[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { res[i] = postorder.get(i); } return res; } boolean[] onPath; boolean[] visited; boolean hasCycle; List\u0026lt;Integer\u0026gt; postorder = new ArrayList\u0026lt;\u0026gt;(); void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; } if (visited[s] || hasCycle) { return; } // 前序遍历位置 visited[s] = true; onPath[s] = true; for (int t : graph[s]) { traverse(graph, t); } // 后序遍历位置 postorder.add(s); onPath[s] = false; } // 建图函数 private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new LinkedList[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; // 先修 edge[1] 再修 edge[0] graph[from].add(to); } return graph; } } 广度优先搜索方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 方法二：广度优先搜索 public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; indegree[to]++; } // 根据入度数组初始化队列 Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { q.offer(i); } } // 广度优先搜索 int count = 0; // 记录遍历的次数 int[] res = new int[numCourses]; // 记录结果 while (!q.isEmpty()) { int cur = q.poll(); res[count] = cur; count++; for (int next : graph[cur]) { indegree[next]--; if (indegree[next] == 0) { q.offer(next); } } } // 如果存在环就返回空数组 return count == numCourses ? res : new int[]{}; } 剑指 Offer II 115. 重建序列 这道题的关键点是如何保证重建序列的唯一性，其实就是判断q.size() == 1，也就是队列的大小是否为1。\n还有一点细节需要注意，那就是先要保证重建序列集中的元素为{1,...,n}，这里用Set集合来判断。\n广度优先搜索：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Solution { public boolean sequenceReconstruction(int[] org, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; seqs) { // 保证重建序列集的完整性，即重建序列中元素能是 {1,...,n} Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (List\u0026lt;Integer\u0026gt; list : seqs) { for (int ele : list) { set.add(ele); } } // 如果set中元素不够，返回 false if (set.size() != org.length) return false; // 如果元素不匹配，返回 false for (int i = 1; i \u0026lt;= org.length; i++) { if (!set.contains(i)) { return false; } } List\u0026lt;Integer\u0026gt;[] graph = buildGraph(org, seqs); // 初始化队列 Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt; indegree.length; i++) { if (indegree[i] == 0) { q.offer(i); } } int count = 0; int[] res = new int[org.length]; while (!q.isEmpty()) { // 保证唯一性 if (q.size() \u0026gt; 1) return false; int cur = q.poll(); res[count] = cur; // 记录拓扑排序结果 count++; int nextCount = 0; for (int next : graph[cur]) { indegree[next]--; if (indegree[next] == 0) { q.offer(next); } } } // 出现环的情况 if (count != org.length) return false; // 比较每一个元素 for (int i = 0; i \u0026lt; org.length; i++) { if (org[i] != res[i]) return false; } return true; } // 建图 int[] indegree; // 入度数组 private List\u0026lt;Integer\u0026gt;[] buildGraph(int[] org, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; seqs) { List\u0026lt;Integer\u0026gt;[] graph = new LinkedList[org.length + 1]; indegree = new int[org.length + 1]; for (int i = 0; i \u0026lt;= org.length; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (List\u0026lt;Integer\u0026gt; ele : seqs) { if (ele.size() \u0026lt; 2) continue; for (int i = 1; i \u0026lt; ele.size(); i++) { int from = ele.get(i - 1), to = ele.get(i); graph[from].add(to); indegree[to]++; } } return graph; } } 参考资料 labuladong的算法小抄 ","date":"2022-05-06T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/06/Algorithms-graph/","title":"图相关算法"},{"content":"下一个更大元素 单调栈的一个应用是求下一个更大的元素。其中用到的较多的是接口Deque，类图结构如下： 496.下一个更大元素I 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { // 单调栈 + 哈希表 public int[] nextGreaterElement(int[] nums1, int[] nums2) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 方便返回答案 // Deque 是双端队列 Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); // 逆序遍历数组 for (int i = nums2.length - 1; i \u0026gt;= 0; i--) { // 如果栈不为空，并且当前的值比栈顶元素大，则抛出栈顶元素，因为不可能是下一个更大元素 // 直到栈为空或者找到下一个更大的元素 while (!stack.isEmpty() \u0026amp;\u0026amp; nums2[i] \u0026gt;= stack.peek()) { stack.pop(); } // 存储当前数的下一个最大元素，数组中没有重复元素，因此可以使用HashMap map.put(nums2[i], stack.isEmpty() ? -1 : stack.peek()); // 向栈中添加当前元素 stack.push(nums2[i]); } int[] ans = new int[nums1.length]; for (int i = 0; i \u0026lt; nums1.length; i++) { ans[i] = map.get(nums1[i]); } return ans; } } 503.下一个更大元素II 这里要求的是循环数组，可以转换为上一题，也就是一个长度为 2 * n 的数组用上一题的方法，实际上可以通过指标取模来达到这个效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { // 单调栈 + 循环数组 public int[] nextGreaterElements(int[] nums) { int n = nums.length; int[] res = new int[n]; Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); // 用指标取模来模拟有 2 * n 长度的数组[0, ... , n - 1, 0, ... , n - 1] for (int i = 2 * n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[i % n] \u0026gt;= stack.peek()) { stack.pop(); } res[i % n] = (stack.isEmpty() ? -1 : stack.peek()); stack.push(nums[i % n]); } return res; } } 739.每日温度 这道题依然是下一个更大元素的变形，换汤不换药，栈中存放的是数组的下标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { // 单调栈 public int[] dailyTemperatures(int[] temperatures) { int[] ans = new int[temperatures.length]; // 为了返回天数，栈中存放的是数组的下标 Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (int i = temperatures.length - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[i] \u0026gt;= temperatures[stack.peek()]) { stack.pop(); } ans[i] = stack.isEmpty() ? 0 : (stack.peek() - i); stack.push(i); } return ans; } } 42.接雨水 思路是：利用单调栈，栈中的元素按高度递减，如果栈中至少有两个元素，说明高度在下降，而如果当前元素的高度比较高，那么就可以形成一个洼地，能够接雨水。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { // 单调栈 public int trap(int[] height) { int ans = 0; Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); int n = height.length; for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; height[i] \u0026gt; height[stack.peek()]) { int top = stack.pop(); if (stack.isEmpty()) { break; } // 如果栈中存在至少两个元素，当前的值比较高，那么可以形成一个洼地，可以接雨水 int left = stack.peek(); int currWidth = i - left - 1; int currHeight = Math.min(height[left] - height[top], height[i] - height[top]); ans += currWidth * currHeight; } stack.push(i); } return ans; } } ","date":"2022-05-01T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/01/monotonic-stack/","title":"单调栈相关题目"},{"content":"参考十大经典排序算法。\n冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class BubbleSort { public int[] sort(int[] sourceArray) { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i \u0026lt; arr.length; i++) { // 设定一个标记，若为 true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成 boolean flag = true; for (int j = 0; j \u0026lt; arr.length - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; } } if (flag) { break; } } return arr; } } 选择排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Selection { public static void sort(Comparable[] a) { // 将 a[] 按升序排列 int N = a.length; for (int i = 0; i \u0026lt; N; i++) { // 将 a[i] 和 a[i + 1 ... N] 中最小的元素交换 int min = i; // 最小元素的索引 for (int j = i + 1; j \u0026lt; N; j++) { if (less(a[j], a[min])) min = j; // 找到a[i+1,...,N]中最小的元素 } exch(a, i, min); } } } 插入排序 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Insertion { public static void sort(Comparable[] a) { // 将 a[] 按升序排列 int N = a.length; for (int i = 1; i \u0026lt; N; i++) { // 将 a[i] 插入到 a[i - 1]、a[i - 2]、a[i - 3]...之中 // less(a[j], a[j - 1])，是如果 a[j] 比 a[j - 1] 小 for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); } } } } 希尔排序 希尔排序的思想是使数组中任意间隔 h 的元素都是有序的。希尔排序更高效的原因是它权衡了子数组的规模和有序性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Shell { public static void sort(Comparable[] a) { // 将 a[] 按升序排列 int N = a.length; int h = 1; while (h \u0026lt; N/3) h = 3 * h + 1; // 1, 4, 13, 40, 121, 364, 1093, ... while (h \u0026gt;= 1) { // 将数组变为 h 有序 for (int i = h; i \u0026lt; N; i++) { // 将 a[i] 插入到 a[i - h], a[i - 2 * h], a[i - 3 * h]...之中 for (int j = i; j \u0026gt;= h \u0026amp;\u0026amp; less(a[j], a[j - h]) ; j -= h) { exch(a, j, j - h); } h = h / 3; } } } } 归并排序 归并排序将数组分成两个子数组分别进行排序，并将有序的子数组归并以将整个数组排序，递归调用发生在处理整个数组之前。\n原地归并的抽象方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static void merge(Comparable[] a, int lo, int mid, int hi) { // 将a[lo,...,mid]和a[mid + 1,...,hi]归并 int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { // 将a[lo,...,hi]复制到aux[lo,...,hi] aux[k] = a[k]; } for (int k = lo; k \u0026lt;= hi; k++) { // 归并回到a[lo,...,hi] if (i \u0026gt; mid) a[k] = aux[j++]; else if (j \u0026gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } } 自顶向下的归并排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Merge { private static Comparable[] aux; // 归并所需的辅助数组 public static void sort(Comparable[] a) { aux = new Comparable[a.length]; // 一次性分配空间 sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { // 将数组a[lo,...,hi]排序 if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, lo, mid); // 将左半边排序 sort(a, mid + 1, hi); // 将右半边排序 merge(a, lo, mid, hi); // 归并结果 } } 快速排序 快速排序将数组排序的方式是当两个子数组都有序时整个数组也就自然有序了，递归调用发生在处理整个数组之后。\n首先是切分算法，使得 a[lo...j-1] \u0026lt;= a[j] \u0026lt;= a[j+1...hi]，返回指标j。实现切分算法的思路是先随机地取a[lo]作为切分元素，然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素，交换它们的位置。如此继续，我们保证左指针i的左侧元素都不大于切分元素，右指针j的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素a[lo]和左子数组最右侧的元素a[j]交换后返回j即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static int partition(Comparable[] a, int lo, int hi) { // 将数组切分为 a[lo,...,i - 1], a[i], a[i + 1,...,hi] int i = lo, j = hi + 1; // 左右扫描指针 Comparable v = a[lo]; // 切分元素 while (true) { // 扫描左右，检查扫描是否结束并交换元素 while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; exch(a, i, j); } exch(a, lo, j); // 将 v = a[j] 放入正确的位置 return j; } 快速排序算法：\n1 2 3 4 5 6 7 8 9 10 11 12 public class Quick { public static void sort(Comparable[] a) { StdRandom.shuffle(a); // 消除对输入的依赖 sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int j = partition(a, lo, hi); // 即切分算法 sort(a, lo, j - 1); // 将左半部分 a[lo,...,j - 1]排序 sort(a, j + 1, hi); // 将右半部分 a[j + 1,...,hi]排序 } } 快速排序中重要的就是切分算法，切分算法还有三向切分。维护一个指针lt使得a[lo,...,lt-1]中的元素都小于v，一个指针gt使得a[gt+1,..,hi]中的元素都大于v，一个指针i使得a[lt,...,i-1]中的元素都等于v。\n三向切分的快速排序:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Quick3way { private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int lt = lo, i = lo + 1, gt = hi; Comparable v = a[lo]; while (i \u0026lt;= gt) { int cmp = a[i].compareTo(v); if (cmp \u0026lt; 0) exch(a, lt++, i++); else if (cmp \u0026gt; 0) exch(a, i, gt--); else i++; } // 现在 a[lo,...,lt-1] \u0026lt; v = a[lt,...,gt] \u0026lt; a[gt+1,...,hi] 成立 sort(a, lo, lt - 1); sort(a, gt + 1, hi); } } 三向切分相关LeetCode题目：\n75.颜色分类 LeetCode排序练习 912.排序数组 ","date":"2022-04-30T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/04/30/sortAlgorithms/","title":"排序算法"},{"content":"打印字母“O” 给一个数n，打印4n行字符串，是一个大“O”的形状。\n例1: n = 1\n1 2 3 4 .**. *..* *..* .**. 例2: n = 2\n1 2 3 4 5 6 7 8 ..****.. .******. **....** **....** **....** **....** .******. ..****.. 例3: n = 3\n1 2 3 4 5 6 7 8 9 10 11 12 ...******... ..********.. .**********. ***......*** ***......*** ***......*** ***......*** ***......*** ***......*** .**********. ..********.. ...******... 思路 将打印每一行抽象成一个函数，例如第一行，先打印字符ch1，重复times1遍，再打印ch2有times2遍，最后打印ch1 有times1遍。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.util.Scanner; /** * @author 文进 * @version 1.0 */ public class N1 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; 4 * n; i++) { if (i \u0026lt; n) { // [0, ..., n - 1] sb.append(printStr(\u0026#39;.\u0026#39;, n - i, \u0026#39;*\u0026#39;, 4 * n - 2 * (n - i))); } else if (i \u0026gt;= 3 * n) { // [3n, ..., 4n - 1] sb.append(printStr(\u0026#39;.\u0026#39;, i - 3 * n + 1, \u0026#39;*\u0026#39;, 4 * n - 2 * (i - 3 * n + 1))); } else { // [n, ..., 3n - 1] sb.append(printStr(\u0026#39;*\u0026#39;, n, \u0026#39;.\u0026#39;, 2 * n)); } sb.append(\u0026#34;\\n\u0026#34;); } // // 或者分开写，分别打印三大段 // for (int i = n; i \u0026gt; 0; i--) { // sb.append(printStr(\u0026#39;.\u0026#39;, i, \u0026#39;*\u0026#39;, 4 * n - 2 * i)); // sb.append(\u0026#34;\\n\u0026#34;); // } // for (int i = 0; i \u0026lt; 2 * n; i++) { // sb.append(printStr(\u0026#39;*\u0026#39;, n, \u0026#39;.\u0026#39;, 2 * n)); // sb.append(\u0026#34;\\n\u0026#34;); // } // for (int i = 1; i \u0026lt;= n; i++) { // sb.append(printStr(\u0026#39;.\u0026#39;, i, \u0026#39;*\u0026#39;, 4 * n - 2 * i)); // sb.append(\u0026#34;\\n\u0026#34;); // } System.out.println(sb); } // ch1 * times1 + ch2 * times2 + ch1 * times1 public static StringBuilder printStr(char ch1, int times1, char ch2, int times2) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; times1; i++) { sb.append(ch1); } for (int i = 0; i \u0026lt; times2; i++) { sb.append(ch2); } for (int i = 0; i \u0026lt; times1; i++) { sb.append(ch1); } return sb; } } n数之和 要构造一个长度为n的数组，输入三个参数n，k，x。n表示数组的长度，数组中所有元素不相等且不超过k，n个数的和为k。最后输出一个任意一个结果就可以，如果找不到这样的数组，就返回-1。\n例1 输入\n1 4 6 15 输出：\n1 1 5 6 3 例2 输入\n1 2 3 4 输出\n1 -1 思路 这个题是n数之和的问题，联想到在一个数组中求和为target的n个数。如果n=2，那么就是两数之和，可以先对数组排序，用双指针求两数之和。当求n个数之和为target时，可以先固定一个数nums[i]，再求n-1个数的和为target-nums[i]。\n这道题只需返回一个可行结果，那么当找到一个解时就立刻返回，可以避免不必要的递归调用。\n同时题目中告诉我们返回的数不超过k并且各不相同，那么提前构造的数组可以是nums = [1,2,3,...,k]，且nums数组不需要再排序了。\n类似的LeetCode题目：\n1.两数之和 15.三数之和 18.四数之和 454.四数相加II 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import java.util.LinkedList; import java.util.List; import java.util.Scanner; /** * @author 文进 * @version 1.0 */ public class N2 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int k = scanner.nextInt(); int x = scanner.nextInt(); int[] nums = new int[k]; for (int i = 0; i \u0026lt; k; i++) { nums[i] = i + 1; } List\u0026lt;Integer\u0026gt; res = nSum(nums, n, 0, x); if (res.size() == n) { StringBuilder sb = new StringBuilder(); for (Integer ele : res) { sb.append(ele + \u0026#34; \u0026#34;); } System.out.println(sb); } else { System.out.println(-1); } } /* n 数之和，nums[] 提前排好序了，并且各不相同 双指针方法 */ public static List\u0026lt;Integer\u0026gt; nSum(int[] nums, int n, int start, int target) { List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); if (n \u0026lt; 2 || n \u0026gt; nums.length) return res; if (n == 2) { int left = start, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum \u0026lt; target) { left++; } else if (sum \u0026gt; target) { right--; } else { res.add(nums[left]); res.add(nums[right]); left++; right--; } } } else { for (int i = start; i \u0026lt; nums.length - 1; i++) { List\u0026lt;Integer\u0026gt; list = nSum(nums, n - 1, i + 1, target - nums[i]); if (list.size() == n - 1) { for (Integer ele : list) { res.add(ele); } res.add(nums[i]); break; } } } return res; } } ","date":"2022-04-19T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/04/19/intern-wangyi/","title":"网易实习笔试题"},{"content":"第2章 Java并发机制的底层实现原理 2.1 volatile的应用 volatile的两条实现原则：\nLock前缀指令会引起处理器缓存回写到内存。 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。 2.2 synchronized的实现原理与应用 synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式：\n对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchonized括号里配置的对象。 Synchonized在JVM里的实现，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的。\nmonitorenter指令在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit与之配对。\n2.2.1 Java对象头 第3章 Java内存模型 3.1 Java内存模型的基础 3.1.1 并发编程模型的两个关键问题 线程之间如何通信 线程之间如何同步，同步是指程序中用于控制不同线程间操作发生相对顺序的机制。 线程之间的通信机制：共享内存和消息传递。\nJava的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。\n3.1.2 Java内存模型的抽象结构 在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。\nJMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。\n3.1.3 从源代码到指令序列的重排序 重排序分为3种：\n编译器优化的重排序 指令级并行的重排序 内存系统的重排序 3.1.4 并发编程模型的分类 由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。\n常见的处理器都允许Store-Load重排序，常见的处理器都不允许对存在数据依赖的操作做重排序。\n3.1.5 happens-before简介 happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。\n一个happens-before规则对应于一个或多个编译器和处理器重排序规则。\n3.2 重排序 3.2.1 数据依赖性 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。\n编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。\n3.2.2 as-if-serial语义 as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。\n3.2.3 程序顺序规则 A happens-before B，当实际执行时B却可以排在A之前执行。 软件技术和硬件技术的共同目标：在不改变程序执行结果的前提下，尽可能提高并行度。\n3.2.4 重排序对多线程的影响 当代码中存在控制依赖时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测执行来控制相关性对并行度的影响。\n在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。\n3.3 顺序一致性 3.3.1 数据竞争与顺序一致性 如果程序是正确同步的，程序的执行将具有顺序一致性。\n3.3.2 顺序一致性内存模型 顺序一致性内存模型有两大特性：\n一个线程中的所有操作必须按照程序的顺序来执行。 （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。 未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。\n3.3.3 同步程序的顺序一致性结果 在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。\n3.3.4 未同步程序的执行特性 对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证线程读操作读取到的值不会无中生有的冒出来。\nJMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。\n从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性（即任意读操作必须要在单个读事务中执行）。\n3.4 volatile的内存语义 3.4.1 volatile的特性 把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。\n可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。 3.4.2 volatile写-读建立的happens-before关系 volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义。\n3.4.3 volatile写-读的内存语义 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。\n可以看作是在两个线程之间在进行消息传递。\n3.4.4 volatile内存语义的实现 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。 当第一个操作时volatile读时，不管第二个操作是什么，都不能重排序。 当第一个操作时volatile写，第二个操作是volatile读时，不能重排序。 基于保守策略的JMM内存屏障插入策略：\n在每个volatile写操作的前面插入一个StoreStore屏障。 在每个volatile写操作的后面插入一个StoreLoad屏障。 在每个volatile读操作的后面插入一个LoadLoad屏障。 在每个volatile读操作的后面插入一个LoadStore屏障。 因为x86仅会对写-读操作做重排序，因此JMM仅需在volatile写操作的后面插入一个StoreLoad屏障。\n3.4.5 JSR-133为什么要增强volatile的内存语义 严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。\n在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。\n3.5 锁的内存语义 3.5.1 锁的释放-获取建立的happens-before关系 锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。\n3.5.2 锁的释放和获取的内存语义 看作是两个线程之间通过主内存发送消息。\n3.5.3 锁内存语义的实现 ReentrantLock的实现依赖于Java同步框架AbstractQueuedSynchronizer（简称AQS）。AQS使用一个整型的volatile变量（命名为state）来维持同步状态。\nReentrantLock分为公平锁和非公平锁。\n使用公平锁时，加锁方法lock调用轨迹如下：\nReentrantLock:lock() 1 2 3 4 5 6 7 8 9 10 11 public ReentrantLock() { sync = new NonfairSync(); // 默认构造器为非公平锁 } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); //true 为公平锁， false 为非公平锁 } public void lock() { sync.lock(); // 如果为公平锁就调用FairSync的lock()，反之就调用NonfairSync.lock() } FairSync:lock() (ReentrantLock的内部类) 1 2 3 final void lock() { acquire(1); } AbstractQueuedSynchronizer:acquire(int arg) 1 2 3 4 5 public final void acquire(int arg) { if (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } ReentrantLock:tryAcquire(int acquires) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; final void lock() { acquire(1); } /** * Fair version of tryAcquire. Don\u0026#39;t grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); /* 在AQS中有如下的变量 state 以及 getSatate()方法： private volatile int state; protected final int getState() { return state; } */ int c = getState(); // 获取锁的开始，首先读 volatile 变量 state if (c == 0) { if (!hasQueuedPredecessors() \u0026amp;\u0026amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u0026lt; 0) throw new Error(\u0026#34;Maximum lock count exceeded\u0026#34;); setState(nextc); return true; } return false; } 使用公平锁时，解锁方法unlock()调用轨迹：\nReentrantLock:unlock() 1 2 3 public void unlock() { sync.release(1); } AbstractQueuedSynchronizer:release(int arg) 1 2 3 4 5 6 7 8 9 public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } Sync:tryRelase(int releases) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } /* AQS中的setState方法： protected final void setState(int newState) { state = newState; } */ setState(c); // 释放锁的最后，写 volatile变量state return free; } 公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。因此，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。\n非公平锁获取锁的方式和公平锁相同。非公平锁的加锁方法lock()调用轨迹如下：\nReentrantLock:lock() NonfairSync:lock() 1 2 3 4 5 6 final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } AbstractQueuedSynchronizer:compareAndSetState(int expect, int update) 1 2 3 4 protected final boolean compareAndSetState(int expect, int update) { // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } 该方法以原子操作的方式更新state变量。compareAndSetState()简称CAS方法。如果当前状态值等于预期值，则以原子的方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。\nsun.misc.Unsafe类的compareAndSwapInt()方法的源代码：\n1 public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 这是一个本地调用方法，会调用相应的C++代码，重要的是源代码中含有cmpxchg，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果是当处理器，就省略lock指令，如果是多处理器就加上lock前缀。\nintel手册对lock前缀的说明：\n确保对内存的读-改-写操作的原子执行。Intel使用缓存锁定来保证指令执行的原子性。缓存锁定将大大降低lock前缀指令的执行开销。 禁止该指令，与之前和之后的读和写指令重排序。 把写缓冲区中的所有数据刷新到内存中。 公平锁和非公平锁的内存语义：\n公平锁和非公平锁释放时，最后都要写一个volatile变量state。 公平锁获取时，首先会去读volatile变量。 非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。 锁释放-获取的内存语义的实现至少有以下两种方式：\n利用volatile变量的写-读所具有的内存语义。 利用CAS所附带的volatile读和volatile写的内存语义。 3.5.4 concurrent包的实现 一个通用化的实现模式：\n首先，声明共享变量volatile. 然后，使用CAS的原子条件更新来实现线程之间的同步。 同时，配合以vilatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的同步。 3.6 final域的内存语义 3.6.1 final域的重排序规则 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作不能重排序。 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 3.6.2 写final域的重排序规则 写final域的重排序规则禁止把final域的写重排序到构造函数之外，具体实现：\nJMM禁止编译器把final域的写重排序到构造函数之外。 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。 写final域的重排序可以保证：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。\n3.6.3 读final域的重排序规则 在一个线程中，初次读对象引用与初次读该对象包含的final域，这两个操作之间不能重排序。实现：\nJMM禁止处理器重排序这两个操作。 编译器会在读final域操作的前面插入一个LoadLoad屏障。 这两个操作之间存在间接依赖关系。\n读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。\n3.6.4 final域为引用类型 对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。\n3.6.5 为什么final引用不能从构造函数内“溢出” 在构造函数返回前，被构造对象的引用不能为其他线程所见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。\n3.6.6 final语义在处理器中的实现 X86处理器，只会对Store-Load进行重排序。根据final域重排序规则，以及X86处理器不会对存在间接依赖关系的操作进行重排序，因此在X86处理器中，final域的读/写不会插入任何内存屏障！\n3.6.7 JSR-133为什么要增强final的语义 通过为final域增加写和读重排序规则，可以为Java程序员提供初始化的安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“溢出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。\n3.7 happens-before 3.7.1 JMM的设计 JSR-133专家组在设计JMM时的核心目标是找到一个好的平衡点：一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制尽可能地放松。\nJMM对不同性质的重排序，采取不同的策略：\n对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。 对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM运行这种重排序）。 3.7.2 happens-before的定义 happens-before关系本质上和as-if-serial语义是一回事，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\n3.7.3 happens-before规则 程序顺序规则 监视器锁规则 volatile变量规则 传递性 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么B线程中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 3.8 双重检查锁定与延迟初始化 3.8.1 双重检查锁定的由来 希望通过双重检查锁定来降低同步的开销。\n3.8.2 问题的根源 创建对象instance = new Instance();可以分解为如下3行伪代码：\n1 2 3 memory = allocate();\t// 1:分配对象的内存空间 ctorInstance(memory);\t// 2:初始化对象 instance = memory; // 3:设置instance指向刚分配的内存地址 2和3之间，可能被重排序，这会导致问题的发生。\n两个办法实现线程安全的延迟初始化：\n不允许2和3重排序。 允许2和3重排序，但不允许其他线程“看到”这个重排序。 3.8.3 基于volatile的解决方案 在双重检查锁定方法的基础上将instance声明为volatile型。\n1 private volatile static Instance instance; 2和3之间的重排序在多线程环境中会被禁止。\n3.8.4 基于类初始化的解决方案 待读。\n3.9 Java内存模型综述 3.9.1 处理器的内存模型 由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。\n3.9.2 各种内存模型之间的关系 JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。\n3.9.3 JMM的内存可见性保证 三类：\n单线程程序。 正确同步的多线程程序。 未同步/未正确同步的多线程程序。提供最小安全保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。 最小安全保障与64位数据的非原子性写并不矛盾。最小安全性并不保证线程读取到的值，一定是某个线程写完后的值。最小安全性保证线程读取到的值不会是无中生有的冒出来，但并不保证线程读取到的值一定是正确的。\n3.9.4 JSR-133对旧内存模型的修补 主要有两个：\n增强volatile的内存语义。 增强final的内存语义。 第4章 Java并发编程基础 4.1 线程简介 4.1.1 什么是线程 现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。\nJava程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。\n4.1.2 为什么要使用多线程 更多的处理器核心 更快的响应时间 更好的编程模型 4.1.3 线程优先级 在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1～10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。\n程序正确性不能依赖线程的优先级高低，有些操作系统会忽略对线程优先级的设定。\n4.1.4 线程的状态 线程在执行Runnable的run()方法之后将会进入终止状态。\n4.1.5 Daemon线程 Daemon线程是一种支持型线程，因为它主要被用做程序中后台调度及支持性工作，也就是守护线程。当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。\n调用Thread.setDaemon(true)将线程设置为Daemon线程。\n在Java虚拟机退出时Daemon线程中的finally块不一定会执行。\n4.2 启动和终止线程 4.2.1 构造线程 构造一个线程，会调用Thread.java中的构造器：\n1 2 3 public Thread(Runnable target, String name) { init(null, target, name, 0); } 接着调用init方法：\n1 2 3 4 private void init(ThreadGroup g, Runnable target, String name, long stackSize) { init(g, target, name, stackSize, null, true); } 调用下面的init方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { if (name == null) { throw new NullPointerException(\u0026#34;name cannot be null\u0026#34;); } this.name = name; // 当前线程就是该线程的父线程 Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it\u0026#39;s an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn\u0026#39;t have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; // 将 daemon、priority属性设置为父线程的对应属性 this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); // 将父线程的 inheritThreadLocal 复制过来 if (inheritThreadLocals \u0026amp;\u0026amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); // 分配一个线程ID } 一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。\n4.2.2 启动线程 线程strart()方法的含义：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。\n4.2.3 理解中断 中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。\n线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断。\n1 2 3 4 5 public boolean isInterrupted() { return isInterrupted(false); } private native boolean isInterrupted(boolean ClearInterrupted); 或者调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。\n1 2 3 public static boolean interrupted() { return currentThread().isInterrupted(true); } 如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。\n许多方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。\n1 2 3 4 5 6 7 /** * @throws InterruptedException * if any thread has interrupted the current thread. The * \u0026lt;i\u0026gt;interrupted status\u0026lt;/i\u0026gt; of the current thread is * cleared when this exception is thrown. */ public static native void sleep(long millis) throws InterruptedException; 4.2.4 过期的suspend()、resume()和stop() suspend()、resume()和stop()类似CD机播放音乐时的暂停、恢复和停止操作。\n4.2.5 安全地终止线程 中断操作 利用一个boolean变量来控制是否需要停止任务并终止该线程。 这两种方法可以使线程在终止时有机会去清理资源。\n4.3 线程间通信 4.3.1 volatile和synchronized关键字 Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝，所以程序在执行过程中，一个线程看到的变量不一定是最新的。 关键字volatile可以用来修饰字段（成员变量）。 关键字synchronized可以修饰方法或者以同步块的形式来进行使用。 通过class信息，对于同步块的实现使用了monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成。 无论采用哪种方式，其本质是对一个对象的监视器进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。 任意一个对象都拥有自己的监视器。 对象、监视器、同步队列和执行线程之间的关系图 4.3.2 等待/通知机制 等待/通知的相关方法是任意Java对象都具备的，被定义在超类java.lang.Object上。 等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。 细节：\n使用wait()、notify()和notifyAll()时需要先对调用对象加锁。 调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。 notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifyAll()的线程释放锁之后，等待线程才有机会从wait()返回。 notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。 从wait()方法返回的前提是获得了调用对象的锁。 4.3.3 等待/通知的经典范式 等待方遵循如下原则：\n获取对象的锁。 如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。 条件满足则执行对应的逻辑。 通知方遵循如下原则：\n获得对象的锁。 改变条件。 通知所有等待在对象上的线程。 4.3.4 管道输入/输出流 管道输入/输出流主要用于线程之间的数据传输，而传输的媒介为内存。 4种具体实现：PipedOutputStream、PipedOutputStream、PipedReader和PipedWriter，前两种面向字节，后两种面向字符。 对于Piped类型的流，必须先要进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。 4.3.5 Thread.join()的使用 如果一个线程A执行了thread.join()语句，其含义是：当线程A等待thread线程终止之后才从thread.join()返回。 每个线程终止的前提是前驱线程终止，每个线程等待前驱线程终止后，才从join()方法返回，这里涉及了等待/通知机制。 当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。 4.3.6 ThreadLocal的使用 ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构，这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。 可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。 ","date":"2022-03-28T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-03-28-The-Art-of-Java-Concurrency-Programming/background.jpg","permalink":"https://wenjin1997.github.io/2022/03/28/The-Art-of-Java-Concurrency-Programming/","title":"Java并发编程的艺术笔记"},{"content":"创建Matlab快捷方式 在命令窗口执行如下命令，参考Linux下安装matlab及创建快捷方式 1 sudo gedit /usr/share/applications/matlab.desktop 在文件中输入如下命令： 1 2 3 4 5 6 7 8 9 10 [Desktop Entry] Encoding=UTF-8 Name=matlab Comment=MATLAB R2014b Exec=/usr/local/MATLAB/R2014b/bin/matlab -desktop Icon=/usr/local/MATLAB/R2014b/bin/matlab_logo.png Terminal=false StartupNotify=true Type=Application Categories=Application;Development; 主要是Exec和Icon路径写对。 3. 用下面的命令可以打开应用列表目录，参考ubuntu删除图标\n1 sudo nautilus /usr/share/applications 创建Anaconda快捷方式 与上述过程类似，Anaconda.desktop文件内容如下：\n1 sudo gedit /usr/share/applications/Anaconda.desktop 1 2 3 4 5 6 7 8 9 10 11 12 [Desktop Entry] Version=1.0 Name=Anaconda Type=Application GenericName=Anaconda Comment=Scientific Python Development Environment - Python3 Exec=sh /home/你的anaconda3所在文件夹名/anaconda3/bin/anaconda-navigator Categories=Development;Science;IDE;Qt;Education; Icon=/home/你的anaconda3所在文件夹名/anaconda3/lib/python3.7/site-packages/anaconda_navigator/static/images/anaconda-icon-256x256.png Terminal=false StartupNotify=true MimeType=text/x-python; ","date":"2022-03-23T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/03/23/Ubuntu/","title":"Ubuntu下创建快捷方式"},{"content":"课程介绍 学习计算机网络时找到了这套课程，作为入门还是不错的，老师的PPT都很通俗易懂。可以在MOOC计算机网络上下载课程PPT，B站上计算机网络微课堂（有字幕无背景音乐版）也有课程视频。\n第1章 概述 1.1 计算机网络在信息时代的作用 略。\n1.2 因特网概述 网络是由若干结点和连接这些结点的链路组成。\n多个网络可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网。因此，互联网就是“网络的网络”。\n因特网是世界上最大的互连网络。它是一个专用名词，采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。\nISP(Internet Service Provider)：因特网服务提供者。例如国内的中国电信、中国联通和中国移动。\n因特网的组成：边缘部分+核心部分\n1.3 电路交换、分组交换、报文交换 分组交换：\n发送方：构造分组、发送分组 路由器：存储转发分组 接收方：接收分组、还原报文 分组交换的优缺点：\n优点 无需建立连接 线路利用率高 简化了存储管理 加速传输 减少出错概率和重发数据量 缺点 引发了转发时延 需要额外的信息量 对于数据报服务，存在失序、丢失和重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程 1.4 计算机网络的定义与分类 计算机网络：一些互相连接的、自治的计算机的集合。\n1.5 计算机网络的性能指标 🚩1.6 计算机网络体系结构 应用层 :解决通过应用进程的交互来实现特定网络应用的问题。为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。\n表示层 :数据处理（编解码、加密解密、压缩解压缩）。\n会话层 :管理（建立、维护、重连）应用程序之间的对话。\n传输层 :解决进程之间基于网络的通信问题。为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议:传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段;用户数据报协议 UDP，提供 无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。\n网络层 :解决分组在多个网络上传输（路由）的问题。为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。\n数据链路层 :解决分组在一个网络（或一段链路）上传输的问题。网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。\n物理层 :解决使用何种信号来传输比特的问题。考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。\n第2章 物理层 2.1 物理层的基本概念 2.2 物理层下面的传输媒体 2.3 传输方式 2.4 编码与调制 2.5 信道的极限容量 第3章 数据链路层 3.1 数据链路层概述 3.2 封装成帧 3.3 差错检测 3.4 可靠传输 3.4.1 可靠传输的基本概念 3.4.2 停止-等待协议SW 3.4.3 回退N帧协议GBN 3.4.4 选择重传协议SR 3.5 点对点协议PPP 3.6 媒体接入控制MAC 3.6.1基本概念 3.6.2静态划分信道 3.6.3 CSMA/CD 3.6.4 CSMA/CA 3.7 MAC地址、IP地址以及ARP协议 3.7.1 MAC地址 3.7.2 IP地址 3.7.3 ARP协议 3.8 集线器与交换机的区别 3.9 以太网交换机自学习和转发帧的流程 3.10 以太网交换机的生成树协议STP 3.11 虚拟局域网VLAN 3.11.1概述 3.11.2 实现机制 第4章 网络层 4.1 网络层概述 4.2 网络层提供的两种服务 4.3 IPv4地址 4.3.1 IPv4地址概述 4.3.2 分类编址的IPv4地址 4.3.3 划分子网的IPv4地址 4.3.4 无分类编址的IPv4地址 4.3.5 IPv4地址的应用规划 4.4 IP数据包的发送和转发过程 4.5 静态路由配置及其可能产生的路由环路问题 4.6 路由选择协议 4.6.1 路由选择协议概述 4.6.2 路由信息协议RIP的基本工作原理 4.6.3 开放最短路径优先OSPF的基本工作原理 4.6.4 边界网关协议BGP的基本工作原理 4.7 IPv4数据报的首部格式 重要的是能画出IPv4数据报的首部格式\n4.8 网际控制协议ICMP 目的：为了更有效地转发IP数据报和提高交付成功的机会 封装在IP数据报中 ICMP差错报告报文分为5种：终点不可达、源点抑制、时间超过、参数问题、改变路由（重定向） 不应发送ICMP差错报告报文 有4种情况 ICMP询问报文 回送请求和回答：测试目的站是否可达 时间戳请求和回答：进行时钟同步和测量时间 ICMP应用 分组网间探测PING 跟踪路由 4.9 虚拟专用网VPN和网络地址转换NAT VPN：利用公用的因特网作为本机构各专用网络之间的通信载体 虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址。有专用地址。 NAT：可使大量使用内部专用地址的网络用户共享少量外部全球地址 网络地址与端口号转换：NAPT，用一个全球IP地址就可以使本地地址的主机同时和因特网上的主机进行通信。 NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护。 第5章 运输层 5.1 运输层概述 计算机网络体系结构中的物理层、数据链路层和网络层共同解决了将主机通过异构网络互联起来说面临的问题，实现了主机到主机的通信。 运输层任务：为运行在不同主机上的应用进程提供直接的通信服务 运输协议：面向连接的TCP和无连接的UDP 5.2 运输层端口号、复用和分用的概念 TCP/IP体系的运输层使用端口号来区分应用层的不同进程 熟知端口号 登记端口号 短暂端口号 端口号只具有本地意义 发送方的复用和接收方的分用 熟知端口号 5.3 UDP和TCP的对比 UDP的首部格式\n5.4 TCP的流量控制 所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。\n利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。\nTCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小。 TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文。 5.5 TCP的拥塞控制 在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的部分，网络性能就要变坏。这种情况就叫做拥塞。\n5.6 TCP超时重传时间的选择 超时重传时间RTO应略大于加权平均往返时间RTTs（又称为平滑的往返时间）。\n5.7 TCP可靠传输的实现 5.8 TCP的运输连接管理 5.8.1 TCP的连接建立 发送针对TCP连接请求的确认的确认不多余，这是为了防止失效的连接请求报文段突然又重传到了TCP服务器，因而导致错误。\nTCP 为什么是三次握手，而不是两次或四次？\n5.8.2 TCP的连接释放 参考两张动图-彻底明白TCP的三次握手与四次挥手:\n为什么建立连接是三次握手，关闭连接确是四次挥手呢？\n建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。\n5.9 TCP报文段的首部格式 序号：指出本TCP报文段数据载荷的第一个字节的序号\n确认号：指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。\nTCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。\n保留：占6比特\n校验和：在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。\n复位标识位RST：用来复位TCP连接。为1表明TCP连接出现了异常。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。\nPSH：推送标志位\n紧急标记位URG\n紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度。\n选项：最大报文段长度MSS选项、窗口扩大选项、时间戳选项（计算往返时间RTT，处理序号超范围的情况）、选择确认选项\n第6章 应用层 6.1 应用层概述 6.2 客户/服务器方式和对等方式 6.3 动态主机配置协议DHCP 6.4 域名系统DNS(Domain Name System) 为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上DNS查询报文的数量，在域名服务器和主机中广泛使用了高速缓存。\nDNS报文使用运输层的UDP协议封装，运输层端口号为53。\n6.5 文件传送协议FTP 6.6 电子邮件 6.7 万维网WWW 万维网是运行在因特网上的一个分布式应用。\n万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网。\n万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置。URL一般形式：\u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt;\n万维网文档\n超文本标记语言HTML，使用多种标签来描述网页的结构和内容 层叠样式表CSS，从审美的角度来描述网页的样式 JavaScript，一种脚本语言，控制网页行为 Cookie是一种对无状态的HTTP进行状态化的技术。\n","date":"2022-03-23T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/03/23/internet/","title":"计算机网络知识总结"},{"content":"主要参考vuepress-theme-reco设置math公式。\n步骤 定位到博客的根目录下，安装库 1 npm i markdown-it-texmath 安装markdown-it 1 npm install markdown-it --save 安装katex 1 npm install katex 修改.vuepress/config.js文件 1 2 3 4 5 6 7 markdown: { lineNumbers: true, anchor: { permalink: false }, toc: {includeLevel: [1,2]}, extendMarkdown: md =\u0026gt; { md.use(require(\u0026#39;markdown-it-texmath\u0026#39;)) } head部分添加下面的代码：\n1 2 3 4 5 [\u0026#39;link\u0026#39;, {\u0026#34;rel\u0026#34;:\u0026#39;stylesheet\u0026#39;, \u0026#34;href\u0026#34;:\u0026#39;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css\u0026#39;}], [\u0026#39;link\u0026#39;, {\u0026#34;rel\u0026#34;:\u0026#39;stylesheet\u0026#39;, \u0026#34;href\u0026#34;:\u0026#39;https://gitcdn.xyz/cdn/goessner/markdown-it-texmath/master/texmath.css\u0026#39;}], [\u0026#39;script\u0026#39;, {\u0026#34;src\u0026#34;: \u0026#39;https://github.com/markdown-it/markdown-it/blob/master/bin/markdown-it.js\u0026#39;}], [\u0026#39;script\u0026#39;, {\u0026#34;src\u0026#34;: \u0026#39;https://gitcdn.xyz/cdn/goessner/markdown-it-texmath/master/texmath.js\u0026#39;}], [\u0026#39;script\u0026#39;, {\u0026#34;src\u0026#34;: \u0026#39;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js\u0026#39;}] 更新提交后，就大功告成了。 ","date":"2022-03-09T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/03/09/mathEquationBlog/","title":"vuepress配置博客支持数学公式"},{"content":"最简显格式 对于如下热传导方程： $$ \\begin{cases} \\frac{\\partial u}{\\partial t} =\\frac{\\partial ^2 u}{\\partial t} \\quad 0","date":"2021-05-24T00:00:00Z","permalink":"https://wenjin1997.github.io/2021/05/24/heat-equation/","title":"数值求解热传导方程"},{"content":"求解如下常微分方程：\n$$ \\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2, \\\\\\ u(1)=1 \\end{cases}\t\\end{aligned} $$精确解 将原方程化为$tdu+udt=0$，则有$d(ut)=0$，解得$ut=C$($C$为常数)，代入初始条件得$C=1$，从而该方程的精确解为： $$ \\begin{aligned} u=\\frac{1}{t},(1\\leq t \\leq2). \\end{aligned} $$欧拉方法 代入欧拉格式得： $$ \\begin{aligned} u_{i+1}=u_{i}+hf(t_i,u_i)=u_i+h(-\\frac{u_i}{t_i}) \\end{aligned} $$隐式欧拉方法 由隐式欧拉格式得： $$ \\begin{aligned} u_{i+1}=u_{i}+hf(t_{i+1},u_{i+1})=u_i+h(-\\frac{u_{i+1}}{t_{i+1}})， \\end{aligned} $$ 移项化简可得： $$ \\begin{aligned} u_{i+1}=\\frac{t_{i+1}u_i}{t_{i+1}+h} \\end{aligned} $$程序 根据上述推导，用python编写程序，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # implict euler method import numpy as np import matplotlib.pyplot as plt # the right term of the ODE def f(t, u): f = -u/t return f # the exact solution of ODE def fexact(t): fexact = 1/t return fexact N = 100 t_n = 2.0 dt = (t_n - 1.0) / N t = np.arange(1.0, t_n + dt, dt) u_euler = np.arange(1.0, t_n + dt, dt) u = np.arange(1.0, t_n + dt, dt) u_true = np.arange(1.0, t_n + dt, dt) i = 0 while i \u0026lt; N: t[i+1] = t[i] + dt u_euler[i+1] = u_euler[i] + dt * f(t[i], u_euler[i]) u[i+1] = (u[i] * t[i+1])/(t[i+1] + dt) u_true[i+1] = fexact(t[i+1]) i = i + 1 err_euler = max(abs(u_euler - u_true)) err_implict_euler = max(abs(u - u_true)) print(\u0026#34;The error of euler method: \u0026#34;,err_euler) print(\u0026#34;The error of implict euler method: \u0026#34;,err_implict_euler) # begin drawing plt.title(\u0026#39;Result\u0026#39;) plt.plot(t, u_euler, color=\u0026#39;green\u0026#39;, label=\u0026#39;euler\u0026#39;) plt.plot(t, u, color=\u0026#39;blue\u0026#39;, label=\u0026#39;implict euler\u0026#39;) plt.plot(t, u_true, color=\u0026#39;red\u0026#39;, label=\u0026#39;exact\u0026#39;) plt.legend() # show the legend plt.xlabel(\u0026#39;t\u0026#39;) plt.ylabel(\u0026#39;u\u0026#39;) plt.show() 结果分析 当取$h=0.01$时，此时欧拉方法的误差为0.02631578947368396，隐式欧拉方法的误差为0.023809523809523836，结果如下图所示：\n当取不同$h$，得到的误差如下表所示：\n$h$ 欧拉方法 隐式欧拉方法 $\\frac{1}{2}$ 0.16666666666666663 0.09999999999999998 $\\frac{1}{4}$ 0.0714285714285714 0.05555555555555558 $\\frac{1}{8}$ 0.033333333333333215 0.02941176470588236 $\\frac{1}{16}$ 0.01612903225806467 0.015151515151515138 $\\frac{1}{32}$ 0.00793650793650813 0.007692307692307665 $\\frac{1}{64}$ 0.0039370078740155193 0.003875968992248069 ","date":"2021-03-11T00:00:00Z","image":"https://wenjin1997.github.io/img/2021-03-11-eluer-method/background.jpg","permalink":"https://wenjin1997.github.io/2021/03/11/euler-method/","title":"欧拉方法、隐式欧拉方法"},{"content":"步骤 1.在本地建立一个文件夹，并定位到该文件夹下\n2.输入命令git init git config --global user.name \u0026quot;wenjin1997\u0026quot; git config --global user.email \u0026quot;wenjin1997@126.com\u0026quot; 3.配置SSHssh-keygen -t rsa -C \u0026quot;xxxxxxxx@163.com\u0026quot; (登录github的邮箱)，中间需要设置密码，可以直接按回车\n4.拷贝SSHpbcopy \u0026lt; ~/.ssh/id_rsa.pub\n5.在github的settings中添加刚刚的SSH\n6.打开终端，验证是否配置成功ssh -T git@github.com\n7.设置登录名及邮箱\n1 2 git config --global user.name \u0026#34;your name\u0026#34; git config --global user.email \u0026#34;your_email@youremail.com\u0026#34; 8.将项目克隆到本地，例如git clone git@github.com:wenjin1997/python-notes.git\n","date":"2021-01-24T00:00:00Z","permalink":"https://wenjin1997.github.io/2021/01/24/git/","title":"如何用git同步本地代码到github"},{"content":"书籍信息 书名：《练习的心态：如何培养耐心、专注和自律》 作者：托马斯 M.斯特纳 书摘 总而言之，我们培育练习的心态，归结为一些简单的法则：\n让自己始终以过程为导向。 重点关注当前。 将过程确定为目标，并且运用总目标作为船舵，以指引自己的努力。 对自己想要做到的事情刻意地训练，带着意图训练，并且自始至终清醒地知道那种意图。 聚焦于过程时，你期望的结果会很轻松、很自然地出现。聚焦于结果时，你便马上陷入纠结之中，对过程感到厌倦、不安、失败和不耐烦。\n通向耐心的第一步是意识到你的内心独白是什么时候开始疯狂奔走，并且拖着你一路狂奔。\n培养耐心的第二步是理解和接受这样一个现实：不论什么事情，都不会尽善尽美。真正的完美，一方面总在不停演变，另一方面也总在你的内心出现，正如之前例举过的绽放的鲜花那样。\n获得任何东西所带来的真正的兴奋感，不论这样东西是一件物品还是一个个人目标，其实是你对获得它那一刻的预测。真正的愉悦取决于你产生和保持的毅力与耐心。它们正是你在长时间内为争取拥有这样东西而努力工作时所需要的。\n判断，对我们生活的运转是必要的，但也有一个不利的方面：它们并不会以一种超然的特性来执行。通常其中包含着某种情绪，而情绪的数量与我们对判断的重要性的感知程度是成比例的。\n你来到这个世界上的时候，只带着你真正的自我而来；而你离开这个世界时，也只能带走你最真实的自我。你在精神上获得的一切，将丰富和发展你的真实自我，变成你永恒的一部分。\n读后感 阅读完这本书并没有花费我多少时间，几乎是一口气就读完了。但是其中的思想方法值得慢慢学习并在生活中去实践。\n最重要的就是为了达成某个目标或者完成某件事情时，我们应该更加注重过程而不是结果。我们常常说“尽力就好了，不要强求自己”，我认为这算是让自己偷懒的一个借口或者是结果不理想时的一个安慰，与注重过程还是有所不同。我们需要活在当下，而不是过去或者未来。我们的目标是我们期望的未来，它应当是指引我们行动的方向，确保自己没有走偏，我们应该体验与感受现在，不要过多的关注于现在距离目标还有多远多远，这只会徒增自己的焦虑与担忧，反而会影响前进的速度。\n书中提到了一个方法是DOC，即Do、Observe、Correct，我认为非常有帮助。比如我们注意到自己为某件事情担心时，这就实现了做（Do）的部分。现在，观察（Observe）自己想要的行为，在对自己为那件事情担心的观察中，将自己与担心那一举动隔离开来。当自己意识到自己担心的情绪对于担心的问题并没有影响时，尽可能地让自己从这种情绪中解脱出来（就是纠正（Correct）的过程）。\n我认为书中还有一个对我有启发的观点是，不论什么事情，都不会尽善尽美。我一直在幻想着一个理想的自己，她很勤奋，自律，热爱学习，热爱生活，善于交流，开朗积极，好像一直都是那么阳光积极，其实这真的就是幻想，对现实无济于事，甚至当自己出现负面情绪或者变得懒惰时，就会产生愧疚自责，离那个理想中的自己更加遥远了，这完完全全会影响当下的行为。不如在一开始就意识到，没有什么是完美的，自己就是这样存在的，这才是真实的自己，至于想要改变什么，那就多关注如何做到，而不是批判一个过去的自己，这完全是不值得的。\n如果说要去思考什么是人生的目标，我们是为了什么而活。我认为这本书给我的一个想法就是，没有什么目标，重要的就是自己体验到了什么。关注于现在在做什么，现在体验到了什么，这些就构成了整个自己的一生。可能自己所有的努力与付出并不是为了获得物质与短暂的快乐，而是寻得自己内心的平静。啊啊~~ 自己还没达到什么物质条件呢，说这个有些大了，富人的快乐你体会不到~~ 哈哈~~~\n","date":"2020-03-10T00:00:00Z","permalink":"https://wenjin1997.github.io/2020/03/10/Practices/","title":"《练习的心态：如何培养耐心、专注和自律》"}]