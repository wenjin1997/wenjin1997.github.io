[{"content":"åŸæ–‡é“¾æ¥ï¼šZero Knowledge Proofs: An illustrated primer, PartÂ 2ã€‚è¿™ç¯‡åšå®¢é€šè¿‡Schnorråè®®è¯¦ç»†è®²è§£äº†é›¶çŸ¥è¯†è¯æ˜ä¸­çš„å®Œå¤‡æ€§ã€å¯é æ€§ä»¥åŠé›¶çŸ¥è¯†ï¼Œå¯¹äºå¼„æ‡‚æå–å™¨ã€æ¨¡æ‹Ÿå™¨ä»¥åŠé›¶çŸ¥è¯†ç­‰æ¦‚å¿µå¾ˆæœ‰å¸®åŠ©ã€‚ä¹‹å‰å¯¹äºæ¨¡æ‹Ÿå™¨çš„ä½œç”¨æœ‰äº›æ‡µæ‡µæ‡‚æ‡‚ï¼Œç°åœ¨çœ‹å®Œåæœ‰ä¸€ç§é€å½»çš„æ„Ÿè§‰ğŸ˜ƒã€‚\nğŸ“ æ€»ç»“ä¸€ä¸‹ï¼š\nä»»ä½•é›¶çŸ¥è¯†è¯æ˜å¿…é¡»æ»¡è¶³ä¸‰ä¸ªé‡è¦çš„æ€§è´¨ï¼š\nå®Œå¤‡æ€§ã€‚ä»»ä½•è¯šå®çš„Proveræœ€ç»ˆéƒ½èƒ½å¤Ÿä½¿Verifierä¿¡æœã€‚ å¯é æ€§ã€‚å¦‚æœèƒ½è¯´æœVerifierï¼Œé‚£ä¹ˆä¸€å®šæœ‰å‘½é¢˜æ˜¯çœŸçš„ã€‚é€†å¦å‘½é¢˜å°±æ˜¯ï¼Œå¦‚æœå‘½é¢˜ä¸ä¸ºçœŸï¼Œé‚£ä¹ˆå°±ä¸èƒ½è¯´æœVerifierã€‚ é›¶çŸ¥è¯†ã€‚Verifieré™¤äº†çŸ¥é“å‘½é¢˜ä¸ºçœŸå¤–ä¸èƒ½è·å¾—å…¶ä»–ä»»ä½•ä¿¡æ¯ã€‚ å¦‚ä½•åœ¨è¯æ˜å¯é æ€§å’Œé›¶çŸ¥è¯†æ€§è´¨çš„åŒæ—¶åˆä¸ä¼šæ³„æ¼çŸ¥è¯†å‘¢ï¼Ÿç§˜è¯€å°±æ˜¯æ¨¡æ‹Ÿå™¨ï¼Œæ¨¡æ‹Ÿå™¨ä¸­æ‹¥æœ‰åœ¨å®é™…ä¸­ä¸å¯èƒ½æœ‰çš„è¶…èƒ½åŠ›ï¼Œæ¯”å¦‚è¯´æ—¶é—´æœºå™¨ã€‚è¿™æ ·å°±å¾ˆå·§å¦™çš„è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼\nè¯æ˜å¯é æ€§ï¼Œä½¿ç”¨æ¨¡æ‹Ÿå™¨ï¼å¯é æ€§è¯´çš„æ˜¯å¦‚æœèƒ½è¯´æœVerifierï¼Œé‚£ä¹ˆä¸€å®šæœ‰å‘½é¢˜ä¸ºçœŸã€‚åšå®¢ä¸­ä¸»è¦è®¨è®ºçš„\u0026quot;statement\u0026quot;æ˜¯ä¸ªäººçŸ¥è¯†è€Œä¸æ˜¯\u0026quot;facts\u0026quot;ï¼Œä¹Ÿå°±æ˜¯â€œæˆ‘çŸ¥é“æŸä¸ªçŸ¥è¯†ï¼Œæˆ–è€…è¯´ç§˜å¯†å§â€ã€‚å…·ä½“æ¥è®²ï¼Œå¯é æ€§å°±å˜æˆäº†ï¼Œå¦‚æœèƒ½è¯´æœVerifierï¼Œé‚£ä¹ˆProverä¸€å®šæ˜¯çŸ¥é“çŸ¥è¯†çš„ã€‚ä¸ºäº†è¯æ˜è¿™ä¸€ç‚¹ï¼Œæ¬å‡ºæå–å™¨çš„æ¦‚å¿µï¼Œæå–å™¨å……å½“Verifierçš„è§’è‰²ï¼Œå¯¹äºä»»ä½•å¯èƒ½çš„Proverï¼Œå¦‚æœéƒ½å­˜åœ¨ä¸€ä¸ªæå–å™¨èƒ½å¤Ÿæå–åˆ°çŸ¥è¯†ï¼Œé‚£ä¹ˆå°±è¯´æ˜Proverè‚¯å®šæ˜¯æœ‰çŸ¥è¯†çš„ã€‚è¿™ä¸å°±è¯æ˜äº†å¯é æ€§å˜›ï¼\né‚£é—®é¢˜æ˜¯æå–å™¨æ€ä¹ˆæå–çŸ¥è¯†å‘¢ï¼Ÿè®©æˆ‘ä»¬ä¸Šæ¨¡æ‹Ÿå™¨ä¸­çš„è¶…èƒ½åŠ›â€”â€”æ—¶å…‰æœºå™¨ï¼æå–å™¨èƒ½å¤Ÿå›æº¯ï¼Œè¾¾åˆ°éª—Proveråœ¨ä¸¤æ¬¡è¿è¡Œä¸­ä½¿ç”¨ç›¸åŒçš„éšæœºæ•°$k$ï¼Œç„¶åè®¡ç®—å‡ºProveråŸæ¥æ‹¥æœ‰çš„å¯†é’¥$a$ã€‚\nè¯æ˜é›¶çŸ¥è¯†ï¼Œä½¿ç”¨æ¨¡æ‹Ÿå™¨ï¼è¦è¯æ˜ç°å®ä¸­çš„Verifieré™¤äº†çŸ¥é“ProverçŸ¥é“çŸ¥è¯†è¿™ä¸€ç‚¹å¤–ä¸èƒ½è·å–åˆ°å…¶ä»–ä»»ä½•ä¿¡æ¯ï¼Œæˆ‘ä»¬æ„é€ ä¸€ä¸ªå‹æ ¹å°±ä¸çŸ¥é“å¯†é’¥$a$çš„Proverï¼Œå®ƒå’Œè¯šå®çš„Verifieräº¤äº’ï¼Œè®©Verifierç›¸ä¿¡Proveræ˜¯çŸ¥é“å¯†é’¥$a$çš„ã€‚åŒæ—¶åœ¨ç»Ÿè®¡æ„ä¹‰ä¸Šï¼Œæ¨¡æ‹Ÿå™¨ä¸­äº¤äº’çš„è¾“å‡ºåˆ†å¸ƒå’ŒçœŸå®Proverå’ŒVerifieräº¤äº’çš„è¾“å‡ºåˆ†å¸ƒæ˜¯ä¸€æ ·çš„ã€‚é‚£ä¹ˆç”±äºæ¨¡æ‹Ÿå™¨ä¸­æ ¹æœ¬æ²¡æœ‰çŸ¥è¯†ï¼Œä¹Ÿå°±è¯æ˜äº†é›¶çŸ¥è¯†ã€‚\né‚£ä¹ˆå¦‚ä½•åœ¨æ¨¡æ‹Ÿå™¨ä¸­è®©Proverè¯´æœVerifierå‘¢ï¼Ÿä¸Šè¶…èƒ½åŠ›â€”â€”æ—¶å…‰æœºå™¨ï¼Proverå…ˆå‘ä¸€ä¸ªåˆå§‹å€¼$g^{k_1}$éª—å–åˆ°Verifierçš„éšæœºæ•°$c$ï¼Œå›æº¯Verifierï¼Œè®©å®ƒå‘é€éšæœºæ•°$z$ï¼Œè¿›è¡Œä¸€äº›è®¡ç®—å¾—åˆ°åˆå§‹å€¼ï¼Œå½“Verifierå‘èµ·éšæœºæŒ‘æˆ˜$c$æ—¶ï¼ŒProverè¾“å‡º$z$å°±èƒ½è®©Verifierç›¸ä¿¡ProverçŸ¥é“å¯†é’¥$a$ï¼Œå®é™…ä¸ŠProverä¸çŸ¥é“å¯†é’¥$a$ã€‚\nä¸Šé¢çš„è¿‡ç¨‹éƒ½æ˜¯äº¤äº’çš„ï¼Œè½¬æ¢æˆéäº¤äº’é›¶çŸ¥è¯†è¯æ˜çš„ä¸€ä¸ªæ–¹å¼æ˜¯ç”¨å¯é çš„å“ˆå¸Œå‡½æ•°æ¥å‘èµ·éšæœºæŒ‘æˆ˜ã€‚\nå¥½çš„ï¼ä¸‹é¢å¼€å§‹è¾¹è¯»åšå®¢æ–‡ç« è¾¹åšç¬”è®°ã€‚ğŸ‘‡\nThis post is the second in a two-part series on zero-knowledge proofs.Â Click hereÂ to readÂ Part 1.\nIn this post Iâ€™m going to continue the short, (relatively) non-technical overview of zero knowledge proofs that I started a couple of years ago. Yes, that was a very long time! If you didnâ€™t catch the first post, now would be anÂ excellent time to go read it.\nBefore we go much further, a bit of a warning. While this series is still intended as a high-level overview, at a certain point itâ€™s necessary to dig a bit deeper into some specific algorithms. So you should expect this post to get a bit wonkier than the last.\nA quick recap, and a bit more on Zero Knowledge(ness) First, a brief refresher.\nIn the last post we defined a zero knowledge proof as an interaction between two computer programs (or Turing machines) â€” respectively called a Prover and a Verifier â€” where the Prover works to convince the Verifier that some mathematical statement is true. We also covered a specific example:Â a clever protocol byÂ Goldreich, Micali and WigdersonÂ that allows us to prove, in zero knowledge, that a graph possessesÂ aÂ three-coloring.\nIn the course of that discussion, we described three critical properties that any zero knowledge proof must satisfy:\nCompleteness:Â If the Prover is honest, then she will eventually convince the Verifier. Soundness:Â The Prover can only convince the Verifier if the statement is true. Zero-knowledge(ness):Â The Verifier learns no information beyond the fact that the statement is true. The real challenge turns out to be finding a way to formally define the last property. How do you state that a Verifier learnsÂ nothingÂ beyond the truth of a statement?\nIn caseÂ you didnâ€™t read theÂ previous postÂ â€” the answer to this question came from Goldwasser, Micali and Rackoff, and itâ€™s very cool. What they argued is that a protocol can be provenÂ zero knowledgeÂ if for every possible Verifier, you can demonstrate the existence of an algorithm called a â€˜Simulatorâ€™, and show that this algorithm has some very special properties.\nFrom a purely mechanical perspective, the Simulator is like a special kind of Prover. However, unlike a real Prover â€” which starts with some special knowledge that allows it to prove the truth of a statement â€” the SimulatorÂ gets no special knowledge at all.*Â Nonetheless, the Simulator (or Simulators) must be able to â€˜foolâ€™ every Verifier into believing that the statement is true, while producing a transcript thatâ€™s statistically identical top (or indistinguishable from) the output of a real Prover.\nä¸Šé¢å…³äºæ¨¡æ‹Ÿå™¨çš„å™è¿°æ¯”è¾ƒé‡è¦ã€‚å¯ä»¥å°†æ¨¡æ‹Ÿå™¨çœ‹ä½œæ˜¯ç‰¹æ®Šçš„ä¸€ç§Proverã€‚æ¨¡æ‹Ÿå™¨å¿…é¡»å¯ä»¥éª—è¿‡ä»»ä½•çš„Verifierç›¸ä¿¡å‘½é¢˜æ˜¯çœŸçš„ï¼Œè€Œä¸”æ¨¡æ‹Ÿå™¨äº§ç”Ÿçš„ç»“æœå’Œä¸ä¸€ä¸ªçœŸå®çš„Proveräº¤äº’å¾—åˆ°çš„ç»“æœåœ¨ç»Ÿè®¡ä¸Šæ˜¯ä¸å¯åŒºåˆ†çš„ã€‚\nThe logic here flows pretty cleanly: sinceÂ Simulator has no â€˜knowledgeâ€™ to extract in the first place, then clearly a VerifierÂ canâ€™tÂ obtain any meaningful amount of information after interacting with it. Moreover, ifÂ the transcript of the interaction is distributed identically to a real protocol run with a normal Prover, then the VerifierÂ canâ€™tÂ do better against the real prover than it can do against the Simulator. (If the VerifierÂ couldÂ do better, then that would imply that the distributions were not statistically identical.) Ergo, the Verifier canâ€™t extract useful information from the real protocol run.\nThis is incredibly wonky, and worse, it seems contradictory! Weâ€™re asking that a protocol be bothÂ soundÂ â€” meaning that a bogusï¼ˆè™šå‡çš„ï¼‰ Prover canâ€™t trick some Verifier into accepting a statement unless it has special knowledge allowing it to prove the statement â€” but weâ€™re also asking for the existence of an algorithm (the simulator) that can literally cheat. Clearly both properties canâ€™t hold at the same time.\nThe solution to this problem is that both propertiesÂ donâ€™tÂ hold at the same time.\nTo build our simulator, weâ€™re allowed to do things to the Verifier that would never happen in the real world. The example that I gave in the previous post was to use a â€˜time machineâ€™ â€” that is, our â€˜Simulatorâ€™ can rewind the Verifier programâ€™s execution in order to â€˜foolâ€™ it. Thus, in a world where we can wind the Verifier back in time, itâ€™s easy to show that a Simulator exists. In the real world, of course it doesnâ€™t. This â€˜trickâ€™ gets us around the contradiction.\nçœ‹ä¼¼æ¨¡æ‹Ÿå™¨æ²¡æœ‰çŸ¥è¯†ä¹Ÿèƒ½éª—è¿‡Verifierå’ŒProveré™¤éæœ‰çŸ¥è¯†æ‰èƒ½é€šè¿‡Verifierçš„æµ‹éªŒæ˜¯çŸ›ç›¾çš„ï¼Œä½†å…¶å®è¿™ä¸¤ä¸ªä¸æ˜¯åŒæ—¶æˆç«‹çš„ã€‚æ¨¡æ‹Ÿå™¨æœ‰ä¸€äº›çœŸå®ä¸–ç•Œæ²¡æœ‰çš„è¶…èƒ½åŠ›ï¼Œæ¯”å¦‚è¯´æ—¶é—´æœºå™¨ï¼Œè¿™æ ·æ¨¡æ‹Ÿå™¨æ˜¯å¯ä»¥éª—è¿‡Verifierçš„ã€‚\nAs a last reminder, to illustrate all of these ideas, we covered one of the first general zero knowledge proofs, devised byÂ Goldreich, Micali and WigdersonÂ (GMW). That protocol allowed us to prove, in zero knowledge, that a graph supports aÂ three-coloring. Of course, proving three colorings isnâ€™t terribly interesting. The real significance of the GMW result is theoretical. Since graph three coloring is known to be in the complexity classÂ NP-complete, the GMW protocol can be used to proveÂ any statementÂ in the classÂ NP. And thatâ€™s quite powerful.\nLet me elaborate slightly on what that means:\nIf there existsÂ anyÂ decision problemÂ (that is, a problem with a yes/no answer) whose witness (solution) can be verified in polynomial time, then: We can prove that said solution exists byÂ (1)Â translating the problem into an instance of the graph three-coloring problem, andÂ (2)Â running the GMW protocol.* This amazing result gives us interactive zero knowledge proofs forÂ every statement in NP.Â TheÂ only problem is that itâ€™s almost totally unusable.\næˆ‘ä»¬çŸ¥é“GMWä¸­çš„å›¾ä¸‰è‰²é—®é¢˜æ˜¯NPCé—®é¢˜ï¼Œè€ŒNPé—®é¢˜å¯ä»¥å½’çº¦æˆå›¾ä¸‰è‰²é—®é¢˜ï¼Œç„¶åå¯ä»¥ç”¨GMWåè®®æ¥è¿›è¡Œé›¶çŸ¥è¯†è¯æ˜ã€‚å”¯ä¸€çš„é—®é¢˜æ˜¯è¿™æ˜¯ä¸å®ç”¨çš„ã€‚\nFrom theory into practice If youâ€™re of a practical mindset, youâ€™re probably shaking your head at all this talk of ZK proofs. Thatâ€™s because actuallyÂ using this approachÂ would be an insanely expensive and stupid thing to do. Most likely youâ€™d first represent your input problem as aÂ boolean circuitÂ where the circuit isÂ satisfiedÂ if and only if you know the correct input. Then youâ€™d have to translate your circuit into a graph, resulting in some further blowup. Finally youâ€™d need to run the GMW protocol, which is damned expensive all by itself.\nSo in practice nobody does this. Itâ€™s really considered a â€˜feasibilityâ€™ï¼ˆå¯è¡Œæ€§ï¼‰ result. Once you show that something is possible, the next step is to make it efficient.\nBut we do use zero knowledge proofs, almost every day. In this post Iâ€™m going to spend some time talking about the moreÂ practicalÂ ZK proofs that we actually use. To do that I just need give just a tiny bit of extra background.\nProofs vs. Proofs of Knowledge Before we go on, thereâ€™s one more concept we need to cover. Specifically, we need to discussÂ what precisely weâ€™re provingÂ when we conductï¼ˆæ‰§è¡Œï¼‰ a zero knowledge proof*.*Let me explain. At a high level, there are two kinds of statement you might want to prove in zero knowledge. Roughly speaking, these break up as follows.\nStatements about â€œfactsâ€.Â For example, I might wish to prove thatÂ â€œa specific graph has a three coloringâ€ or â€œsome numberÂ NÂ is in the set of composite numbersâ€œ.Â Each of these is a statement about some intrinsic property of the universe.\nStatements about my personal knowledge.Â Alternatively, I might wish to prove that IÂ knowÂ some piece information. Examples of this kind of statement include: â€œIÂ knowÂ a three coloring for this graphâ€, or â€œIÂ knowÂ the factorization ofÂ Nâ€.Â These go beyond merely proving that a fact is true, and actually rely on what the Prover knows.\né™ˆè¿°çš„å‘½é¢˜æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯äº‹å®ï¼Œä¸€ç§æ˜¯ä¸ªäººçš„çŸ¥è¯†ã€‚åœ¨è¿™ç¯‡åšå®¢ä¸­ï¼Œä¸»è¦å…³æ³¨åœ¨ç¬¬äºŒç§å‘½é¢˜ã€‚\nItâ€™s important to recognize that thereâ€™s a big difference between these two kinds of statements! For example, it may be possible to prove that a numberÂ NÂ is compositeÂ even if you donâ€™t know the full factorization.Â So merely proving the first statement isÂ notÂ equivalent to proving the second one.\nThe second class of proof is known as a â€œproof of knowledgeâ€. It turns out to be extremely useful for proving a variety of statements that we use in real life. In this post, weâ€™ll mostly be focusing on this kind of proof.\nThe Schnorr identification protocol Now that weâ€™ve covered some of the required background, itâ€™s helpful to move on to a specific and very useful proof of knowledge that was invented by Claus-Peter Schnorr in the 1980s. At first glance, the Schnorr protocol may seem a bit odd, but in fact itâ€™s the basis of many of our modern signature schemes today.\nSchnorr wasnâ€™t really concerned with digital signatures, however. His concern was withÂ identification.Â Specifically, letâ€™s imagine that Alice has published her public key to the world, and later on wants to prove that she knows the secret key corresponding to that public key. This is the exact problem that we encounter in real-world protocols such as public-key SSH, so it turns out to be well-motivated.\nSchnorr began with the assumption that the public key would be of a very specific format. Specifically, letÂ pÂ be some prime number, and letÂ gÂ be aÂ generatorÂ of aÂ cyclic groupï¼ˆå¾ªç¯ç¾¤ï¼‰Â of prime-orderÂ q. To generate a keypair, Alice would first pick a random integerÂ aÂ between 1 andÂ q, and then compute the keypair as:\n$PK_A=g^a\\mod p,SK_A = a$\n(If youâ€™ve been around the block a time or two, youâ€™ll probably notice that this is the same type of key used forÂ Diffie-HellmanÂ and theÂ DSA signingÂ algorithm. Thatâ€™s not a coincidence, and it makes this protocol very useful.)\nAlice keeps her secret key to herself, but sheâ€™s free to publish her public key to the world. Later on, when she wants to proveÂ knowledgeÂ of her secret key, she conducts the following simple interactive protocol with Bob:\nThereâ€™s a lot going on in here, so letâ€™s take a minute to unpack things.\nFirst off, we should ask ourselves if the protocol isÂ complete.Â This is usually the easiest property to verify: if Alice performs the protocol honestly, should Bob be satisfied at the end of it? In this case, completeness is pretty easy to see just by doing a bit of substitution:\næ³¨æ„ï¼Œç”±äºé€‰å–çš„$k \\in { 1, \\dots, q }$ï¼Œå› æ­¤$k\\mod q = k$ã€‚\nè¿™é‡Œè¯æ˜äº†å®Œå¤‡æ€§ï¼šè¯šå®çš„Aliceæ˜¯èƒ½å¤Ÿè¯´æœBobçš„ã€‚\nProving soundness The harder property isÂ soundness.Â Mainly because we donâ€™t yet have a good definition of what it means for a proof of knowledge to beÂ sound.Â Remember that what we want to show is the following:\nIf Alice successfully convinces Bob, thenÂ she must knowÂ the secret keyÂ a.\nå¯é æ€§ï¼šå¦‚æœAliceèƒ½å¤ŸæˆåŠŸè®©Bobä¿¡æœï¼Œé‚£ä¹ˆå¥¹ä¸€å®šçŸ¥é“å¯†é’¥$a$ã€‚ä¹Ÿå°±æ˜¯è¯´å¦‚æœAliceä¸æ˜¯è¯šå®çš„ï¼Œå¥¹ä¸çŸ¥é“å¯†é’¥$a$çš„è¯ï¼Œé‚£ä¹ˆå¥¹è‚¯å®šä¸èƒ½è¯´æœBobã€‚\nItâ€™s easy to look at the equations above and try to convince yourself that Aliceâ€™s only way to cheat the protocol is to knowÂ a. But thatâ€™s hardly a proof.\nWhen it comes to demonstrating the soundness of a proof of knowledge, we have a really nice formal approach. Just as with the Simulator we discussed above, we need to demonstrate the existence of a special algorithm. This algorithm is called aÂ knowledge extractor, and it does exactly what it claims to. A knowledge extractor (or just â€˜Extractorâ€™ for short) is a special type of Verifier that interacts with a Prover, and â€” if the Prover succeeds in completing the proof â€” the Extractor should be able to extract the Proverâ€™s original secret.\næƒ³è¦è¯æ˜å¯é æ€§ï¼Œå€ŸåŠ©äºçŸ¥è¯†æå–å™¨æ¥è¯æ˜ã€‚ä¸€ä¸ªçŸ¥è¯†æå–å™¨æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„Verifierï¼Œå®ƒå’ŒProverè¿›è¡Œäº¤äº’ï¼Œå¦‚æœProverèƒ½æˆåŠŸé€šè¿‡è¯æ˜ï¼Œé‚£ä¹ˆæå–å™¨å¯ä»¥æå–åˆ°ProveråŸæ¥çš„å¯†ç ã€‚\nAnd this answers our question above. To proveÂ soundnessÂ for a proof of knowledge, we must show that an Extractor exists for every possible Prover.\nä¸ºäº†è¯æ˜å¯é æ€§ï¼Œæˆ‘ä»¬ç°åœ¨å¿…é¡»è¯æ˜å¯¹äºæ¯ä¸€ä¸ªå¯èƒ½çš„Proverï¼Œéƒ½å­˜åœ¨è¿™æ ·ä¸€ä¸ªæå–å™¨ã€‚ç»“åˆä¸Šé¢æåˆ°çš„å¯é æ€§é™ˆè¿°ï¼Œå¦‚æœAliceèƒ½å¤ŸæˆåŠŸè®©Bobä¿¡æœï¼Œé‚£ä¹ˆå¥¹ä¸€å®šçŸ¥é“å¯†é’¥$a$ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœå¯¹äºæ¯ä¸€ä¸ªå¯èƒ½è®©Bobä¿¡æœçš„Aliceï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ªçŸ¥è¯†æå–å™¨æ¥ä¸Aliceäº¤äº’ï¼Œèƒ½æå–åˆ°å¯†é’¥$a$ï¼Œä¸å°±è¯´æ˜äº†Aliceè‚¯å®šçŸ¥é“å¯†é’¥$a$å˜›ï¼å› æ­¤è¯æ˜äº†å¯é æ€§ã€‚\nè¯æ˜é€»è¾‘æ˜¯ï¼šå¯¹æ¯ä¸€ä¸ªå¯èƒ½çš„Proverå­˜åœ¨ä¸€ä¸ªæå–å™¨ â‡’ å¦‚æœAliceèƒ½è®©Bobä¿¡æœï¼ŒAliceä¸€å®šçŸ¥é“åŸæ¥çš„ç§˜å¯†ï¼ˆå¯é æ€§ï¼‰\nOf course this again seems totally contradictory to the purpose of a zero knowledge protocol â€” where weâ€™reÂ notÂ supposed to be able to learn secrets from a Prover. Fortunately weâ€™ve already resolved this conundrum once for the case of the Simulator. Here again, we take the same approach. The Extractor isÂ notÂ required to exist during a normal run of the protocol. We simply show that it exists if weâ€™re allowed to take special liberties with the Prover â€” in this case, weâ€™ll use â€˜rewindingâ€™ to wind back the Proverâ€™s execution and allow us to extract secrets.\nå½“ç„¶è¿™çœ‹èµ·æ¥åˆå’Œé›¶çŸ¥è¯†è¯æ˜åè®®çš„ç›®çš„å†²çªäº†ï¼Œä½†æ˜¯æˆ‘ä»¬ä¾ç„¶å¯ä»¥ç”¨æ¨¡æ‹Ÿå™¨çš„æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬åªéœ€è¦è®©Proveræ‹¥æœ‰è¶…èƒ½åŠ›ï¼Œç„¶åè¿™æ ·çš„æå–å™¨æ˜¯å­˜åœ¨çš„ã€‚è¿™ä¸ªè¶…èƒ½åŠ›å¯ä»¥æ˜¯æ—¶é—´æœºå™¨ï¼Œè‚¯å®šç°å®ä¸–ç•Œä¸å­˜åœ¨æ—¶é—´æœºå™¨ï¼Œå› æ­¤ä¸ä¼šå’Œæ³„æ¼çŸ¥è¯†è¿™ä¸ªç›®çš„ç›¸å†²çªã€‚\nThe extractor for the Schnorr protocol is extremely clever â€” and itâ€™s also pretty simple. Letâ€™s illustrate it in terms of a protocol diagram. Alice (the Prover) is on the left, and the Extractor is on the right:\nThe key observation here is that by rewinding Aliceâ€™s execution, the Extractor can â€˜trickâ€™ Alice into making two different proof transcripts using the sameÂ k. This shouldnâ€™t normally happen in a real protocol run, where Alice specifically picks a newÂ kÂ for each execution of the protocol.\nå…³é”®çš„ä¸€ç‚¹æ˜¯é€šè¿‡è®©Aliceé‡æ–°æ‰§è¡Œåˆ°ç¬¬2æ­¥ï¼Œæå–å™¨å¯ä»¥éª—Aliceç»™ä¸¤ä¸ªä¸åŒçš„è¯æ˜ä½†æ˜¯ç”¨åŒä¸€ä¸ª$k$ã€‚åœ¨å®é™…çš„åè®®è¿è¡Œä¸­ï¼Œè¿™æ˜¯é€šå¸¸ä¸åº”è¯¥å‘ç”Ÿçš„ï¼ŒAliceä¼šåœ¨åè®®æ¯æ¬¡æ‰§è¡Œçš„æ—¶å€™ç‰¹åˆ«é€‰æ‹©ä¸€ä¸ªæ–°çš„$k$ã€‚\nIf the Extractor can trick Alice into doing this, then he can solve the following simple equation to recover Aliceâ€™s secret:\nå¦‚æœæå–å™¨èƒ½å¤Ÿéª—Aliceè¿™æ ·åšçš„è¯ï¼Œæå–å™¨æ˜¯å¯ä»¥æå–åˆ°Aliceæ‹¥æœ‰çš„å¯†é’¥$a$ã€‚\næ¨å¯¼çš„è¯¦ç»†è¿‡ç¨‹ï¼š\n$$ \\begin{array}{l} \\frac{s_1 - s_2}{c_1 - c_2} \\mod q \u0026 \\\\\\ \\quad = \\frac{((ac_1+k) \\mod q)-((ac_2 + k) \\mod q)}{c_1 - c_2} \\mod q \\\\\\ \\quad = \\frac{(ac_1+k)-(ac_2 + k) }{c_1 - c_2} \\mod q \\\\\\ \\quad = \\frac{ac_1 - ac_2 }{c_1 - c_2} \\mod q \\\\\\ \\quad = a \\mod q \\end{array} $$Itâ€™s worth taking a moment right now to note that thisÂ alsoÂ implies a serious vulnerabilityï¼ˆæ¼æ´ï¼‰ in bad implementations of the Schnorr protocol. If you everÂ accidentallyÂ use the sameÂ kÂ for two different runs of the protocol, an attacker may be able to recover your secret key! This can happen if you use a bad random number generator.\néœ€è¦æ³¨æ„Schnorr protocolåœ¨å®é™…ä¸­å¯èƒ½å‡ºç°çš„æ¼æ´ï¼Œé‚£å°±æ˜¯åœ¨ä¸åŒè¿è¡Œä¸­ä½¿ç”¨ç›¸åŒçš„$k$ï¼Œå› æ­¤è¦é€‰æ‹©å¥½çš„éšæœºç”Ÿæˆå™¨ã€‚\nIndeed, those with a bit more experience will notice that this is similar to aÂ *real*Â attack on systems (with bad random number generators)Â that implement ECDSA or DSA signatures! This is also not a coincidence. The (EC)DSA signature family is based on Schnorr. Ironicallyï¼ˆè®½åˆºåœ°ï¼‰, the developers of DSA managed to retain this vulnerability of the Schorr family of protocols whileÂ at the same timeÂ ditching the security proof that makes Schnorr so nice.\nProving zero-knowledge(ness) against an honest Verifier Having demonstratedï¼ˆè¯æ˜ï¼‰ that Schnorr signatures are complete and sound, it remains only to prove that theyâ€™re â€˜zero knowledgeâ€™. Remember that to do this, normally we require a Simulator that can interact with any possible Verifier and produce a â€˜simulatedâ€™ transcript of the proof, even if the Simulator doesnâ€™t know the secret itâ€™s proving it knows.\nä¸ºäº†è¯æ˜â€œé›¶çŸ¥è¯†â€ï¼Œä¸€èˆ¬è¦æ±‚æœ‰ä¸€ä¸ªå¯ä»¥å’Œæ‰€æœ‰å¯èƒ½çš„Verifierçš„æ¨¡æ‹Ÿå™¨ï¼Œè¾“å‡ºè¯æ˜çš„ç»“æœï¼Œè€Œæ¨¡æ‹Ÿå™¨ç”šè‡³ä¸çŸ¥é“å®ƒè¦è¯æ˜çš„çŸ¥è¯†ã€‚\nThe standard Schnorr protocol does not have such a Simulator, for reasons weâ€™ll get into in a second. Instead, to make the proof work we need to make a special assumption. Specifically, the Verifier needs to be â€˜honestâ€™. That is, we need to make the special assumption that it will run its part of the protocol correctly â€” namely, that it will pick its challenge â€œcâ€Â using only its random number generator,Â and will not choose this value based on any input we provide it. As long as it does this, we can construct a Simulator.\næ ‡å‡†çš„Schnorråè®®æ˜¯æ²¡æœ‰è¿™æ ·çš„æ¨¡æ‹Ÿå™¨çš„ã€‚è¿™é‡Œè¦åšä¸€ä¸ªå‡è®¾ï¼ŒVerifieréœ€è¦æ˜¯â€œè¯šå®çš„â€ã€‚æˆ‘ä»¬éœ€è¦å‡è®¾åœ¨Verifieré€‰æ‹©æŒ‘æˆ˜â€œcâ€æ—¶ï¼Œåªç”¨åˆ°ä¸€ä¸ªéšæœºæ•°ç”Ÿæˆå™¨ï¼Œè€Œä¸ä¼šé€‰æ‹©é‚£äº›åŸºäºä»»ä½•æˆ‘ä»¬æä¾›çš„è¾“å…¥ç”Ÿæˆçš„å€¼ã€‚\nHereâ€™s how the Simulator works.\nLetâ€™s say we are trying to prove knowledge of a secret $a$ for some public key $g^a \\mod p$ â€” but we donâ€™t actually know the value*.* Our Simulator assumes that the Verifier will choose some value $c$ as its challenge, and moreover, it knows that the honest Verifier will choose the value $c$ only based on its random number generator â€” and not based on any inputs the Prover has provided.\nFirst, output some initialÂ $g^{k_1}$ as the Proverâ€™s first message*,*Â and find out what challenge $c$Â the Verifier chooses. Rewind the Verifier, and pick a random integerÂ $z$Â in the rangeÂ ${ 0, \\cdots, q-1 }$. ComputeÂ $g^{k_2} = g^z * g^{a(-c)}$Â **and outputÂ $g^{k_2}$Â as the Proverâ€™s new initial message. When the Verifier challenges onÂ $c$Â again, outputÂ $z$. Notice that the transcript $g^k,c,z$ will verify correctly as a perfectly valid, well-distributed proof of knowledge of the value $a$. The Verifier will accept this output as a valid proof of knowledge of $a$, even though the Simulator does not know $a$ in the first place!\nè¯¦ç»†çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š\nWhat this proves is thatÂ if we can rewind a Verifier, then (just as in the first post in this series) we can always trick the Verifier into believing we have knowledge of a value, even when we donâ€™t. And since the statistical distribution of our protocol is identical to the real protocol, this means that our protocol must be zero knowledge â€” against an honest Verifier.\nåœ¨æ¨¡æ‹Ÿå™¨ä¸–ç•Œé‡Œï¼Œæˆ‘ä»¬å¯ä»¥å›æº¯Verifierï¼Œè®©è¯šå®çš„Verifierç›¸ä¿¡æˆ‘ä»¬æ˜¯çŸ¥é“å¯†é’¥$a$çš„ï¼Œä½†å…¶å®æˆ‘ä»¬æ ¹æœ¬ä¸çŸ¥é“$a$æ—¶å¤šå°‘ã€‚ç”±äºåœ¨ç»Ÿè®¡åˆ†å¸ƒä¸Šæˆ‘ä»¬çš„åè®®å’ŒçœŸå®çš„åè®®æ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆå¯¹äºè¯šå®çš„Verifierï¼Œæˆ‘ä»¬çš„åè®®ä¸€å®šæ˜¯é›¶çŸ¥è¯†çš„ã€‚\nFrom interactive toÂ non-interactive So far weâ€™ve shown how to use the Schnorr protocol to interactively prove knowledge of a secret key $a$ that corresponds to a public key $g^a$. This is an incredibly useful protocol, but it only works if our Verifier is online and willing to interact with us.\nAn obvious question is whether we can make this protocol workÂ without interaction. Specifically, can I make a proof that I can send you without you even being online. Such a proof is called aÂ non-interactive zero knowledge proofÂ (NIZK).Â Turning Schnorr into a non-interactive proof seems initially quiteÂ difficult â€” since the protocol fundamentally relies on the Verifier picking a random challenge. Fortunately there is a clever trick we can use.\nThis techniqueÂ wasÂ developed by Fiat and Shamir in the 1980s. What they observed was thatÂ if you have a decent hash function lying around,Â you can convert an interactive protocol into a non-interactive one by simply using the hash function to pick the challenge.\næ€ä¹ˆå°†äº¤äº’å¼é›¶çŸ¥è¯†è¯æ˜è½¬æ¢æˆéäº¤äº’å¼é›¶çŸ¥è¯†è¯æ˜å‘¢ï¼Ÿè½¬æ¢çš„éš¾ç‚¹åœ¨äºVerifieréœ€è¦é€‰æ‹©ä¸€ä¸ªéšæœºçš„æŒ‘æˆ˜ï¼Œä¸€ä¸ªè§£å†³æ–¹æ³•æ˜¯ä½¿ç”¨å¯é çš„å“ˆå¸Œå‡½æ•°æ¥é€‰æ‹©è¿™ä¸ªæŒ‘æˆ˜ã€‚\nSpecifically, the revised protocol for proving knowledge of $a$ with respect to a public key $g^k$ looks like this:\nThe Prover picksÂ $g^k$ (just as in the interactiveÂ protocol). Now, the prover computesÂ the challenge as $c = H(g^k||M)$ whereÂ $H()$Â is a hash function, and $M$ is an (optional) and arbitary message string. ComputeÂ $ac+k \\mod q$Â (just as in the interactive protocol). The upshot here is that the hash function is picking the challenge $c$ without any interaction with the Verifier. In principle, if the hash function is â€œstrong enoughâ€ (meaning, itâ€™s a random oracle) then the result is a completely non-interactive proof of knowledge of the value $a$ that the Prover can send to the Verifier. The proof of this is relatively straightforward.\nThe particularly neat thing about this protocol is that it isnâ€™t just a proof of knowledge, itâ€™s also a signature scheme. That is, if you put a message into the (optional) value $M$, you obtain a signature on $M$, whichÂ can only be produced by someone who knows the secret key $a$. The resulting protocol is called the Schnorr signature scheme, and itâ€™s the basis of real-world protocols like EdDSA.\nè¿™ä¸ªåè®®ä¸ä»…ä»…æ˜¯çŸ¥è¯†çš„è¯æ˜ï¼Œä¹Ÿæ˜¯ä¸€ç§ç­¾åæ–¹æ¡ˆã€‚\nPhew. Yes, this has been a long post and thereâ€™s probably a lot more to be said. Hopefully there will be more time for that in a third post â€” which should only take me another three years.\nNotes:\nIn this definition, itâ€™s necessary that the statement be literally true. ","date":"2022-11-30T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-30-Zero-Knowledge-Proofs-An-illustrated-primer-Part2/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/30/Zero-Knowledge-Proofs-An-illustrated-primer-Part2/","title":"Zero Knowledge Proofs: An illustrated primer, PartÂ 2"},{"content":"æœ¬ç¯‡åšå®¢è®°å½•äº†å®‰æ¯”å®éªŒå®¤çŸ¥è¯†è¯æ˜ä»‹ç»ç³»åˆ—æ–‡ç« çš„ç¬”è®°ã€‚å‡ ç¯‡æ–‡ç« å¦‚ä¸‹ï¼š\nåˆè¯†ã€Œé›¶çŸ¥è¯†ã€ä¸ã€Œè¯æ˜ã€ ä»ã€Œæ¨¡æ‹Ÿã€ç†è§£é›¶çŸ¥è¯†è¯æ˜ï¼šå¹³è¡Œå®‡å®™ä¸æ—¶å…‰å€’æµ è¯»å¿ƒæœ¯ï¼šä»é›¶çŸ¥è¯†è¯æ˜ä¸­æå–ã€ŒçŸ¥è¯†ã€ äºšç‘Ÿç‹çš„ã€Œéšæœºã€æŒ‘æˆ˜ï¼šä»äº¤äº’åˆ°éäº¤äº’å¼é›¶çŸ¥è¯†è¯æ˜ åˆè¯†ã€Œé›¶çŸ¥è¯†ã€ä¸ã€Œè¯æ˜ã€ åŸæ–‡é“¾æ¥ï¼šåˆè¯†ã€Œé›¶çŸ¥è¯†ã€ä¸ã€Œè¯æ˜ã€ã€‚\næ–‡ç« å…ˆä»‹ç»äº†â€œè¯æ˜â€çš„å†å²ã€‚\nå¤å¸Œè…Šï¼šã€Œè¯æ˜ã€ == ã€Œæ´è§ã€ äºŒåä¸–çºªåˆï¼šã€Œè¯æ˜ã€ == ã€Œç¬¦å·æ¨ç†ã€ å…­åå¹´ä»£ï¼šã€Œè¯æ˜ã€ == ã€Œç¨‹åºã€ å…«åå¹´ä»£ï¼šã€Œè¯æ˜ã€ == ã€Œäº¤äº’ã€ï¼Œæ‹“å®½äº†ã€Œè¯æ˜ã€çš„æ¦‚å¿µã€‚é€šè¿‡æ„é€ ä¸¤ä¸ªå›¾çµæœºè¿›è¡Œã€Œäº¤äº’ã€è€Œä¸æ˜¯ã€Œæ¨ç†ã€ï¼Œæ¥è¯æ˜ä¸€ä¸ªå‘½é¢˜åœ¨æ¦‚ç‡ä¸Šæ˜¯å¦æˆç«‹ã€‚ é›¶çŸ¥è¯†è¯æ˜æœ‰ä»€ä¹ˆç”¨å¤„ï¼Ÿ\né›¶çŸ¥è¯†è¯æ˜æŠ€æœ¯å¯ä»¥è§£å†³æ•°æ®çš„ä¿¡ä»»é—®é¢˜ï¼Œè®¡ç®—çš„ä¿¡ä»»é—®é¢˜ï¼\né›¶çŸ¥è¯†è¯æ˜æŠ€æœ¯å¯ä»¥ã€Œæ¨¡æ‹Ÿã€å‡ºä¸€ä¸ªç¬¬ä¸‰æ–¹ï¼Œæ¥ä¿è¯æŸä¸€ä¸ªè®ºæ–­æ˜¯å¯ä¿¡çš„ã€‚\næ¢å¥è¯è¯´ï¼Œå½“æˆ‘ä»¬æ”¶åˆ°ä¸€ä¸ªåŠ äº†å¯†çš„æ•°æ®ï¼Œ ç„¶åè¿˜æœ‰ä¸€ä¸ªé›¶çŸ¥è¯†è¯æ˜ã€‚è¿™ä¸ªé›¶çŸ¥è¯†è¯æ˜æ˜¯è¯´ ã€Œå…³äºæ•°æ®çš„ X æ–­è¨€æˆç«‹ã€ï¼Œé‚£ä¹ˆè¿™ç­‰ä»·äºæœ‰ä¸€ä¸ªå¤©ä½¿åœ¨æˆ‘ä»¬è€³è¾¹æ‚„å£°è¯´ï¼Œã€Œå…³äºæ•°æ®çš„X æ–­è¨€æˆç«‹ã€ï¼\nå¯¹äºè¿™ä¸ªÂ X æ–­è¨€ï¼Œå¯ä»¥éå¸¸çµæ´»ï¼Œå®ƒå¯ä»¥æ˜¯ä¸€ä¸ªÂ NPå¤æ‚åº¦çš„ç®—æ³•ã€‚å¤§ç™½è¯è®²åªè¦æˆ‘ä»¬èƒ½å†™ä¸€æ®µç¨‹åºï¼ˆä¸€ä¸ªå¤šé¡¹å¼æ—¶é—´çš„ç®—æ³•ï¼‰æ¥åˆ¤æ–­ä¸€ä¸ªæ•°æ®æ˜¯å¦æ»¡è¶³Â X æ–­è¨€ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–­è¨€å°±å¯ä»¥ç”¨é›¶çŸ¥è¯†è¯æ˜çš„æ–¹å¼æ¥è¡¨è¾¾ã€‚é€šä¿—ç‚¹è®²ï¼Œåªè¦æ•°æ®åˆ¤å®šæ˜¯å®¢è§‚çš„ï¼Œé‚£ä¹ˆé›¶çŸ¥è¯†è¯æ˜å°±é€‚ç”¨ã€‚\né›¶çŸ¥è¯†è¯æ˜çš„ç”¨å¤„ï¼š\næ•°æ®çš„éšç§ä¿æŠ¤ è®¡ç®—å‹ç¼©ä¸åŒºå—é“¾æ‰©å®¹ ç«¯åˆ°ç«¯çš„é€šè®¯åŠ å¯† èº«ä»½è®¤è¯ å»ä¸­å¿ƒåŒ–å­˜å‚¨ ä¿¡ç”¨è®°å½• æ„é€ å®Œå…¨å…¬å¹³çš„ç°å®æ•°å­—åŒ–å•†å“çš„äº¤æ˜“åè®® çŸ¥è¯†å’Œä¿¡æ¯çš„åŒºåˆ«ï¼š\nã€ŒçŸ¥è¯†ã€æ˜¯ä¸ã€Œè®¡ç®—éš¾åº¦ã€ç›¸å…³ï¼Œè€Œã€Œä¿¡æ¯ã€åˆ™ä¸æ˜¯ ã€ŒçŸ¥è¯†ã€æ˜¯ä¸å…¬å…±æ‰€çŸ¥çš„ä¸œè¥¿æœ‰å…³ï¼Œè€Œã€Œä¿¡æ¯ã€ä¸»è¦ä¸éƒ¨åˆ†å…¬å¼€çš„ä¸œè¥¿æœ‰å…³ å¯éªŒè¯è®¡ç®—ä¸ç”µè·¯å¯æ»¡è¶³æ€§é—®é¢˜ï¼š\nå¦å¤–ç”µè·¯å¯æ»¡è¶³é—®é¢˜å’Œåœ°å›¾ä¸‰æŸ“è‰²é—®é¢˜ä¸€æ ·ï¼Œæ˜¯NP-Completeé—®é¢˜ã€‚NP-Complete æ˜¯ä¸€ç±»é—®é¢˜ï¼Œä»–çš„æ±‚è§£è¿‡ç¨‹æ˜¯å¤šé¡¹å¼æ—¶é—´å†…éš¾ä»¥å®Œæˆçš„ï¼Œå³ã€Œæ±‚è§£å›°éš¾ã€ï¼Œä½†æ˜¯éªŒè¯è§£çš„è¿‡ç¨‹æ˜¯å¤šé¡¹å¼æ—¶é—´å¯ä»¥å®Œæˆçš„ï¼Œå³ã€ŒéªŒè¯ç®€å•ã€ã€‚\næ‰€è°“çš„ç”µè·¯å¯æ»¡è¶³æ€§å°±æ˜¯æŒ‡ï¼Œå­˜åœ¨æ»¡è¶³ç”µè·¯çš„ä¸€ä¸ªè§£ã€‚å¦‚æœè¿™ä¸ªè§£çš„è¾“å‡ºå€¼ç­‰äºä¸€ä¸ªç¡®å®šå€¼ï¼Œé‚£ä¹ˆè¿™ä¸ªè§£å°±èƒ½ã€Œè¡¨ç¤ºã€ç”µè·¯çš„è®¡ç®—è¿‡ç¨‹ã€‚\nã€Œé›¶çŸ¥è¯†çš„ç”µè·¯å¯æ»¡è¶³æ€§è¯æ˜åè®®ã€æä¾›äº†ä¸€ç§æœ€ç›´æ¥çš„ä¿æŠ¤éšç§/æ•æ„Ÿæ•°æ®çš„æŠ€æœ¯\nä»ã€Œæ¨¡æ‹Ÿã€ç†è§£é›¶çŸ¥è¯†è¯æ˜ï¼šå¹³è¡Œå®‡å®™ä¸æ—¶å…‰å€’æµ åŸæ–‡é“¾æ¥ï¼šä»ã€Œæ¨¡æ‹Ÿã€ç†è§£é›¶çŸ¥è¯†è¯æ˜ï¼šå¹³è¡Œå®‡å®™ä¸æ—¶å…‰å€’æµã€‚\nå®‰å…¨çš„å®šä¹‰ä¸ä¸å¯åŒºåˆ†æ€§\nè¿™ä¸€éƒ¨åˆ†æ˜¯å¯†ç å­¦ä¸­çš„çŸ¥è¯†ã€‚\nä¸€åˆ‡å®‰å…¨éƒ½æœ‰å‰æçš„ã€‚åªæœ‰ç»è¿‡æ•°å­¦è¯æ˜ä¹‹åï¼Œå¤§å®¶æ‰èƒ½å¤Ÿç¡®ä¿¡è¿™ä¸ª ç®—æ³•/æ–¹æ¡ˆ çš„å®‰å…¨æ€§åŸºäºä¸€äº›éå¸¸æ˜ç¡®çš„ã€Œå®‰å…¨å‡è®¾ã€ã€‚\nå®Œç¾å®‰å…¨ï¼šå‡è®¾ä½ æ˜¯ä¸€ä¸ªæ”»å‡»è€…ï¼Œä½ é€šè¿‡å¯†æ–‡è·å–ä¸åˆ°ä»»ä½•æœ‰ä»·å€¼çš„ä¿¡æ¯ï¼Œç ´è§£çš„å”¯ä¸€æ‰‹æ®µå°±æ˜¯é çè’™ã€‚\nğŸ“ åœ¨Dan Boneh and Victor Shoup çš„ ã€ŠA Graduate Course in Applied Cryptographyã€‹ä¹¦ä¸­å®šä¹‰ä¸ºï¼š\né€šè¿‡å¯†æ–‡è·å–ä¸åˆ°ä¿¡æ¯ï¼Œè¿™å°±æ„å‘³ç€ä½ æ²¡æœ‰è·å¾—ä»»ä½•é¢å¤–çš„è®¡ç®—èƒ½åŠ›ï¼Œèƒ½å¤Ÿå¸®åŠ©è®©ä½ ä»¥æ›´çŸ­çš„æ—¶é—´æ¥è®¡ç®—å‡ºæ˜æ–‡ã€‚\nè¯­ä¹‰å®‰å…¨ï¼šå‡è®¾ä½ æ˜¯ä¸€ä¸ªæ”»å‡»è€…ï¼Œä½ é€šè¿‡å¯†æ–‡åœ¨å¤šé¡¹å¼æ—¶é—´å†…è®¡ç®—ä¸å‡ºæ¥ä»»ä½•æœ‰ä»·å€¼çš„ä¿¡æ¯ã€‚\nğŸ“’ä¹¦ä¸­å®šä¹‰ä¸ºï¼š ä¸å¯åŒºåˆ†çš„æ¦‚å¿µï¼š æˆ‘ä»¬åˆå¼•å…¥ä¸€ä¸ªæ¦‚å¿µâ€”â€”ã€Œä¸å¯åŒºåˆ†æ€§ã€ï¼Œæ¥é‡æ–°è¡¨è¿°åŠ å¯†ç®—æ³•çš„å®‰å…¨æ€§ï¼šå‡è®¾ä½ æ˜¯ä¸€ä¸ªæ”»å‡»è€…ï¼Œè€Œæˆ‘æœ‰ä¸€ä¸ªåŠ å¯†ç®—æ³•ï¼š\nä½ éšæœºäº§ç”Ÿä¸¤æ®µç­‰é•¿çš„æ˜æ–‡ï¼Œm1=ã€Œç™½æ—¥ä¾å±±å°½ï¼Œé»„æ²³å…¥æµ·æµã€ï¼Œm2=ã€Œçƒ«çƒ«çƒ«çƒ«çƒ«ï¼Œçƒ«çƒ«çƒ«çƒ«çƒ«ã€ ä½ æŠŠè¿™ä¸¤æ®µæ˜æ–‡ï¼Œm1Â ä¸Â m2Â äº¤ç»™æˆ‘ æˆ‘éšæœºæŒ‘é€‰ä¸€ä¸ªæ˜æ–‡ï¼Œä¸å‘Šè¯‰ä½ æ˜¯å“ªä¸€ä¸ªï¼Œç„¶åè¿›è¡ŒåŠ å¯†ï¼Œäº§ç”Ÿä¸€ä¸ªå¯†æ–‡Â c æˆ‘æŠŠå¯†æ–‡Â cÂ å‡ºç¤ºç»™ä½ çœ‹ï¼Œè®©ä½ çŒœè¿™ä¸ªcÂ ç©¶ç«Ÿæ˜¯ç”±å”è¯—åŠ å¯†äº§ç”Ÿï¼Œè¿˜æ˜¯ä¹±ç åŠ å¯†äº§ç”Ÿ å¦‚æœä½ ç”¨ä¸€å°è®¡ç®—æœºæ¥ç ´è§£cï¼Œåœ¨å¤šé¡¹å¼æ—¶é—´å†…ç ´è§£ä¸å‡ºæ¥ï¼Œä¹Ÿå°±æ˜¯è¯´ä½ æ²¡åŠæ³•åŒºåˆ†cçš„æ¥æºï¼Œé‚£ä¹ˆå°±è¯´æ˜åŠ å¯†ç®—æ³•æ˜¯è¯­ä¹‰å®‰å…¨çš„ åŒºåˆ†ä¸¤ä¸ªä¸–ç•Œ\nè¯æ˜çš„é›¶çŸ¥è¯†è¿‡ç¨‹ï¼Œç­‰ä»·äºæ„é€ ï¼ˆå¯»æ‰¾ï¼‰ä¸€ä¸ªã€Œæ¨¡æ‹Ÿã€ç®—æ³•ï¼Œè¿™ä¸ªç®—æ³•èƒ½å¤Ÿè®©æ¨¡æ‹Ÿå™¨æ¥æ¨¡æ‹Ÿå‡ºä¸€ä¸ªã€Œæ²¡æœ‰çŸ¥è¯†ã€çš„ç†æƒ³ä¸–ç•Œã€‚å¦‚æœè¿™ä¸ªç®—æ³•å­˜åœ¨ï¼Œè€Œä¸”ä¸¤ä¸ªä¸–ç•Œä¸å¯åŒºåˆ†ï¼Œé‚£ä¹ˆå°±è¯æ˜å®Œæ¯•ã€‚\næ‰€è°“çš„ä¸å¯åŒºåˆ†æ€§é’ˆå¯¹çš„æ˜¯ç†æƒ³ä¸–ç•Œä¸­çš„ä¸ªä½“è®¤çŸ¥è€Œè¨€ã€‚è€Œã€Œå¯åŒºåˆ†æ€§ã€æ˜¯å¯¹ä½äºä¸–ç•Œå¤–éƒ¨çš„ç¥è€Œè¨€ã€‚\né¦–å…ˆã€Œé›¶çŸ¥è¯†ã€æ˜¯ä¸ºäº†ä¿æŠ¤ Alice çš„åˆ©ç›Šï¼Œå› ä¸º Alice ä¸æƒ³åœ¨äº¤äº’è¿‡ç¨‹ä¸­é€éœ²æ›´å¤šçš„ä¿¡æ¯ç»™ Bobï¼Œä¸æƒ³è®© Bob çŸ¥é“å¥¹æ‰€æ‹¥æœ‰çš„ç§˜å¯†Â wï¼Œç”šè‡³ä¸æƒ³è®© Bob ä»äº¤äº’çš„è¿‡ç¨‹ä¸­åˆ†æå‡ºå“ªæ€•ä¸€ä¸ç‚¹çš„ä¿¡æ¯ã€‚é‚£ä¹ˆæ€ä¹ˆä¿è¯è¿™ä¸€ç‚¹å‘¢ï¼Ÿã€Œæ¨¡æ‹Ÿå™¨ã€è¿™æ—¶å€™ç™»åœºäº†ï¼Œå®ƒèƒ½æ¨¡æ‹Ÿå‡ºä¸€ä¸ªå’Œç°å®ä¸–ç•Œå¤–è¡¨ä¸€æ¨¡ä¸€æ ·çš„ã€Œç†æƒ³ä¸–ç•Œã€ï¼Œç„¶åã€Œæ¨¡æ‹Ÿå™¨ã€åœ¨è¿™ä¸ªä¸–ç•Œä¸­å¯ä»¥è½»æ¾åœ°éª—è¿‡ä»»ä½•ä¸€ä¸ªå¯¹æ‰‹ï¼Œè®©å¯¹æ–¹æ— æ³•åˆ†è¾¨è‡ªå·±æ˜¯åœ¨ç°å®ä¸–ç•Œä¸­ï¼Œè¿˜æ˜¯ç†æƒ³ä¸–ç•Œä¸­ã€‚å› ä¸ºã€Œæ¨¡æ‹Ÿå™¨ã€æ‰‹é‡Œæ²¡æœ‰é‚£ä¸ªç§˜å¯†Â wï¼Œã€Œç†æƒ³ä¸–ç•Œã€æ˜¯é›¶çŸ¥è¯†çš„ã€‚åˆå› ä¸ºä¸¤ä¸ªä¸–ç•Œçš„ä¸å¯åŒºåˆ†æ€§ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾—å‡ºç»“è®ºï¼šAlice çš„äº¤äº’åè®®æ˜¯ã€Œé›¶çŸ¥è¯†ã€çš„ã€‚\nåœ°å›¾ä¸‰æŸ“è‰²é—®é¢˜çš„é›¶çŸ¥è¯†è¯æ˜\næ–‡ç« ä¸­ç”¨å›¾ç‰‡å½¢è±¡çš„è¯´æ˜äº†é›¶çŸ¥è¯†è¯æ˜çš„è¿‡ç¨‹ã€‚ä¸è¿‡è¿™æ˜¯é’ˆå¯¹è¯šå®çš„Bobï¼Œå¦‚æœæ˜¯ä¸è¯šå®çš„Bobå‘¢ï¼Ÿå¦‚æœåœ¨æ¨¡æ‹Ÿå™¨ç¬¬ä¸€æ¬¡å®æ–½æ—¶é—´å€’æµä¹‹åï¼ŒBobåˆé€‰æ‹©äº†ä¸åŒçš„è¾¹ï¼Œé‚£ä¹ˆæ¨¡æ‹Ÿå™¨å¯ä»¥æŠŠé¢œè‰²æ‰“ä¹±ä¹‹åï¼Œå†æ¬¡è¿è¡Œæ—¶é—´å€’æµï¼Œåœ¨å¤šæ¬¡æ—¶é—´å€’æµä¹‹åï¼ŒBob æå¤§çš„æ¦‚ç‡æ€»ä¼šä¸€æ¬¡é€‰æ‹©æ¨¡æ‹Ÿå™¨è¿›è¡ŒæŸ“è‰²çš„é‚£æ¡è¾¹ï¼Œç„¶åè¿™æ—¶å€™æ¨¡æ‹Ÿå™¨æ‰èµ°åˆ°ç¬¬ä¸‰æ­¥ï¼Œæ‰“å¼€çº¸ç‰‡ã€‚\né˜¿é‡Œå·´å·´ã€æ´ç©´ä¸èŠéº»å¼€é—¨\næ–‡ç« ä¸­å†æ¬¡é˜è¿°äº†é˜¿é‡Œå·´å·´ä¸å¤§ç›—çš„æ•…äº‹ï¼Œè¿™ä¸ªæ•…äº‹æ¥æºäºè®ºæ–‡How to explain zero-knowledge protocols to your childrenï¼Œæˆ‘çš„è®ºæ–‡çš„ç¬”è®°è§è¿™é‡Œã€‚The Jealous Reporterç”¨çš„å‰ªè¾‘æ‰‹æ®µå°±æ˜¯æ¨¡æ‹Ÿå™¨ä¸­çš„è¶…èƒ½åŠ›ï¼Œç”±äºä¸¤å®¶ç”µè§†å°æ”¾å‡ºçš„å½±ç‰‡äººä»¬æ— æ³•åŒºåˆ†ï¼Œè€Œå‡çš„é‚£ä¸ªæ ¹æœ¬ä¸çŸ¥é“æ´ç©´çš„ç§˜å¯†ï¼Œè¿™ä¹Ÿå°±è¯æ˜äº†è¿™ä¸ªè¿‡ç¨‹æ˜¯é›¶çŸ¥è¯†çš„ã€‚\næ¨¡æ‹Ÿå™¨ä¸å›¾çµæœº\næ¨¡æ‹Ÿå™¨ä¸èƒ½éšä¾¿å¼€æŒ‚ã€‚æ¨¡æ‹Ÿå™¨å…¶å®åªæ˜¯ä¸€ä¸ªå›¾çµæœºï¼Œè€Œå‰é¢æåˆ°çš„æ—¶é—´å€’æµæ˜¯å›¾çµæœºå¯ä»¥å®ç°çš„åŠŸèƒ½ã€‚\næ–‡ç« ä¸­ä¸‹é¢è¿™æ®µè¯å¾ˆé‡è¦ğŸ‘‡\nè¯æ˜é›¶çŸ¥è¯†çš„è¿‡ç¨‹ï¼Œå°±æ˜¯è¦å¯»æ‰¾ä¸€ä¸ªç®—æ³•ï¼Œæˆ–è€…æ›´é€šä¿—ç‚¹è¯´ï¼Œå†™å‡ºä¸€æ®µä»£ç ï¼Œå®ƒè¿è¡Œåœ¨å¤–éƒ¨è®¡ç®—æœºç³»ç»Ÿä¸­ï¼Œä½†æ˜¯å®ç°äº†è™šæ‹Ÿæœºçš„åŠŸèƒ½ã€‚è€Œä¸”åœ¨è™šæ‹Ÿæœºä¸­ï¼Œéœ€è¦æœ‰ä¸€ä¸ªä¸å¸¦æœ‰ã€ŒçŸ¥è¯†ã€ä½œä¸ºè¾“å…¥çš„ Zliceï¼Œå¯ä»¥éª—è¿‡æ”¾å…¥è™šæ‹Ÿæœºè¿è¡Œçš„ Bobã€‚\nè¯»å¿ƒæœ¯ï¼šä»é›¶çŸ¥è¯†è¯æ˜ä¸­æå–ã€ŒçŸ¥è¯†ã€ è¿™ç¯‡æ–‡ç« å®é™…æ˜¯åœ¨è¯´æ˜é›¶çŸ¥è¯†è¯æ˜ä¸­çš„å¯é æ€§ã€‚\nã€Œé›¶çŸ¥è¯†ã€vs. ã€Œå¯é æ€§ã€ ã€Œé›¶çŸ¥è¯†è¯æ˜ã€å¹¶ä¸æ˜¯é€šè¿‡ç»™å‡ºä¸€ä¸ªä¸å…è®¸å‘ç”Ÿçš„äº‹ä»¶åˆ—è¡¨æ¥å®šä¹‰ï¼Œè€Œæ˜¯ç›´æ¥ç»™å‡ºäº†ä¸€ä¸ªæœ€æè‡´çš„ã€Œæ¨¡æ‹Ÿæ¡ä»¶ã€ã€‚\næ‰€è°“ã€Œæ¨¡æ‹Ÿæ¡ä»¶ã€æ˜¯æŒ‡ï¼Œé€šè¿‡ã€Œæ¨¡æ‹Ÿã€æ–¹æ³•æ¥å®ç°ä¸€ä¸ªã€Œç†æƒ³ä¸–ç•Œã€ï¼Œä½¿ä¹‹ä¸ã€Œç°å®ä¸–ç•Œã€ä¸å¯åŒºåˆ†ï¼›è€Œç”±äºåœ¨ç†æƒ³ä¸–ç•Œä¸­ä¸å­˜åœ¨çŸ¥è¯†ï¼Œæ‰€ä»¥å¯ä»¥æ¨å¯¼å‡ºç»“è®ºï¼šç°å®ä¸–ç•Œæ»¡è¶³ã€Œé›¶çŸ¥è¯†ã€ã€‚\næˆ‘ä»¬ç»§ç»­åˆ†æä¸‹ä¸€ä¸ªäº¤äº’ç³»ç»Ÿï¼ˆå®‰å…¨åè®®ï¼‰çš„ä¸‰ä¸ªæ€§è´¨ï¼šã€Œå®Œå¤‡æ€§ã€ã€ã€Œå¯é æ€§ã€ä¸ã€Œé›¶çŸ¥è¯†ã€ã€‚\nå¯é æ€§ï¼ˆSoundnessï¼‰ï¼šAlice åœ¨æ²¡æœ‰çŸ¥è¯†çš„æƒ…å†µä¸‹ä¸èƒ½é€šè¿‡ Bob çš„éªŒè¯ã€‚\nå®Œå¤‡æ€§ï¼ˆCompletenessï¼‰ï¼šAlice åœ¨æœ‰çŸ¥è¯†çš„æƒ…å†µä¸‹å¯ä»¥é€šè¿‡ Bob çš„éªŒè¯ã€‚\né›¶çŸ¥è¯†ï¼ˆZero-knowledgeï¼‰ï¼šAlice åœ¨äº¤äº’çš„è¿‡ç¨‹ä¸­ä¸ä¼šæ³„éœ²å…³äºçŸ¥è¯†çš„ä»»ä½•ä¿¡æ¯ã€‚\næˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥ã€Œå¯é æ€§ã€å’Œã€Œå®Œå¤‡æ€§ã€æœ‰ä¸€ç§ã€Œå¯¹ç§°æ€§ã€ã€‚å¯é æ€§ä¿è¯äº†æ¶æ„çš„ Alice ä¸€å®šå¤±è´¥ï¼Œè€Œå®Œå¤‡æ€§ä¿è¯äº†è¯šå®çš„ Alice ä¸€å®šæˆåŠŸã€‚\nç®€æ´çš„Schnorråè®®\nğŸ“ è¿™ä¸€å°èŠ‚çš„å†…å®¹è¡¥å……äº†å…³äºç¾¤çš„çŸ¥è¯†ã€‚\nAlice æ‹¥æœ‰ä¸€ä¸ªç§˜å¯†æ•°å­—ï¼Œaï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ªæ•°å­—æƒ³è±¡æˆã€Œç§é’¥ã€ï¼Œç„¶åæŠŠå®ƒã€Œæ˜ å°„ã€åˆ°æ¤­åœ†æ›²çº¿ç¾¤ä¸Šçš„ä¸€ä¸ªç‚¹Â a*Gï¼Œç®€å†™ä¸ºÂ aGã€‚è¿™ä¸ªç‚¹æˆ‘ä»¬æŠŠå®ƒå½“åšã€Œå…¬é’¥ã€ã€‚\nsk = a PK = aG è¯·æ³¨æ„ã€Œæ˜ å°„ã€è¿™ä¸ªè¯ï¼Œæˆ‘ä»¬è¿™é‡Œå…ˆç®€è¦ä»‹ç»ã€ŒåŒæ€ã€è¿™ä¸ªæ¦‚å¿µã€‚æ¤­åœ†æ›²çº¿ç¾¤æœ‰é™åŸŸä¹‹é—´å­˜åœ¨ç€ä¸€ç§åŒæ€æ˜ å°„å…³ç³»ã€‚æœ‰é™åŸŸï¼Œæˆ‘ä»¬ç”¨Â Zqè¿™ä¸ªç¬¦å·è¡¨ç¤ºï¼Œå…¶ä¸­ç´ æ•°Â qæ˜¯æŒ‡æœ‰é™åŸŸçš„å¤§å°ï¼Œå®ƒæ˜¯æŒ‡ä»Â 0, 1, 2, â€¦, q-1Â è¿™æ ·ä¸€ä¸ªæ•´æ•°é›†åˆã€‚è€Œåœ¨ä¸€æ¡æ¤­åœ†æ›²çº¿ä¸Šï¼Œæˆ‘ä»¬é€šè¿‡ä¸€ä¸ªåŸºç‚¹ï¼ŒGï¼Œå¯ä»¥äº§ç”Ÿä¸€ä¸ªã€Œå¾ªç¯ç¾¤ã€ï¼Œæ ‡è®°ä¸ºÂ 0G, G, 2G, â€¦, (q-1)Gï¼Œæ­£å¥½æ˜¯æ•°é‡ä¸ºÂ qä¸ª æ›²çº¿ç‚¹çš„é›†åˆã€‚ä»»æ„ä¸¤ä¸ªæ›²çº¿ç‚¹æ­£å¥½å¯ä»¥è¿›è¡Œä¸€ç§ã€Œç‰¹æ®Šçš„äºŒå…ƒè¿ç®—ã€ï¼ŒG + G = 2Gï¼Œ2G + 3G = 5Gï¼Œçœ‹èµ·æ¥è¿™ä¸ªäºŒå…ƒè¿ç®—å¥½åƒå’Œã€ŒåŠ æ³•ã€ç±»ä¼¼ï¼Œæ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ã€‚äºæ˜¯æˆ‘ä»¬å°±ç”¨Â +è¿™ä¸ªç¬¦å·æ¥è¡¨ç¤ºã€‚ä¹‹æ‰€ä»¥æŠŠè¿™ä¸ªç¾¤ç§°ä¸ºå¾ªç¯ç¾¤ï¼Œå› ä¸ºæŠŠç¾¤çš„æœ€åä¸€ä¸ªå…ƒç´ Â (q-1)Gï¼Œå†åŠ ä¸Šä¸€ä¸ªÂ Gå°±å›å·åˆ°ç¾¤çš„ç¬¬ä¸€ä¸ªå…ƒç´ Â 0Gã€‚\nç»™ä»»æ„ä¸€ä¸ªæœ‰é™åŸŸä¸Šçš„æ•´æ•°Â rï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨å¾ªç¯ç¾¤ä¸­æ‰¾åˆ°ä¸€ä¸ªå¯¹åº”çš„ç‚¹Â rGï¼Œæˆ–è€…ç”¨ä¸€ä¸ªæ ‡é‡ä¹˜æ³•æ¥è¡¨ç¤ºÂ r*Gã€‚ä½†æ˜¯åè¿‡æ¥è®¡ç®—æ˜¯å¾ˆã€Œå›°éš¾ã€çš„ï¼Œè¿™æ˜¯ä¸€ä¸ªã€Œå¯†ç å­¦éš¾é¢˜ã€â€”â€” è¢«ç§°ä¸ºç¦»æ•£å¯¹æ•°éš¾é¢˜[2]ã€‚\nä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä»»æ„ç»™ä¸€ä¸ªæ¤­åœ†æ›²çº¿å¾ªç¯ç¾¤ä¸Šçš„ç‚¹Â Rï¼Œé‚£ä¹ˆåˆ°åº•æ˜¯æœ‰é™åŸŸä¸­çš„å“ªä¸€ä¸ªæ•´æ•°å¯¹åº”Â Rï¼Œè¿™ä¸ªè®¡ç®—æ˜¯å¾ˆéš¾çš„ï¼Œå¦‚æœæœ‰é™åŸŸè¶³å¤Ÿå¤§ï¼Œæ¯”å¦‚è¯´ 256bit è¿™ä¹ˆå¤§ï¼Œæˆ‘ä»¬å§‘ä¸”å¯ä»¥è®¤ä¸ºè¿™ä¸ªåå‘è®¡ç®—æ˜¯ä¸å¯èƒ½åšåˆ°çš„ã€‚\nSchnorr åè®®å……åˆ†åˆ©ç”¨äº†æœ‰é™åŸŸå’Œå¾ªç¯ç¾¤ä¹‹é—´å•å‘æ˜ å°„ï¼Œå®ç°äº†æœ€ç®€å•çš„é›¶çŸ¥è¯†è¯æ˜å®‰å…¨åè®®ï¼šAlice å‘ Bob è¯æ˜å¥¹æ‹¥æœ‰Â PKÂ å¯¹åº”çš„ç§é’¥Â skã€‚\nzÂ çš„è®¡ç®—å’ŒéªŒè¯è¿‡ç¨‹å¾ˆæœ‰è¶£ï¼Œæœ‰å‡ ä¸ªå…³é”®æŠ€å·§ï¼š\né¦–å…ˆ Bob å¿…é¡»ç»™å‡ºä¸€ä¸ªã€Œéšæœºã€æŒ‘æˆ˜æ•°ï¼Œç„¶å Bob åœ¨æ¤­åœ†æ›²çº¿ä¸ŠåŒæ€åœ°æ£€æŸ¥Â zÂ ã€‚å¦‚æœæˆ‘ä»¬æŠŠæŒ‘æˆ˜æ•°Â cÂ çœ‹æˆæ˜¯ä¸€ä¸ªæœªçŸ¥æ•°ï¼Œé‚£ä¹ˆÂ r+a*c=zÂ å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªä¸€å…ƒä¸€æ¬¡æ–¹ç¨‹ï¼Œå…¶ä¸­Â rÂ ä¸Â aÂ æ˜¯æ–¹ç¨‹ç³»æ•°ã€‚è¯·æ³¨æ„åœ¨Â cÂ æœªçŸ¥çš„å‰æä¸‹ï¼Œå¦‚æœÂ r + a*x = r' + a'*xÂ è¦æˆç«‹ï¼Œé‚£ä¹ˆæ ¹æ® Schwatz-Zippel å®šç†[3]ï¼Œæå¤§æ¦‚ç‡ä¸ŠÂ r=r'ï¼Œa=a'Â éƒ½æˆç«‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ Alice åœ¨Â cÂ æœªçŸ¥çš„å‰æä¸‹ï¼Œæƒ³æ‰¾åˆ°å¦ä¸€å¯¹ä¸åŒçš„Â r',a'Â æ¥è®¡ç®—Â zÂ éª—è¿‡ Bob æ˜¯å‡ ä¹ä¸å¯èƒ½çš„ã€‚è¿™ä¸ªéšæœºæŒ‘æˆ˜æ•°Â cÂ å®ç°äº†rÂ å’ŒÂ aÂ çš„é™åˆ¶ã€‚è™½ç„¶ Bob éšæœºé€‰äº†ä¸€ä¸ªæ•°ï¼Œä½†æ˜¯ç”±äº Alice äº‹å…ˆä¸çŸ¥é“ï¼Œæ‰€ä»¥ Alice ä¸å¾—ä¸ä½¿ç”¨ç§é’¥Â aÂ æ¥è®¡ç®—Â zã€‚è¿™é‡Œçš„å…³é”®ï¼šÂ cÂ å¿…é¡»æ˜¯ä¸ªéšæœºæ•°ã€‚ Bob éªŒè¯æ˜¯åœ¨æ¤­åœ†æ›²çº¿ç¾¤ä¸Šå®Œæˆã€‚Bob ä¸çŸ¥é“rï¼Œä½†æ˜¯ä»–çŸ¥é“Â rÂ æ˜ å°„åˆ°æ›²çº¿ä¸Šçš„ç‚¹Rï¼›Bob ä¹Ÿä¸çŸ¥é“Â aï¼Œä½†æ˜¯ä»–çŸ¥é“Â aÂ æ˜ å°„åˆ°æ›²çº¿ç¾¤ä¸Šçš„ç‚¹Â PKï¼Œå³Â a*Gã€‚é€šè¿‡åŒæ€æ˜ å°„ä¸Schwatz-Zippel å®šç†ï¼ŒBob å¯ä»¥æ ¡éªŒÂ zÂ çš„è®¡ç®—è¿‡ç¨‹æ˜¯å¦æ­£ç¡®ï¼Œä»è€ŒçŸ¥é“ Alice ç¡®å®æ˜¯é€šè¿‡Â rÂ å’ŒÂ aÂ è®¡ç®—å¾—å‡ºçš„Â zï¼Œä½†æ˜¯åˆä¸æš´éœ²Â rÂ ä¸Â aÂ çš„å€¼ã€‚ è¿˜æœ‰ï¼Œåœ¨åè®®ç¬¬ä¸€æ­¥ä¸­äº§ç”Ÿçš„éšæœºæ•°Â rÂ ä¿è¯äº†Â aÂ çš„ä¿å¯†æ€§ã€‚å› ä¸ºä»»ä½•ä¸€ä¸ªç§˜å¯†å½“å’Œä¸€ä¸ªç¬¦åˆã€Œä¸€è‡´æ€§åˆ†å¸ƒã€çš„éšæœºæ•°ç›¸åŠ ä¹‹åçš„å’Œä»ç„¶ç¬¦åˆã€Œä¸€è‡´æ€§åˆ†å¸ƒã€ã€‚ ğŸ“ cå¿…é¡»æ˜¯éšæœºæ•°ã€‚\nå†é‡æ¨¡æ‹Ÿå™¨\nå…¶å®ï¼Œã€Œå¯é æ€§ã€å’Œã€Œé›¶çŸ¥è¯†ã€è¿™ä¸¤ä¸ªæ€§è´¨åœ¨å¦ä¸€ä¸ªç»´åº¦ä¸Šä¹Ÿæ˜¯å­˜åœ¨ç€ä¸€ç§å¯¹ç§°æ€§ã€‚**å¯é æ€§ä¿è¯äº†æ¶æ„çš„ Alice ä¸€å®šå¤±è´¥ï¼Œé›¶çŸ¥è¯†ä¿è¯äº†æ¶æ„çš„ Bob ä¸€å®šä¸ä¼šæˆåŠŸã€‚**æœ‰è¶£åœ°æ˜¯ï¼Œè¿™ç§å¯¹ç§°æ€§å°†ä½“ç°åœ¨æ¨¡æ‹Ÿå‡ºæ¥çš„ã€Œç†æƒ³ä¸–ç•Œã€ä¸­ã€‚\n","date":"2022-11-30T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-30-sec-bit-zkp-summary/toni-osmundson-ZQtk_VAvO7Y-unsplash.jpeg","permalink":"https://wenjin1997.github.io/2022/11/30/sec-bit-zkp-summary/","title":"å®‰æ¯”å®éªŒå®¤é›¶çŸ¥è¯†è¯æ˜ä»‹ç»ç³»åˆ—æ–‡ç« "},{"content":"è®ºæ–‡è§Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzlesã€‚æœ¬ç¯‡è®ºæ–‡è¯¦ç»†çš„ä»‹ç»äº†å…³äºæ•°ç‹¬é—®é¢˜çš„å¯†ç å­¦å’Œç‰©ç†ä¸Šçš„é›¶çŸ¥è¯†è¯æ˜åè®®ã€‚å¯ä»¥äº†è§£åˆ°é›¶çŸ¥è¯†è¯æ˜åè®®çš„å®Œæ•´è¿‡ç¨‹ï¼Œä¸€èˆ¬æ­¥éª¤æœ‰å“ªäº›ã€‚\n1 Introduction å¦‚ä½•åœ¨ä¸é€éœ²è§£çš„æƒ…å†µä¸‹è®©åˆ«äººç›¸ä¿¡ä½ çŸ¥é“ä¸€ä¸ªæ•°ç‹¬çš„è§£ã€‚å…³æ³¨ä¸¤ä»¶äº‹ï¼Œè¯æ˜è€…å¦‚ä½•è¯´æ˜ï¼š\nç»™å®šä¸€ä¸ªæ•°ç‹¬é—®é¢˜ï¼Œå­˜åœ¨ä¸€ä¸ªè§£ ä»–çŸ¥é“è¿™ä¸ªè§£ï¼Œä½†æ˜¯ä¸ç”¨ç»™å‡ºå…³äºè§£çš„ä»»ä½•å…¶ä»–ä¿¡æ¯ æ•°ç‹¬é—®é¢˜åœ¨è®¡ç®—å¤æ‚åº¦ä¸Šå±äºNPé—®é¢˜ï¼Œäº‹å®ä¸Šï¼Œæ˜¯NP-å®Œå…¨é—®é¢˜ã€‚NPé—®é¢˜æ„å‘³ç€å¾ˆå®¹æ˜“éªŒè¯ä¸€ä¸ªè§£æ˜¯å¦æ­£ç¡®ã€‚\n2 Definitions ä¸€èˆ¬åŒ–çš„æ•°ç‹¬é—®é¢˜ï¼Œæ•°ç‹¬é—®é¢˜çš„å¤§å°æ˜¯ $n = k^2$ï¼Œæ€»å…± $n \\times n$ä¸ªæ ¼å­ï¼Œæ¯ä¸ªå°å—æ˜¯ $k \\times k$å¤§å°çš„ï¼Œé‚£ä¹ˆæ•°çš„èŒƒå›´æ˜¯ ${ 1, \u0026hellip;, n}$ã€‚æ¯”å¦‚å¸¸è§çš„ $k = 3$ï¼Œ$9 \\times 9$ å¤§å°çš„æ•°ç‹¬ã€‚ä¸€ä¸ªå…·ä½“æ•°ç‹¬é—®é¢˜ä¾‹å­å’Œè§£éƒ½æ˜¯ $O(n^2 \\log n)$ ä½çš„ã€‚\nCryptographic Functionalities åè®®ä¸­æœ‰ä¸¤æ–¹ï¼Œä¸€ä¸ªæ˜¯proverï¼Œä¸€ä¸ªæ˜¯verifierã€‚ä¸€æ—¦proverå’Œverifierå›ºå®šä¸‹æ¥ï¼Œä»–ä»¬äº¤äº’å‘çš„æ¶ˆæ¯å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªåªåŒ…å«proverå’Œverifieréšæœºæ•°çš„å‡½æ•°ã€‚ä¸‹é¢è®¨è®ºè¿™ä¸ªåè®®çš„ä¸€äº›æ€§è´¨ï¼š\ncompleteness.\nä¸€ä¸ªè¯šå®çš„verifierä¼šaccepectä¸€ä¸ªæ­£ç¡®çš„è¯æ˜ã€‚ä¹Ÿå°±æ˜¯ä¸€ä¸ªproveræœ‰ä¸€ä¸ªåˆæ³•çš„è§£ä¼šéµå¾ªè¿™ä¸ªåè®®ã€‚\nsoundness error.\nThe soundness error (or soundness) of the protocol is the (upper bound on the) probability that a verifier accepts an incorrect proof, i.e. a proof to a fallacious statement; in our case this corresponds to the event that a prover who does not a solution to a given Sudoku puzzle, claims that it knows to solve it, and the verifier accepts this claim.\nå¯¹äºé”™è¯¯çš„è¯æ˜ï¼Œä¼šæœ‰å¤šå°‘çš„æ¦‚ç‡é€šè¿‡verifierçš„éªŒè¯ã€‚\nzero-knowledge.\nThe goal in designing the protocols is to prevent the verifier from gaining any new knowledge from a correct (interactive) proof. I.e., the protocol should be zero- knowledge in the following sense: whatever a verifier could learn by interacting with the correct prover, the verifier could learn itself.\nä»€ä¹ˆæ˜¯é›¶çŸ¥è¯†å‘¢ï¼Ÿæ— è®ºverifieré€šè¿‡ä¸proveräº¤äº’å­¦åˆ°äº†ä»€ä¹ˆï¼Œé‚£ä¹ˆverifierä¹Ÿèƒ½é€šè¿‡å’Œè‡ªå·±äº¤äº’å­¦åˆ°è¿™äº›çŸ¥è¯†ï¼Œæ‰æ˜¯çœŸçš„æ²¡æœ‰æ³„éœ²ä»»ä½•åˆ«çš„çŸ¥è¯†ã€‚å®é™…æ“ä½œä¸­æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„æ¨¡æ‹Ÿå™¨ã€‚è¿™ä¸ªæ¨¡æ‹Ÿå™¨ä¼šç”Ÿæˆverifierå’Œproverä¹‹é—´çš„å¯¹è¯ï¼ŒåŒæ—¶åªçŸ¥é“puzzleï¼Œè€Œä¸çŸ¥é“æ•°ç‹¬çš„è§£ã€‚è¦æ±‚æ¨¡æ‹Ÿå™¨ä¸­verifierä¸proverå¯¹è¯ä¹‹é—´çš„åˆ†å¸ƒå’ŒçœŸå®çš„æƒ…å†µä¸‹ä¸¤è€…ä¹‹é—´çš„åˆ†å¸ƒæ˜¯ä¸€æ ·çš„ï¼Œè¿™æ ·å°±æ— æ³•åŒºåˆ†æ¨¡æ‹Ÿå™¨å’ŒçœŸå®çš„æƒ…å†µã€‚\nproofs-of-knowledge.\nOur protocols should also be proofs-of-knowledge: if the prover (or anyone imper- sonating him) can succeed in making the verifier accept, then there is another ma- chine, called the extractor, that can communicate with the prover and actually come up with the solution itself. This must involve running the prover several times using the same randomness (which is not possible under normal circumstances), so as not to contradict the zero-knowledge properties.\nè¯æ˜proverç¡®å®æœ‰çŸ¥è¯†ï¼Œå­˜åœ¨è¿™æ ·ä¸€ä¸ªæå–å™¨ï¼Œå®ƒèƒ½å¤Ÿé€šè¿‡å’Œproveräº¤äº’å¾—åˆ°çŸ¥è¯†ï¼Œå½“ç„¶ï¼Œå®ƒä¸èƒ½å‘é€é€šå¸¸çš„éšæœºæ•°ï¼Œå®ƒå¯ä»¥å¤šæ¬¡ä½¿ç”¨ç›¸åŒçš„éšæœºæ•°ã€‚\nè®ºæ–‡ä¸­è¯æ˜ä¸­ç”¨åˆ°çš„å”¯ä¸€çš„å¯†ç å­¦å·¥å…·æ˜¯ commitment protocolã€‚ä¸€ä¸ªæ‰¿è¯ºåè®®ï¼Œå‘é€æ–¹å‘æ¥æ”¶æ–¹æ‰¿è¯ºä¸€ä¸ªå€¼ï¼Œæ¥æ”¶æ–¹ä¸ä¼šå­¦åˆ°ä»»ä½•å…³äºè¿™ä¸ªå€¼æœ‰ç”¨çš„ä¿¡æ¯ã€‚è¿™æ ·çš„ä¸€ä¸ªåè®®åŒ…å«ä¸¤ä¸ªé˜¶æ®µï¼š\ncommit phase æ‰¿è¯ºé˜¶æ®µã€‚\nå‘é€æ–¹ç»‘å®šä¸€äº›å€¼ $v$ï¼Œæ¥æ”¶æ–¹ä¸èƒ½å†³å®šä»»ä½•å…³äº $v$ æœ‰ç”¨çš„ä¿¡æ¯ã€‚ç‰¹åˆ«åœ°ï¼Œå¯¹äºä»»æ„çš„$b$å’Œ$bâ€™$ï¼Œæ¥å—æ–¹æ— æ³•åŒºåˆ†$v=b$å’Œ$v=bâ€™$ã€‚è¿™ä¸ªæ€§è´¨ç§°ä¸º hidingã€‚\ndecommit or reval phase\næ¥æ”¶æ–¹è·å¾—$v$åï¼Œç¡®ä¿å®ƒæ˜¯åŸæ¥çš„å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€æ—¦commité˜¶æ®µç»“æŸï¼Œæ¥æ”¶æ–¹ä¼šåœ¨revalé˜¶æ®µæ¥æ”¶ä¸€ä¸ªå”¯ä¸€çš„å€¼ã€‚è¿™ä¸ªæ€§è´¨ç§°ä¸º bindingã€‚\nbit commitmentå¯ä»¥é«˜æ•ˆæ‰§è¡Œã€‚\nPhysical Protocols åœ¨æ–‡ç« ä¸­ä½¿ç”¨ tamper-evident sealed envelopesï¼Œä¹Ÿå°±æ˜¯é˜²æ‹†å°ä¿¡å°ã€‚åœ¨æ•°ç‹¬çš„ä¾‹å­ä¸­ï¼Œæ¯ä¸ªç›–ä½çš„å¡ç‰‡å½“ä½œæ˜¯è¿™æ ·çš„ tamper-evident sealed envelopesï¼Œå°†å¡ç‰‡ç¿»å¼€å°±ç›¸å½“äºæ‹†å¼€ä¿¡å°ã€‚\n3. Cryptographic Protocols veriferè¦ä¿è¯ä¸¤ä»¶äº‹æƒ…ï¼š\nå­˜åœ¨ä¸€ä¸ªè§£ the prover çŸ¥é“è¿™ä¸ªè§£ é›¶çŸ¥è¯†åè®®è¯æ˜çš„ç»“æ„ï¼š\nThe prover commits to several values. These values are functions of the instance, the solution and some randomization known only to the prover. è¯æ˜æ–¹æ‰¿è¯ºä¸€äº›å€¼ã€‚ The verifier requests that the prover open some of the committed valuesâ€”this is called the challenge. The verifier chooses the challenge at random from a collec- tion of possible challenges. éªŒè¯æ–¹å‘èµ·æŒ‘æˆ˜ã€‚ The prover opens the requested values. è¯æ˜æ–¹æ‰“å¼€è¦æ±‚çš„å€¼ã€‚ The verifier checks the consistency of the opened values with the given instance, and accepts or rejects accordingly. éªŒè¯æ–¹éªŒè¯ç»™å®šå®ä¾‹æ‰“å¼€å€¼çš„ä¸€è‡´æ€§ï¼Œç„¶åç›¸åº”åœ°æ¥å—æˆ–è€…æ‹’ç»ã€‚ è¦æ±‚åœ¨æ­¥éª¤3ä¸­æ‰“å¼€çš„å€¼çš„åˆ†å¸ƒæ˜¯ä¸€ä¸ªå…³äºæ•°ç‹¬é—®é¢˜å’Œæ­¥éª¤2ä¸­å‘é€çš„æŒ‘æˆ˜çš„æœ‰æ•ˆå‡½æ•°ã€‚é‚£ä¹ˆç»“åˆæ‰¿è¯ºåè®®çš„ä¸å¯åŒºåˆ†æ€§è´¨ï¼Œè¯´æ˜äº†æœ‰æ•ˆæ¨¡æ‹Ÿå™¨çš„å­˜åœ¨æ€§ã€‚\næ¨¡æ‹Ÿå™¨çš„æ“ä½œå¦‚ä¸‹ï¼šåœ¨æ­¥éª¤2ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªéªŒè¯æ–¹å¯èƒ½å‘èµ·çš„æŒ‘æˆ˜ï¼Œè®¡ç®—æ­¥éª¤1ä¸­ä¼šæ»¡è¶³æŒ‘æˆ˜çš„å€¼ã€‚æ¨¡æ‹Ÿå™¨æ¨¡æ‹Ÿå°†è¿™äº›å€¼å‘é€ç»™éªŒè¯æ–¹ï¼Œç„¶åè¿è¡ŒéªŒè¯æ–¹çš„ç®—æ³•ï¼Œç”¨åˆšåˆšå¾—åˆ°çš„å€¼å’Œæ•°ç‹¬é—®é¢˜ä½œä¸ºè¾“å…¥ã€‚æ¨¡æ‹Ÿå™¨ä¼šè·å¾—åœ¨æ­¥éª¤2ä¸­å‘é€çš„æŒ‘æˆ˜ã€‚å¦‚æœè¿™ä¸ªæŒ‘æˆ˜æ˜¯å®ƒä¹‹å‰çŒœçš„å€¼ï¼Œæ¨¡æ‹Ÿå™¨å°±ä¼šæ‰“å¼€ä¹‹å‰å‘é€çš„æ‰¿è¯ºï¼Œé‚£ä¹ˆéªŒè¯æ–¹è‡ªç„¶ä¼šæ¥å—ï¼Œæ¨¡æ‹Ÿå™¨å¯ä»¥ç»§ç»­æ‰§è¡Œè¿™ä¸ªåè®®ï¼Œå¦åˆ™çš„è¯ï¼Œæ¨¡æ‹Ÿå™¨ä¼šé‡ç½®å¹¶é‡æ–°å¼€å§‹ã€‚è¿™é‡Œæœ‰ç‚¹ç»•ï¼ŒåŸæ–‡å¦‚ä¸‹ï¼š\nThe simulator operates in the following way: it picks at random a challenge that the verifier might send in Step 2 (i.e. it guesses what the verifierâ€™s challenge will be), and computes commitments for Step 1 that will satisfy this challenge. The simulator simulates sending these commitments to the verifier, then it runs the verifierâ€™s algo- rithm with the puzzle as its input, a fresh set of random bits and these commitments being the first message it receives. It then obtains the challenge the verifier sends in Step 2. If this challenge is indeed the value it guessed, then the simulator can open the commitments it sent and the verifier should accept; the simulator can continue simulating the protocol and output the transcript of the simulated protocol execution. Otherwise, the simulator resets the simulation and starts it all over again.\nå¦‚æœå¯èƒ½çš„æŒ‘æˆ˜çš„æ•°é‡æ˜¯å¤šé¡¹å¼çš„ï¼Œé‚£ä¹ˆæ¯æ¬¡æ¨¡æ‹Ÿå™¨çŒœæµ‹éªŒè¯æ–¹çš„æŒ‘æˆ˜ï¼Œå°±æ˜¯ç”¨â€œreasonably highâ€æ¦‚ç‡æ˜¯æ­£ç¡®çš„ã€‚è¿™ä¸ªè¿‡ç¨‹ä¿è¯äº†åè®®æ˜¯é›¶çŸ¥è¯†çš„ï¼Œå› ä¸ºæ¨¡æ‹Ÿå™¨çš„è¾“å‡ºå’ŒéªŒè¯æ–¹ä»è¯æ˜æ–¹äº¤äº’å¾—åˆ°çš„è¾“å‡ºæ˜¯ä¸èƒ½åŒºåˆ†çš„ï¼Œä½†æ˜¯æ¨¡æ‹Ÿå™¨è¿™ä¸€è¿‡ç¨‹çš„è®¡ç®—æ˜¯æ²¡æœ‰å’Œè¯æ˜æ–¹äº¤äº’çš„ï¼Œé‚£è‚¯å®šä¸èƒ½å¾—åˆ°ä»»ä½•å…³äºè§£çš„çŸ¥è¯†ã€‚\n3.1 A Protocol Based on Coloring å¯¹äº3-Colorability Protocolï¼Œè¯æ˜è€…é‡æ–°æ’åˆ—é¢œè‰²ï¼Œç„¶åæäº¤æ¯ä¸ªé¡¶ç‚¹é‡æ–°æ’åˆ—ä¹‹åçš„é¢œè‰²ã€‚éªŒè¯æ–¹éšæœºé€‰æ‹©ä¸€æ¡è¾¹ï¼Œæ£€æŸ¥è¾¹çš„ä¸¤ç«¯é¢œè‰²æ˜¯å¦æ˜¯ä¸åŒçš„ã€‚\nå¯¹äºæ•°ç‹¬é—®é¢˜ï¼Œè¿™ä¸ªåè®®æ˜¯å¦‚ä¸‹è¿™æ ·çš„ï¼š\nProveræ­¥éª¤1æ˜¯éšæœºé€‰æ‹©ä¸€ä¸ªæ’åˆ—$\\sigma$ï¼Œä»${1,\\dots,n}$æ˜ å°„åˆ°${1,\\dots,n}$ï¼Œè¿™æ ·é¿å…æ³„æ¼åŸæ¥çš„è§£ã€‚\n3.2 An Efficient Cryptographic Protocol with Constant Soundness Error ä¸‹é¢è¿™ç§åè®®æœ‰å¸¸æ•°çš„soundness errorã€‚è¿™ä¸ªåè®®çš„æƒ³æ³•æ˜¯å°†æ¯ä¸ªå•å…ƒå¤åˆ¶ä¸‰ä»½ï¼Œåˆ›å»ºå…³äºè§£çš„è¡Œã€åˆ—ä»¥åŠå­ç½‘æ ¼çš„è§†è§’ã€‚å¤åˆ¶åçš„æ¯ä¸ªå•å…ƒéšæœºæ’åˆ—ï¼Œproverçš„å·¥ä½œæ˜¯è¯´æ˜ä»¥ä¸‹æ€§è´¨ï¼š\nå¯¹åº”è¡Œã€åˆ—ã€å­ç½‘æ ¼å«æœ‰æ‰€æœ‰å¯èƒ½çš„æ•°å­—ï¼Œå¦‚${ 1,2,\u0026hellip;,n }$ã€‚ ä¸€ä¸ªå•å…ƒçš„ä¸‰ä¸ªç‰ˆæœ¬çš„å€¼éƒ½æ˜¯ç›¸åŒçš„ã€‚ è¿™äº›å¤åˆ¶åçš„å•å…ƒä¸­åŒ…å«é¢„å…ˆç¡®å®šçš„å€¼ã€‚ å¦‚æœä¸Šè¿°ä¸‰ä¸ªæ¡ä»¶éƒ½æ»¡è¶³çš„è¯ï¼Œè¯´æ˜å­˜åœ¨è¿™æ ·ä¸€ä¸ªè§£å¹¶ä¸”proveræ˜¯çŸ¥é“å®ƒçš„ã€‚å…·ä½“çš„åè®®å¦‚ä¸‹ï¼š\nä¸Šé¢è¿‡ç¨‹ä¸æ˜¯å¾ˆå¥½ç†è§£ï¼Œä¾‹å¦‚$n=4$çš„æƒ…å†µï¼Œ$3 \\times n^2 = 2 \\times 4^2 = 3 \\times 16$ï¼Œæ•°ç‹¬è°œé¢˜é‡Œå¡«çš„æ•°å­—èŒƒå›´æ˜¯ ${ 1,2,3,4 }$ã€‚è¿™æ ·æœ‰è§£çš„ä¸‰ä¸ªå‰¯æœ¬ï¼Œåˆ†åˆ«æ˜¯è¡Œã€åˆ—ã€subgridsã€‚\nProverï¼š\næäº¤$3 \\times n^2$ ä¸ªå€¼ $v_1,v_2,â€¦,v_{3 \\times 4^2}$ã€‚$v_{i_1}ã€v_{i_2}ã€v_{i_3}$ æ˜¯åŸæ¥æ•°ç‹¬è§£ä¸­çš„å€¼ï¼Œæœ‰ç›¸åŒçš„å€¼ï¼Œ$(i_1,i_2,i_3)$ æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼Œæ˜¯éšæœºçš„ä¸‹æ ‡ï¼Œä¾‹å¦‚å›¾ä¸­çš„$(3,16,9)$ã€$(80,1,17)$ã€‚ æäº¤èŒƒå›´${ 1,2, \\dots , 3 \\times n^2 }$ä¸­ $n^2$ä¸ªä¸‰å…ƒç»„$(i_1,i_2,i_3)$ï¼Œä¾‹å¦‚${ (3,16,9),(80,1,17)\\dots,(i_1,i_2,i_3), \\dots }$ã€‚ æäº¤æ­¥éª¤2ä¸­ä¸ªæ¯ä¸ªä¸‰å…ƒç»„çš„åå­—ï¼Œå¦‚$(3,16,9)$çš„åå­—å°±æ˜¯$(rows,columns,subgrids)$ï¼Œ$(80,1,17)$å¯¹åº”çš„æ˜¯$(subgrids,rows,columns)$ã€‚ æäº¤æ­¥éª¤1ä¸­$3n$ç»„ä½ç½®ï¼Œå¯¹åº”è¡Œã€åˆ—å’Œå­ç½‘æ ¼ï¼Œå¹¶ä¸”åœ¨æ¯ç»„ä¸­ä¸ä¼šå­˜åœ¨ç›¸äº¤çš„ä¸¤ä¸ªå•å…ƒæ ¼ã€‚ä¾‹å¦‚å›¾ä¸­è“è‰²ç®­å¤´éƒ¨åˆ†ã€‚ Verifierï¼šé€‰æ‹©ä»¥ä¸‹ä¸‰ä¸ªä¸­çš„ä¸€ä¸ªè¿›è¡ŒæŒ‘æˆ˜ï¼š\n(a) æ‰“å¼€æ­¥éª¤1ä¸­$3 \\times n^2$ä¸ªå€¼ï¼Œä»¥åŠæ­¥éª¤4ä¸­$3n$ç»„çš„ä½ç½®ã€‚éªŒè¯æ¯ç»„ä¸­æ˜¯å¦å«æœ‰$n$ä¸ªä¸åŒçš„å€¼ï¼Œä»»æ„ä¸¤ç»„ä¹‹é—´ä¸ç›¸äº¤ã€‚\n(b)æ‰“å¼€æ­¥éª¤1ä¸­$3n^2$ä¸ªå€¼ä»¥åŠæ­¥éª¤2ã€‚éªŒè¯æäº¤çš„ä¸‰å…ƒç»„å¯¹åº”ä¸‹æ ‡çš„å€¼éƒ½æ˜¯ç›¸åŒçš„ã€‚\n(c)æ‰“å¼€æ­¥éª¤2ã€3ã€4ä¸­æäº¤çš„å€¼ä»¥åŠæ­¥éª¤1ä¸­å·²ç»å¡«å¥½çš„æ•°ç‹¬ï¼Œå¦‚å›¾ä¸­ç´«è‰²æ•°å­—ã€‚éªŒè¯(i)æ‰“å¼€çš„å€¼å’Œä¹‹å‰è®¾å®šçš„å€¼æ˜¯ä¸€è‡´çš„ï¼Œ(ii)æ­¥éª¤4ä¸­çš„æ¯ä¸ªé›†åˆå’Œä¹‹å‰çš„ä½ç½®æ˜¯ä¸€è‡´çš„ï¼Œ(iii)æ¯ä¸ªä¸‰å…ƒç»„çš„åå­—å¯¹åº”æ˜¯æ­£ç¡®çš„ã€‚\nOverhead of our Protocols ä¸Šé¢ä¸¤ä¸ªåè®®éƒ½å¯ä»¥é€šè¿‡é‡å¤æ‰§è¡Œæ¥é™ä½soundness errorã€‚\n4 Physical Protocols ç‰©ç†ä¸Šçš„åè®®ï¼Œä½¿ç”¨ Tamper Evidenceä½œä¸ºç‰©ç†çš„å¯†ç å­¦åŸºç¡€ï¼Œå°±æ˜¯å¯†å°çš„ä¿¡å°ã€‚\nå¯†ç å­¦åè®®å’Œç‰©ç†çš„åè®®çš„è¿˜æœ‰ä¸€ä¸ªä¸åŒæ˜¯ï¼š\nThe protocol does not prevent cheating by adversaries that accept the risk of being labelled as cheaters (in this respect it is similar to the model of covert adversaries).\nä¸¤ä¸ªå‡½æ•°éœ€è¦ç”¨åˆ°ï¼šshuffle å’Œ triplicateã€‚\nå®ç°å¯†å°æ•ˆæœæœ‰ä¸‰ç§æ–¹å¼ï¼š\nå¯†å°çš„ä¿¡å° åˆ®åˆ®å¡ éªŒè¯æ–¹å’Œè¯æ˜æ–¹åœ¨åŒä¸€ä¸ªæˆ¿é—´ï¼Œç”¨æ ‡å‡†çš„ä¸é€æ˜å¡ç‰‡ï¼Œå¯†å°å°±æ˜¯æŠŠæ•°å­—ç›–ç€ï¼Œæ­å¼€æ•°å­—å°±æ˜¯ç¿»è½¬å¡ç‰‡ï¼Œå°†æ•°å­—æœä¸Šã€‚ åè®®3\nProtocol 3 A physical protocol with 1/9 soundness error\nThe prover places three scratch-off cards on each cell. On filled-in cells, he places three cards with the correct value, which are already open (scratched). For each row/column/subgrid, the verifier chooses (at random) one of the three cards of each cell in the corresponding row/column/subgrid. The prover makes packets of the verifierâ€™s requested cards (i.e. for every row/ column/subgrid, he assembles the requested cards). He then shuffles each of the 3n packets separately (using the shuffle functionality), and hands the shuffled packets to the verifier. The verifier scratches off all the cards in each packet and verifies that each packet contains all of the numbers. è¿™ä¸ªåè®®éœ€è¦æ‰§è¡Œçš„æ´—ç‰Œæ¬¡æ•°æ¯”è¾ƒå¤šï¼Œå¯¹äº$9 \\times 9$çš„æƒ…å†µï¼Œéœ€è¦è¿›è¡Œ$3 \\times n = 3 \\times 9 = 27$æ¬¡æ´—ç‰Œï¼Œåœ¨å®é™…æ“ä½œä¸­è¿™ä¸ªæ¬¡æ•°è¿‡å¤šã€‚\n4.1.1 Reducing the Number of Shuffles ä¸Šé¢çš„æ„æ€æ˜¯åœ¨éªŒè¯é˜¶æ®µï¼Œproverç»™æ¯ä¸ªè¢‹å­æ ‡è®°ä¸€ä¸ªå€¼ï¼Œä»$0$åˆ°$c-1$ï¼Œå¦‚æœæ ‡è®°çš„æ˜¯$0$è¡¨ç¤ºè¿™ä¸ªå£è¢‹ä¸è¢«é€‰ä¸­ã€‚é‚£ä¹ˆå¯¹äºæ¯ä¸€ä¸ªæ ‡è®°çš„å·$i$ï¼Œå¦‚æœæœ‰$t$ä¸ªè¢‹å­æ˜¯è¿™ä¸ªæ ‡è®°ï¼Œå°±æŠŠè¿™$t$ä¸ªè¢‹å­æ··åˆåœ¨ä¸€èµ·è¿›è¡Œæ´—ç‰Œæ“ä½œï¼Œæœ€åéªŒè¯é‡Œé¢æ¯ä¸ªæ•°å­—æ˜¯å¦å‡ºç°$t$æ¬¡ã€‚è¿™æ ·å°±å¤§å¤§å‡å°‘äº†shuffleså‡½æ•°çš„è°ƒç”¨æ¬¡æ•°ã€‚\n4.2 A Physical Zero-Knowledge Protocol with no Soundness Error è¿™ç§åè®®proveræ˜¯æ²¡æœ‰åŠæ³•ä½œå¼Šçš„ã€‚\n4.3 A Protocol Using Scissors and a Sheet of Paper ","date":"2022-11-29T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-29-Cryptographic-and-Physical-Zero-Knowledge-Proof-Systems-for-Solutions-of-Sudoku-Puzzles/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/29/Cryptographic-and-Physical-Zero-Knowledge-Proof-Systems-for-Solutions-of-Sudoku-Puzzles/","title":"Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzles"},{"content":"åœ¨æ–‡ç«  How to explain zero-knowledge protocols to your children ä¸­é€šè¿‡é˜¿é‡Œå·´å·´ä¸ç¥ç§˜çš„æ´ç©´çš„æ•…äº‹ä»‹ç»äº†ä»€ä¹ˆæ˜¯é›¶çŸ¥è¯†è¯æ˜ã€‚ä¸­æ–‡ç¿»è¯‘æ–‡ç« è§ã€è¯‘ã€‘How to Explain Zero-Knowledge Protocols to Your Childrenã€‚ä¸‹é¢ç®€è¦è®°å½•æ–‡ç« çš„ç¬”è®°ï¼š\nThe Strange Cave of Ali Baba é˜¿é‡Œå·´å·´æ¯å¤©éƒ½å»é›†å¸‚ä¸Šï¼Œæ€»è¢«å°å·å·ä¸œè¥¿ï¼Œæ¯æ¬¡å°å·éƒ½è·‘åˆ°ä¸€ä¸ªæ´ç©´ï¼Œé‡Œé¢æœ‰ä¸€ä¸ªå²”è·¯å£ï¼Œæœ‰ä¸¤æ¡é“è·¯ï¼Œé˜¿é‡Œå·´å·´è¿½ç€å°å·æ¥åˆ°æ´ç©´ï¼Œé˜¿é‡Œå·´å·´æ¯æ¬¡åªèƒ½é€‰æ‹©ä¸€ä¸ªå£è¿›å…¥ï¼Œæ¯æ¬¡å°å·éƒ½èƒ½é€ƒèµ°ã€‚åœ¨ç»å†æ‚²å‚¬çš„40æ¬¡è¢«å·åï¼Œä¸ç§‘å­¦å‘€ï¼Œæ¯æ¬¡å°å·éƒ½èƒ½é€‰æ‹©é˜¿é‡Œå·´å·´ä¸èµ°çš„é‚£æ¡è·¯ï¼Œé‚£å°å·å¾—å¤šå¹¸è¿ï¼Œ$\\frac{1}{2^{40}}$çš„æ¦‚ç‡ï¼Œä¸å¤ªå¯èƒ½ï¼ï¼ï¼æ´ç©´ä¸€å®šæœ‰ä»€ä¹ˆä¸å¯å‘Šäººçš„ç§˜å¯†ï¼\nä¸€å¤©é˜¿é‡Œå·´å·´æå‰è—åœ¨æ´ç©´é‡Œï¼Œå‘ç°å°å·è¯´å‡ºäº†â€œèŠéº»å¼€é—¨â€å’’è¯­ï¼Œæ´ç©´è¿æ¥äº†èµ·æ¥ã€‚\néš¾æ€ªè¿™äº›å°å·æ¯æ¬¡èƒ½é¡ºåˆ©é€ƒè„±ã€‚åæ¥é˜¿é‡Œå·´å·´ä¸æ–­å®éªŒå’’è¯­ï¼Œå‘ç°å¯ä»¥ä¿®æ”¹å’’è¯­ï¼Œç°åœ¨åªæœ‰ä»–çŸ¥é“æ–°çš„å’’è¯­äº†ã€‚é˜¿é‡Œå·´å·´æŠŠè¿™ä¸ªç¥å¥‡çš„ç»å†å†™åœ¨æ‰‹ç¨¿ä¸Šæµä¼ äº†ä¸‹æ¥ã€‚\nThe Fate of the Manuscript åæ¥ï¼Œé˜¿é‡Œå·´å·´çš„åä»£ Mick Ali çŸ¥é“å’’è¯­çš„ç§˜å¯†ï¼Œä½†æ˜¯ä»–ä¸æƒ³å‘Šè¯‰ä¸–äººè¿™ä¸ªç§˜å¯†ï¼Œåªæƒ³è¯´æœåˆ«äººç›¸ä¿¡ä»–çŸ¥é“è¿™ä¸ªç§˜å¯†ã€‚ä¸€å®¶ç”µè§†å°ç‹¬å®¶æŠ¥é“è¿™ä¸ªè¿‡ç¨‹ï¼Œå®éªŒæ˜¯è¿™æ ·è¿›è¡Œçš„ï¼š\næ‘„å½±å›¢é˜Ÿå…ˆæ‹æ‘„ä¸¤ä¸ªæ­»èƒ¡åŒçš„ç»†èŠ‚ æ¯ä¸ªäººéƒ½ç¦»å¼€æ´ç©´ï¼ŒMick Ali å•ç‹¬ä¸€äººè¿›å…¥æ´ç©´ è®°è€…è¿›å…¥åˆ°æ´ç©´çš„å²”è·¯å£ï¼ŒæŠ›ä¸€æšé“¶å¸ï¼Œé€‰æ‹©å·¦è¾¹è¿˜æ˜¯å³è¾¹ï¼Œæ¥ç€å¤§å–Šè®©Mikeä»é€‰æ‹©çš„é‚£ä¸€è¾¹å‡ºæ¥ é‡å¤ä¸Šè¿°è¿‡ç¨‹40æ¬¡ Mickè¿ç»­æˆåŠŸ40æ¬¡ï¼Œå·²ç»èƒ½è¶³å¤Ÿè¯´æœæˆ‘ä»¬ä»–çŸ¥é“å’’è¯­ã€‚\nThe Jealous Reporter å«‰å¦’çš„è®°è€…æ‰¾æ¥ä¸€ä¸ªæ¼”å‘˜è£…æ‰®æˆMickçš„æ ·å­ï¼Œä½†æ˜¯ä»–ä¸çŸ¥é“å’’è¯­ï¼Œè®°è€…ä¹Ÿæ¨¡æ‹Ÿä¸Šè¿°è¿‡ç¨‹ï¼Œä¸è¿‡æœ€åå‰ªæ‰å¤±è´¥çš„ç‰‡æ®µï¼Œåªå±•ç¤ºè¿ç»­æˆåŠŸ40æ¬¡çš„ç»“æœã€‚\næ¨¡æ‹Ÿçš„æƒ…å†µå’ŒçœŸå®çš„æƒ…å†µä¸€åŒå‘ä¸–äººè¿›è¡Œå±•ç¤ºï¼Œäººä»¬ä¹Ÿæ— æ³•åŒºåˆ«å­°çœŸå­°å‡ï¼Œè¿™ä¸æ°å¥½è¯´æ˜å’’è¯­çš„ç§˜å¯†æ²¡æœ‰æ³„éœ²å˜›ï¼ä½†æ˜¯äººä»¬éƒ½ç›¸ä¿¡MickçŸ¥é“å’’è¯­çš„ç§˜å¯†ã€‚è¿™ä¸€è¿‡ç¨‹å°±åœ¨è¯æ˜é›¶çŸ¥è¯†ï¼ï¼ï¼\nThe Tests in Parallel ä¸Šé¢çš„è¯æ˜è¿‡ç¨‹è¦è¿ç»­è¿›è¡Œ40æ¬¡ï¼Œæœ‰æ²¡æœ‰æ–¹æ³•å¹¶è¡Œå‘¢ï¼Ÿå¯ä»¥å»ºé€ è¿™æ ·ä¸€åº§å¤§å¦ï¼Œæ¯ä¸€å±‚æœ‰ä¸€ä¸ªæ´ç©´ï¼Œæ¯ä¸€ä¸ªæ´ç©´éƒ½æœ‰è‡ªå·±çš„å’’è¯­ï¼Œæ¯ä¸ªæ´ç©´æœ‰ä¸€ä¸ªæ¼”å‘˜ï¼Œåœ¨åŒä¸€æ—¶åˆ»ä»–ä»¬è¿›å…¥æ´ç©´ç„¶åéšæœºé€‰æ‹©è¿›å…¥å“ªä¸€è¾¹ï¼Œæœ€åå‡ºæ¥ã€‚ä½†æ˜¯è¿™æ ·çš„è¯ï¼Œéœ€è¦åœ¨ç§˜å¯†çš„æ•°é‡å’Œæ‹æ‘„åœºæ™¯æ•°é‡ä¸Šåšä¸€ä¸ªå¹³è¡¡ã€‚\nThe Prior Agreement ä¹‹å‰çš„æ¨¡æ‹Ÿåœºæ™¯éœ€è¦åæœŸå‰ªæ‰é‚£äº›ä¸æˆåŠŸçš„åœºæ™¯ï¼Œæœ‰æ²¡æœ‰è¿ç»­è¿›è¡ŒæŒ‘æˆ˜æˆåŠŸçš„åŠæ³•å‘¢ï¼Ÿé‚£å°±æ˜¯éªŒè¯è€…å’Œè¯æ˜è€…ä¹‹é—´äº‹å…ˆå•†å®šéšæœºé€‰æ‹©èµ°å“ªè¾¹ï¼Œè¿ç»­è¿›è¡Œ40æ¬¡ä¹Ÿèƒ½æŒ‘æˆ˜æˆåŠŸã€‚\nA Single Test, A Single Secret å¦‚ä½•åªè¿›è¡Œä¸€æ¬¡æµ‹è¯•ï¼Œå°±è®©äººä»¬è¶³å¤Ÿç›¸ä¿¡æ‹¥æœ‰ç§˜å¯†å‘¢ï¼Ÿå»ºé€ ä¸‹é¢è¿™æ ·çš„æ´ç©´ï¼š\nåªéœ€è¦å•ç‹¬ä¸€æ¬¡æµ‹è¯•å°±èƒ½å¤Ÿè®©äººè¾¾åˆ°è¿ç»­40æ¬¡æµ‹è¯•ç›¸åŒæ°´å¹³çš„ä¿¡æœåº¦ï¼Œæ¥ç›¸ä¿¡Mickæ˜¯çŸ¥é“è¿™ä¸ªå’’è¯­çš„ç§˜å¯†çš„ã€‚\n","date":"2022-11-28T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-28-How-to-explain-zero-knowledge-protocols-to-your-children/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/28/How-to-explain-zero-knowledge-protocols-to-your-children/","title":"How to explain zero-knowledge protocols to your children"},{"content":"æœ¬ç¯‡æ˜¯åšå®¢ã€ŠThe Incredible Machineã€‹çš„ç¬”è®°ï¼Œæ–‡ç« é€šè¿‡ä¸€ä¸ªæ•°ç‹¬çš„æ•…äº‹æ¥è§£é‡Šä»€ä¹ˆæ˜¯é›¶çŸ¥è¯†è¯æ˜ã€‚\nå…ˆæ€»ç»“ä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹ï¼š\näº¤äº’å¼è¯æ˜ã€‚AliceçŸ¥é“æ•°ç‹¬çš„è§£ï¼Œå…ˆå°†ç­”æ¡ˆå†™åœ¨çº¸ä¸Šï¼Œç„¶åç›–ä½ï¼ŒBobå‘èµ·ä¸€ä¸ªéšæœºæŒ‘æˆ˜ï¼Œå¯ä»¥é€‰æ‹©è¡Œã€åˆ—æˆ–è€…ä¸€ä¸ª3 $\\times$ 3çš„å—ã€‚å¦‚æœé€‰æ‹©è¡Œï¼Œé‚£ä¹ˆæ”¶é›†æ¯è¡Œçš„çº¸ç‰‡åˆ°ä¸€ä¸ªè¢‹å­é‡Œï¼Œæ··åˆåï¼Œæ¯ä¸ªè¢‹å­æ‰“å¼€éƒ½æ˜¯1ï½9çš„æ•°å­—ã€‚é‡å¤æ­¤è¿‡ç¨‹è®©æˆ‘ä»¬ç†ç”±ç›¸ä¿¡AliceçŸ¥é“æ•°ç‹¬çš„è§£ï¼Œå¹¶ä¸”è¿™ä¸€è¿‡ç¨‹æ²¡æœ‰æ³„æ¼è§£ã€‚ æ¨¡æ‹Ÿã€‚ä¸Šè¿°è¿‡ç¨‹åœ¨Aliceå’ŒBobäº‹å…ˆå•†å®šéšæœºæŒ‘æˆ˜é€‰æ‹©çš„é¡ºåºåï¼Œå¯ä»¥åœ¨ä¸çŸ¥é“æ•°ç‹¬è§£çš„æƒ…å†µä¸‹é€šè¿‡æŒ‘æˆ˜ã€‚è¿™ä¹Ÿæ­£å¥½è¯æ˜äº†è¿™ä¸€è¿‡ç¨‹æ˜¯é›¶çŸ¥è¯†çš„ã€‚ éäº¤äº’å¼è¯æ˜ã€‚ç”±ä¸€ä¸ªæœºå™¨æ¥æ¨¡æ‹Ÿè¿™ä¸€è¿‡ç¨‹ï¼Œæœºå™¨å†…éƒ¨äº‹å…ˆç„Šä¸€ä¸ªéšæœºæŒ‘æˆ˜çš„é¡ºåºï¼Œè¿™ä¸ªé¡ºåºå¯ä»¥ç”±ä¸€ä¸ªä»ªå¼æ¥å®Œæˆï¼Œä¿è¯æ²¡æœ‰äººçŸ¥é“è¿™ä¸ªé¡ºåºã€‚è¿™ä¸ªæœºå™¨ä¹Ÿæ˜¯å­˜åœ¨ç¼ºç‚¹çš„ï¼Œå¯ä»¥é€šè¿‡å®éªŒå¾—åˆ°è¿™ä¸ªéšæœºé¡ºåºã€‚ æ­£æ–‡å¦‚ä¸‹ï¼š\nHow Alice, Bob, and Charlie used Zero-Knowledge and Blockchains to launch The Global Sudoku Revolution.\nThis post is inspired by two great papers that make zero-knowledge proofs accessible to a wide audience:\n[1] How to Explain Zero Knowledge Protocols to Your Children (QuisquaterÂ et. al.)\n[2] Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzles (GradwohlÂ et. al.).\nAlice, Bob, and Charlie loved to solve Sudoku problems.The three friends liked challenging each other with puzzles all the time (in fact, sometimes they solved Sudoku problems that wereÂ REALLY largeÂ â€” not just 9x9 taken fromÂ here). Alice was the cleverest of the three. She would draw a Sudoku board on paper, and fill in some of theÂ constraints. Then, sheâ€™d let Bob and Charlie try to solve the puzzle.\nThe Proof One day, Bob, who was working on an especially difficult Sudoku that Alice had devisedï¼ˆè®¾è®¡çš„ï¼‰ sighed with despairï¼ˆç»æœ›çš„ï¼‰. â€œI swear, this puzzle has no solution! Alice just gave me one of the unsolvable ones to mess with me!â€\nHe quickly came to Alice to complain.\nâ€œIâ€™ll prove to you that this puzzle has a solution, and that I know it!â€ declared Alice. â€œGood!â€ Said Bob, who was secretly hoping to learn the answer and later tauntï¼ˆå˜²è®½ï¼‰ Charlie with it.\nâ€œIn fact, Iâ€™ll prove it to you with â€˜zero-knowledgeâ€™, that is, without ever revealing the solution itselfâ€. â€œIâ€™d like to see you tryâ€, said Bob, who was still thinking of all the fun heâ€™d have teasing ï¼ˆæˆå¼„ï¼‰Charlie.\nThe Commitment Alice retrieved 81 blank index cards. She quickly wrote a single digit (from 1 to 9) on each card and carefully placed the cards on the table, in a 9-by-9 matrix, organized just like a Sudoku puzzle. All of the cards were placed face down, with the exception of the few that had the constraints that Bob had already seen written on them.\néšæœºé€‰æ‹©è¡Œã€åˆ—æˆ–è€…ä¸€ä¸ªå—æ¥è¿›è¡ŒéªŒè¯ã€‚\nThe Random Challenge Bob was excited. The solution was close. Heâ€™d been working on the problem for ages!\nâ€œBob, you arenâ€™t allowed to peak at the cards!â€ Alice exclaimed to Bobâ€™s disappointment. â€œNot yet anyway. But I will let you test the solution. You can choose whether you want to check the rows, the columns, or the blocks. Pick one at random.â€\nBob decided to pick the rows. Alice proceeded to place the cards from each row inside an opaque bag â€” one bag per row. She gave each bag a thorough shake, making sure the index cards inside were mixed well. She handed the bags to Bob, who gave her a quizzical look.\nVerification â€œWell, open them!â€ she said. â€œThey should each have exactly 9 cards with all the numbers 1 through 9â€. Bob opened each bag and verified that this was indeed the case.\nâ€œThis doesnâ€™t prove a thing!â€ I can also do that! Iâ€™d just have to place the numbers 1 through 9 in each row in any order iâ€™d like!â€ said Bob quickly.\nAlice explained that she couldnâ€™t have known in advance that Bob would pick the rows. Sheâ€™s not a mind reader! In fact, only a correct solution would have the numbers 1â€“9 in each row, column, and box and so if her solution was not correct, Bob would have at least a 1 in 3 chance of catching her.\nRinse and Repeat Bob thought that a 1 in 3 chance of catching Alice wasnâ€™t good enough. He still had a gnawing suspicion that the puzzle was unsolvable. He demanded that Alice repeat the procedure with him â€” each time placing the same cards for the same Sudoku problem face down on the floor, but letting him pick a different test at random. After a long series of tests, Bob was forced to admit that Alice was either an extremely lucky person, or, that she simply has a solution to the Sudoku problem (or perhaps she could read his thoughts after all). He was also quite disappointed that he had gained no knowledge (zero-knowledge) about the solution. All he knew after all these tests was that it was highly likely that every row, column and block did indeed contain the numbers 1â€“9 exactly once, which could only be so if Alice knew the solution.\nThe three friends had made it a habit to prove to one another that their Sudoku challenges were solvable. After all, no one wants to spend his time on an unsolvable problem. Each test was long and quite exhausting, but Sudoku is after all very serious business.\nå¦‚æœåªè¿›è¡Œä¸€æ¬¡éªŒè¯ï¼Œé‚£ä¹ˆAliceå¯èƒ½ä¼šæœ‰1/3æ¦‚ç‡ä½œå¼Šï¼Œå› æ­¤éœ€è¦é‡å¤è¿›è¡Œéšæœºè¯•éªŒï¼Œæé«˜å¯ä¿¡åº¦ã€‚\nBlockchains and The Global Sudoku Revolution One day, Alice had a great idea. Knowing that her love for Sudoku is shared by millions online, she decided to open her very own YouTube channel, where she can post her own Sudoku challenges online. She called it â€œThe Sudoku Blockchainâ€ (she didnâ€™t know what blockchains were exactly, but it was such a cool buzzwordï¼ˆæ—¶é«¦æœ¯è¯­ï¼Œæµè¡Œè¡Œè¯ï¼‰). She dreamed of many channel subscribers that would send her Bitcoins and decided to include features that the competing Sudoku channels did not have: She asked Bob to verify the existence of a solution to each of the puzzles using a zero-knowledge proof. Sheâ€™d film the whole thing and put it on the Sudoku Blockchain, so that everyone would know that (with high probability) each of the puzzles is indeed solvable.\nThe Simulation One day, Alice came over to Bobâ€™s house to record the proof for a Sudoku challenge, but found that she left the solution to the puzzle at home. Since she was in a hurry to publish the new challenge online, she begged Bob to film it with her anyway. She convinced Bob to pretend to run the proof with her. Together they agreed on a sequence of tests (rows / columns / and blocks) that Bob would â€œrandomlyâ€ pick. Since Alice too knew the sequence of tests, she could easily pass them without having the solution to the puzzle.\nCharlie, who was travelling abroad and saw the video was later surprised when Alice and Bob told him how they filmed it. â€œIâ€™ll never trust you two again!â€ he exclaimed. â€œNo one should trust any of your online video proofs!â€.\næ¨¡æ‹Ÿï¼Œåœ¨æ¨¡æ‹Ÿæƒ…å†µä¸‹æœ‰ä¸€ç§è¶…èƒ½åŠ›ï¼Œäº‹å…ˆçº¦å®šâ€œéšæœºâ€é€‰æ‹©çš„é¡ºåºï¼Œä¸çŸ¥é“çœŸæ­£çš„è§£ä¹Ÿèƒ½é€šè¿‡æµ‹è¯•ï¼Œè¿™ä¸æ­£æ°å¥½è¯´æ˜æ²¡æœ‰æ³„æ¼çŸ¥è¯†å˜›ï¼\nThe Incredible Machine and Non-Interactive Proofs Charlie was frustrated. He did not want to easily give up his Sudoku solving habit, but knowing that Alice and Bob were not trustworthy, he wanted a way to check proofs remotely. After a few sleepless nights, he declared to Alice and Bob that he had a new idea. He locked himself in his room for hours and labored frantically through the night. In the morning, Charlie presented Alice and Bob with his incredible new invention: â€œThe Zero-Knowledge Sudoku Non-Interactive Proof Machineâ€ (or zk-SNIPM as he like to refer to it).\nThe Machine was basically an automated version of Aliceâ€™s test. Alice would need to place her cards on the conveyor belt, and feed Sudoku solutions to the machine. The machine would then collect the cards from rows, columns, or boxes and place them automatically into bags that would come out on the other side (after being thoroughly mixed). Then, Alice could open the bags while the camera was still rolling and reveal their contents.\nThe machine had a control panel with a long series of dials that set the test for each set of 81 cards that Alice would feed in. Charlie had set up his own secret series of tests and then welded the control panelâ€™s cover shut (Alice was worried that he also booby-trapped it with explosives, or filled it up with scorpions, vials of acid, or some other similarly nasty thing. Charlie was a bit extreme when it came to securing his devices).\nCharlie could now trust his machine to provide a series of tests that was unknown to Alice so that he could watch youtube videos of proofs and be relatively sure that Alice had not cheated together with Bob.\nThe Ceremony Alice and Bob were jealous of Charlieâ€™s zk-SNIPM machine and wanted to use it to verify all puzzles (including those that Charlie invented). The only problem was that Charlie was the one who had set up the secret series of tests, and they could not let him use it for proofs (he could easily cheat since he knows the sequence of tests). Instead, Alice suggested that they conduct a multi-party set up of the machine together. A sort of â€œtrusted setup ceremonyâ€. She asked Charlie to open the control panel (and remove all of his nasty traps). Each of the dials on the control panel had 3 states, and you would need to rotate it to select the test.\nShe suggested that they place the machine in a dark room, and remove all the labels from the knobs. Each one of them would then go into the room with the machine in the dark (Bob also suggested that theyâ€™d be blindfolded just for good measure, and that they each wear a tinfoil hat to prevent mind reading side-channel attacks by Alice) and would turn the knobs on the machine to a random position (either turn them one-third of a turn clockwise, two-thirds of a turn clockwise, or leave them as they are). This way, the final setting of each knob would not be known to any single one of them (in fact, even if two participants colluded, they would not know the final state of the knob without the third personâ€™s assistance). After the set-up ceremony was over, theyâ€™d weld the cover of the machine shut.\nCracking the Machine One afternoon, when Bob and Charlie were off travelling, Alice was left alone with the machine. She started wondering if it was as secure as advertised. Thinking about it for a while she decided to feed it slightly modified Sudoku puzzle solutions in order to discover which tests the machine was using. She used a Sudoku puzzle that she could solve, and fed in many boards to see that the solution is indeed accepted by the machine. She then repeated the procedure, but changed the first board fed to the machine to simply include the numbers 1â€“9 in each row (without forming a legal solution in columns or boxes). The test still passed, and she then realized she can use this idea to learn the sequence of tests that were pre-set within the machine.\nè¿™é‡ŒAliceå…ˆç”¨ä¸€ä¸ªæ•°ç‹¬çš„çœŸè§£å–‚ç»™æœºå™¨ï¼Œçœ‹çœ‹æœºå™¨çš„è¾“å‡ºç»“æœã€‚æ¥ç€é‡å¤è¿™ä¸€è¿‡ç¨‹ï¼Œä½†æ˜¯ä¿®æ”¹è§£ï¼Œä¿è¯æ¯è¡Œæ˜¯æ•°å­—1ï½9ï¼Œå–‚ç»™æœºå™¨ï¼ŒæŸ¥çœ‹æœºå™¨çš„è¾“å‡ºç»“æœï¼Œè¿™æ ·å¯ä»¥æ¨æµ‹å‡ºä¹‹å‰é€šè¿‡ä»ªå¼å¾—åˆ°çš„éšæœºé¡ºåºã€‚\nAlice felt very frustrated. Can you help Alice build a better zk-SNIPM? Can you think of a series of tests that would be harder to crack, or is the approach doomed to fail? Write us and tell us your ideas!\nA Note About the Real World In fact, the zk-SNIPM is a tongue-in-cheek construction of aÂ non-interactive zero-knowledge prover, somewhere between zk-SNARKs and tamper-proof hardware. zk-SNIPM relies on a â€œphysicalâ€ type of zero-knowledge proof. Such physical proofs could in fact be made much more powerful, for example, by using a photocopy machine to copy the cards and check the rows, columns and boxes simultaneously on the same solution. Still, we have elected to utilize a physical proving system that has some analogies to computational proofs found in cryptographic zero-knowledge constructions.\nAliceâ€™s initial proving method is analogous to anÂ interactiveÂ zero-knowledge proof protocol, where the verifier sends a randomÂ challengeÂ to the prover, after she commits to the solution. A prover and verifier that are colluding and share this random challenge in advance can simulate a proof, without really knowing the solutions. AÂ non-interactiveÂ version that must work without this challenge step, is constructed by hiding the challenge itself in some cryptographic â€œmachineryâ€ in advance. This prevents the prover from having access to the challenge. Indeed, one good way to generate such a trusted challenge is through a â€œceremonyâ€ enacted through multiparty computation that combines the randomness from several participants into a single random challenge, encoded in the proving system.\nå¼€å§‹çš„è¯æ˜æ–¹æ³•ç±»ä¼¼äº¤äº’å¼é›¶çŸ¥è¯†è¯æ˜åè®®ï¼ŒéªŒè¯è€…ç»™è¯æ˜æ–¹ä¸€ä¸ªéšæœºæŒ‘æˆ˜ï¼Œç„¶åè¿›è¡ŒéªŒè¯ã€‚è¯æ˜æ–¹å’ŒéªŒè¯æ–¹å¯ä»¥äº‹å…ˆä½œå¼Šå•†é‡éšæœºæŒ‘æˆ˜çš„é¡ºåºï¼Œè¿™æ ·ä»–ä»¬åœ¨ä¸çŸ¥é“è§£çš„æƒ…å†µä¸‹å¯ä»¥æ¨¡æ‹Ÿä¸€ä¸ªè¯æ˜ã€‚åæ¥çš„æœºå™¨éªŒè¯è¿‡ç¨‹æ˜¯éäº¤äº’å¼è¯æ˜ï¼Œå®ç°æ„é€ ä¸€ä¸ªéšæœºé¡ºåºï¼Œå¯ä»¥é€šè¿‡ä»ªå¼çš„æ–¹å¼ï¼Œç„¶åå†è¿›è¡Œè¯æ˜ã€‚\nThe Sudoku example in this post is taken in slightly modified form fromÂ Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzles (Gradwohl et. al.).\nMany thanks to Daniel Benarroch for his help with this post.\nThis post was originally published onÂ qed-it.com.\n","date":"2022-11-28T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-28-The-Incredible-Machine/nicolas-houdayer-3h_uBlWlobU-unsplash.jpg","permalink":"https://wenjin1997.github.io/2022/11/28/The-Incredible-Machine/","title":"The Incredible Machine"},{"content":"å¼€å§‹å­¦ä¹ å¯†ç å­¦ï¼Œè¿™æ˜¯ä¸€å¥—ä¸é”™çš„è¯¾ç¨‹ã€‚å®˜æ–¹è¯¾ç¨‹é“¾æ¥Online Cryptography Courseã€‚æ•™æA Graduate Course in Applied Cryptographyï¼ŒCourseraä¸Šçš„é“¾æ¥ä¸ºå¯†ç å­¦ Iã€‚\nä¸‹é¢è®°å½•ç¬¬ä¸€å‘¨çš„å­¦ä¹ ç¬”è®°ã€‚\nCourse Overview å¯†ç å­¦æ— å¤„ä¸åœ¨ï¼ŒDVDä½¿ç”¨çš„æ˜¯CSSåŠ å¯†ï¼ŒBlu-rayä½¿ç”¨çš„æ˜¯AACSåŠ å¯†ã€‚\nå¸¸ç”¨çš„HTTPSåº•å±‚ç”¨çš„æ˜¯SSL/TLSã€‚å®‰å…¨çš„äº¤æµä¸­é—´æ˜¯æ²¡æœ‰å·å¬å’Œç¯¡æ”¹çš„ã€‚\nå¯¹ç§°åŠ å¯†ç³»ç»Ÿä½¿ç”¨çš„æ˜¯åŒä¸€ä¸ªkeyã€‚åŠ å¯†ç®—æ³•æ˜¯å…¬å¼€çš„ï¼Œæ°¸è¿œä¸è¦ä½¿ç”¨ä¸€ä¸ªä¸“æœ‰çš„åŠ å¯†ç®—æ³•ã€‚\nå¯†ç å­¦ä¸æ˜¯æ‰€æœ‰å®‰å…¨é—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼Œä¾‹å¦‚è½¯ä»¶æ¼æ´æˆ–è€…å·¥ç¨‹ä¸Šçš„æ”»å‡»ã€‚\nWhat is cryptography? Crypto core å¯†ç å­¦çš„æ ¸å¿ƒå»ºç«‹å¯†é’¥ï¼Œä¿è¯äº¤æµçš„å¯é å’Œå®Œæ•´æ€§ã€‚\nBut crypto can do much more å¯†ç å­¦å¯ä»¥åº”ç”¨åœ¨åŒ¿åäº¤æµä¸­ï¼Œä¸Šå›¾ä¸­çš„åŒ¿åæ˜¯ç›¸äº’çš„ï¼ŒAliceä¸çŸ¥é“å¯¹æ–¹æ˜¯è°ï¼ŒBobä¹Ÿä¸çŸ¥é“å¯¹æ–¹æ˜¯è°ã€‚\nå¯†ç å­¦åº”ç”¨åœ¨åŒ¿åç”µå­è´§å¸ï¼Œç±»ä¼¼äºæˆ‘ä»¬å»å•†åº—æ¶ˆè´¹ï¼Œä¸æƒ³è®©å•†åº—çŸ¥é“æˆ‘ä»¬çš„èº«ä»½ï¼ŒåŒæ—¶åœ¨ç½‘ç»œä¸­ï¼Œè¦ä¿è¯ç”µå­è´§å¸ä¸èƒ½é‡å¤æ¶ˆè´¹ã€‚\nProtocols åœ¨é€‰ä¸¾æˆ–è€…ç§æœ‰æ‹å–çš„ä¾‹å­ä¸­ï¼Œæœ‰å—ä¿¡çš„ç¬¬ä¸‰æ–¹æ¥è¿›è¡Œå…¬å¸ƒç»“æœã€‚è¿™é‡Œæœ‰ä¸€ä¸ªé‡è¦çš„ç†è®ºï¼Œä»»ä½•å¯ä»¥ä½¿ç”¨å—ä¿¡ç¬¬ä¸‰æ–¹å®Œæˆçš„äº‹ä¹Ÿå¯ä»¥ä¸ç”¨ç¬¬ä¸‰æ–¹å°±èƒ½å®Œæˆã€‚\nCrypto magic A rigorous science å¯†ç å­¦æ˜¯ä¸€é—¨ä¸¥è°¨çš„å­¦ç§‘ï¼Œè¦éµå¾ªä»¥ä¸Šä¸‰ä¸ªæ­¥éª¤ã€‚\nHistory æ›¿æ¢å¼åŠ å¯†çš„å¯†é’¥ç©ºé—´å¾ˆå¤§ï¼Œæ˜¯26ä¸ªå­—æ¯çš„å…¨æ’åˆ—ã€‚\nç ´è§£æ›¿æ¢å¼åŠ å¯†çš„æ–¹æ³•æ˜¯åˆ©ç”¨äº†è‹±è¯­å­—æ¯å‡ºç°çš„é¢‘ç‡ï¼Œå­—æ¯eå‡ºç°çš„é¢‘ç‡æœ€é«˜ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¯¹æˆªè·åˆ°çš„å¯†æ–‡ç»Ÿè®¡å‡ºç°çš„é¢‘ç‡ï¼Œå‡ºç°é¢‘ç‡æœ€é«˜çš„å­—æ¯å°±å¯¹åº”äºå­—æ¯eã€‚æ¥ç€å†åˆ©ç”¨äºŒåˆå­—æ¯å‡ºç°çš„é¢‘ç‡ã€‚\nå½“æˆ‘ä»¬çŸ¥é“keyä¸­åŠ å¯†å­—æ¯çš„é•¿åº¦æ—¶ï¼Œå°±å¾ˆå¥½ç ´è§£ã€‚\nDiscrete Probability è¿™éƒ¨åˆ†è¯¦ç»†ä»‹ç»è§https://en.wikibooks.org/wiki/High_School_Mathematics_Extensions/Discrete_Probabilityã€‚\nEvents The union bound Random Variables The uniform random variable Randomized algorithms Independence XOR å¼‚æˆ–ä¸­é‡è¦çš„ä¸€ä¸ªå®šç†æ˜¯ï¼ŒYæ˜¯ä¸€ä¸ªéšæœºå˜é‡ï¼ŒXæ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å‡åŒ€åˆ†å¸ƒå˜é‡ï¼ŒYä¸Xå¼‚æˆ–ä¹‹åæ˜¯ä¸€ä¸ªå‡åŒ€åˆ†å¸ƒå˜é‡ã€‚\nThe birthday paradox å½“$n=1.2 \\times \\sqrt{|U|}$æ—¶ï¼Œ$U$ ä¸­å­˜åœ¨ä¸¤ä¸ªå˜é‡ç›¸ç­‰çš„æ¦‚ç‡å¤§äºç­‰äº$1/2$ã€‚å¸¸è¯†è®¤ä¸ºå¯èƒ½æ˜¯$|U|/2$ï¼Œå› æ­¤ä¹Ÿå«åšæ‚–è®ºã€‚\nThe One Time Pad keyå’Œè¦åŠ å¯†çš„æ¶ˆæ¯çš„é•¿åº¦ä¸€æ ·é•¿ã€‚\nkeyä¹Ÿå¯ä»¥ç®—å‡ºæ¥ï¼Œæ˜¯må’Œcçš„å¼‚æˆ–ã€‚\nä»€ä¹ˆæ˜¯å®‰å…¨çš„åŠ å¯†å‘¢ï¼Ÿé¦™å†œçš„å®šä¹‰æ˜¯ï¼Œä¸èƒ½ä»å¯†æ–‡ä¸­å¾—åˆ°ä»»ä½•å…³äºåŸæ–‡çš„ä¿¡æ¯ã€‚\nç”¨æ¦‚ç‡æ¥å®šä¹‰ perfect secrecyï¼Œä¹Ÿå°±æ˜¯ä»å¯†æ–‡ä¸­æ— æ³•åŒºåˆ†ä»»æ„ä¸¤ä¸ªåŸæ–‡ï¼Œå¾—åˆ°ä¸¤ä¸ªä¸åŒmessageçš„æ¦‚ç‡æ˜¯ç›¸åŒçš„ã€‚\nOTPæ˜¯æœ‰perfectå®‰å…¨æ€§çš„ã€‚\nOTPæ˜¯æ²¡æœ‰æƒŸå¯†æ–‡æ”»å‡»ï¼Œä½†æ˜¯æœ‰å…¶ä»–æ”»å‡»ã€‚\nPseudorandom Generators ç”¨ä¼ªéšæœºkeyä»£æ›¿éšæœºkeyã€‚\næ°¸è¿œä¸è¦åœ¨åŠ å¯†ä¸­ä½¿ç”¨glibcä¸­çš„random()å‡½æ•°ã€‚\nNegligible vs. non-negligible å¯å¿½ç•¥çš„ï¼šæ„æ€æ˜¯æ¯”å¤šé¡¹å¼çš„é€†ä¸‹é™åœ°è¿˜è¦å¿«ã€‚\nAttacks on OTP and stream ciphers ä¸èƒ½ä¸¤æ¬¡ä½¿ç”¨ç›¸åŒçš„PRG(k)ã€‚\nå®¢æˆ·ç«¯åˆ°æœåŠ¡ç«¯ä¸æœåŠ¡ç«¯åˆ°å®¢æˆ·ç«¯åº”è¯¥ä½¿ç”¨ä¸åŒçš„keyã€‚\nä¸­é—´å¯ä»¥åŠ å…¥pï¼Œç„¶åè¿›è¡Œç¯¡æ”¹ã€‚\nReal-world Stream Ciphers PRG Security Defs ä¸€ä¸ªå®‰å…¨çš„PRGæ˜¯ä¸å¯é¢„æµ‹çš„ã€‚\nåè¿‡æ¥ä¹Ÿæˆç«‹ï¼Œä¸€ä¸ªä¸å¯é¢„æµ‹çš„PRGæ˜¯å®‰å…¨çš„ã€‚\nç”¨åˆ°äº†å‰é¢å®šç†(Yaoâ€™82)çš„é€†å¦å‘½é¢˜ã€‚ä¸å®‰å…¨çš„PRGæ˜¯å¯é¢„æµ‹çš„ã€‚\næ›´ä¸€èˆ¬çš„å®šä¹‰ï¼Œcomputationally indistinguishableã€‚\nSemantic security å‰ä¸¤ä¸ªå®šä¹‰éƒ½å¤ªå¼ºäº†ï¼Œéœ€è¦ä¸€ä¸ªå¼±ä¸€äº›çš„å®šä¹‰ï¼Œæ‰¾åˆ°å­˜åœ¨çš„ $m_0$ ä¸ $m_1$ã€‚\nè¿™é‡Œç»™å‡ºäº†semantically secure çš„å®šä¹‰ã€‚\nOTPæ˜¯ semantically secure çš„ã€‚\nStream ciphers are semantically secure ","date":"2022-11-21T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-21-Dan-Boneh-Cryptography-Week1/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/21/Dan-Boneh-Cryptography-Week1/","title":"Dan Boneh Cryptography I Week1"},{"content":"æœ€è¿‘åˆæŠŠè‡ªå·±çš„åšå®¢æŠ˜è…¾äº†ä¸€éï¼Œä¹‹å‰ç”¨çš„æ˜¯vuepressæ­å»ºçš„ï¼Œå¥ˆä½•å®åœ¨çœ‹ä¸æƒ¯å­—ä½“å¤ªå°ï¼Œé…ç½®å­—ä½“å¤§å°åŠå¤©ä¸æˆåŠŸï¼Œç´¢æ€§æƒ³ç€é‡æ–°æ­å»ºä¸€ä¸‹ã€‚ç½‘ä¸Šæœç´¢åˆ°çš„ä¸»è¦æœ‰hexoå’Œhugoï¼Œä¹‹å‰å°è¯•è¿‡hexoï¼Œæ²¡æœ‰å¾ˆæ»¡æ„ï¼Œè¿™æ¬¡å°±è¯•ç€ç”¨hugoæ­å»ºã€‚\nå®‰è£…Hugo 1 brew install hugo æ¥ç€è¿è¡Œï¼š\n1 hugo version æ˜¾ç¤ºæ­£å¸¸åˆ™è¯´æ˜å®‰è£…æˆåŠŸã€‚\nåˆ›å»ºHugoç½‘ç«™ 1 hugo new site hugo-blog è¿è¡Œæ•ˆæœå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 jinjin@Mac-mini test % hugo new site hugo-blog Congratulations! Your new Hugo site is created in /Users/jinjin/code/test/hugo-blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. é€‰æ‹©ä¸»é¢˜ åœ¨å®˜æ–¹ç½‘ç«™ä¸»é¢˜æ¿å—é€‰æ‹©ä¸€ä¸ªå–œæ¬¢çš„ä¸»é¢˜ï¼Œæˆ‘é€‰æ‹©çš„æ˜¯Clean Whiteï¼Œæ¥ç€å¯ä»¥æŒ‰ç…§ä¸»é¢˜ç»™çš„æ•™ç¨‹è¿›è¡Œå®‰è£…ã€‚ä¸ºäº†åç»­æ–¹ä¾¿githubç®¡ç†éƒ¨ç½²ä»¥åŠä¿®æ”¹ä¸»é¢˜ï¼Œå°†åŸä¸»é¢˜ä»“åº“forkåˆ°è‡ªå·±çš„è´¦æˆ·ï¼Œç”¨git submoduleæ–¹å¼è¿›è¡Œä»“åº“é“¾æ¥ã€‚\né¦–å…ˆæ‰¾åˆ°ä¸»é¢˜çš„githubä»“åº“ï¼Œç„¶åforkä¸‹æ¥ï¼Œæ¥ç€åœ¨æœ¬åœ°ä½¿ç”¨git submoduleå‘½ä»¤ï¼Œè¿™é‡Œä»“åº“åœ°å€å·²ç»å˜æˆè‡ªå·±è´¦æˆ·ä¸‹ä¸»é¢˜ä»“åº“çš„åœ°å€äº†ã€‚\n1 git submodule add https://github.com/wenjin1997/hugo-theme-cleanwhite.git themes/hugo-theme-cleanwhite åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œè¿è¡Œgit submoduleä¸git cloneé‡åˆ°äº†ä¸€äº›é—®é¢˜ã€‚\nè§£å†³ Failed to connect to github.com port 443 å‚è€ƒFailed to connect to github.com port 443: Operation timed outè§£å†³è¯¥é—®é¢˜ï¼Œè®¿é—®https://ping.chinaz.com/github.comï¼Œæ‰¾åˆ°ä¸€ä¸ªå¯ç”¨çš„ipåœ°å€ï¼Œä¾‹å¦‚ä¸º140.82.121.4ã€‚\n1 2 cd ~ sudo vim /etc/hosts åœ¨hostæ–‡ä»¶ä¸­è¿›è¡Œä¿®æ”¹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 ## # Host Database # # localhost is used to configure the loopback interface # when the system is booting. Do not change this entry. ## 127.0.0.1 localhost 255.255.255.255 broadcasthost ::1 localhost 140.82.121.4 github.com è§£å†³HTTP/2 stream 1 was not closed cleanly before end of the underlying stream ä¹‹åä½¿ç”¨git cloneåˆå‡ºç°å¦‚ä¸‹é”™è¯¯ï¼š\n1 2 3 jinjin@Mac-mini themes % git clone https://github.com/zhaohuabing/hugo-theme-cleanwhite.git Cloning into \u0026#39;hugo-theme-cleanwhite\u0026#39;... fatal: unable to access \u0026#39;https://github.com/zhaohuabing/hugo-theme-cleanwhite.git/\u0026#39;: HTTP/2 stream 1 was not closed cleanly before end of the underlying stream å‚è€ƒè§£å†³ HTTP/2 stream 1 was not closed cleanly before end of the underlying streamï¼Œéœ€è¦å¯¹gitè¿›è¡Œå…¨å±€é…ç½®ã€‚\n1 git config --global http.version HTTP/1.1 åˆå§‹åŒ–ä¸»é¢˜é…ç½®åŠå‘å¸ƒ 1 2 cd themes cp -r hugo-theme-cleanwhite/exampleSite/** ../ æ¥ç€è¿è¡Œhugo serveråœ¨æœ¬åœ°http://localhost:1313/å°±èƒ½çœ‹åˆ°åšå®¢çš„æ ·å­äº†ã€‚\n1 2 cd .. hugo server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 jinjin@Mac-mini hugo-blog % hugo server Start building sites â€¦ hugo v0.101.0+extended darwin/arm64 BuildDate=unknown | EN -------------------+----- Pages | 71 Paginator pages | 8 Non-page files | 0 Static files | 70 Processed images | 0 Aliases | 17 Sitemaps | 1 Cleaned | 0 Built in 82 ms Watching for changes in /Users/jinjin/code/hugo-blog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /Users/jinjin/code/hugo-blog/config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop ^C% ä¿®æ”¹é…ç½® å¯ä»¥è¾¹ä¿®æ”¹åšå®¢è¾¹åœ¨æœ¬åœ°é¢„è§ˆæ•ˆæœï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„ä¿®æ”¹ï¼Œå°±æ˜¯åœ¨æ ¹ç›®å½•ä¸‹çš„congig.tomlæ–‡ä»¶ä¸­å°†baseurlä¿®æ”¹ä¸ºè‡ªå·±çš„åšå®¢åœ°å€ã€‚\n1 baseurl = \u0026#34;https://wenjin1997.github.io\u0026#34; GitHub Pageså‘å¸ƒåšå®¢ é¦–å…ˆè¦åœ¨githubä¸Šåˆ›å»ºè‡ªå·±\u0026lt;è´¦æˆ·å\u0026gt;.github.ioçš„ä»“åº“ã€‚\næ‰‹åŠ¨å‘å¸ƒ Hugoç”Ÿæˆçš„é™æ€é¡µé¢ä¼šæ”¾åœ¨publicæ–‡ä»¶å¤¹ä¸‹ã€‚\n1 2 hugo cd public æ¥ç€å‘è¿œç¨‹æ¨é€æˆ‘ä»¬çš„gitä»“åº“ã€‚\n1 2 3 4 5 git init git remote add origin git@github.com:wenjin1997/wenjin1997.github.io git add . git commit -m \u0026#34;add test\u0026#34; git push origin master å¦‚æœåœ¨æ·»åŠ è¿œç¨‹ä»“åº“æ—¶å‡ºç°é”™è¯¯ï¼Œå‚è€ƒGit æç¤ºfatal: remote origin already exists é”™è¯¯è§£å†³åŠæ³•è§£å†³æ–¹æ³•ï¼Œç”¨ä¸‹é¢çš„å‘½ä»¤åˆ é™¤è¿œç¨‹gitä»“åº“ï¼š\n1 git remote rm origin æ¥ç€å†ç”¨git remote add origin git@github.com:wenjin1997/wenjin1997.github.ioé‡æ–°æ·»åŠ è¿œç¨‹ä»“åº“ã€‚\nè¿è¡Œæ•ˆæœå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 jinjin@Mac-mini hugo-blog % cd public jinjin@Mac-mini public % git init hint: Using \u0026#39;master\u0026#39; as the name for the initial branch. This default branch name hint: is subject to change. To configure the initial branch name to use in all hint: of your new repositories, which will suppress this warning, call: hint: hint: git config --global init.defaultBranch \u0026lt;name\u0026gt; hint: hint: Names commonly chosen instead of \u0026#39;master\u0026#39; are \u0026#39;main\u0026#39;, \u0026#39;trunk\u0026#39; and hint: \u0026#39;development\u0026#39;. The just-created branch can be renamed via this command: hint: hint: git branch -m \u0026lt;name\u0026gt; Initialized empty Git repository in /Users/jinjin/code/hugo-blog/public/.git/ jinjin@Mac-mini public % git remote add origin git@github.com:wenjin1997/wenjin1997.github.io jinjin@Mac-mini public % git add . jinjin@Mac-mini public % git commit -m \u0026#34;add test\u0026#34; [master (root-commit) af5a609] add test 165 files changed, 60905 insertions(+) create mode 100644 2017/11/03/hello-world/index.html create mode 100644 2017/11/04/istio-install_and_example/index.html create mode 100644 2017/11/07/istio-traffic-shifting/index.html ...ï¼ˆçœç•¥ï¼‰ jinjin@Mac-mini public % git push origin master Enumerating objects: 285, done. Counting objects: 100% (285/285), done. Delta compression using up to 8 threads Compressing objects: 100% (213/213), done. Writing objects: 100% (285/285), 3.32 MiB | 341.00 KiB/s, done. Total 285 (delta 82), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (82/82), done. To github.com:wenjin1997/wenjin1997.github.io * [new branch] master -\u0026gt; master è®¿é—®è‡ªå·±çš„åšå®¢åœ°å€wenjin1997.github.ioï¼Œå¯ä»¥çœ‹åˆ°å¤§åŠŸå‘Šæˆå•¦ï¼\nè‡ªåŠ¨å‘å¸ƒ ä½¿ç”¨Github Action é…ç½®è‡ªåŠ¨å‘å¸ƒåšå®¢ï¼Œå…ˆè¦åˆ›å»ºä¸€ä¸ªä»“åº“ï¼Œä¾‹å¦‚hugo-blogï¼Œè¿™é‡Œæ”¾ç½®åšå®¢çš„æºç ï¼ŒåŒ…æ‹¬è‡ªå·±çš„åšå®¢æ–‡ç« ã€å›¾ç‰‡ç­‰ã€‚åœ¨ä»“åº“åˆ›å»º.github/workflows/deploy.ymlæ–‡ä»¶ï¼Œé…ç½®å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: wenjin1997/wenjin1997.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} æ³¨æ„è¦ä¿®æ”¹ EXTERNAL_REPOSITORY: wenjin1997/wenjin1997.github.ioã€‚\nCheckoutæ­¥éª¤ä¸­çš„withä¸­é…ç½®çš„submoudleså€¼ä¸ºtrueå¯ä»¥åŒæ­¥åšå®¢æºä»“åº“çš„å­æ¨¡å—ã€‚\nåœ¨GitHubè´¦æˆ·ä¸‹Setting - Developer settings - Personal access tokens - Tkens(classic)åˆ›å»ºä¸€ä¸ªTokenã€‚\næƒé™å¼€å¯repoå’Œworkflowã€‚\né…ç½®åå¤åˆ¶ç”Ÿæˆçš„Tokenï¼ˆåªä¼šå‡ºç°ä¸€æ¬¡ï¼‰ï¼Œåœ¨åˆšåˆšåˆ›å»ºçš„æºä»“åº“hugo-blogçš„Settings - Security - Secretes - Actionsä¸­æ·»åŠ PERSON_TOKENä¸ºåˆšåˆšçš„Tokenã€‚\nå®Œæˆä¸Šè¿°é…ç½®åï¼Œæœ¬åœ°ä¿®æ”¹åšå®¢æ–‡ç« ï¼Œå‘ä»“åº“hugo-blogè¿›è¡Œæ¨é€ï¼Œå¯ä»¥è§¦å‘GitHub Actionï¼Œä¼šè‡ªåŠ¨ç”Ÿæˆåšå®¢é¡µé¢å¹¶æ¨é€åˆ°GitHub Pagesä»“åº“ï¼ŒGitHub Pagesä»“åº“æ›´æ–°åï¼Œåˆä¼šè‡ªåŠ¨è§¦å‘å®˜æ–¹é¡µé¢éƒ¨ç½²CIï¼Œå®ç°åšå®¢å‘å¸ƒã€‚\nåšå®¢æ”¯æŒæ•°å­¦å…¬å¼ å‚è€ƒHugoåšå®¢æ·»åŠ LaTeXè¯­æ³•æ”¯æŒï¼Œåœ¨ä¸»é¢˜æ–‡ä»¶themes/hugo-theme-clean-white/layouts/partialsä¸‹åˆ›å»ºmathjax.htmlï¼Œå†…å®¹ä¸ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; async src=\u0026#34;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[\u0026#39;$\u0026#39;,\u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;,\u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;,\u0026#39;$$\u0026#39;], [\u0026#39;\\[\\[\u0026#39;,\u0026#39;\\]\\]\u0026#39;]], processEscapes: true, processEnvironments: true, skipTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;], TeX: { equationNumbers: { autoNumber: \u0026#34;AMS\u0026#34; }, extensions: [\u0026#34;AMSmath.js\u0026#34;, \u0026#34;AMSsymbols.js\u0026#34;] } } }); MathJax.Hub.Queue(function() { // Fix \u0026lt;code\u0026gt; tags after MathJax finishes running. This is a // hack to overcome a shortcoming of Markdown. Discussion at // https://github.com/mojombo/jekyll/issues/199 var all = MathJax.Hub.getAllJax(), i; for(i = 0; i \u0026lt; all.length; i += 1) { all[i].SourceElement().parentNode.className += \u0026#39; has-jax\u0026#39;; } }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; code.has-jax { font: inherit; font-size: 100%; background: inherit; border: inherit; color: #515151; } \u0026lt;/style\u0026gt; åœ¨themes/hugo-theme-clean-white/layouts/partials/head.htmlæ–‡ä»¶æœ«å°¾æ·»åŠ ä¸‹é¢ä¸€è¡Œä»£ç ï¼š\n1 {{ partial \u0026#34;mathjax.html\u0026#34; . }} è¿™æ ·åœ¨æ¯ä¸ªé¡µé¢éƒ½ä¼šè‡ªåŠ¨æ’å…¥ä»£ç ï¼Œæ”¯æŒæ•°å­¦å…¬å¼äº†ã€‚\nTipsï¼šä¸Šé¢ä½¿ç”¨çš„æ˜¯MathJaxï¼Œå¯¹äºLaTeXå…¬å¼ä¸­çš„æ¢è¡Œç¬¦ï¼Œè¦ä½¿ç”¨\\\\\\ä¸‰ä¸ªæ–œæ ä»£æ›¿\\\\ï¼Œä¾‹å¦‚\n1 2 3 4 5 6 \\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2, \\\\\\ u(1)=1 \\end{cases}\t\\end{aligned} è¿™æ ·æ‰èƒ½æ­£å¸¸æ˜¾ç¤ºä¸¤è¡Œå…¬å¼ï¼š\n$$ \\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2, \\\\\\ u(1)=1 \\end{cases}\t\\end{aligned} $$å‚è€ƒèµ„æ–™ Hugo å®˜ç½‘ Hugo + GitHub Actionï¼Œæ­å»ºä½ çš„åšå®¢è‡ªåŠ¨å‘å¸ƒç³»ç»Ÿ å¦‚ä½•åˆ©ç”¨ GitHub Pages å’Œ Hugo è½»æ¾æ­å»ºä¸ªäººåšå®¢ï¼Ÿ ä½¿ç”¨ Hugo å’Œ GitHub Pages æ­å»ºé™æ€åšå®¢ Hugo Themes: Clean White zhaohuabing/hugo-theme-cleanwhite Failed to connect to github.com port 443: Operation timed out è§£å†³ HTTP/2 stream 1 was not closed cleanly before end of the underlying stream Git æç¤ºfatal: remote origin already exists é”™è¯¯è§£å†³åŠæ³• Hugoåšå®¢æ·»åŠ LaTeXè¯­æ³•æ”¯æŒ ","date":"2022-11-19T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-19-hugo-post/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/19/hugo-post/","title":"å¦‚ä½•ç”¨Hugo + Github Actionéƒ¨ç½²ä¸ªäººåšå®¢"},{"content":"åŸæ–‡é“¾æ¥ï¼šZero Knowledge Proofs: An illustrated primerã€‚æœ¬ç¯‡æ–‡ç« é€šè¿‡å›¾ä¸‰è‰²é—®é¢˜æ¥ä»‹ç»ä»€ä¹ˆæ˜¯é›¶çŸ¥è¯†è¯æ˜ã€‚\nOne of the best things about modern cryptography ï¼ˆå¯†ç å­¦ï¼‰ is the beautiful terminology ï¼ˆæœ¯è¯­ï¼‰. You could start any number of punk bandsï¼ˆæœ‹å…‹ä¹é˜Ÿï¼‰ (orÂ Tumblrs) named after cryptography terms like â€˜hard-core predicateâ€™, â€˜trapdoor functionâ€™,Â â€˜Â or â€˜impossible differential cryptanalysis ï¼ˆå¯†ç åˆ†æï¼‰â€™. And of course, I havenâ€™t even mentioned the one term that surpasses all of these. That term is â€˜zero knowledgeâ€˜.\nIn fact, the term â€˜zero knowledgeâ€™ is so appealingï¼ˆæœ‰å¸å¼•åŠ›çš„ï¼‰ that it leads to problems. People misuse it, assuming that zero knowledge must be synonymousï¼ˆåŒä¹‰è¯ï¼‰ with â€˜really, reallyÂ secureâ€˜. Hence it gets tackedï¼ˆé™„åŠ ï¼Œå¢è¡¥ï¼‰ onto all kinds of stuff â€” likeÂ encryptionï¼ˆåŠ å¯†ï¼‰ systemsÂ and anonymityï¼ˆåŒ¿åï¼‰ networks â€” that really have nothing to do with true zero knowledge protocols.\næ¾„æ¸…é›¶çŸ¥è¯†çš„è¯¯åŒºï¼ŒåƒåŠ å¯†ç³»ç»Ÿå’ŒåŒ¿åç½‘ç»œï¼ŒçœŸçš„å’Œé›¶çŸ¥è¯†åè®®æ²¡æœ‰å…³ç³»ã€‚\nThis all serves to underscore a point:Â zero-knowledge proofsÂ are one of the most powerful tools cryptographers have ever devisedï¼ˆè®¾è®¡çš„ï¼‰. But unfortunately theyâ€™re also relatively poorly understood. In this series of posts Iâ€™m going try to give a (mostly)Â nonâ€“mathematicalÂ description of what ZK proofs are, and what makes them so special. In this post and the next Iâ€™ll talk about some of the ZK protocols we actually use.\nOrigins of Zero Knowledge The notion of â€˜zero knowledgeâ€™ was first proposedÂ in the 1980sÂ by MIT researchers Shafi Goldwasser, Silvio Micali and Charles Rackoff. These researchers were working on problems related toÂ interactive proof systems, theoretical systems where a first party (called a â€˜Proverâ€™) exchanges messages with a second party (â€˜Verifierâ€™) to convince the Verifier that some mathematical statement is true.*\né›¶çŸ¥è¯†çš„æ¦‚å¿µå‡ºç°åœ¨1980s Shafi Goldwasserï¼ŒSilvio Micali å’Œ Charles Rackoffå‘è¡¨çš„è¿™ç¯‡æ–‡ç« ä¸­ã€‚ç ”ç©¶è€…å…³æ³¨åœ¨äº¤äº’å¼è¯æ˜ç³»ç»Ÿï¼Œä¸€æ–¹æ˜¯â€œProverâ€ï¼Œå¦ä¸€æ–¹æ˜¯â€œVerifierâ€ï¼ŒProverä¸Verifieräº¤æ¢ä¿¡æ¯ï¼Œæ¥è¯´æœVerifieråœ¨æ•°å­¦ä¸Šï¼ˆå¯ä»¥æ˜¯æ¦‚ç‡æ„ä¹‰ä¸‹ï¼‰ç›¸ä¿¡ä¸€äº›é™ˆè¿°æ˜¯çœŸçš„ã€‚\nPrior to GoldwasserÂ et al., most work in this area focused theÂ soundnessÂ of the proof system. That is, it considered the case where a maliciousï¼ˆæ¶æ„çš„ï¼‰ Prover attempts to â€˜trickâ€™ a Verifier into believing a false statement. What Goldwasser, Micali and Rackoff did was to turn this problem on its head. Instead of worrying only about the Prover, they asked: what happens if you donâ€™t trust theÂ Verifier?\nä¹‹å‰çš„å·¥ä½œä¸»è¦è€ƒè™‘è¯æ˜ç³»ç»Ÿçš„å¯é æ€§ï¼Œè€ƒè™‘çš„æ˜¯æ¶æ„çš„è¯æ˜æ–¹ï¼Œè€Œ Goldwasser, Micali å’Œ Rackoff å¼€å§‹è€ƒè™‘å¦‚æœä¸ç›¸ä¿¡éªŒè¯è€…ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæˆ‘ä»¬ä¸èƒ½å‚»ä¹ä¹çš„å°±æŠŠä¸€äº›ç§˜å¯†æ³„æ¼ç»™proverã€‚\nThe specific concern they raised wasÂ information leakage.Â Concretely, they asked, how much extra informationÂ is the Verifier going to learn during the course of this proof, beyond the mere fact that the statement is true?\nä»–ä»¬è€ƒè™‘çš„æ˜¯éªŒè¯è€…å¯èƒ½ä¼šæ³„æ¼ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯åœ¨é™¤äº†çŸ¥é“é™ˆè¿°æ˜¯çœŸçš„è¿™ä¸ªä¿¡æ¯å¤–ï¼ŒéªŒè¯è€…é€šè¿‡è¿™ä¸ªè¯æ˜è¿‡ç¨‹è¿˜çŸ¥é“ä»€ä¹ˆé¢å¤–çš„ä¿¡æ¯ï¼Ÿ\nItâ€™s important to note that this is not simply of theoretical interest. There are real, practical applications where this kind of thing matters.\nHereâ€™s one: imagine that a real-world client wishes to log into a web server using a password. The standard â€˜real worldâ€™ approach to this problem involves storing aÂ hashed version of the passwordÂ on the server. The login can thus be viewed as a sort of â€˜proofâ€™ that a given password hash is the output of a hash function on some password â€” and more to the point, that the client actuallyÂ knowsÂ the password.\nMost real systems implement this â€˜proofâ€™ in the absolute worst possible way. The client simply transmits the original password to the server, which re-computes the password hash and compares it to the stored value. The problem here is obvious: at the conclusion of the protocol,Â the server has learned my cleartext password.Â Modern password hygieneï¼ˆå«ç”Ÿï¼‰ therefore involves a good deal of praying that servers arenâ€™t compromisedï¼ˆæŸå®³ï¼‰.\nè¿™é‡Œä¸¾äº†ç°å®ä¸­çš„ä¸€ä¸ªä¾‹å­ï¼Œå°±æ˜¯å¯†ç ç™»å½•ã€‚å¤§å¤šæ•°å®é™…çš„ç³»ç»Ÿä¸­å®¢æˆ·ç«¯ç®€å•çš„å°†åŸå§‹å¯†ç å‘é€ç»™æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯å†è®¡ç®—ä¸€éå¯†ç çš„å“ˆå¸Œå€¼ï¼Œç„¶åå’Œå­˜å‚¨çš„å€¼è¿›è¡Œæ¯”è¾ƒã€‚è¿™é‡Œä¼šå‡ºç°å®‰å…¨é—®é¢˜ï¼Œå¯†ç ä¸æ³„æ¼åªèƒ½ç¥ˆç¥·äºæœåŠ¡ç«¯ä¸ä¼šå‡ºç°é—®é¢˜ã€‚\nWhat Goldwasser, Micali and Rackoff proposedÂ was a new hope for conducting such proofs. If fully realized, zero knowledge proofs would allow us to prove statements like the one above, while provably revealingÂ no informationÂ beyond the single bit of information corresponding to â€˜this statement is trueâ€™.\né›¶çŸ¥è¯†å°±æ˜¯é™¤äº†â€™this statement is trueâ€™å¤–ä¸ä¼šæ³„æ¼ä»»ä½•å…¶ä»–çš„ä¿¡æ¯ã€‚\nA â€˜real worldâ€™ example So far this discussion has been pretty abstract. To make things a bit more concrete, letâ€™s go ahead and give a â€˜realâ€™ example of a (slightly insaneï¼ˆç–¯ç‹‚çš„ï¼›éå¸¸æ„šè ¢çš„ï¼‰) zero knowledge protocol.\nFor the purposes of this example, Iâ€™d like you to imagine that Iâ€™m a telecomï¼ˆç”µä¿¡ï¼‰ magnateï¼ˆå·¨å¤´ï¼‰ in the process of deployingï¼ˆéƒ¨ç½²ï¼‰ a new cellularï¼ˆèœ‚çªï¼‰ communications network. My network structure is represented by the graph below. Each vertexï¼ˆé¡¶ç‚¹ï¼‰ in this graph represents a cellular radio tower, and the connecting lines (edges) indicate locations where two cellsÂ overlapï¼ˆé‡å ï¼‰, meaning that their transmissions are likely to interfere with each other.\néƒ¨ç½²èœ‚çªç½‘çš„ä¾‹å­ï¼Œæ¯ä¸ªé¡¶ç‚¹ä»£è¡¨ä¸€ä¸ªèœ‚çªå¡”ï¼Œæ¯ä¸ªè¾¹ä»£è¡¨ç€ä¸¤ä¸ªæœ‰é‡å ï¼Œæ„å‘³ç€ä»–ä»¬ä¹‹é—´çš„ä¼ è¾“ä¼šç›¸äº’å½±å“ã€‚\nThis overlap is problematic, since it means that signals from adjacent towers are likely to scrambleï¼ˆäº‰å¤ºï¼‰ reception. Fortunately my network design allows me to configure each tower to one of three different frequency bands to avoid such interference.\nThus the challenge in deploying my network is to assign frequency bands to the towers such that no two overlapping cells share the same frequencies. If we use colors to represent the frequency bands, we can quickly work out one solution to the problem:\nä¸¤ä¸ªç›¸é‚»å¡”ä¹‹é—´ç”¨ä¸åŒçš„é¢‘ç‡ï¼Œä¹Ÿå°±è½¬æ¢ä¸ºå›¾ä¸‰è‰²é—®é¢˜ã€‚åœ¨è®¡ç®—å¤æ‚åº¦åˆ†ç±»ä¸Šï¼Œå®ƒå±äºNP-completeé—®é¢˜ã€‚\nOf course, many of you will notice that what Iâ€™m describing here is simply an instance of the famous theory problem called theÂ graph three-coloringÂ problem. You might also know that what makes this problem interesting is that, for some graphs, it can be quite hard to find a solution, or even to determineÂ ifÂ a solution exists.Â **In fact, graph three-coloring â€” specifically, the decision problem of whether a given graph supports a solution with three colors â€” is known to be in the complexity classÂ NP-complete.\nIt goes without saying that the toy example above is easy to solve by hand. But what if it wasnâ€™t? For example, imagine that my cellular network was very large and complex, so much so that the computing power at my disposalï¼ˆå¤„ç†ï¼‰ was not sufficient to find a solution. In this instance, it would be desirable toÂ outsourceÂ the problem to someone else who has plenty of computing power. For example, I might hire my friends at Google to solve it for me on spec.\nBut this leads to a problem.\nSuppose that Google devotes a large percentage of their computing infrastructure to searching for a valid coloring for my graph. Iâ€™m certainly not going to pay them until I know that they really have such a coloring. At the same time, Google isnâ€™t going to give me a copy of their solution until Iâ€™ve paid up. Weâ€™ll wind up at an impasseï¼ˆåƒµå±€ï¼‰.\nIn real life thereâ€™s probably a common-sense answer to this dilemma, one that involves lawyers and escrowï¼ˆç¬¬ä¸‰æ–¹æ‰˜ç®¡ï¼‰ accounts. But this is not a blog about real life, itâ€™s a blog about cryptography. And if youâ€™ve ever read aÂ crypto paper, youâ€™ll understand that the right way to solve this problem isÂ to dream up an absolutely crazy technical solution.\nA crazy technical solution (with hats!) The engineers at Google consult with Silvio Micali at MIT, who in consultation with his colleaguesÂ Oded Goldreich and Avi Wigderson,Â comes up withÂ the following clever protocol â€” one so elegant that it doesnâ€™t even require any computers. All it requires is a large warehouse, lots of crayonsï¼ˆèœ¡ç¬”ï¼‰, and plenty of paper. Oh yes, and a whole bunch of hats.**\nHereâ€™s how it works.\nFirst I will enter the warehouse, cover the floor with paper, and draw a blank representation of my cell network graph. Then Iâ€™ll exit the warehouse. Google can now enter enter, shuffle a collection of three crayons toÂ pick a random assignment of the three agreed-upon crayon colorsÂ (red/blue/purple, as in the example above), and color in the graph in with their solution. Note that it doesnâ€™t matter which specific crayons they use, only that the coloring is valid.\nBefore leaving the warehouse, Google covers up each of the vertices with a hat. When I come back in, this is what Iâ€™ll see:\nObviously this approach protects Googleâ€™s secret coloring perfectly. But it doesnâ€™t help me at all. For all I know, Google might have filled in the graph with a random, invalid solution. They might not even have colored the graph at all.\nTo address my valid concerns, Google now gives me an opportunity to â€˜challengeâ€™ their solution to the graph coloring*.*Â Iâ€™m allowed to pick â€” at random â€” a single â€˜edgeâ€™ of this graph (that is, one line between two adjacent hats). Google will then remove the two corresponding hats, revealing a small portion of their solution:\nNotice that there are two outcomes to my experiment:\nIf the two revealed vertices are the same color (or arenâ€™t colored in at all!) then I definitely know that Google is lying to me. Clearly Iâ€™m not going to pay Google a cent. If the two revealed vertices are different colors, then GoogleÂ mightÂ notÂ be lying to me. Hopefully the first proposition is obvious. The second one requires a bit more consideration. The problem is thatÂ even after our experiment, Google could still be lying to me â€” after all, I only looked under two of the hats. If there areÂ EÂ different edges in the graph, then Google could fill in an invalidÂ solution and still get away with it most of the time. Specifically, after one test they could succeed in cheating me with probability up to (E-1)/EÂ (which forÂ a 1,000 edge graph works out to 99.9% of the time).\nFortunately Google has an answer to this. Weâ€™ll just run the protocolÂ again!\nWe put down fresh paper with a new, blank copy of the graph.Â Google now picks a new (random) shuffle of the three crayons. Next they fill in the graph with a valid solution, but using the new random ordering of the three colors.\nThe hats go back on. I come back in and repeat the challenge process, picking a new random edge. Once again the logic above applies. Only this time if all goes well, I should now be slightly more confident that Google is telling me the truth. Thatâ€™s because in order to cheat me, Google would have had to get lucky twice in a row. That can happen â€” but it happens with relatively lower probability. The chance that Google fools me twice in a row is now (E-1)/*E **Â (E-1)/EÂ (or about 99.8% probability for our 1,000 edge example above).\nFortunately we donâ€™t have to stop at two challenges. In fact, we can keep trying this over and over again until Iâ€™m confident that Google is probably telling me the truth.\nBut donâ€™t take my word for it. Thanks to some neat Javascript, you canÂ go try it yourself.\nNote that Iâ€™ll never be perfectly certain that Google is being honest â€” thereâ€™s always going to be a tiny probability that theyâ€™re cheating me. But after a large number of iterations (E^2,Â as it happens) I can eventually raise my confidence to the point where Google can only cheat me withÂ negligibleÂ probability â€” low enough thatÂ for all practical purposesÂ itâ€™s not worth worrying about. And then Iâ€™ll be able to safely hand Google my money.\nWhat you need to believe is that Google is alsoÂ protected. Even if I try to learn something about their solution by keeping notes between protocol runs, it shouldnâ€™t matter. Iâ€™m foiled by Googleâ€™s decision toÂ randomizeÂ their color choices between each iteration. The limited information I obtain does me no good, and thereâ€™s no way for me toÂ linkÂ the data I learn between interactions.\næ€»ç»“ä¸€ä¸‹ä¸Šé¢çš„è¿‡ç¨‹ï¼Œé¦–å…ˆæˆ‘è¿›å…¥æˆ¿é—´ï¼Œç”»å‡ºå›¾ï¼Œæ¥ç€Googleè¿›å…¥æˆ¿é—´ï¼Œéšæœºé€‰æ‹©ä¸‰ç§é¢œè‰²ï¼Œæ¶‚ä¸Šè§£æ³•ï¼Œç›–ä¸Šå¸½å­ï¼Œæœ€åæˆ‘å†è¿›å…¥æˆ¿é—´ï¼Œå–ä¸‹ä»»æ„ä¸€ä¸ªè¾¹çš„ä¸¤ä¸ªå¸½å­ï¼Œçœ‹æ˜¯å¦æ˜¯ç›¸åŒé¢œè‰²ã€‚é‡å¤ä¸Šè¿°è¿‡ç¨‹è¶³å¤Ÿå¤šæ¬¡ï¼Œ$E^2$æ¬¡ï¼Œæœ‰ç†ç”±ç›¸ä¿¡Googleæœ‰è§£ï¼Œè€Œæˆ‘æ— æ³•é€šè¿‡è¿™ä¸ªäº¤äº’è¿‡ç¨‹è·å¾—è§£çš„ä¿¡æ¯ã€‚\nWhat makes it â€˜zero knowledgeâ€™? Iâ€™ve claimed to you that this protocol leaks no information about Googleâ€™s solution. But donâ€™t let me get away with this! The first rule of modern cryptography isÂ never to trust peopleÂ who claim such things without proof.\nGoldwasser, Micali and Rackoff proposed three following properties that every zero-knowledge protocol must satisfy. Stated informally, they are:\nCompleteness.Â If Google is telling the truth, then they will eventually convince me (at least with high probability). Soundness.Â Google canÂ onlyÂ convince meÂ ifÂ theyâ€™re actually telling the truth. Zero-knowledgeness.Â (Yes itâ€™s really called this.)Â **IÂ donâ€™t learnÂ anythingÂ elseÂ **about Googleâ€™s solution. é›¶çŸ¥è¯†åè®®éœ€è¦æ»¡è¶³ï¼š\nå®Œå¤‡æ€§ã€‚å¦‚æœGoogleè¯´çš„æ˜¯äº‹å®ï¼Œé‚£ä¹ˆä»–ä»¬æœ€ç»ˆä¼šè¯´æœæˆ‘ã€‚ å¯é æ€§ã€‚åªæœ‰å½“GoogleçœŸçš„è¯´çš„æ˜¯äº‹å®æ—¶æ‰èƒ½è¯´æœæˆ‘ã€‚ é›¶çŸ¥è¯†ã€‚æˆ‘ä¸èƒ½è·å¾—å…³äºGoogle è§£æ³•çš„ä»»ä½•çŸ¥è¯†ã€‚ Weâ€™ve already discussed the argument for completeness. The protocol will eventually convince me (with a negligible error probability), provided we run it enough times. Soundness is also pretty easy to show here. If Google ever tries to cheat me, I will detect their treachery with overwhelming probability.\nå®Œå¤‡æ€§è¯æ˜ï¼šä¸Šè¿°è¿‡ç¨‹å·²ç»è¯æ˜äº†ï¼Œåªè¦äº¤äº’è¿‡ç¨‹é‡å¤çš„æ¬¡æ•°è¶³å¤Ÿå¤šï¼Œæœ€ç»ˆéƒ½ä¼šä»¥ä¸€ä¸ªå¯ä»¥å¿½ç•¥çš„é”™è¯¯æ¦‚ç‡æ¥ä½¿æˆ‘ä¿¡æœã€‚\nå¯é æ€§è¯æ˜ï¼šå¦‚æœGoogleæ¬ºéª—æˆ‘ï¼Œæˆ‘ä¼šæœ‰å‹å€’æ€§çš„æ¦‚ç‡å‘ç°è¿™ä¸€ç‚¹ã€‚\nå‚è€ƒBIUè¯¾ç¨‹ï¼Œå®Œå¤‡æ€§å’Œå¯é æ€§çš„ä¸¥æ ¼å®šä¹‰ã€‚\nThe hard part here is the â€˜zero knowledgenessâ€™ property. To do this, we need to conduct a very strange thought experiment.\nA thought experiment (with time machines) First, letâ€™s start with a crazy hypotheticalï¼ˆå‡è®¾ï¼‰. Imagine that Googleâ€™s engineers arenâ€™t quite as capable as people make them out to be. They work on this problem for weeks and weeks,Â but they never manage to come up with a solution. With twelve hours to go until showtime, the Googlers get desperate. They decide toÂ trickÂ me intoÂ thinkingÂ they have a coloring for the graph, even though they donâ€™t.\nTheir idea is to sneak into the GoogleX workshop and borrow Googleâ€™s prototypeÂ time machine. Initially the plan is to travel backwards a few years and use the extra working time to take another crack at solving the problem. Unfortunately it turns out that, like most Google prototypes, the time machine has some limitations. Most critically: itâ€™s only capable of going backwards in timeÂ four and a half minutes.\nSo using the time machine to manufacture more working time is out. But still, it turns out that even this very limited technology can still be used to trick me.\nI donâ€™t really know whatâ€™s going on herebut it seemed apropos.\nThe plan is diabolicallyï¼ˆéå¸¸ï¼‰ simple. Since GoogleÂ doesnâ€™t actually knowÂ a valid coloring for the graph, theyâ€™ll simply color the paper with a bunch of random colors, then put the hats on. If by sheer luck, I challenge them on a pair of vertices that happen to be different colors, everyone will heave a sigh of relief and weâ€™ll continue with the protocol. So far so good.\nInevitablyï¼ˆä¸å¯é¿å…åœ°ï¼‰, though, Iâ€™m going to pull off a pair of hats and discover two vertices of theÂ sameÂ color. In the normal protocol, Google would now be totally bustedï¼ˆå´©æºƒï¼‰. And this is where the time machine comes in. Whenever Google finds themselves in this awkward situation, they simply fix it. That is, a designated Googler pulls a switch, â€˜rewindsâ€™ time about four minutes, and the Google team recolors the graph with a completely new random solution. Now they let time roll forward and try again.\nIn effect, the time machine allows Google to â€˜repairâ€™ any accidents that happen during their bogusï¼ˆè™šå‡çš„ï¼‰ protocol execution, which makes the experience look totally legitimate to me. Since bad challenge results will occur only 1/3 of the time, the expected runtime of the protocol (from Googleâ€™s perspective) is only moderately greater than the time it takes to run the honest protocol. From my perspective I donâ€™t even know that the extra time machine trips are happening.\nThis last point is the most important. In fact, from my perspective, being unaware that the time machine is in the picture, the resulting interactionÂ is exactly the same as the real thing.Â Itâ€™s statistically identical.Â And yet itâ€™s worth pointing out again that in the time machine version,Â Google has absolutely no information about how to color the graph.\næ€»ç»“ä¸€ä¸‹ï¼ŒGoogleä¸çŸ¥é“å›¾æ¶‚è‰²çš„è§£æ³•ï¼Œä½†æ˜¯ä»–ä»¬æœ‰ç¥å™¨æ—¶é—´æœºå™¨ï¼Œå¯ä»¥å€’é€€å››åˆ†åŠçš„æ—¶é—´ã€‚ å¦‚æœåœ¨äº¤äº’è¿‡ç¨‹ä¸­å¤±è´¥ï¼Œä»–ä»¬å°±ä½¿ç”¨æ—¶é—´æœºå™¨å€’é€€ï¼Œé‡æ–°æ¶‚è‰²ã€‚ ä»æˆ‘çš„è§’åº¦æ¥çœ‹ï¼Œæˆ‘æ²¡æœ‰æ„è¯†åˆ°ä»–ä»¬æœ‰æ—¶é—´æœºå™¨ï¼Œå› æ­¤äº§ç”Ÿçš„äº’åŠ¨å’ŒçœŸå®çš„ä¸œè¥¿å®Œå…¨ä¸€æ ·ï¼Œåœ¨ç»Ÿè®¡ä¸Šæ˜¯ç›¸åŒçš„ã€‚ä½†æ˜¯åœ¨æ—¶é—´æœºå™¨ç‰ˆæœ¬ï¼ŒGoogleå®Œå…¨æ²¡æœ‰æ¶‚è‰²çš„è§£æ³•ã€‚\nBIUè¯¾ç¨‹ä¸­å¯¹HVZKçš„å®šä¹‰ï¼š\nWhat the hell is the point of this? What weâ€™ve just shown is an example of aÂ simulation. Note that in a world where time runs only forward and nobody can trick me with a time machine, the hat-based protocol is correct andÂ sound, meaning that afterÂ E^2Â rounds I should be convinced (with all but negligible probability) that the graph really is colorable and that Google is putting valid inputs into the protocol.\nWhat weâ€™ve just shown is that if time doesnâ€™t run only forward â€” specifically, if Google can â€˜rewindâ€™ my view of time â€” then they can fake a valid protocol runÂ even if they have no information at all about the actual graph coloring.\nFrom my perspective, whatâ€™s the difference between the two protocol transcripts? When we consider the statistical distribution of the two, thereâ€™s no difference at all*.*Â Both convey exactly the same amount of useful information.\nBelieve it or not, this proves something very important.\nSpecifically, assume that I (the Verifier) have some strategy that â€˜extractsâ€™ useful information about Googleâ€™s coloring after observing an execution of the honest protocol. Then my strategy should work equally well in the case where Iâ€™m being fooled with a time machine. The protocol runs are, from my perspective, statistically identical. I physically cannot tell the difference.\nThus if the amount of information I can extract is identical in the â€˜real experimentâ€™ and the â€˜time machine experimentâ€™, yet the amount of information Google puts into the â€˜time machineâ€™ experiment is exactly zero â€” then this implies that even in the real world the protocol must not leak any useful information.\nThus it remains only to show that computer scientists have time machines. We do! (Itâ€™s a well-kept secret.)\næ€»ç»“ï¼šä»æˆ‘çš„è§†è§’æ¥çœ‹ï¼Œä¸¤ä¸ªåè®®æ˜¯æ²¡æœ‰åŒºåˆ«çš„ï¼Œå› ä¸ºå®ƒä»¬åœ¨ç»Ÿè®¡ä¸Šçš„åˆ†å¸ƒæ˜¯ç›¸åŒçš„ï¼Œå®ƒä»¬éƒ½ä¼ è¾¾äº†å®Œå…¨ç›¸åŒæ•°é‡çš„æœ‰ç”¨ä¿¡æ¯ã€‚ å…·ä½“æ¥è¯´ï¼Œå¦‚æœæˆ‘èƒ½åœ¨çœŸå®ä¸–ç•Œä¸­æå–ä¸€äº›æœ‰ç”¨çš„ä¿¡æ¯ï¼Œé‚£ä¹ˆæˆ‘åœ¨æ—¶é—´æœºå™¨ç‰ˆæœ¬ä¸­ä¹Ÿèƒ½æå–æœ‰ç”¨çš„ä¿¡æ¯ï¼Œä½†æ˜¯ç”±äºæ—¶é—´æœºå™¨å®éªŒä¸­çš„ä¿¡æ¯é‡ä¸º0ï¼Œå› æ­¤ä¹Ÿå°±æ„å‘³ç€å³ä½¿æ˜¯åœ¨ç°å®ä¸–ç•Œï¼Œåè®®ä¹Ÿä¸ä¼šæ³„æ¼ä»»ä½•æœ‰ç”¨çš„ä¿¡æ¯ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬çŸ¥é“è®¡ç®—æœºç§‘å­¦å®¶æ‹¥æœ‰æ—¶é—´æœºå™¨ã€‚\nGetting rid of the hats (and time machines) Of course we donâ€™t actually want to run a protocol with hats. And even Google (probably?) doesnâ€™t have a literal time machine.\nTo tie things together, we first need to bring our protocol into the digital world. This requires that we construct the digital equivalent of a â€˜hatâ€™: something that both hides a digital value, while simultaneously â€˜bindingâ€™ (or â€˜committingâ€™) the maker to it, so she canâ€™t change her mind after the fact. è¿™é‡Œè¯´çš„å°±æ˜¯bindingæ€§è´¨ï¼Œæ­éœ²ä¹‹åå€¼å°±å›ºå®šä¸‹æ¥äº†ã€‚\nFortunately we have a perfect tool for this application. Itâ€™s called a digitalÂ commitment scheme.Â A commitment scheme allows one party to â€˜commitâ€™ to a given message while keeping it secret, and then later â€˜openâ€™ the resulting commitment to reveal whatâ€™s inside. They can be built out of various ingredientsï¼ˆç»„æˆéƒ¨åˆ†ï¼‰, including (strong) cryptographic hash functions.******\nè¿™é‡Œç»™å‡ºäº†ä¸€ä¸ªæ•°å­— commitment schemeã€‚\nGiven a commitment scheme, we now have all the ingredients we need to run the zero knowledge protocol electronically. The Prover first encodes its vertex colorings as a set of digital messages (for example, the numbers 0, 1, 2), then generates digital commitments to each one. These commitments get sent over to the Verifier. When the Verifier challenges on an edge, the Prover simply reveals the opening values for the commitments corresponding to the two vertices.\nå…¶å®å°±æ˜¯ç”¨æ•°å­—çš„commitmentæ¥ä»£æ›¿ä¹‹å‰ç‰©ç†ä¸Šçš„å¸½å­ã€‚\nSo weâ€™ve managed to eliminate the hats. But how do we prove that this protocol is zero knowledge?\nFortunately now that weâ€™re in the digital world, we no longer need a real time machine to prove things about this protocol. A key trick is to specify in our setting that the protocol is not going to be run between twoÂ people, but rather between two differentÂ computer programsÂ (or, to be more formal, probabilisticÂ Turing machines.)\nWhat we can now prove is the following theorem: if you could ever come up with a computer program (for the Verifier) that extracts useful information after participating in a run of the protocol, then it would be possible to use a â€˜time machineâ€™ on that program in order to make it extract the same amount of useful information from a â€˜fakeâ€™ run of the protocol where the Prover doesnâ€™t put in any information to begin with.\nAnd since weâ€™re now talking aboutÂ computer programs, it should be obvious that rewinding time isnâ€™t such an extraordinary feat at all. In fact, we rewind computer programs all the time. For example, consider usingÂ virtual machine software with a snapshot capability.\nExample of rewinding through VM snapshots. An initial VM is played forward, rewound to aninitial snapshot, then execution is forked to a new path.\nEven if you donâ€™t have fancy virtual machine software, any computer program can be â€˜rewoundâ€™ to an earlier state, simply by starting the program over again from the beginning and feeding it exactly the same inputs. Provided that the inputs â€” including all random numbers â€” are fixed, the program will always follow the same execution path. Thus you can rewind a program just by running it from the start and â€˜forkingâ€™ its execution when it reaches some desired point.\nUltimately what we get is the following theorem. If there exists any Verifier computer program that successfully extracts information by interactively running this protocol with some Prover, then we can simply use the rewinding trick on that program to commit to a random solution, then â€˜trickâ€™ the Verifier by rewinding its execution whenever we canâ€™t answer its challenge correctly. The same logic holds as we gave above: if such a Verifier succeeds in extracting information after running the real protocol, then it should be able to extract theÂ same amount of informationÂ from the simulated, rewinding-based protocol. But since thereâ€™s no information going into the simulated protocol, thereâ€™s no information to extract. Thus the information the Verifier can extract must always be zero.\nOk, so what does this all mean? So letâ€™s recap. We know that the protocol is complete and sound, based on our analysis above. The soundness argument holds in any situation where we know that nobody is fiddlingï¼ˆæ— è¶³è½»é‡åœ°ï¼‰ with time â€” that is, the Verifier is running normally and nobody is rewinding its execution.\nAt the same time, the protocol is also zero knowledge. To prove this, we showed that any Verifier program that succeeds in extracting information must also be able to extract information from a protocol run where rewinding is used andÂ no information is available in the first place.Â Which leads to an obvious contradictionï¼ˆçŸ›ç›¾ï¼‰, and tells us that the protocol canâ€™t leak information in either situation.\nåŒæ—¶åè®®ä¹Ÿæ˜¯é›¶çŸ¥è¯†çš„ã€‚ä¸ºäº†è¯æ˜è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å·²ç»å±•ç¤ºäº†ä»»ä½•èƒ½å¤ŸæˆåŠŸæå–ä¿¡æ¯çš„éªŒè¯ç¨‹åºä¹Ÿå¿…é¡»åœ¨ä½¿ç”¨äº†rewindingè¶…èƒ½åŠ›çš„åè®®ä¸­æˆåŠŸæå–ä¿¡æ¯ï¼Œä½†æ˜¯è¿™ä¸ªåè®®æ˜¯ä¸èƒ½è·å–åˆ°ä»»ä½•çŸ¥è¯†çš„ã€‚è¿™ä¹Ÿå°±å‘Šè¯‰äº†æˆ‘ä»¬åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹éƒ½æ²¡æœ‰æ³„æ¼çŸ¥è¯†ã€‚\nThereâ€™s an important benefit to all this. Since itâ€™s trivial for anyone to â€˜fakeâ€™ a protocol transcript, even after Google proves to me that they have a solution, I canâ€™t re-play a recording of the protocol transcript to prove anything to anyone else (say, a judge). Thatâ€™s because the judge would have no guarantee that the video was recorded honestly, and that I didnâ€™t simplyÂ editÂ in the same way Google might have done using the time machine. This means that protocol transcripts themselves contain no information. The protocol is only meaningful if I myself participated, and I can be sure that it happened in real time.\næ¨¡æ‹Ÿçš„å’ŒçœŸå®çš„æ˜¯æ— æ³•åœ¨çœŸå®ä¸–ç•Œä¸­è¿›è¡ŒåŒºåˆ†çš„ï¼Œæ‰€ä»¥åªæœ‰å½“æˆ‘å‚ä¸è¿›å»çš„æ—¶å€™ï¼Œåè®®æ‰æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå¹¶ä¸”æˆ‘èƒ½ç¡®ä¿å®åœ¨çœŸå®æ—¶é—´ä¸­å‘ç”Ÿçš„ã€‚\nProofs for all of NP! If youâ€™ve made it this far, Iâ€™m pretty sure youâ€™re ready for the big news. Which is that 3-coloring cellphone networks isnâ€™t all that interesting of a problem â€” at least, not in and of itself.\nThe really interesting thing about the 3-coloring problem is that itâ€™s in the classÂ NP-complete. To put this informally, the wonderful thing about such problems is thatÂ any other problem in the classÂ NPÂ can be translated into an instance of that problem.In a single stroke, this result â€”Â due toÂ Goldreich, Micali and WigdersonÂ â€” proves that â€˜efficientâ€™ ZK proofs exists for a vast class of useful statements, many of which areÂ way moreÂ interesting than assigning frequencies to cellular networks. You simply find a statement (in NP) that you wish to prove, such as our hash function example from above, then translate it into an instance of the 3-coloring problem. At that point you simply run the digital version of the hat protocol.\nä¸‰æ¶‚è‰²é—®é¢˜æ˜¯NPCé—®é¢˜ï¼Œé‚£ä¹ˆå¯¹äºä¸€ä¸ªæƒ³è¦è¯æ˜çš„NPé—®é¢˜ï¼Œéƒ½å¯ä»¥å½’çº¦åˆ°è¿™ä¸ªNPCé—®é¢˜ï¼Œç„¶åè½¬åŒ–æˆä¸‰æ¶‚è‰²é—®é¢˜ï¼Œç”¨ä¸Šé¢çš„æ•°å­—åè®®è¿›è¡Œè¿è¡Œå°±å¯ä»¥äº†ã€‚\nIn summary, and next time Of course, actually running this protocol for interesting statements would be an insanelyï¼ˆç–¯ç‹‚åœ°ï¼‰ silly thing for anyone to do, since the cost of doing so would include the total size of the original statement and witness, plus the reduction cost to convert it into a graph, plus theÂ $E^2$Â protocol rounds youâ€™d have to conduct in order to convince someone that the proof is valid. Theoretically this is â€˜efficientâ€™, since the total cost of the proof would be polynomial in the input size, but in practice it would be anything but.\nç†è®ºä¸Šä¸Šé¢çš„ä¸‰è‰²é—®é¢˜çš„é›¶çŸ¥è¯†è¯æ˜åè®®æ˜¯â€œefficentâ€ï¼Œä½†æ˜¯ä¸å®ç”¨ã€‚\nSo what weâ€™ve shown so far is that such proofs areÂ possible. It remains for us to actually find proofs that are practical enough for real-world use.\nIn theÂ next postÂ Iâ€™ll talk about some of those â€” specifically, theÂ efficientÂ proofs that we use for various useful statements. Iâ€™ll give some examples (from real applications) where these things have been used. Also at reader request: Iâ€™ll also talk about why I dislikeÂ SRPÂ so much.\nSeeÂ hereÂ for Part 2.\nNotes:\nFormally, the goal of an interactive proof is to convince the Verifier that a particular string belongs to some language. Typically the Prover is very powerful (unbounded), but the Verifier is limited in computation. * This example is based on the original solution of Goldwasser, Micali and Rackoff, and the teaching example using hats is based on an explanation by Silvio Micali. I take credit only for the silly mistakes. ***** A simple example of a commitment can be built using a hash function. To commit to the value â€œxâ€ simply generate some (suitably long) string of random numbers, which weâ€™ll call â€˜saltâ€™, and output the commitmentÂ C = Hash(salt || x). To open the commitment, you simply reveal â€˜xâ€™ and â€˜saltâ€™. Anyone can check that the original commitment is valid by recomputing the hash. This is secure under some (moderately strong) assumptions about the function itself. ","date":"2022-11-16T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-11-16-Zero-Knowledge-Proofs-An-illustrated-primer/background.jpg","permalink":"https://wenjin1997.github.io/2022/11/16/Zero-Knowledge-Proofs-An-illustrated-primer/","title":"Zero Knowledge Proofs: An illustratedÂ primer"},{"content":"å¼‚æ­¥Webæ¡†æ¶ç”Ÿæ€ Rocket tide warp tower-web Thruster gotham actix-web ntex axum Rocketæ¡†æ¶ å®˜æ–¹æ•™ç¨‹ï¼šThe Rocket Programming Guide\nRocketè®¾è®¡æ ¸å¿ƒå“²å­¦ï¼š\nSecurity, correctness, and developer experience are paramount. All request handling information should be typed and self-contained. Decisions should not be forced. Lifecycle\nRocket\u0026rsquo;s main task is to listen for incoming web requests, dispatch the request to the application code, and return a response to the client. We call the process that goes from request to response the \u0026ldquo;lifecycle\u0026rdquo;. We summarize the lifecycle as the following sequence of steps:\nRouting è·¯ç”± Validation éªŒè¯ Processing å¤„ç† Response å›å¤ 1 2 3 4 #[get(\u0026#34;/world\u0026#34;)] // \u0026lt;- route attribute fn world() -\u0026gt; \u0026amp;\u0026#39;static str { // \u0026lt;- request handler \u0026#34;hello, world!\u0026#34; } Lanuching\nRocket begins serving requests after being launched, which starts a multi-threaded asynchronous server and dispatches requests to matching routes as they arrive.\n1 2 3 4 5 6 7 8 9 10 11 #[macro_use] extern crate rocket; #[get(\u0026#34;/world\u0026#34;)] fn world() -\u0026gt; \u0026amp;\u0026#39;static str { \u0026#34;Hello, world!\u0026#34; } #[launch] fn rocket() -\u0026gt; _ { rocket::build().mount(\u0026#34;/hello\u0026#34;, routes![world]) } Dynamic Paths\n1 2 3 4 #[get(\u0026#34;/hello/\u0026lt;name\u0026gt;\u0026#34;)] fn hello(name: \u0026amp;str) -\u0026gt; String { format!(\u0026#34;Hello, {}!\u0026#34;, name) } Forwarding\nRoutes are attempted in increasing rank order. Rocket chooses a default ranking from -12 to -1, detailed in the next section, but a route\u0026rsquo;s rank can also be manually set with the rank attribute. To illustrate, consider the following routes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[get(\u0026#34;/user/\u0026lt;id\u0026gt;\u0026#34;)] fn user(id: usize) { /* ... */ } #[get(\u0026#34;/user/\u0026lt;id\u0026gt;\u0026#34;, rank = 2)] fn user_int(id: isize) { /* ... */ } #[get(\u0026#34;/user/\u0026lt;id\u0026gt;\u0026#34;, rank = 3)] fn user_str(id: \u0026amp;str) { /* ... */ } #[launch] fn rocket() -\u0026gt; _ { rocket::build().mount(\u0026#34;/\u0026#34;, routes![user, user_int, user_str]) } actix-web å®˜æ–¹æ–‡æ¡£ï¼šactix_web\nå¯ä»¥é€šè¿‡å®æ¥åˆ›å»ºæå–å™¨ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use actix_web::{get, web, App, HttpServer, Responder}; #[get(\u0026#34;/hello/{name}\u0026#34;)] async fn greet(name: web::Path\u0026lt;String\u0026gt;) -\u0026gt; impl Responder { format!(\u0026#34;Hello {}!\u0026#34;, name) } #[actix_web::main] // or #[tokio::main] async fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { HttpServer::new(|| { App::new().service(greet) }) .bind((\u0026#34;127.0.0.1\u0026#34;, 8080))? .run() .await } å…¶ä»–\nLemmyè®ºå› actix-extrasï¼šactixä¸­é—´ä»¶ actix-webåº•å±‚åŸºäºactix-netä¸­é—´åº“ï¼Œå°è£…äº†å’Œç½‘ç»œç›¸å…³çš„ä¸œè¥¿ã€‚\nåœ¨actix-net/actix-rt/src/arbiter.rsä¸‹æ¯ä¸ªarbiterå¯¹åº”ä¸€ä¸ªçº¿ç¨‹ã€‚\ngotham æ¯”è¾ƒæ—©çš„æ¡†æ¶ï¼ŒåŸºäºtokioå®ç°ã€‚\nThruster æ„å»ºäºhyperä¹‹ä¸Šï¼Œè¿™ä¸ªä¸­é—´ä»¶åœ¨è¯·æ±‚è¿‡ç¨‹ä¸­è®¾ç½®ä¸Šä¸‹æ–‡ã€‚\ntower æ–‡æ¡£ï¼š tower\nTower is a library of modular and reusable components for building robust networking clients and servers.\nhyper å®˜æ–¹æ–‡æ¡£ï¼šhyper\nå…³äºè·¯ç”±ç”¨åˆ°route-recognizerï¼Œå®ƒçš„åº•å±‚æ˜¯éç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºã€‚\nwarp githubä»“åº“åœ°å€ï¼šwarpã€‚\nfilterçš„å·¥ä½œæœºåˆ¶ï¼ŒåŸºäºhyperã€‚Rust-Warp-Exampleæ˜¯ä¸€ä¸ªåº”ç”¨å®ä¾‹ã€‚\nä¸€äº›åº•å±‚çš„åº“ httpï¼šè§£æå¤„ç†HTTPåè®®ï¼Œå¯¹httpè¯·æ±‚å’Œå“åº”åšäº†ä¸€ä¸ªç±»å‹æŠ½è±¡ã€‚ http-bodyï¼šåšå¼‚æ­¥httpè¯·æ±‚å’Œå“åº”ã€‚ http-typesï¼šåŸºäºasync-stdã€‚ tower-httpï¼šåŸºäºtowerã€httpã€http-bodyã€çš„ä¸­é—´ä»¶ã€‚ hyperï¼šHTTPçš„å®ç°ï¼Œæ²¡æœ‰æ•´åˆtower-httpã€‚ Rustå¼‚æ­¥Webæ¡†æ¶ ç»“æ„ï¼š\næ¡†æ¶æ¥å£è®¾è®¡ è·¯ç”±ç»“æ„å®ç° å®ç°Handler æ·»åŠ tracingæ‰“å°æ—¥å¿— å®ç°æå–å™¨ å®ç°ä¸­é—´ä»¶ é”™è¯¯å¤„ç† è¡¥å……å­¦ä¹  æ­£åˆ™è¡¨è¾¾å¼ Cow and_thenã€and dyn pinã€unpin Oneshot pin_project! ç½‘ç»œä¸­çš„è¯·æ±‚æ–¹æ³•æœ‰å“ªäº›ï¼ŸåŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ Any ç»ˆç«¯å‘½ä»¤ curlï¼Œå‚è€ƒLinux curlå‘½ä»¤è¯¦è§£ DSLæ˜¯ä»€ä¹ˆï¼Ÿå‚è€ƒè°ˆè°ˆ DSL ä»¥åŠ DSL çš„åº”ç”¨ï¼ˆä»¥ CocoaPods ä¸ºä¾‹ï¼‰ uri async_trait mapã€map_err curl http://... -I -HEAD tower é˜…è¯»axumæºç  kv-serve å’Œ web å¦‚ä½•è¿æ¥åœ¨ä¸€èµ·ï¼Ÿ å‚è€ƒèµ„æ–™ å¼ æ±‰ä¸œçš„Rustå®æˆ˜è¯¾\nå¼ æ±‰ä¸œçš„Rustå®æˆ˜è¯¾è§†é¢‘è¯¾ç¨‹ä»£ç ç¤ºä¾‹\n","date":"2022-08-23T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/08/23/rust-web/","title":"Rustå¼‚æ­¥Webæ¡†æ¶"},{"content":"åœ¨macæœ¬åœ°æ‰“å¼€ç»ˆç«¯ï¼Œåˆ›å»ºå¯†é’¥å¯¹ã€‚\n1 ssh-keygen -t rsa -C \u0026#39;your email@domain.com\u0026#39; -t æŒ‡å®šå¯†é’¥ç±»å‹ï¼Œé»˜è®¤å³ rsa ï¼Œå¯ä»¥çœç•¥ -C è®¾ç½®æ³¨é‡Šæ–‡å­—ï¼Œæ¯”å¦‚ä½ çš„é‚®ç®±ï¼Œå¯ä»¥çœç•¥\næ¥ç€å°±æŒ‰å›è½¦ï¼Œå¦‚æœå‘ç°ä¹‹å‰çš„ id_rsa æ–‡ä»¶éœ€è¦è¦†ç›–ï¼Œåˆ™å¯ä»¥å¦å¤–åˆ›å»ºæ–‡ä»¶å­˜å‚¨å¯†é’¥ã€‚\n1 Enter file in which to save the key (/Users/zheng/.ssh/id_rsa): linux_id_rsa æ¥ç€åœ¨ç”¨æˆ·æ–‡ä»¶å¤¹ä¸‹èƒ½æ‰¾åˆ° linux_id_rsa å’Œ linux_id_rsa.pub è¿™ä¸¤ä¸ªæ–‡ä»¶ï¼Œå°†å®ƒä»¬å¤åˆ¶åˆ° /.ssh ç›®å½•ä¸‹ã€‚\nä¸‹é¢å°†ç”Ÿæˆçš„å…¬é’¥å¤åˆ¶åˆ°æœåŠ¡å™¨ï¼Œå°±æ˜¯å°†macæœ¬åœ°çš„ linux_id_rsa.pub ä¸­çš„å†…å®¹å¤åˆ¶åˆ°æœåŠ¡å™¨ä¸Š ~/.ssh/authorized_keys æ–‡ä»¶ä¸­ã€‚æˆ‘è¿™é‡Œæ²¡æœ‰ç”¨å‘½ä»¤ï¼Œç›´æ¥ç”¨é¢æ¿å¤åˆ¶è¿‡å»ï¼Œä¹Ÿå¯ä»¥ç”¨ scp å‘½ä»¤ã€‚\næ¥ç€é…ç½®æœ¬åœ°~/.ssh/config æ–‡ä»¶ï¼Œå› ä¸ºæˆ‘ä»¬çš„æ˜¯ linux_id_rsa æ–‡ä»¶ã€‚\n1 2 3 4 5 Host alias #è‡ªå®šä¹‰åˆ«å HostName hostname #æ›¿æ¢ä¸ºä½ çš„sshæœåŠ¡å™¨ipæˆ–domain Port port #sshæœåŠ¡å™¨ç«¯å£ï¼Œé»˜è®¤ä¸º22 User user #sshæœåŠ¡å™¨ç”¨æˆ·å IdentityFile ~/.ssh/linux_id_rsa #ç¬¬ä¸€ä¸ªæ­¥éª¤ç”Ÿæˆçš„å…¬é’¥æ–‡ä»¶å¯¹åº”çš„ç§é’¥æ–‡ä»¶ æœ¬æ¥ç™»å½•å‘½ä»¤æ˜¯ï¼š\n1 ssh -p \u0026lt;ç«¯å£å·\u0026gt; \u0026lt;ç”¨æˆ·å\u0026gt;@\u0026lt;ipåœ°å€\u0026gt; ç°åœ¨ç›´æ¥ç”¨åˆ«åå°±å¯ä»¥ç™»å½•äº†ã€‚\n1 ssh alias å‚è€ƒèµ„æ–™ Macä½¿ç”¨sshå¯†é’¥ç™»å½•Linux è®¾ç½® SSH é€šè¿‡å¯†é’¥ç™»å½• githubç”Ÿæˆå¤šä¸ªssh keyï¼Œå¦‚ä½•è§£å†³ ","date":"2022-08-01T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/08/01/Linux-ssh/","title":"Macç”¨sshè¿œç¨‹è¿æ¥æœåŠ¡å™¨"},{"content":"Rustdocï¼šä½ å¯ä»¥ç”¨å®ƒåšä»€ä¹ˆï¼Œä»¥åŠå®ƒçš„æœªæ¥ Rust è®¡ç®—åŠ é€ŸæŠ€æœ¯è§£è¯»åŠé«˜æ€§èƒ½ä»£ç é‡æ„å®è·µ ä»é›¶å¼€å§‹å®ç°Rust Fuzzerä»é›¶å¼€å§‹å®ç°Rust Fuzzer å¤æ‚ Rust å¼€æºé¡¹ç›®çš„ç»´æŠ¤ åŸºäºLLVM Rustä»£ç æ··æ·†è®¾è®¡ä¸å®ç° Rust APIå¯é æ€§åˆ†æä¸éªŒè¯ ä½ ä¸ºä»€ä¹ˆéœ€è¦ã€ŒRust ç¼–ç è§„èŒƒã€ ","date":"2022-07-07T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/31/RustChinaConf/","title":"Rustå¼€å‘è€…å¤§ä¼š"},{"content":"æœ¬ç« è‡³ä¸‹è€Œä¸Šçš„æ–¹å¼æ¥å¸¦é¢†å¤§å®¶ç†è§£å¼‚æ­¥ç¼–ç¨‹:\nå¼‚æ­¥ I/O æ¨¡å‹ å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ï¼š äº‹ä»¶é©±åŠ¨æ¨¡å‹ Futures ç”Ÿæˆå™¨ ä¸ Pin async/await å¼‚æ­¥è¿è¡Œæ—¶ä»‹ç»ï¼šasync-stdã€tokioã€bastionã€smol å¼‚æ­¥IOæ¨¡å‹ åŸºæœ¬æ¦‚å¿µ åŒæ­¥å’Œå¼‚æ­¥ï¼Œå…³æ³¨çš„æ˜¯æ¶ˆæ¯é€šä¿¡æœºåˆ¶ã€‚ï¼ˆè°ƒç”¨è€…è§†è§’ï¼‰ç»“åˆçƒ§å¼€æ°´çš„ä¾‹å­ã€‚ åŒæ­¥ï¼Œå‘å‡ºä¸€ä¸ªè°ƒç”¨ï¼Œåœ¨æ²¡æœ‰å¾—åˆ°ç»“æœä¹‹å‰ä¸è¿”å›ã€‚æ°´æ²¡çƒ§å¥½ä¸ç¦»å¼€ã€‚ å¼‚æ­¥ï¼Œå‘å‡ºä¸€ä¸ªè°ƒç”¨ï¼Œåœ¨æ²¡æœ‰å¾—åˆ°ç»“æœä¹‹å‰è¿”å›ã€‚æ°´æ²¡çƒ§å¥½æ—¶ï¼Œå¯ä»¥å…ˆå»å¹²åˆ«çš„ã€‚ é˜»å¡å’Œéé˜»å¡ï¼Œå…³æ³¨çš„æ˜¯ç¨‹åºç­‰å¾…è°ƒç”¨ç»“æœçš„çŠ¶æ€ã€‚ï¼ˆè¢«è°ƒç”¨è€…è§†è§’ï¼‰ é˜»å¡ï¼Œåœ¨è°ƒç”¨ç»“æœè¿”å›ä¹‹å‰ï¼Œçº¿ç¨‹è¢«æŒ‚èµ·ã€‚ éé˜»å¡ï¼Œåœ¨è°ƒç”¨ç»“æœè¿”å›ä¹‹å‰ï¼Œçº¿ç¨‹ä¸ä¼šè¢«æŒ‚èµ·ã€‚ é˜»å¡ï¼Œä¸ç³»ç»Ÿè°ƒç”¨æœ‰å…³ã€‚\nI/Oæ¨¡å‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 +-+ é˜» å¡ I/O (BIO) | +-+ é é˜» å¡ I/O (NIO) | +----+ åŒ æ­¥ I/O +--+ | | | +-+ I/O å¤š è·¯ å¤ ç”¨ | | | +-+ ä¿¡ å· é©± åŠ¨ I/O I/O æ¨¡ å‹ +---+ | | | +-+ Linux (AIO) | | (io_uring) +----+ å¼‚ æ­¥ I/O +--+ | +-+ windows (IOCP) åŒæ­¥é˜»å¡I/O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Application kernel +---------+ +-----------+ +---+ | | syscall | no | | | Read | +--------\u0026gt; | datagram | | | recvfrom| | ready | | | | | + | +-+ wait for | | | | | +-+ data | | | v | | | | | datagram | | | | | ready | +---+ | | | | | | | copy | +---+ | | | datagram | | |process | | + | +-+ copy data |datagram | return | | | +-+ from kernel to user | | \u0026lt;--------+ | v | | | | | copy | +---+ | | | complete | +---------+ +-----------+ è¾“å…¥æ“ä½œä¸¤ä¸ªé˜¶æ®µï¼š\nè¿›ç¨‹ç­‰å¾…å†…æ ¸æŠŠæ•°æ®å‡†å¤‡å¥½ï¼›è¿™ä¸ªé˜¶æ®µå¯ä»¥é˜»å¡ä¹Ÿå¯éé˜»å¡ï¼Œè®¾ç½®socketå±æ€§ã€‚ é˜»å¡ï¼š recvfrom é˜»å¡çº¿ç¨‹ç›´åˆ°è¿”å›æ•°æ®å°±ç»ªçš„ç»“æœã€‚ éé˜»å¡ï¼šç«‹å³è¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œè½®è¯¢ç›´åˆ°æ•°æ®å°±ç»ªã€‚ ä»å†…æ ¸ç¼“å†²åŒºå‘è¿›ç¨‹ç¼“å†²åŒºå¤åˆ¶æ•°æ®ã€‚ï¼ˆä¸€ç›´é˜»å¡ï¼‰ å¼‚æ­¥I/Oï¼Œrecvfromæ€»æ˜¯ç«‹å³è¿”å›ï¼Œä¸¤ä¸ªé˜¶æ®µéƒ½ç”±å†…æ ¸å®Œæˆã€‚\nI/Oå¤šè·¯å¤ç”¨ IOå¤šè·¯å¤ç”¨æ˜¯ä¸€ç§åŒæ­¥IOæ¨¡å‹ï¼Œå®ç°ä¸€ä¸ªçº¿ç¨‹å¯ä»¥ç›‘è§†å¤šä¸ªæ–‡ä»¶å¥æŸ„ã€‚\næ”¯æŒI/Oå¤šè·¯å¤ç”¨çš„ç³»ç»Ÿè°ƒç”¨æœ‰ select/pselect/poll/epollï¼Œæœ¬è´¨éƒ½æ˜¯ åŒæ­¥ I/Oï¼Œå› ä¸ºæ•°æ®æ‹·è´éƒ½æ˜¯é˜»å¡çš„ã€‚ é€šè¿‡ select/epoll æ¥åˆ¤æ–­æ•°æ®æŠ¥æ˜¯å¦å‡†å¤‡å¥½ï¼Œå³åˆ¤æ–­å¯è¯»å¯å†™çŠ¶æ€ã€‚\nè¡¥å……èµ„æ–™ I/Oæ¨¡å‹å’ŒI/Oè°ƒç”¨æ˜¯ä¸æ˜¯åˆ†ä¸æ¸…æ¥šï¼Œå‚è€ƒç†è§£ä¸€ä¸‹5ç§IOæ¨¡å‹ã€é˜»å¡IOå’Œéé˜»å¡IOã€åŒæ­¥IOå’Œå¼‚æ­¥IOã€‚\nå…ˆç†è§£ä»€ä¹ˆæ˜¯IOï¼š\nè¦è¾“å…¥è¾“å‡ºæ•°æ®åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼šç”¨æˆ·è¿›ç¨‹ç©ºé—´\u0026lt;\u0026ndash;\u0026gt;å†…æ ¸ç©ºé—´ã€å†…æ ¸ç©ºé—´\u0026lt;\u0026ndash;\u0026gt;è®¾å¤‡ç©ºé—´ï¼ˆç£ç›˜ã€ç½‘ç»œç­‰ï¼‰ã€‚\né˜»å¡IOæ¨¡å‹\nè¿›ç¨‹å‘èµ·IOç³»ç»Ÿè°ƒç”¨åï¼Œè¿›ç¨‹è¢«é˜»å¡ï¼Œè½¬åˆ°å†…æ ¸ç©ºé—´å¤„ç†ï¼Œæ•´ä¸ªIOå¤„ç†å®Œæ¯•åè¿”å›è¿›ç¨‹ã€‚æ“ä½œæˆåŠŸåˆ™è¿›ç¨‹è·å–åˆ°æ•°æ®ã€‚\néé˜»å¡IOæ¨¡å‹\nè¿›ç¨‹å‘èµ·IOç³»ç»Ÿè°ƒç”¨åï¼Œå¦‚æœå†…æ ¸ç¼“å†²åŒºæ²¡æœ‰æ•°æ®ï¼Œéœ€è¦åˆ°IOè®¾å¤‡ä¸­è¯»å–ï¼Œè¿›ç¨‹è¿”å›ä¸€ä¸ªé”™è¯¯è€Œä¸ä¼šè¢«é˜»å¡ï¼›è¿›ç¨‹å‘èµ·IOç³»ç»Ÿè°ƒç”¨åï¼Œå¦‚æœå†…æ ¸ç¼“å†²åŒºæœ‰æ•°æ®ï¼Œå†…æ ¸å°±ä¼šæŠŠæ•°æ®è¿”å›è¿›ç¨‹ã€‚\nIOå¤ç”¨æ¨¡å‹\nå¤šä¸ªè¿›ç¨‹çš„IOå¯ä»¥æ³¨å†Œåˆ°ä¸€ä¸ªå¤ç”¨å™¨ï¼ˆselectï¼‰ä¸Šï¼Œç„¶åç”¨ä¸€ä¸ªè¿›ç¨‹è°ƒç”¨è¯¥selectï¼Œselectä¼šç›‘å¬æ‰€æœ‰æ³¨å†Œè¿›æ¥çš„IOï¼›\nå¦‚æœselectæ²¡æœ‰ç›‘å¬çš„IOåœ¨å†…æ ¸ç¼“å†²åŒºéƒ½æ²¡æœ‰å¯è¯»æ•°æ®ï¼Œselectè°ƒç”¨è¿›ç¨‹ä¼šè¢«é˜»å¡ï¼›è€Œå½“ä»»ä¸€IOåœ¨å†…æ ¸ç¼“å†²åŒºä¸­æœ‰å¯ç”¨æ•°æ®æ—¶ï¼Œselectè°ƒç”¨å°±ä¼šè¿”å›ï¼›\nè€Œåselectè°ƒç”¨è¿›ç¨‹å¯ä»¥è‡ªå·±æˆ–é€šçŸ¥å¦å¤–çš„è¿›ç¨‹ï¼ˆæ³¨å†Œè¿›ç¨‹ï¼‰æ¥å†æ¬¡å‘èµ·è¯»å–IOï¼Œè¯»å–å†…æ ¸ä¸­å‡†å¤‡å¥½çš„æ•°æ®ã€‚\nselectã€pollã€epoll\nLinuxä¸­IOå¤ç”¨çš„å®ç°æ–¹å¼ä¸»è¦æœ‰selectã€pollå’Œepollã€‚ Select: æ³¨å†ŒIOã€é˜»å¡æ‰«æï¼Œç›‘å¬çš„IOæœ€å¤§è¿æ¥æ•°ä¸èƒ½å¤šäºFD_SIZEã€‚ Poll: åŸç†å’ŒSelectç›¸ä¼¼ï¼Œæ²¡æœ‰æ•°é‡é™åˆ¶ï¼Œä½†IOæ•°é‡å¤§æ‰«æçº¿æ€§æ€§èƒ½ä¸‹é™ã€‚ Epollï¼šäº‹ä»¶é©±åŠ¨ä¸é˜»å¡ï¼Œmmapå®ç°å†…æ ¸ä¸ç”¨æˆ·ç©ºé—´çš„æ¶ˆæ¯ä¼ é€’ï¼Œæ•°é‡å¾ˆå¤§ï¼ŒLinux2.6åå†…æ ¸æ”¯æŒã€‚ ä¿¡å·é©±åŠ¨IOæ¨¡å‹\nå½“è¿›ç¨‹å‘èµ·ä¸€ä¸ªIOæ“ä½œï¼Œä¼šå‘å†…æ ¸æ³¨å†Œä¸€ä¸ªä¿¡å·å¤„ç†å‡½æ•°ï¼Œç„¶åè¿›ç¨‹è¿”å›ä¸é˜»å¡ï¼›å½“å†…æ ¸æ•°æ®å°±ç»ªæ—¶ä¼šå‘ç”Ÿä¸€ä¸ªä¿¡å·ç»™è¿›ç¨‹ï¼Œè¿›ç¨‹ä¾¿åœ¨ä¿¡å·å¤„ç†å‡½æ•°ä¸­è°ƒç”¨IOè¯»å–æ•°æ®ã€‚\nç‰¹ç‚¹ï¼šå›è°ƒæœºåˆ¶ï¼Œå®ç°ã€å¼€å‘åº”ç”¨éš¾åº¦å¤§ã€‚\nå¼‚æ­¥IOæ¨¡å‹\nå½“è¿›ç¨‹å‘èµ·ä¸€ä¸ªIOæ“ä½œï¼Œè¿›ç¨‹è¿”å›ï¼ˆä¸é˜»å¡ï¼‰ï¼Œä½†ä¹Ÿä¸èƒ½è¿”å›ç»“æœï¼›å†…æ ¸æŠŠæ•´ä¸ªIOå¤„ç†å®Œåï¼Œä¼šé€šçŸ¥è¿›ç¨‹ç»“æœã€‚å¦‚æœIOæ“ä½œæˆåŠŸåˆ™è¿›ç¨‹ç›´æ¥è·å–åˆ°æ•°æ®ã€‚\nä¸€å›¾æ€»ç»“ï¼š\nepoll 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 +--------------------------------+ +-------------------------+ | epoll_ctl | | epoll_wait | | | | | | | | +----+ | | +---+ | | | | | | | | | | | | | | +-+---+--+ | | +--+-+ | | | | | | | | | +--++ +-++ | | | | epoll_create +----\u0026gt; | | | | | | | +--+-+ | | +-+-+ +--+ +----\u0026gt;+ | | | | | |event| | | | | +----+--+ | | +--+-+ | | | | | | | | | ++ | | | | | | +--+ +-+-+ | | +--+-+ | | | | | | | | | | | | +--+ +---+ | | | | | | | | +----+ | | çº¢ é»‘ æ ‘ | | é“¾ è¡¨ | +--------------------------------+ +-------------------------+ epoll_create(int size) : å†…æ ¸äº§ç”Ÿä¸€ä¸ªepollå®ä¾‹æ•°æ®ç»“æ„ï¼Œå¹¶è¿”å›ä¸€ä¸ªepfd epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)ï¼šå°†è¢«ç›‘å¬çš„æè¿°ç¬¦æ·»åŠ åˆ°çº¢é»‘æ ‘æˆ–ä»çº¢é»‘æ ‘ä¸­åˆ é™¤æˆ–è€…å¯¹ç›‘å¬äº‹ä»¶è¿›è¡Œä¿®æ”¹ã€‚ epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout): é˜»å¡ç­‰å¾…æ³¨å†Œçš„äº‹ä»¶å‘ç”Ÿï¼Œè¿”å›äº‹ä»¶çš„æ•°ç›®ï¼Œå¹¶å°†è§¦å‘çš„äº‹ä»¶å†™å…¥eventsæ•°ç»„ä¸­ epoll ä¸¤ç§è§¦å‘æœºåˆ¶ï¼š\næ°´å¹³è§¦å‘æœºåˆ¶ï¼ˆLT)ã€‚ç¼“å†²åŒºåªè¦æœ‰æ•°æ®å°±è§¦å‘è¯»å†™ã€‚epoll é»˜è®¤å·¥ä½œæ–¹å¼ã€‚select/pollåªæ”¯æŒè¯¥æ–¹å¼ã€‚ è¾¹ç¼˜è§¦å‘æœºåˆ¶ï¼ˆET)ã€‚ç¼“å†²åŒºç©ºæˆ–æ»¡çš„çŠ¶æ€æ‰è§¦å‘è¯»å†™ã€‚nginx ä½¿ç”¨è¯¥æ–¹å¼ï¼Œé¿å…é¢‘ç¹è¯»å†™ã€‚ æƒŠç¾¤é—®é¢˜ï¼š\nå½“å¤šä¸ªè¿›ç¨‹/çº¿ç¨‹è°ƒç”¨epoll_waitæ—¶ä¼šé˜»å¡ç­‰å¾…ï¼Œå½“å†…æ ¸è§¦å‘å¯è¯»å†™äº‹ä»¶ï¼Œæ‰€æœ‰è¿›ç¨‹/çº¿ç¨‹éƒ½ä¼šè¿›è¡Œå“åº”ï¼Œä½†æ˜¯å®é™…ä¸Šåªæœ‰ä¸€ä¸ªè¿›ç¨‹/çº¿ç¨‹çœŸå®å¤„ç†è¿™äº›äº‹ä»¶ã€‚ Liux 4.5 é€šè¿‡å¼•å…¥ EPOLLEXCLUSIVE æ ‡è¯†æ¥ä¿è¯ä¸€ä¸ªäº‹ä»¶å‘ç”Ÿæ—¶å€™åªæœ‰ä¸€ä¸ªçº¿ç¨‹ä¼šè¢«å”¤é†’ï¼Œä»¥é¿å…å¤šä¾¦å¬ä¸‹çš„æƒŠç¾¤é—®é¢˜ã€‚\nè¡¥å……èµ„æ–™ Linuxä¸‹çš„I/Oå¤ç”¨ä¸epollè¯¦è§£\nselectã€pollã€epoll\nLinuxä¸­IOå¤ç”¨çš„å®ç°æ–¹å¼ä¸»è¦æœ‰selectã€pollå’Œepollï¼š Selectï¼šæ³¨å†ŒIOã€é˜»å¡æ‰«æï¼Œç›‘å¬çš„IOæœ€å¤§è¿æ¥æ•°ä¸èƒ½å¤šäºFD_SIZEï¼› Pollï¼šåŸç†å’ŒSelectç›¸ä¼¼ï¼Œæ²¡æœ‰æ•°é‡é™åˆ¶ï¼Œä½†IOæ•°é‡å¤§æ‰«æçº¿æ€§æ€§èƒ½ä¸‹é™ï¼› Epoll ï¼šäº‹ä»¶é©±åŠ¨ä¸é˜»å¡ï¼Œmmapå®ç°å†…æ ¸ä¸ç”¨æˆ·ç©ºé—´çš„æ¶ˆæ¯ä¼ é€’ï¼Œæ•°é‡å¾ˆå¤§ï¼ŒLinux2.6åå†…æ ¸æ”¯æŒã€‚ selectçš„ç¼ºé™·ï¼š\nselecté¢„ä¼°é”™è¯¯äº†ä¸€ä»¶äº‹ï¼Œå½“æ•°åä¸‡å¹¶å‘è¿æ¥å­˜åœ¨æ—¶ï¼Œå¯èƒ½æ¯ä¸€æ¯«ç§’åªæœ‰æ•°ç™¾ä¸ªæ´»è·ƒçš„è¿æ¥ï¼ŒåŒæ—¶å…¶ä½™æ•°åä¸‡è¿æ¥åœ¨è¿™ä¸€æ¯«ç§’æ˜¯éæ´»è·ƒçš„ã€‚ åœ¨Linuxå†…æ ¸ä¸­ï¼Œselectæ‰€ç”¨åˆ°çš„FD_SETæ˜¯æœ‰é™çš„ï¼Œå³å†…æ ¸ä¸­æœ‰ä¸ªå‚æ•°__FD_SETSIZEå®šä¹‰äº†æ¯ä¸ªFD_SETçš„å¥æŸ„ä¸ªæ•°ã€‚ å†…æ ¸ä¸­å®ç° selectæ˜¯ç”¨è½®è¯¢æ–¹æ³•ï¼Œå³æ¯æ¬¡æ£€æµ‹éƒ½ä¼šéå†æ‰€æœ‰FD_SETä¸­çš„å¥æŸ„ï¼Œæ˜¾ç„¶ï¼Œselectå‡½æ•°æ‰§è¡Œæ—¶é—´ä¸FD_SETä¸­çš„å¥æŸ„ä¸ªæ•°æœ‰ä¸€ä¸ªæ¯”ä¾‹å…³ç³»ï¼Œå³ selectè¦æ£€æµ‹çš„å¥æŸ„æ•°è¶Šå¤šå°±ä¼šè¶Šè´¹æ—¶ã€‚ ç›¸æ¯”äºselectæœºåˆ¶ï¼Œpollåªæ˜¯å–æ¶ˆäº†æœ€å¤§ç›‘æ§æ–‡ä»¶æè¿°ç¬¦æ•°é™åˆ¶ï¼Œå¹¶æ²¡æœ‰ä»æ ¹æœ¬ä¸Šè§£å†³selectå­˜åœ¨çš„é—®é¢˜ã€‚\nepollç²¾å·§çš„ä½¿ç”¨äº†3ä¸ªæ–¹æ³•æ¥å®ç°selectæ–¹æ³•è¦åšçš„äº‹ï¼š\næ–°å»ºepollæè¿°ç¬¦==epoll_create() epoll_ctl(epollæè¿°ç¬¦ï¼Œæ·»åŠ æˆ–è€…åˆ é™¤æ‰€æœ‰å¾…ç›‘æ§çš„è¿æ¥) è¿”å›çš„æ´»è·ƒè¿æ¥ ==epoll_waitï¼ˆ epollæè¿°ç¬¦ ï¼‰ ä¸selectç›¸æ¯”ï¼Œepollåˆ†æ¸…äº†é¢‘ç¹è°ƒç”¨å’Œä¸é¢‘ç¹è°ƒç”¨çš„æ“ä½œã€‚ä¾‹å¦‚ï¼Œepoll_ctlæ˜¯ä¸å¤ªé¢‘ç¹è°ƒç”¨çš„ï¼Œè€Œepoll_waitæ˜¯éå¸¸é¢‘ç¹è°ƒç”¨çš„ã€‚è¿™æ—¶ï¼Œepoll_waitå´å‡ ä¹æ²¡æœ‰å…¥å‚ï¼Œè¿™æ¯”selectçš„æ•ˆç‡é«˜å‡ºä¸€å¤§æˆªï¼Œè€Œä¸”ï¼Œå®ƒä¹Ÿä¸ä¼šéšç€å¹¶å‘è¿æ¥çš„å¢åŠ ä½¿å¾—å…¥å‚è¶Šå‘å¤šèµ·æ¥ï¼Œå¯¼è‡´å†…æ ¸æ‰§è¡Œæ•ˆç‡ä¸‹é™ã€‚\nè¦æ·±åˆ»ç†è§£epollï¼Œé¦–å…ˆå¾—äº†è§£epollçš„ä¸‰å¤§å…³é”®è¦ç´ ï¼šmmapã€çº¢é»‘æ ‘ã€é“¾è¡¨ã€‚\nepollæ˜¯é€šè¿‡å†…æ ¸ä¸ç”¨æˆ·ç©ºé—´mmapåŒä¸€å—å†…å­˜å®ç°çš„ã€‚mmapå°†ç”¨æˆ·ç©ºé—´çš„ä¸€å—åœ°å€å’Œå†…æ ¸ç©ºé—´çš„ä¸€å—åœ°å€åŒæ—¶æ˜ å°„åˆ°ç›¸åŒçš„ä¸€å—ç‰©ç†å†…å­˜åœ°å€ï¼ˆä¸ç®¡æ˜¯ç”¨æˆ·ç©ºé—´è¿˜æ˜¯å†…æ ¸ç©ºé—´éƒ½æ˜¯è™šæ‹Ÿåœ°å€ï¼Œæœ€ç»ˆè¦é€šè¿‡åœ°å€æ˜ å°„æ˜ å°„åˆ°ç‰©ç†åœ°å€ï¼‰ï¼Œä½¿å¾—è¿™å—ç‰©ç†å†…å­˜å¯¹å†…æ ¸å’Œå¯¹ç”¨æˆ·å‡å¯è§ï¼Œå‡å°‘ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¹‹é—´çš„æ•°æ®äº¤æ¢ã€‚å†…æ ¸å¯ä»¥ç›´æ¥çœ‹åˆ°epollç›‘å¬çš„å¥æŸ„ï¼Œæ•ˆç‡é«˜ã€‚\nçº¢é»‘æ ‘å°†å­˜å‚¨epollæ‰€ç›‘å¬çš„å¥—æ¥å­—ã€‚ä¸Šé¢mmapå‡ºæ¥çš„å†…å­˜å¦‚ä½•ä¿å­˜epollæ‰€ç›‘å¬çš„å¥—æ¥å­—ï¼Œå¿…ç„¶ä¹Ÿå¾—æœ‰ä¸€å¥—æ•°æ®ç»“æ„ï¼Œepollåœ¨å®ç°ä¸Šé‡‡ç”¨çº¢é»‘æ ‘å»å­˜å‚¨æ‰€æœ‰å¥—æ¥å­—ï¼Œå½“æ·»åŠ æˆ–è€…åˆ é™¤ä¸€ä¸ªå¥—æ¥å­—æ—¶ï¼ˆepoll_ctlï¼‰ï¼Œéƒ½åœ¨çº¢é»‘æ ‘ä¸Šå»å¤„ç†ï¼Œçº¢é»‘æ ‘æœ¬èº«æ’å…¥å’Œåˆ é™¤æ€§èƒ½æ¯”è¾ƒå¥½ï¼Œæ—¶é—´å¤æ‚åº¦O(logN)ã€‚\né€šè¿‡epoll_ctlå‡½æ•°æ·»åŠ è¿›æ¥çš„äº‹ä»¶éƒ½ä¼šè¢«æ”¾åœ¨çº¢é»‘æ ‘çš„æŸä¸ªèŠ‚ç‚¹å†…ï¼Œæ‰€ä»¥ï¼Œé‡å¤æ·»åŠ æ˜¯æ²¡æœ‰ç”¨çš„ã€‚å½“æŠŠäº‹ä»¶æ·»åŠ è¿›æ¥çš„æ—¶å€™æ—¶å€™ä¼šå®Œæˆå…³é”®çš„ä¸€æ­¥ï¼Œé‚£å°±æ˜¯è¯¥äº‹ä»¶éƒ½ä¼šä¸ç›¸åº”çš„è®¾å¤‡ï¼ˆç½‘å¡ï¼‰é©±åŠ¨ç¨‹åºå»ºç«‹å›è°ƒå…³ç³»ï¼Œå½“ç›¸åº”çš„äº‹ä»¶å‘ç”Ÿåï¼Œå°±ä¼šè°ƒç”¨è¿™ä¸ªå›è°ƒå‡½æ•°ï¼Œè¯¥å›è°ƒå‡½æ•°åœ¨å†…æ ¸ä¸­è¢«ç§°ä¸ºï¼šep_poll_callback,è¿™ä¸ªå›è°ƒå‡½æ•°å…¶å®å°±æ‰€æŠŠè¿™ä¸ªäº‹ä»¶æ·»åŠ åˆ°rdllistè¿™ä¸ªåŒå‘é“¾è¡¨ä¸­ã€‚ä¸€æ—¦æœ‰äº‹ä»¶å‘ç”Ÿï¼Œepollå°±ä¼šå°†è¯¥äº‹ä»¶æ·»åŠ åˆ°åŒå‘é“¾è¡¨ä¸­ã€‚é‚£ä¹ˆå½“æˆ‘ä»¬è°ƒç”¨epoll_waitæ—¶ï¼Œepoll_waitåªéœ€è¦æ£€æŸ¥rdliståŒå‘é“¾è¡¨ä¸­æ˜¯å¦æœ‰å­˜åœ¨æ³¨å†Œçš„äº‹ä»¶ï¼Œæ•ˆç‡éå¸¸å¯è§‚ã€‚è¿™é‡Œä¹Ÿéœ€è¦å°†å‘ç”Ÿäº†çš„äº‹ä»¶å¤åˆ¶åˆ°ç”¨æˆ·æ€å†…å­˜ä¸­å³å¯ã€‚\nepoll_waitçš„å·¥ä½œæµç¨‹ï¼š\nepoll_waitè°ƒç”¨ep_pollï¼Œå½“rdlistä¸ºç©ºï¼ˆæ— å°±ç»ªfdï¼‰æ—¶æŒ‚èµ·å½“å‰è¿›ç¨‹ï¼Œç›´åˆ°rdlistä¸ç©ºæ—¶è¿›ç¨‹æ‰è¢«å”¤é†’ã€‚ æ–‡ä»¶fdçŠ¶æ€æ”¹å˜ï¼ˆbufferç”±ä¸å¯è¯»å˜ä¸ºå¯è¯»æˆ–ç”±ä¸å¯å†™å˜ä¸ºå¯å†™ï¼‰ï¼Œå¯¼è‡´ç›¸åº”fdä¸Šçš„å›è°ƒå‡½æ•°ep_poll_callback()è¢«è°ƒç”¨ã€‚ ep_poll_callbackå°†ç›¸åº”fdå¯¹åº”epitemåŠ å…¥rdlistï¼Œå¯¼è‡´rdlistä¸ç©ºï¼Œè¿›ç¨‹è¢«å”¤é†’ï¼Œepoll_waitå¾—ä»¥ç»§ç»­æ‰§è¡Œã€‚ ep_events_transferå‡½æ•°å°†rdlistä¸­çš„epitemæ‹·è´åˆ°txlistä¸­ï¼Œå¹¶å°†rdlistæ¸…ç©ºã€‚ ep_send_eventså‡½æ•°ï¼ˆå¾ˆå…³é”®ï¼‰ï¼Œå®ƒæ‰«ætxlistä¸­çš„æ¯ä¸ªepitemï¼Œè°ƒç”¨å…¶å…³è”fdå¯¹ç”¨çš„pollæ–¹æ³•ã€‚æ­¤æ—¶å¯¹pollçš„è°ƒç”¨ä»…ä»…æ˜¯å–å¾—fdä¸Šè¾ƒæ–°çš„eventsï¼ˆé˜²æ­¢ä¹‹å‰eventsè¢«æ›´æ–°ï¼‰ï¼Œä¹‹åå°†å–å¾—çš„eventså’Œç›¸åº”çš„fdå‘é€åˆ°ç”¨æˆ·ç©ºé—´ï¼ˆå°è£…åœ¨struct epoll_eventï¼Œä»epoll_waitè¿”å›ï¼‰ã€‚ selectã€pollå’Œepollä¸‰ç§I/Oå¤ç”¨æ¨¡å¼çš„æ¯”è¾ƒï¼š\nç³»ç»Ÿè°ƒç”¨ select poll epoll äº‹ä»¶é›†åˆ ç”¨æˆ·é€šè¿‡3ä¸ªå‚æ•°åˆ†åˆ«ä¼ å…¥æ„Ÿå…´è¶£çš„å¯è¯»ï¼Œå¯å†™åŠå¼‚å¸¸ç­‰äº‹ä»¶å†…æ ¸é€šè¿‡å¯¹è¿™äº›å‚æ•°çš„åœ¨çº¿ä¿®æ”¹æ¥åé¦ˆå…¶ä¸­çš„å°±ç»ªäº‹ä»¶è¿™ä½¿å¾—ç”¨æˆ·æ¯æ¬¡è°ƒç”¨selectéƒ½è¦é‡ç½®è¿™3ä¸ªå‚æ•° ç»Ÿä¸€å¤„ç†æ‰€æœ‰äº‹ä»¶ç±»å‹ï¼Œå› æ­¤åªéœ€è¦ä¸€ä¸ªäº‹ä»¶é›†å‚æ•°ã€‚ç”¨æˆ·é€šè¿‡pollfd.eventsä¼ å…¥æ„Ÿå…´è¶£çš„äº‹ä»¶ï¼Œå†…æ ¸é€šè¿‡ä¿®æ”¹pollfd.reventsåé¦ˆå…¶ä¸­å°±ç»ªçš„äº‹ä»¶ å†…æ ¸é€šè¿‡ä¸€ä¸ªäº‹ä»¶è¡¨ç›´æ¥ç®¡ç†ç”¨æˆ·æ„Ÿå…´è¶£çš„æ‰€æœ‰äº‹ä»¶ã€‚å› æ­¤æ¯æ¬¡è°ƒç”¨epoll_waitæ—¶ï¼Œæ— éœ€åå¤ä¼ å…¥ç”¨æˆ·æ„Ÿå…´è¶£çš„äº‹ä»¶ã€‚epoll_waitç³»ç»Ÿè°ƒç”¨çš„å‚æ•°eventsä»…ç”¨æ¥åé¦ˆå°±ç»ªçš„äº‹ä»¶ åº”ç”¨ç¨‹åºç´¢å¼•å°±ç»ªæ–‡ä»¶æè¿°ç¬¦çš„æ—¶é—´å¤æ‚åº¦ O(n) O(n) O(1) æœ€å¤§æ”¯æŒæ–‡ä»¶æè¿°ç¬¦æ•° ä¸€èˆ¬æœ‰æœ€å¤§å€¼é™åˆ¶ 65535 65535 å·¥ä½œæ¨¡å¼ LT LT æ”¯æŒETé«˜æ•ˆæ¨¡å¼ å†…æ ¸å®ç°å’Œå·¥ä½œæ•ˆç‡ é‡‡ç”¨è½®è¯¢æ–¹å¼æ£€æµ‹å°±ç»ªäº‹ä»¶ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(n) é‡‡ç”¨è½®è¯¢æ–¹å¼æ£€æµ‹å°±ç»ªäº‹ä»¶ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(n) é‡‡ç”¨å›è°ƒæ–¹å¼æ£€æµ‹å°±ç»ªäº‹ä»¶ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(1) io_uring å¼‚æ­¥ I/O æ¨¡å‹ Linux AIO å®ç°çš„å¹¶ä¸ç†æƒ³ï¼Œæ‰€ä»¥å¼•å…¥äº†æ–°çš„å¼‚æ­¥I/Oæ¥å£ io_uringã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 +----+ Head +---------+ +----------+ Head | | | | | | | | | | | +---------+ +----------+ | | | | | | | | | | | +---------+ +----------+ | | | | | | | | | | | +---------+ +----------+ | | | | | | Tail +---------+ +----------+ Tail \u0026lt;--+ | +--------------------------------------------+ | | | Kernel | | | | | | | | +-------+ +-------+ | | | | | | | | | | +---------------\u0026gt; | SQ | | CQ | +--------+ | | | | | | | +-------+ +-------+ | | | +--------------------------------------------+ io_uringæ¥å£é€šè¿‡ä¸¤ä¸ªä¸»è¦æ•°æ®ç»“æ„å·¥ä½œï¼š\næäº¤é˜Ÿåˆ—æ¡ç›®ï¼ˆsqeï¼‰ å®Œæˆé˜Ÿåˆ—æ¡ç›®ï¼ˆcqeï¼‰ è¿™äº›ç»“æ„çš„å®ä¾‹ä½äºå†…æ ¸å’Œåº”ç”¨ç¨‹åºä¹‹é—´çš„å…±äº«å†…å­˜å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…ç¯å½¢ç¼“å†²åŒºä¸­ã€‚\nå‚è€ƒï¼š\nHow io_uring and eBPF Will Revolutionize Programming in Linux A Universal I/O Abstraction for C++ äº‹ä»¶é©±åŠ¨ç¼–ç¨‹æ¨¡å‹ å› ä¸ºå¤„ç† I/O å¤ç”¨çš„ç¼–ç¨‹æ¨¡å‹ç›¸å½“å¤æ‚ï¼Œä¸ºäº†ç®€åŒ–ç¼–ç¨‹ï¼Œå¼•å…¥äº†ä¸‹é¢ä¸¤ç§æ¨¡å‹ã€‚\nReactorï¼ˆååº”å™¨ï¼‰ æ¨¡å¼ï¼Œå¯¹åº”åŒæ­¥I/Oï¼Œè¢«åŠ¨çš„äº‹ä»¶åˆ†ç¦»å’Œåˆ†å‘æ¨¡å‹ã€‚æœåŠ¡ç­‰å¾…è¯·æ±‚äº‹ä»¶çš„åˆ°æ¥ï¼Œå†é€šè¿‡ä¸å—é—´æ–­çš„åŒæ­¥å¤„ç†äº‹ä»¶ï¼Œä»è€Œåšå‡ºååº”ã€‚ Preactorï¼ˆä¸»åŠ¨å™¨ï¼‰ æ¨¡å¼ï¼Œå¯¹åº”å¼‚æ­¥I/Oï¼Œä¸»åŠ¨çš„äº‹ä»¶åˆ†ç¦»å’Œåˆ†å‘æ¨¡å‹ã€‚è¿™ç§è®¾è®¡å…è®¸å¤šä¸ªä»»åŠ¡å¹¶å‘çš„æ‰§è¡Œï¼Œä»è€Œæé«˜ååé‡ï¼›å¹¶å¯æ‰§è¡Œè€—æ—¶é•¿çš„ä»»åŠ¡ï¼ˆå„ä¸ªä»»åŠ¡é—´äº’ä¸å½±å“ï¼‰ã€‚ Reactor Model:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 +----------------+ req Dispatch | | +------+ +--------\u0026gt; | req handler | | | | +----------------+ | | +----+ | +------+ | event +------------+ | | | | | +--------\u0026gt; | Service | |Dispatch +----------------+ | Handler +------------\u0026gt; | | req +---------\u0026gt; | | | | req handler | +------+ | +------------+ | +----------------+ | | | event | | +----+ | +------+ | Dispatch +----------------+ +---------\u0026gt;+ | | req handler | +----------------+ ä¸‰ç§å®ç°æ–¹å¼ï¼š\nå•çº¿ç¨‹æ¨¡å¼ã€‚ accept()ã€read()ã€write()ä»¥åŠconnect()æ“ä½œ éƒ½åœ¨åŒä¸€çº¿ç¨‹ã€‚ å·¥ä½œè€…çº¿ç¨‹æ± æ¨¡å¼ã€‚é I/O æ“ä½œäº¤ç»™çº¿ç¨‹æ± å¤„ç† å¤šçº¿ç¨‹æ¨¡å¼ã€‚ä¸»Reactor (master) ï¼Œè´Ÿè´£ç½‘ç»œç›‘å¬ ï¼Œ å­Reactor(worker) è¯»å†™ç½‘ç»œæ•°æ®ã€‚ è¯»å†™æ“ä½œæµç¨‹ï¼š\nåº”ç”¨æ³¨å†Œè¯»å†™å°±ç»ªäº‹ä»¶å’Œç›¸å…³è”çš„äº‹ä»¶å¤„ç†å™¨ äº‹ä»¶åˆ†ç¦»å™¨ç­‰å¾…äº‹ä»¶å‘ç”Ÿ å½“å‘ç”Ÿè¯»å†™å°±ç»ªäº‹ä»¶ï¼Œäº‹ä»¶åˆ†ç¦»å™¨è°ƒç”¨å·²æ³¨å†Œçš„äº‹ä»¶å¤„ç†å™¨ äº‹ä»¶å¤„ç†å™¨æ‰§è¡Œè¯»å†™æ“ä½œ å‚ä¸è€…ï¼š\næè¿°ç¬¦ï¼ˆhandleï¼‰ï¼šæ“ä½œç³»ç»Ÿæä¾›çš„èµ„æºï¼Œè¯†åˆ« socketç­‰ã€‚ åŒæ­¥äº‹ä»¶å¤šè·¯åˆ†ç¦»å™¨ã€‚å¼€å¯äº‹ä»¶å¾ªç¯ï¼Œç­‰å¾…äº‹ä»¶çš„å‘ç”Ÿã€‚å°è£…äº† å¤šè·¯å¤ç”¨å‡½æ•° select/poll/epollç­‰ã€‚ äº‹ä»¶å¤„ç†å™¨ã€‚æä¾›å›è°ƒå‡½æ•°ï¼Œç”¨äºæè¿°ä¸åº”ç”¨ç¨‹åºç›¸å…³çš„æŸä¸ªäº‹ä»¶çš„æ“ä½œã€‚ å…·ä½“çš„äº‹ä»¶å¤„ç†å™¨ã€‚äº‹ä»¶å¤„ç†å™¨æ¥å£çš„å…·ä½“å®ç°ã€‚ä½¿ç”¨æè¿°ç¬¦æ¥è¯†åˆ«äº‹ä»¶å’Œç¨‹åºæä¾›çš„æœåŠ¡ã€‚ Reactor ç®¡ç†å™¨ã€‚äº‹ä»¶å¤„ç†å™¨çš„è°ƒåº¦æ ¸å¿ƒã€‚åˆ†ç¦»æ¯ä¸ªäº‹ä»¶ï¼Œè°ƒåº¦äº‹ä»¶ç®¡ç†å™¨ï¼Œè°ƒç”¨å…·ä½“çš„å‡½æ•°å¤„ç†æŸä¸ªäº‹ä»¶ã€‚ è¡¥å……èµ„æ–™ äº‹ä»¶é©±åŠ¨åŠå…¶è®¾è®¡æ¨¡å¼\nä»äº‹ä»¶è§’åº¦è¯´ï¼Œäº‹ä»¶é©±åŠ¨ç¨‹åºçš„åŸºæœ¬ç»“æ„æ˜¯ç”±ä¸€ä¸ªäº‹ä»¶æ”¶é›†å™¨ã€ä¸€ä¸ªäº‹ä»¶å‘é€å™¨å’Œä¸€ä¸ªäº‹ä»¶å¤„ç†å™¨ç»„æˆã€‚\näº‹ä»¶å¾ªç¯å™¨çš„å®ç°\näº‹ä»¶å¾ªç¯å™¨ä¸æ–­æ¥å—æ¥è‡ªå®¢æˆ·ç«¯ï¼ˆClientï¼‰çš„è¯·æ±‚ï¼Œäº‹ä»¶å¾ªç¯å™¨æŠŠè¯·æ±‚è½¬äº¤ç»™æ³¨å†Œäº†æŸç±»äº‹ä»¶çš„å·¥ä½œçº¿ç¨‹ï¼ˆWorkerï¼‰å¤„ç†ã€‚\næ ¹æ®å®ç°çš„æ–¹å¼ä¸åŒï¼Œåœ¨ç½‘ç»œç¼–ç¨‹ä¸­åŸºäºäº‹ä»¶é©±åŠ¨ä¸»è¦æœ‰ä¸¤ç§è®¾è®¡æ¨¡å¼ï¼šReactorå’ŒProactorã€‚\nReactoræ¨¡å¼æ¡†æ¶\nä½¿ç”¨Reactoræ¨¡å‹ï¼Œå¿…å¤‡çš„å‡ ä¸ªç»„ä»¶ï¼šäº‹ä»¶æºã€Reactoræ¡†æ¶ã€äº‹ä»¶å¤šè·¯å¤ç”¨æœºåˆ¶å’Œäº‹ä»¶å¤„ç†ç¨‹åºï¼Œå…ˆæ¥çœ‹çœ‹Reactoræ¨¡å‹çš„æ•´ä½“æ¡†æ¶ï¼Œæ¥ä¸‹æ¥å†å¯¹æ¯ä¸ªç»„ä»¶åšé€ä¸€è¯´æ˜ã€‚\n1ï¼‰äº‹ä»¶æºï¼šLinuxä¸Šæ˜¯æ–‡ä»¶æè¿°ç¬¦ï¼ŒWindowsä¸Šå°±æ˜¯Socketæˆ–è€…Handleäº†ï¼Œè¿™é‡Œç»Ÿä¸€ç§°ä¸ºâ€œå¥æŸ„é›†â€ï¼›ç¨‹åºåœ¨æŒ‡å®šçš„å¥æŸ„ä¸Šæ³¨å†Œå…³å¿ƒçš„äº‹ä»¶ï¼Œæ¯”å¦‚I/Oäº‹ä»¶ã€‚\n2ï¼‰äº‹ä»¶å¤šè·¯å¤ç”¨æœºåˆ¶ï¼šç”±æ“ä½œç³»ç»Ÿæä¾›çš„I/Oå¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œæ¯”å¦‚selectå’Œepollã€‚ç¨‹åºé¦–å…ˆå°†å…¶å…³å¿ƒçš„å¥æŸ„ï¼ˆäº‹ä»¶æºï¼‰åŠå…¶äº‹ä»¶æ³¨å†Œåˆ°å¤šè·¯å¤ç”¨æœºåˆ¶ä¸Šã€‚å½“æœ‰äº‹ä»¶åˆ°è¾¾æ—¶ï¼Œäº‹ä»¶å¤šè·¯å¤ç”¨æœºåˆ¶ä¼šå‘å‡ºé€šçŸ¥â€œåœ¨å·²ç»æ³¨å†Œçš„å¥æŸ„é›†ä¸­ï¼Œä¸€ä¸ªæˆ–å¤šä¸ªå¥æŸ„çš„äº‹ä»¶å·²ç»å°±ç»ªâ€ã€‚ç¨‹åºæ”¶åˆ°é€šçŸ¥åï¼Œå°±å¯ä»¥åœ¨éé˜»å¡çš„æƒ…å†µä¸‹å¯¹äº‹ä»¶è¿›è¡Œå¤„ç†äº†ã€‚\n3ï¼‰ Reactorã€‚æ˜¯äº‹ä»¶ç®¡ç†çš„æ¥å£ï¼Œå†…éƒ¨ä½¿ç”¨äº‹ä»¶å¤šè·¯å¤ç”¨æœºåˆ¶æ³¨å†Œã€æ³¨é”€äº‹ä»¶ï¼›å¹¶è¿è¡Œäº‹ä»¶å¾ªç¯ï¼Œå½“æœ‰äº‹ä»¶è¿›å…¥â€œå°±ç»ªâ€çŠ¶æ€æ—¶ï¼Œè°ƒç”¨æ³¨å†Œäº‹ä»¶çš„å›è°ƒå‡½æ•°å¤„ç†äº‹ä»¶ã€‚\n4ï¼‰äº‹ä»¶å¤„ç†ç¨‹åºã€‚äº‹ä»¶å¤„ç†ç¨‹åºæä¾›äº†ä¸€ç»„æ¥å£ï¼Œæ¯ä¸ªæ¥å£å¯¹åº”äº†ä¸€ç§ç±»å‹çš„äº‹ä»¶ï¼Œä¾›Reactoråœ¨ç›¸åº”çš„äº‹ä»¶å‘ç”Ÿæ—¶è°ƒç”¨ï¼Œæ‰§è¡Œç›¸åº”çš„äº‹ä»¶å¤„ç†ã€‚é€šå¸¸å®ƒä¼šç»‘å®šä¸€ä¸ªæœ‰æ•ˆçš„å¥æŸ„ã€‚\nä½¿ç”¨Reactoræ¨¡å¼åï¼Œäº‹ä»¶æ§åˆ¶æµæ˜¯ä»€ä¹ˆæ ·å­å‘¢ï¼Ÿå¯ä»¥å‚è§ä¸‹é¢çš„åºåˆ—å›¾ã€‚\næˆ‘ä»¬åˆ†åˆ«ä»¥è¯»æ“ä½œå’Œå†™æ“ä½œä¸ºä¾‹æ¥çœ‹çœ‹Reactorä¸­çš„å…·ä½“æ­¥éª¤ï¼š\nåº”ç”¨ç¨‹åºæ³¨å†Œè¯»å°±ç»ªäº‹ä»¶å’Œç›¸å…³è”çš„äº‹ä»¶å¤„ç†å™¨ï¼›\näº‹ä»¶åˆ†ç¦»å™¨ç­‰å¾…äº‹ä»¶çš„å‘ç”Ÿï¼›\nå½“å‘ç”Ÿè¯»å°±ç»ªäº‹ä»¶çš„æ—¶å€™ï¼Œäº‹ä»¶åˆ†ç¦»å™¨è°ƒç”¨ç¬¬ä¸€æ­¥æ³¨å†Œçš„äº‹ä»¶å¤„ç†å™¨ï¼›\näº‹ä»¶å¤„ç†å™¨é¦–å…ˆæ‰§è¡Œå®é™…çš„è¯»å–æ“ä½œï¼Œç„¶åæ ¹æ®è¯»å–åˆ°çš„å†…å®¹è¿›è¡Œè¿›ä¸€æ­¥çš„å¤„ç†ã€‚\nå†™å…¥æ“ä½œç±»ä¼¼äºè¯»å–æ“ä½œï¼Œåªä¸è¿‡ç¬¬ä¸€æ­¥æ³¨å†Œçš„æ˜¯å†™å°±ç»ªäº‹ä»¶ã€‚\nProactor\næˆ‘ä»¬æ¥çœ‹çœ‹Proactoræ¨¡å¼ä¸­è¯»å–æ“ä½œå’Œå†™å…¥æ“ä½œçš„è¿‡ç¨‹ï¼š\nåº”ç”¨ç¨‹åºåˆå§‹åŒ–ä¸€ä¸ªå¼‚æ­¥è¯»å–æ“ä½œï¼Œç„¶åæ³¨å†Œç›¸åº”çš„äº‹ä»¶å¤„ç†å™¨ï¼Œæ­¤æ—¶äº‹ä»¶å¤„ç†å™¨ä¸å…³æ³¨è¯»å–å°±ç»ªäº‹ä»¶ï¼Œè€Œæ˜¯å…³æ³¨è¯»å–å®Œæˆäº‹ä»¶ï¼Œè¿™æ˜¯åŒºåˆ«äºReactorçš„å…³é”®ã€‚\näº‹ä»¶åˆ†ç¦»å™¨ç­‰å¾…è¯»å–æ“ä½œå®Œæˆäº‹ä»¶ã€‚\nåœ¨äº‹ä»¶åˆ†ç¦»å™¨ç­‰å¾…è¯»å–æ“ä½œå®Œæˆçš„æ—¶å€™ï¼Œæ“ä½œç³»ç»Ÿè°ƒç”¨å†…æ ¸çº¿ç¨‹å®Œæˆè¯»å–æ“ä½œï¼ˆå¼‚æ­¥I/Oéƒ½æ˜¯æ“ä½œç³»ç»Ÿè´Ÿè´£å°†æ•°æ®è¯»å†™åˆ°åº”ç”¨ä¼ é€’è¿›æ¥çš„ç¼“å†²åŒºä¾›åº”ç”¨ç¨‹åºæ“ä½œï¼‰ï¼Œå¹¶å°†è¯»å–çš„å†…å®¹æ”¾å…¥ç”¨æˆ·ä¼ é€’è¿‡æ¥çš„ç¼“å­˜åŒºä¸­ã€‚è¿™ä¹Ÿæ˜¯åŒºåˆ«äºReactorçš„ä¸€ç‚¹ã€‚\näº‹ä»¶åˆ†ç¦»å™¨æ•è·åˆ°è¯»å–å®Œæˆäº‹ä»¶åï¼Œæ¿€æ´»åº”ç”¨ç¨‹åºæ³¨å†Œçš„äº‹ä»¶å¤„ç†å™¨ï¼Œäº‹ä»¶å¤„ç†å™¨ç›´æ¥ä»ç¼“å­˜åŒºè¯»å–æ•°æ®ï¼Œè€Œä¸éœ€è¦è¿›è¡Œå®é™…çš„è¯»å–æ“ä½œã€‚\nProactorä¸­å†™å…¥æ“ä½œå’Œè¯»å–æ“ä½œï¼Œåªä¸è¿‡æ„Ÿå…´è¶£çš„äº‹ä»¶æ˜¯å†™å…¥å®Œæˆäº‹ä»¶ã€‚\nä»ä¸Šé¢å¯ä»¥çœ‹å‡ºï¼ŒReactorå’ŒProactoræ¨¡å¼çš„ä¸»è¦åŒºåˆ«å°±æ˜¯çœŸæ­£çš„è¯»å–å’Œå†™å…¥æ“ä½œæ˜¯ç”±è°æ¥å®Œæˆçš„ï¼ŒReactorä¸­éœ€è¦åº”ç”¨ç¨‹åºè‡ªå·±è¯»å–æˆ–è€…å†™å…¥æ•°æ®ï¼Œè€ŒProactoræ¨¡å¼ä¸­ï¼Œåº”ç”¨ç¨‹åºä¸éœ€è¦è¿›è¡Œå®é™…çš„è¯»å†™è¿‡ç¨‹ï¼Œå®ƒåªéœ€è¦ä»ç¼“å­˜åŒºè¯»å–æˆ–è€…å†™å…¥å³å¯ï¼Œæ“ä½œç³»ç»Ÿä¼šè¯»å–ç¼“å­˜åŒºæˆ–è€…å†™å…¥ç¼“å­˜åŒºåˆ°çœŸæ­£çš„I/Oè®¾å¤‡ã€‚\nepollä»£ç å®è·µ å‚è§rust-epoll-exampleã€‚\nReactorä»£ç å®è·µ å‚è§rust-reactore-executor-exampleã€‚\nMiniMioä»£ç å®è·µ epollåªæ”¯æŒåœ¨Linuxç³»ç»Ÿä¸‹ä½¿ç”¨ï¼Œè€Œminimioå®ç°äº†è·¨å¹³å°ã€‚\nä¼šå°†å„ä¸ªå¹³å°çš„å‘½ä»¤æ‹¿å‡ºæ¥ã€‚æ¯”å¦‚Selectoråšäº†æŠ½è±¡ï¼Œæ¯ä¸ªå¹³å°å®é™…ä¸Šä¸åŒã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #[cfg(target_os = \u0026#34;windows\u0026#34;)] mod windows; #[cfg(target_os = \u0026#34;windows\u0026#34;)] pub use windows::{Event, Registrator, Selector, TcpStream}; #[cfg(target_os = \u0026#34;macos\u0026#34;)] mod macos; #[cfg(target_os = \u0026#34;macos\u0026#34;)] pub use macos::{Event, Registrator, Selector, TcpStream}; #[cfg(target_os = \u0026#34;linux\u0026#34;)] mod linux; #[cfg(target_os = \u0026#34;linux\u0026#34;)] pub use linux::{Event, Registrator, Selector, TcpStream}; åœ¨lib.rsä¸­æŠ½è±¡å‡ºè·¨å¹³å°çš„ç»“æ„Pollã€‚ä»£è¡¨äº‹ä»¶é˜Ÿåˆ—ã€‚\n1 2 3 4 5 #[derive(Debug)] pub struct Poll { registry: Registry, is_poll_dead: Arc\u0026lt;AtomicBool\u0026gt;, } Pollæœ‰ä¸€ä¸ªè½®è¯¢æ–¹æ³•pollã€‚åœ¨å®é™…è°ƒç”¨æ—¶å·²ç»å®ç°äº†è·¨å¹³å°ã€‚\n1 2 3 pub fn poll(\u0026amp;mut self, events: \u0026amp;mut Events, timeout_ms: Option\u0026lt;i32\u0026gt;) -\u0026gt; io::Result\u0026lt;usize\u0026gt;{ // ... } Mioä»£ç å®è·µ ç”Ÿäº§ç¯å¢ƒä¸­çš„å¤šè·¯å¤ç”¨è·¨å¹³å°ä»£ç mioã€‚\nå…¶ä¸­æŠ½è±¡å‡ºäº†Pollç»“æ„ä½“ã€‚\n1 2 3 pub struct Poll { registry: Registry, } è¿™é‡Œç”¨åˆ°äº†è®¾è®¡æ¨¡å¼â€”â€”å¤–è§‚æ¨¡å¼ï¼Œå¤–è§‚æ¨¡å¼ç›¸å…³çŸ¥è¯†è§è¿™é‡Œã€‚\nå¤–è§‚æ¨¡å¼ï¼ˆFacade Patternï¼‰éšè—ç³»ç»Ÿçš„å¤æ‚æ€§ï¼Œå¹¶å‘å®¢æˆ·ç«¯æä¾›äº†ä¸€ä¸ªå®¢æˆ·ç«¯å¯ä»¥è®¿é—®ç³»ç»Ÿçš„æ¥å£ã€‚è¿™ç§ç±»å‹çš„è®¾è®¡æ¨¡å¼å±äºç»“æ„å‹æ¨¡å¼ï¼Œå®ƒå‘ç°æœ‰çš„ç³»ç»Ÿæ·»åŠ ä¸€ä¸ªæ¥å£ï¼Œæ¥éšè—ç³»ç»Ÿçš„å¤æ‚æ€§ã€‚\nè¿™ç§æ¨¡å¼æ¶‰åŠåˆ°ä¸€ä¸ªå•ä¸€çš„ç±»ï¼Œè¯¥ç±»æä¾›äº†å®¢æˆ·ç«¯è¯·æ±‚çš„ç®€åŒ–æ–¹æ³•å’Œå¯¹ç°æœ‰ç³»ç»Ÿç±»æ–¹æ³•çš„å§”æ‰˜è°ƒç”¨ã€‚\nå¼‚æ­¥ç¼–ç¨‹æ¨¡å‹æ¦‚è¦ è®©æˆ‘ä»¬å…ˆä»å»ºç«‹å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹çš„æ•´ä½“æ¦‚å¿µæ¡†æ¶å¼€å§‹ï¼Œå…ˆä¸æ·±å…¥ç»†èŠ‚ã€‚\nRust æä¾›çš„å¼‚æ­¥å¹¶å‘ç›¸æ¯”äºå…¶ä»–è¯­è¨€æœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ\nRust è¯­è¨€åªæ˜¯æä¾›ä¸€ä¸ªé›¶æˆæœ¬çš„å¼‚æ­¥ç¼–ç¨‹æŠ½è±¡ï¼Œè€Œä¸å†…ç½®è¿è¡Œæ—¶ã€‚ åŸºäº Generator å®ç°çš„ Futureï¼Œåœ¨ Future åŸºç¡€ä¸Š æä¾› async/await è¯­æ³•ç³–ã€‚æœ¬è´¨æ˜¯ä¸€ä¸ªçŠ¶æ€æœºã€‚ æŸ¥çœ‹ README å’Œå…¶ä»–ç¼–ç¨‹è¯­è¨€æ¯”è¾ƒçš„å›¾ç¤ºã€‚\nä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥ï¼Ÿ\nå¯¹æè‡´æ€§èƒ½çš„è¿½æ±‚ã€‚ å¯¹ç¼–ç¨‹ä½“éªŒçš„è¿½æ±‚ã€‚ å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹å‘å±•é˜¶æ®µï¼š\nCallback Promise/Future async/await å¯åœ¨é¡¹ç›® README æŸ¥çœ‹å›è°ƒåœ°ç‹±ç¤ºä¾‹å›¾ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 A +------+ | | | | | +-------------------+ | | | | | | | | Bv +------+ +-----+ | | | | | | | do1 | | | | | | | +-----+ | | | | | | | do2 | | | +-+---+ | | | | | | | A | | +------+ | | | | | | | | | | | | \u0026lt;----------------+ | | | | | | +------+ æ—©æœŸ Rust å¼‚æ­¥å†™æ³•ç¤ºæ„ï¼š\n1 2 3 4 5 6 7 let future = id_rpc(\u0026amp;my_server).and_then(|id| { get_row(id) }).map(|row| { json::encode(row) }).and_then(|encoded| { write_string(my_socket, encoded) }); è¿™æ ·å†™ä¼šå­˜åœ¨å¤§é‡å†…åµŒ Futureï¼Œå¼€å‘ä½“éªŒä¸å¥½ã€‚\nå¼•å…¥ async/await ä¹‹åï¼š\n1 2 3 4 let id = id_rpc(\u0026amp;my_server).await; let row = get_row(id).await; let encoded = json::encode(row); write_string(my_socket, encoded).await; æ‹¥æœ‰äº†å’ŒåŒæ­¥ä»£ç ä¸€è‡´çš„ä½“éªŒã€‚\nå¼‚æ­¥ä»»åŠ¡å¯çœ‹ä½œæ˜¯ä¸€ç§ç»¿è‰²çº¿ç¨‹\næŸ¥çœ‹ README ç›¸å…³å›¾ç¤º\nå¯ä»¥è¯´ï¼Œå¼‚æ­¥ä»»åŠ¡çš„è¡Œä¸ºæ˜¯æ¨¡ä»¿ çº¿ç¨‹ æ¥æŠ½è±¡ã€‚\nçº¿ç¨‹åœ¨è¿›ç¨‹å†…ï¼Œå¼‚æ­¥ä»»åŠ¡åœ¨çº¿ç¨‹å†…ã€‚ çº¿ç¨‹å¯è¢«è°ƒåº¦åˆ‡æ¢ï¼ˆLinuxé»˜è®¤æŠ¢å å¼ï¼‰ï¼Œå¼‚æ­¥ä»»åŠ¡ä¹Ÿå¯ä»¥è¢«è°ƒåº¦ï¼ˆåä½œå¼è€ŒéæŠ¢å å¼ï¼‰ã€‚åŒºåˆ«åœ¨äºï¼Œå¼‚æ­¥ä»»åŠ¡åªåœ¨ç”¨æˆ·æ€ï¼Œæ²¡æœ‰çº¿ç¨‹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ã€‚ çº¿ç¨‹æœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¼‚æ­¥ä»»åŠ¡ä¹Ÿæœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚ çº¿ç¨‹é—´å¯ä»¥é€šä¿¡ï¼Œå¼‚æ­¥ä»»åŠ¡ä¹‹é—´ä¹Ÿå¯ä»¥é€šä¿¡ã€‚ çº¿ç¨‹é—´æœ‰ç«äº‰ï¼Œå¼‚æ­¥ä»»åŠ¡ä¹‹é—´ä¹Ÿæœ‰ç«äº‰ã€‚ æ•´ä¸ªå¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µï¼ŒåŒ…æ‹¬å¼‚æ­¥è¯­æ³•ã€å¼‚æ­¥è¿è¡Œæ—¶éƒ½æ˜¯å›´ç»•å¦‚ä½•å»ºç«‹è¿™ç§ã€Œç»¿è‰²çº¿ç¨‹ã€æŠ½è±¡è€Œæˆçš„ã€‚\nä»€ä¹ˆæ˜¯ç»¿è‰²çº¿ç¨‹ï¼Ÿ\nåœ¨è®¡ç®—æœºç¨‹åºè®¾è®¡ä¸­ï¼Œç»¿è‰²çº¿ç¨‹æ˜¯ä¸€ç§ç”±è¿è¡Œç¯å¢ƒæˆ–è™šæ‹Ÿæœºè°ƒåº¦ï¼Œè€Œä¸æ˜¯ç”±æœ¬åœ°åº•å±‚æ“ä½œç³»ç»Ÿè°ƒåº¦çš„çº¿ç¨‹ã€‚ç»¿è‰²çº¿ç¨‹å¹¶ä¸ä¾èµ–åº•å±‚çš„ç³»ç»ŸåŠŸèƒ½ï¼Œæ¨¡æ‹Ÿå®ç°äº†å¤šçº¿ç¨‹çš„è¿è¡Œï¼Œè¿™ç§çº¿ç¨‹çš„ç®¡ç†è°ƒé…å‘ç”Ÿåœ¨ç”¨æˆ·ç©ºé—´è€Œä¸æ˜¯å†…æ ¸ç©ºé—´ï¼Œæ‰€ä»¥å®ƒä»¬å¯ä»¥åœ¨æ²¡æœ‰åŸç”Ÿçº¿ç¨‹æ”¯æŒçš„ç¯å¢ƒä¸­å·¥ä½œã€‚\nFutureå’ŒFutures-rsä»‹ç» Futureï¼šæä¾›äº†å¼‚æ­¥è®¡ç®—ã€‚\nFuture traitï¼š\n1 2 3 4 5 pub trait Future { type Output; fn poll(self: Pin\u0026lt;\u0026amp;mut Self\u0026gt;, cx: \u0026amp;mut Context\u0026lt;\u0026#39;_\u0026gt;) -\u0026gt; Poll\u0026lt;Self::Output\u0026gt;; } å…¶ä¸­pollæ–¹æ³•å¾ˆé‡è¦ï¼Œå°è¯•å»å°†futureå¾—åˆ°ä¸€ä¸ªæœ€ç»ˆçš„å€¼ã€‚å¦‚æœæœ€ç»ˆçš„å€¼æ²¡æœ‰å‡†å¤‡å¥½ï¼Œä¹Ÿä¸ä¼šè¿›è¡Œé˜»å¡ã€‚\ntaskï¼šå¯ä»¥ç†è§£ä¸ºåˆ›å»ºç»¿è‰²çº¿ç¨‹ã€‚\nå…¶ä¸­é‡è¦çš„æ˜¯Enum std::task::Poll\n1 2 3 4 pub enum Poll\u0026lt;T\u0026gt; { Ready(T), Pending, } futures-rsï¼šå¯¹futureåšäº†æ‰©å±•ã€‚\nç¼–å†™å¼‚æ­¥echoæœåŠ¡ ä»€ä¹ˆæ˜¯æ–‡ä»¶æè¿°ç¬¦ï¼Ÿ\næ–‡ä»¶æè¿°ç¬¦ï¼ˆFile descriptorï¼‰æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„ä¸€ä¸ªæœ¯è¯­ï¼Œæ˜¯ä¸€ä¸ªç”¨äºè¡¨è¿°æŒ‡å‘æ–‡ä»¶çš„å¼•ç”¨çš„æŠ½è±¡åŒ–æ¦‚å¿µã€‚\næ–‡ä»¶æè¿°ç¬¦åœ¨å½¢å¼ä¸Šæ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•°ã€‚å®é™…ä¸Šï¼Œå®ƒæ˜¯ä¸€ä¸ªç´¢å¼•å€¼ï¼ŒæŒ‡å‘å†…æ ¸ä¸ºæ¯ä¸€ä¸ªè¿›ç¨‹æ‰€ç»´æŠ¤çš„è¯¥è¿›ç¨‹æ‰“å¼€æ–‡ä»¶çš„è®°å½•è¡¨ã€‚å½“ç¨‹åºæ‰“å¼€ä¸€ä¸ªç°æœ‰æ–‡ä»¶æˆ–è€…åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶æ—¶ï¼Œå†…æ ¸å‘è¿›ç¨‹è¿”å›ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ã€‚åœ¨ç¨‹åºè®¾è®¡ä¸­ï¼Œä¸€äº›æ¶‰åŠåº•å±‚çš„ç¨‹åºç¼–å†™å¾€å¾€ä¼šå›´ç»•ç€æ–‡ä»¶æè¿°ç¬¦å±•å¼€ã€‚ä½†æ˜¯æ–‡ä»¶æè¿°ç¬¦è¿™ä¸€æ¦‚å¿µå¾€å¾€åªé€‚ç”¨äºUNIXã€Linuxè¿™æ ·çš„æ“ä½œç³»ç»Ÿã€‚\nä»£ç è§async-echo-serverã€‚\næµç¨‹å›¾ï¼š\nå…ˆçœ‹çœ‹æ–‡ä»¶çš„ç»“æ„ï¼š\nmain epoll tcp_listener executor reactor util tcp_listener:\nè¿™é‡Œä¸»è¦æ˜¯å‡ ä¸ªå¼‚æ­¥è®¡ç®—çš„å®ç°ï¼Œä¹Ÿå°±æ˜¯AccpectFutureã€ReadFutureã€WriteFutureã€‚\nepollï¼šLinuxä¸‹epollçš„å°è£…ã€‚\nä¸»è¦å°±æ˜¯è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ï¼Œé‡è¦çš„æ˜¯epollçš„ä¸‰ä¸ªæ–¹æ³•epoll_createã€epoll_ctlã€epoll_waitã€‚\nexecutorï¼šæ‰§è¡Œå™¨ï¼Œæ€æ ·è°ƒåº¦è¿™äº›ç»¿è‰²çº¿ç¨‹ï¼Œå¦‚ä½•æ‰§è¡Œä»»åŠ¡ã€‚\nreactorï¼šæ·»åŠ äº‹ä»¶ï¼Œæ£€æµ‹åˆ°äº‹ä»¶åå”¤é†’äº‹ä»¶ï¼Œè®©æ‰§è¡Œå™¨å»æ‰§è¡Œã€‚\næ·±å…¥ç†è§£å¼‚æ­¥Taskæ¨¡å‹ å›é¡¾ Rust å¼‚æ­¥ task æ¨¡å‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 +------------------------------------------------------------------+ | | | +--------------------------------------------------------+ | | | | | | | +-------------------------------------------------+ | | | | |-------------+ +----------+ +--------------+ | | | | | || futureobj | | futureobj| | futureobj | | | | | | +-------------+ +----------+ +--------------+ | | | | | | å ç¨‹ task | | | | | +-------------------------------------------------+ | | | | | | | | çº¿ ç¨‹ | | | +--------------------------------------------------------+ | | | | | | +--------------------------------------------------------+ | | | +--------------------------------------------------+ | | | | | | | | | | | +------------+ +-------------------------------+ | | | | | | futureobj | | futureobj || futureobj || | | | | | +------------+ +-------------------------------+ | | | | | å ç¨‹ task | | | | | +--------------------------------------------------+ | | | | çº¿ ç¨‹ | | | +--------------------------------------------------------+ | | | | è¿› ç¨‹ | +------------------------------------------------------------------+ ä»€ä¹ˆæ˜¯åç¨‹ï¼Ÿ\nåç¨‹ï¼ˆè‹±è¯­ï¼šcoroutineï¼‰æ˜¯è®¡ç®—æœºç¨‹åºçš„ä¸€ç±»ç»„ä»¶ï¼Œæ¨å¹¿äº†åä½œå¼å¤šä»»åŠ¡çš„å­ä¾‹ç¨‹ï¼Œå…è®¸æ‰§è¡Œè¢«æŒ‚èµ·ä¸è¢«æ¢å¤ã€‚ç›¸å¯¹å­ä¾‹ç¨‹è€Œè¨€ï¼Œåç¨‹æ›´ä¸ºä¸€èˆ¬å’Œçµæ´»ï¼Œä½†åœ¨å®è·µä¸­ä½¿ç”¨æ²¡æœ‰å­ä¾‹ç¨‹é‚£æ ·å¹¿æ³›ã€‚åç¨‹æ›´é€‚åˆäºç”¨æ¥å®ç°å½¼æ­¤ç†Ÿæ‚‰çš„ç¨‹åºç»„ä»¶ï¼Œå¦‚åä½œå¼å¤šä»»åŠ¡ã€å¼‚å¸¸å¤„ç†ã€äº‹ä»¶å¾ªç¯ã€è¿­ä»£å™¨ã€æ— é™åˆ—è¡¨å’Œç®¡é“ã€‚\nåŒçº¿ç¨‹çš„æ¯”è¾ƒ\nåç¨‹éå¸¸ç±»ä¼¼äºçº¿ç¨‹ã€‚ä½†æ˜¯åç¨‹æ˜¯åä½œå¼å¤šä»»åŠ¡çš„ï¼Œè€Œçº¿ç¨‹å…¸å‹æ˜¯æŠ¢å å¼å¤šä»»åŠ¡çš„ã€‚è¿™æ„å‘³ç€åç¨‹æä¾›å¹¶å‘æ€§è€Œéå¹¶è¡Œæ€§ã€‚åç¨‹è¶…è¿‡çº¿ç¨‹çš„å¥½å¤„æ˜¯å®ƒä»¬å¯ä»¥ç”¨äºç¡¬æ€§å®æ—¶çš„è¯­å¢ƒï¼ˆåœ¨åç¨‹ä¹‹é—´çš„åˆ‡æ¢ä¸éœ€è¦æ¶‰åŠä»»ä½•ç³»ç»Ÿè°ƒç”¨æˆ–ä»»ä½•é˜»å¡è°ƒç”¨ï¼‰ï¼Œè¿™é‡Œä¸éœ€è¦ç”¨æ¥å®ˆå«å…³é”®åŒºæ®µçš„åŒæ­¥æ€§åŸè¯­ï¼ˆprimitiveï¼‰æ¯”å¦‚äº’æ–¥é”ã€ä¿¡å·é‡ç­‰ï¼Œå¹¶ä¸”ä¸éœ€è¦æ¥è‡ªæ“ä½œç³»ç»Ÿçš„æ”¯æŒã€‚æœ‰å¯èƒ½ä»¥ä¸€ç§å¯¹è°ƒç”¨ä»£ç é€æ˜çš„æ–¹å¼ï¼Œä½¿ç”¨æŠ¢å å¼è°ƒåº¦çš„çº¿ç¨‹å®ç°åç¨‹ï¼Œä½†æ˜¯ä¼šå¤±å»æŸäº›åˆ©ç›Šï¼ˆç‰¹åˆ«æ˜¯å¯¹ç¡¬æ€§å®æ—¶æ“ä½œçš„é€‚åˆæ€§å’Œç›¸å¯¹å»‰ä»·çš„ç›¸äº’ä¹‹é—´åˆ‡æ¢ï¼‰ã€‚\nçº¿ç¨‹æ˜¯åä½œå¼å¤šä»»åŠ¡çš„è½»é‡çº§çº¿ç¨‹ï¼Œæœ¬è´¨ä¸Šæè¿°äº†åŒåç¨‹ä¸€æ ·çš„æ¦‚å¿µã€‚å…¶åŒºåˆ«ï¼Œå¦‚æœä¸€å®šè¦è¯´æœ‰çš„è¯ï¼Œæ˜¯åç¨‹æ˜¯è¯­è¨€å±‚çº§çš„æ„é€ ï¼Œå¯çœ‹ä½œä¸€ç§å½¢å¼çš„æ§åˆ¶æµï¼Œè€Œçº¿ç¨‹æ˜¯ç³»ç»Ÿå±‚çº§çš„æ„é€ ï¼Œå¯çœ‹ä½œæ°å·§æ²¡æœ‰å¹¶è¡Œè¿è¡Œçš„çº¿ç¨‹ã€‚è¿™ä¸¤ä¸ªæ¦‚å¿µè°æœ‰ä¼˜å…ˆæƒæ˜¯äº‰è®®æ€§çš„ï¼šçº¿ç¨‹å¯çœ‹ä½œä¸ºåç¨‹çš„ä¸€ç§å®ç°[6]ï¼Œä¹Ÿå¯çœ‹ä½œå®ç°åç¨‹çš„åŸºåº•[7]ã€‚\nç†è§£ leaf-futures vs Non-leaf-futures (async/await) å¶å­futuresï¼šåƒä»£ç ç¤ºä¾‹ä¸­çš„AccpectFutureã€ReadFutureã€WriteFutureï¼Œè¦å’ŒReactoræ‰“äº¤é“ï¼Œæ¯”è¾ƒåº•å±‚ã€‚ éå¶å­futuresï¼šç”¨asyncæˆ–è€…awaitå®ç°ï¼Œä¸šåŠ¡å±‚é¢çš„ã€‚ ç†è§£ Wakerï¼š å½“äº‹ä»¶æºæ³¨å†Œè¯¥Futureå°†åœ¨æŸä¸ªäº‹ä»¶ä¸Šç­‰å¾…æ—¶ï¼Œå®ƒå¿…é¡»å­˜å‚¨å”¤é†’ç¨‹åºï¼Œä»¥ä¾¿ä»¥åå¯ä»¥è°ƒç”¨å”¤é†’æ¥å¼€å§‹å”¤é†’é˜¶æ®µã€‚ ä¸ºäº†å¼•å…¥å¹¶å‘æ€§ï¼Œèƒ½å¤ŸåŒæ—¶ç­‰å¾…å¤šä¸ªäº‹ä»¶éå¸¸é‡è¦ï¼Œå› æ­¤å”¤é†’å™¨ä¸å¯èƒ½ç”±å•ä¸ªäº‹ä»¶æºå”¯ä¸€æ‹¥æœ‰ã€‚ ç»“æœï¼ŒWakerç±»å‹éœ€è¦æ˜¯å®ç° Clone çš„ã€‚\nStruct std::task::Waker\n1 2 3 4 5 #[repr(transparent)] #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] pub struct Waker { waker: RawWaker, } Waker å¯ä»¥å”¤é†’ä¸€ä¸ªä»»åŠ¡ï¼Œé€šè¿‡é€šçŸ¥æ‰§è¡Œå™¨ã€‚\nWakerå®ç°äº†ä¸€äº›traitã€‚\n1 2 3 4 5 6 #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] impl Unpin for Waker {} #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] unsafe impl Send for Waker {} #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] unsafe impl Sync for Waker {} 1 2 3 4 5 6 7 8 9 10 11 12 #[derive(PartialEq, Debug)] #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] pub struct RawWaker { /// A data pointer, which can be used to store arbitrary data as required /// by the executor. This could be e.g. a type-erased pointer to an `Arc` /// that is associated with the task. /// The value of this field gets passed to all functions that are part of /// the vtable as the first parameter. data: *const (), /// Virtual function pointer table that customizes the behavior of this waker. vtable: \u0026amp;\u0026#39;static RawWakerVTable, } è¿™é‡ŒRawwakeræœ‰ä¸¤ä¸ªå†…å®¹ï¼Œä¸€ä¸ªdataå¯ä»¥ä¿å­˜ä¸Šä¸‹æ–‡ï¼Œä¸€ä¸ªvtableæ˜¯è™šè¡¨ã€‚\nç†è§£å¹¶å‘ï¼ˆwaker å¹¶å‘ å’Œ poll å¹¶å‘ï¼‰ æ·±å…¥ Futures-rs:\nFuture and task futures-rs futures-lite async-awaitè¯­æ³•èƒŒå å†å² å¤„ç†å¼‚æ­¥äº‹ä»¶çš„ä¸‰ç§æ–¹å¼ï¼š\nCallback Promise/Future async/await async/await æ˜¯ç›®å‰ä½“éªŒæœ€å¥½çš„æ–¹å¼ï¼ŒRust è¦æ”¯æŒå®ƒå¹¶ä¸å®¹æ˜“ã€‚\nasync/await è¯­æ³•ä»‹ç» å‚è€ƒï¼šAsynchronous Programming in Rust\nasync ä¸¤ç§ç”¨æ³•ï¼šasync fn å‡½æ•° å’Œ async {} å—ã€‚\n1 2 3 4 5 6 7 8 9 10 11 // async å‡½æ•°ï¼ŒçœŸæ­£ä¼šè¿”å› `Future\u0026lt;Output = u8\u0026gt;`ï¼Œè€Œä¸æ˜¯è¡¨é¢çœ‹ä¸Šå»çš„ `u8` async fn foo() -\u0026gt; u8 { 5 } // async å—ç”¨æ³•ï¼Œè¿”å› `impl Future\u0026lt;Output = u8\u0026gt;` fn bar() -\u0026gt; impl Future\u0026lt;Output = u8\u0026gt; { // è¿™é‡Œ `async` å—è¿”å› `impl Future\u0026lt;Output = u8\u0026gt;` async { let x: u8 = foo().await; x + 5 } } await å°†æš‚åœå½“å‰å‡½æ•°çš„æ‰§è¡Œï¼Œç›´åˆ°æ‰§è¡Œè€…å°† Future ç»“æŸä¸ºæ­¢ã€‚è¿™ä¸ºå…¶ä»– Future ä»»åŠ¡æä¾›äº†è®¡ç®—çš„æœºä¼šã€‚\nç”Ÿæˆå™¨ Future åº•å±‚å®ç°ä¾èµ–äº ç”Ÿæˆå™¨ã€‚ async/await å¯¹åº”åº•å±‚ç”Ÿæˆå™¨ resume/yield ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #![feature(generators, generator_trait)] use std::ops::Generator; use std::pin::Pin; fn main() { let mut gen = || { yield 1; yield 2; yield 3; return 4; }; // for _ in 0..4 { // // ä¸ºäº†ç»™åµŒå…¥å¼æ”¯æŒå¼‚æ­¥ï¼Œå¤šä¼ å…¥äº†ä¸€ä¸ªç©ºçš„unitç»™resumeæ–¹æ³• // let c = Pin::new(\u0026amp;mut gen).resume(()); // println!(\u0026#34;{:?}\u0026#34;, c); // } let c = Pin::new(\u0026amp;mut gen).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); let c = Pin::new(\u0026amp;mut gen).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); let c = Pin::new(\u0026amp;mut gen).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); let c = Pin::new(\u0026amp;mut gen).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); } ç”Ÿæˆç­‰ä»·ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #![allow(unused)] #![feature(generators, generator_trait)] use std::ops::{Generator, GeneratorState}; use std::pin::Pin; enum __Gen { // (0) åˆå§‹çŠ¶æ€ Start, // (1) resumeæ–¹æ³•æ‰§è¡Œä»¥å State1(State1), // (2) resumeæ–¹æ³•æ‰§è¡Œä»¥å State2(State2), // (3) resumeæ–¹æ³•æ‰§è¡Œä»¥å State3(State3), // (4) resumeæ–¹æ³•æ‰§è¡Œä»¥åï¼Œæ­£å¥½å®Œæˆ Done } struct State1 { x: u64 } struct State2 { x: u64 } struct State3 { x: u64 } impl Generator for __Gen { type Yield = u64; type Return = u64; fn resume(self: Pin\u0026lt;\u0026amp;mut Self\u0026gt;, _: ()) -\u0026gt; GeneratorState\u0026lt;u64, u64\u0026gt; { let mut_ref = self.get_mut(); match std::mem::replace(mut_ref, __Gen::Done) { __Gen::Start =\u0026gt; { *mut_ref = __Gen::State1(State1{x: 1}); GeneratorState::Yielded(1) } __Gen::State1(State1{x: 1}) =\u0026gt; { *mut_ref = __Gen::State2(State2{x: 2}); GeneratorState::Yielded(2) } __Gen::State2(State2{x: 2}) =\u0026gt; { *mut_ref = __Gen::State3(State3{x: 3}); GeneratorState::Yielded(3) } __Gen::State3(State3{x: 3}) =\u0026gt; { *mut_ref = __Gen::Done; GeneratorState::Complete(4) } _ =\u0026gt; { panic!(\u0026#34;generator resumed after completion\u0026#34;) } } } } fn main(){ let mut gen = { __Gen::Start }; for _ in 0..4 { println!(\u0026#34;{:?}\u0026#34;, unsafe{ Pin::new(\u0026amp;mut gen).resume(())}); } } ç”Ÿæˆå™¨åŸºæœ¬ç”¨æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #![allow(unused)] #![feature(generators, generator_trait)] use std::pin::Pin; use std::ops::Generator; pub fn up_to(limit: u64) -\u0026gt; impl Generator\u0026lt;Yield = u64, Return = u64\u0026gt; { move || { for x in 0..limit { yield x; } return limit; } } fn main(){ let a = 10; let mut b = up_to(a); unsafe { for _ in 0..=10{ let c = Pin::new(\u0026amp;mut b).resume(()); println!(\u0026#34;{:?}\u0026#34;, c); } } } ç”Ÿæˆå™¨å˜èº«ä¸ºè¿­ä»£å™¨ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #![allow(unused)] #![feature(generators, generator_trait)] use std::pin::Pin; use std::ops::{Generator, GeneratorState}; pub fn up_to() -\u0026gt; impl Generator\u0026lt;Yield = u64, Return = ()\u0026gt; { move || { let mut x = 0; loop { x += 1; yield x; } return (); } } fn main(){ let mut gen = up_to(); unsafe { for _ in 0..10{ match Pin::new(\u0026amp;mut gen).resume(()) { GeneratorState::Yielded(i) =\u0026gt; println!(\u0026#34;{:?}\u0026#34;, i), _ =\u0026gt; println!(\u0026#34;Completed\u0026#34;), } } } } ç”Ÿæˆå™¨å˜èº«ä¸º Future:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #![allow(unused)] #![feature(generators, generator_trait)] use std::ops::{Generator, GeneratorState}; use std::pin::Pin; pub fn up_to(limit: u64) -\u0026gt; impl Generator\u0026lt;Yield = (), Return = Result\u0026lt;u64, ()\u0026gt;\u0026gt; { move || { for x in 0..limit { yield (); } return Ok(limit); } } fn main(){ let limit = 2; let mut gen = up_to(limit); unsafe { for i in 0..=limit{ match Pin::new(\u0026amp;mut gen).resume(()) { GeneratorState::Yielded(v) =\u0026gt; println!(\u0026#34;resume {:?} : Pending\u0026#34;, i), GeneratorState::Complete(v) =\u0026gt; println!(\u0026#34;resume {:?} : Ready\u0026#34;, i), } } } } åœ¨æ ‡å‡†åº“Futureå†…éƒ¨ï¼Œå¯ä»¥ä»Generatorè½¬æ¢ä¸ºFutureã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #[lang = \u0026#34;from_generator\u0026#34;] #[doc(hidden)] #[unstable(feature = \u0026#34;gen_future\u0026#34;, issue = \u0026#34;50547\u0026#34;)] #[rustc_const_unstable(feature = \u0026#34;gen_future\u0026#34;, issue = \u0026#34;50547\u0026#34;)] #[inline] pub const fn from_generator\u0026lt;T\u0026gt;(gen: T) -\u0026gt; impl Future\u0026lt;Output = T::Return\u0026gt; where T: Generator\u0026lt;ResumeTy, Yield = ()\u0026gt;, { #[rustc_diagnostic_item = \u0026#34;gen_future\u0026#34;] struct GenFuture\u0026lt;T: Generator\u0026lt;ResumeTy, Yield = ()\u0026gt;\u0026gt;(T); // We rely on the fact that async/await futures are immovable in order to create // self-referential borrows in the underlying generator. impl\u0026lt;T: Generator\u0026lt;ResumeTy, Yield = ()\u0026gt;\u0026gt; !Unpin for GenFuture\u0026lt;T\u0026gt; {} impl\u0026lt;T: Generator\u0026lt;ResumeTy, Yield = ()\u0026gt;\u0026gt; Future for GenFuture\u0026lt;T\u0026gt; { type Output = T::Return; fn poll(self: Pin\u0026lt;\u0026amp;mut Self\u0026gt;, cx: \u0026amp;mut Context\u0026lt;\u0026#39;_\u0026gt;) -\u0026gt; Poll\u0026lt;Self::Output\u0026gt; { // SAFETY: Safe because we\u0026#39;re !Unpin + !Drop, and this is just a field projection. let gen = unsafe { Pin::map_unchecked_mut(self, |s| \u0026amp;mut s.0) }; // Resume the generator, turning the `\u0026amp;mut Context` into a `NonNull` raw pointer. The // `.await` lowering will safely cast that back to a `\u0026amp;mut Context`. match gen.resume(ResumeTy(NonNull::from(cx).cast::\u0026lt;Context\u0026lt;\u0026#39;static\u0026gt;\u0026gt;())) { GeneratorState::Yielded(()) =\u0026gt; Poll::Pending, GeneratorState::Complete(x) =\u0026gt; Poll::Ready(x), } } } GenFuture(gen) } no-stdå¼‚æ­¥ç”Ÿæ€ä»‹ç» futures-micro å¯¹futuresçš„æœ€å°çš„å®ç° embassy åµŒå…¥å¼ç”Ÿæ€ executor for no-std no-stdçš„æ‰§è¡Œå™¨ï¼Œå¯ä»¥ç”¨åœ¨åµŒå…¥å¼åŠWebAssemblyä¸Š ä¸€ä¸ªå¼‚æ­¥ç¼“å­˜ä»£ç å®ç° ä»£ç è§retainerã€‚\nä¸‹é¢åˆ†æä¸‹ä»£ç ç»“æ„ï¼Œé¦–å…ˆæ˜¯ entry.rsã€‚\nç¼“å­˜çš„entryç»“æ„ï¼š\n1 2 3 4 5 #[derive(Debug)] pub struct CacheEntry\u0026lt;V\u0026gt; { pub(crate) value: V, pub(crate) expiration: Option\u0026lt;CacheExpiration\u0026gt;, } æœ‰ç›¸åº”çš„å€¼valueä»¥åŠè¿‡æœŸæ—¶é—´expirationï¼Œè¿™é‡Œè¿‡æœŸæ—¶é—´æ˜¯ä¸€ä¸ªOptionï¼Œå› ä¸ºæœ‰çš„å¯ä»¥æ²¡æœ‰è¿‡æœŸæ—¶é—´ã€‚\nCacheExpirationï¼š\n1 2 3 4 #[derive(Debug)] pub struct CacheExpiration { instant: Instant, } ä»£è¡¨ç¼“å­˜ä¸­çš„è¿‡æœŸæ—¶é—´ï¼Œè¿™é‡Œå¯¹Instantæœ‰ä¸€ä¸ªåŒ…è£…ï¼Œæ–¹ä¾¿å®ç°ä¸€äº›æ–¹æ³•ã€‚\n1 2 3 4 5 #[derive(Debug)] pub struct CacheEntryReadGuard\u0026lt;\u0026#39;a, V\u0026gt; { pub(crate) entry: *const CacheEntry\u0026lt;V\u0026gt;, pub(crate) marker: PhantomData\u0026lt;\u0026amp;\u0026#39;a CacheEntry\u0026lt;V\u0026gt;\u0026gt;, } å¯¹åº•å±‚ç¼“å­˜ç»“æ„çš„å¼•ç”¨çš„ä¸€ä¸ªè¯»ä¿æŠ¤ã€‚å½“ä½¿ç”¨é”çš„æ—¶å€™ï¼Œè¿™ä¸ªç»“æ„å¯ä»¥è¿”å›ä¸€ä¸ªæŒ‡å‘å†…éƒ¨ç¼“å­˜ entries çš„å¼•ç”¨ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚åŒæ—¶CacheEntryReadGuardå®ç°äº†Sendå’ŒSyncã€‚\n1 2 3 // Stores a raw pointer to `T`, so if `T` is `Sync`, the lock guard over `T` is `Send`. unsafe impl\u0026lt;V\u0026gt; Send for CacheEntryReadGuard\u0026lt;\u0026#39;_, V\u0026gt; where V: Sized + Sync {} unsafe impl\u0026lt;V\u0026gt; Sync for CacheEntryReadGuard\u0026lt;\u0026#39;_, V\u0026gt; where V: Sized + Send + Sync {} cache.rs\nç¼“å­˜ç»“æ„ï¼š\n1 2 3 4 pub struct Cache\u0026lt;K, V\u0026gt; { store: RwLock\u0026lt;BTreeMap\u0026lt;K, CacheEntry\u0026lt;V\u0026gt;\u0026gt;\u0026gt;, label: String, } ç›‘æ§æ˜¯å¦æœ‰è¿‡æœŸç¼“å­˜ï¼š\n1 2 3 4 5 6 7 pub async fn monitor(\u0026amp;self, sample: usize, threshold: f64, frequency: Duration) { let mut interval = Interval::platform_new(frequency); loop { interval.as_mut().await; self.purge(sample, threshold).await; } } å¯ä»¥çœ‹åˆ° purge å‡½æ•°æœ€ç»ˆå®ç°å¼‚æ­¥æ¸…ç†ã€‚\nè¿™é‡Œè¯´ä¸‹Redisçš„ç¼“å­˜è¿‡æœŸå¤„ç†æ–¹å¼ï¼š\næƒ°æ€§åˆ é™¤ã€‚å½“æŸ¥æ‰¾ä¸€ä¸ªkeyï¼Œè¿‡æœŸæ—¶åˆ é™¤ã€‚ å®šæœŸåˆ é™¤ã€‚æ¯éš”ä¸€æ®µæ—¶é—´ï¼Œéšæœºå–ä¸€å®šæ•°é‡çš„keyï¼Œçœ‹çœ‹ç¼“å­˜ä¸­æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœåˆ°è¾¾ä¸€å®šçš„é˜ˆå€¼æ¯”å¦‚20%å·²ç»è¿‡æœŸäº†ï¼Œåˆ™è¿›è¡Œåˆ é™¤ï¼Œå¦‚æœæ²¡æœ‰åˆ°è¾¾è¯¥é˜ˆå€¼ï¼Œåˆ™ä¸åˆ é™¤ã€‚ å…³äºRedisç¼“å­˜ï¼Œå‚è§Redisç¼“å­˜æ€»ç»“ï¼šæ·˜æ±°æœºåˆ¶ã€ç¼“å­˜é›ªå´©ã€æ•°æ®ä¸ä¸€è‡´\u0026hellip;.ã€‚\nå¼‚æ­¥è¿è¡Œæ—¶ç”Ÿæ€ tokio å’Œrustå¼‚æ­¥æ ‡å‡†æœ‰äº›å·®å¼‚ï¼Œæˆç†Ÿ async-std è®©å¼€å‘è€…é¡ºåˆ©ç¼–å†™å¼‚æ­¥ï¼Œå¯¹æ ‡å‡†åº“çš„å¼‚æ­¥ smol è½»é‡çº§ï¼Œæ¯”è¾ƒé€šç”¨ glommio ç”Ÿäº§çº§åº”ç”¨ bastion é«˜å¯ç”¨åˆ†å¸ƒå¼å®¹é”™æ¡†æ¶ smolè¿è¡Œæ—¶ å…ˆçœ‹çœ‹smolä¸­çš„Cargo.tomlã€‚\n1 2 3 4 5 6 7 8 9 10 11 [dependencies] async-channel = \u0026#34;1.4.2\u0026#34; async-executor = \u0026#34;1.3.0\u0026#34; async-fs = \u0026#34;1.3.0\u0026#34; async-io = \u0026#34;1.1.2\u0026#34; async-lock = \u0026#34;2.3.0\u0026#34; async-net = \u0026#34;1.4.3\u0026#34; async-process = \u0026#34;1.0.0\u0026#34; blocking = \u0026#34;1.0.0\u0026#34; futures-lite = \u0026#34;1.11.0\u0026#34; once_cell = \u0026#34;1.4.1\u0026#34; smolå¯¹è¿™äº›ç»„ä»¶åšäº†ä¸€ä¸ªæ•´åˆï¼Œè¿™äº›ç»„ä»¶ä¹Ÿå¯ä»¥å•ç‹¬ä½¿ç”¨ã€‚\nsmolæ–‡æ¡£ Modules\nName Description channel An async multi-producer multi-consumer channel. fs Async filesystem primitives. future Combinators for the Future trait. io Tools and combinators for I/O. lock Async synchronization primitives. net Async networking primitives for TCP/UDP/Unix communication. prelude Traits Future, Stream, AsyncRead, AsyncWrite, AsyncBufRead, AsyncSeek, and their extensions. process Async interface for working with processes. stream Combinators for the Stream trait. Structs\nName Description Async Async adapter for I/O types. å¼‚æ­¥é€‚é…å™¨ï¼Œå¯ä»¥å°†é˜»å¡IOå˜ä¸ºéé˜»å¡IOã€‚ Executor An async executor. å¼‚æ­¥æ‰§è¡Œå™¨ã€‚ LocalExecutor A thread-local executor. å•çº¿ç¨‹æ‰§è¡Œå™¨ã€‚ Task A spawned task. ä»»åŠ¡ã€‚ Timer A future that expires at a point in time. Unblock Runs blocking I/O on a thread pool. smolæºç  src/spawn.rs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 use once_cell::sync::Lazy; /// å°†å¼‚æ­¥ä»»åŠ¡åŠ å…¥åˆ° task ä¸­ï¼Œäº¤ç»™ Global æ‰§è¡Œå™¨ pub fn spawn\u0026lt;T: Send + \u0026#39;static\u0026gt;(future: impl Future\u0026lt;Output = T\u0026gt; + Send + \u0026#39;static) -\u0026gt; Task\u0026lt;T\u0026gt; { static GLOBAL: Lazy\u0026lt;Executor\u0026lt;\u0026#39;_\u0026gt;\u0026gt; = Lazy::new(|| { let num_threads = { // Parse SMOL_THREADS or default to 1. std::env::var(\u0026#34;SMOL_THREADS\u0026#34;) .ok() .and_then(|s| s.parse().ok()) .unwrap_or(1) }; for n in 1..=num_threads { thread::Builder::new() .name(format!(\u0026#34;smol-{}\u0026#34;, n)) .spawn(|| loop { // catch_unwind æ–¹æ³• // å¯ä»¥æ•è·æ ˆå±•å¼€ï¼Œè¿è¡Œpanicçº¿ç¨‹å­˜æ´»å¹¶ç»§ç»­è¿è¡Œã€‚ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„std::panic::catch_unwind()å‡½æ•°ã€‚ catch_unwind(|| block_on(GLOBAL.run(future::pending::\u0026lt;()\u0026gt;()))).ok(); }) .expect(\u0026#34;cannot spawn executor thread\u0026#34;); } Executor::new() }); GLOBAL.spawn(future) } èŠå¤©æ¡†ä¾‹å­ chat-server èŠå¤©æ¡†æœåŠ¡å™¨çš„äº‹ä»¶ï¼š\n1 2 3 4 5 6 7 8 9 10 11 /// An event on the chat server. enum Event { /// A client has joined. Join(SocketAddr, Arc\u0026lt;Async\u0026lt;TcpStream\u0026gt;\u0026gt;), /// A client has left. Leave(SocketAddr), /// A client sent a message. Message(SocketAddr, String), } å‘å®¢æˆ·ç«¯åˆ†å‘äº‹ä»¶ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /// Dispatches events to clients. async fn dispatch(receiver: Receiver\u0026lt;Event\u0026gt;) -\u0026gt; io::Result\u0026lt;()\u0026gt; { // Currently active clients. let mut map = HashMap::\u0026lt;SocketAddr, Arc\u0026lt;Async\u0026lt;TcpStream\u0026gt;\u0026gt;\u0026gt;::new(); // Receive incoming events. while let Ok(event) = receiver.recv().await { // Process the event and format a message to send to clients. let output = match event { Event::Join(addr, stream) =\u0026gt; { map.insert(addr, stream); format!(\u0026#34;{} has joined\\n\u0026#34;, addr) } Event::Leave(addr) =\u0026gt; { map.remove(\u0026amp;addr); format!(\u0026#34;{} has left\\n\u0026#34;, addr) } Event::Message(addr, msg) =\u0026gt; format!(\u0026#34;{} says: {}\\n\u0026#34;, addr, msg), }; // Display the event in the server process. print!(\u0026#34;{}\u0026#34;, output); // Send the event to all active clients. for stream in map.values_mut() { // Ignore errors because the client might disconnect at any point. stream.write_all(output.as_bytes()).await.ok(); } } Ok(()) } æœåŠ¡ç«¯ main å‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 fn main() -\u0026gt; io::Result\u0026lt;()\u0026gt; { smol::block_on(async { // Create a listener for incoming client connections. let listener = Async::\u0026lt;TcpListener\u0026gt;::bind(([127, 0, 0, 1], 6000))?; // Intro messages. println!(\u0026#34;Listening on {}\u0026#34;, listener.get_ref().local_addr()?); println!(\u0026#34;Start a chat client now!\\n\u0026#34;); // Spawn a background task that dispatches events to clients. // é€šè¿‡ channel å®ç°æ¶ˆæ¯ä¼ é€’ let (sender, receiver) = bounded(100); // detach å‡½æ•° // åˆ†ç¦»ä»»åŠ¡ï¼Œè®©å®ƒåœ¨åå°è¿è¡Œ smol::spawn(dispatch(receiver)).detach(); loop { // Accept the next connection. let (stream, addr) = listener.accept().await?; let client = Arc::new(stream); let sender = sender.clone(); // Spawn a background task reading messages from the client. smol::spawn(async move { // Client starts with a `Join` event. sender.send(Event::Join(addr, client.clone())).await.ok(); // Read messages from the client and ignore I/O errors when the client quits. read_messages(sender.clone(), client).await.ok(); // Client ends with a `Leave` event. sender.send(Event::Leave(addr)).await.ok(); }) .detach(); } }) } chat-client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn main() -\u0026gt; io::Result\u0026lt;()\u0026gt; { smol::block_on(async { // Connect to the server and create async stdin and stdout. let stream = Async::\u0026lt;TcpStream\u0026gt;::connect(([127, 0, 0, 1], 6000)).await?; let stdin = Unblock::new(std::io::stdin()); let mut stdout = Unblock::new(std::io::stdout()); // Intro messages. println!(\u0026#34;Connected to {}\u0026#34;, stream.get_ref().peer_addr()?); println!(\u0026#34;My nickname: {}\u0026#34;, stream.get_ref().local_addr()?); println!(\u0026#34;Type a message and hit enter!\\n\u0026#34;); let reader = \u0026amp;stream; let mut writer = \u0026amp;stream; // Wait until the standard input is closed or the connection is closed. future::race( async { let res = io::copy(stdin, \u0026amp;mut writer).await; println!(\u0026#34;Quit!\u0026#34;); res }, async { let res = io::copy(reader, \u0026amp;mut stdout).await; println!(\u0026#34;Server disconnected!\u0026#34;); res }, ) .await?; Ok(()) }) } futures_lite æ–‡æ¡£ï¼šfutures_liteï¼Œfuturesåº“çš„è½»é‡ç‰ˆã€‚\nModules\nName Description future Combinators for the Future trait. io Tools and combinators for I/O. prelude Traits Future, Stream, AsyncRead, AsyncWrite, AsyncBufRead, AsyncSeek, and their extensions. stream Combinators for the Stream trait. ä¸»è¦å°±æ˜¯ä¸Šè¿°å››ä¸ªæ¨¡å—ã€‚\nasync_io æ–‡æ¡£ï¼šasync_io\nåœ¨async_io/lib.rsä¸­å®šä¹‰äº†ä¸¤ä¸ªç»“æ„ä½“ï¼Œä¸€ä¸ªæ˜¯Timerï¼Œå¦ä¸€ä¸ªæ˜¯Asyncã€‚\nTimer: åœ¨æŸä¸ªæ—¶é—´ç‚¹åˆ°æœŸçš„ Futureã€‚ Async: åœ¨å¼‚æ­¥ç¼–ç¨‹ä¸­åœ¨æ ‡å‡†ç½‘ç»œç±»å‹ï¼ˆè¿˜æœ‰è®¸å¤šå…¶ä»–ç±»å‹çš„ï¼‰ä¸­ä½¿ç”¨çš„ä¸€ä¸ªé€‚é…å™¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #[derive(Debug)] pub struct Timer { /// This timer\u0026#39;s ID and last waker that polled it. /// /// When this field is set to `None`, this timer is not registered in the reactor. id_and_waker: Option\u0026lt;(usize, Waker)\u0026gt;, /// The next instant at which this timer fires. when: Instant, /// The period. period: Duration, } #[derive(Debug)] pub struct Async\u0026lt;T\u0026gt; { /// A source registered in the reactor. source: Arc\u0026lt;Source\u0026gt;, /// The inner I/O handle. io: Option\u0026lt;T\u0026gt;, } è¿™é‡Œç”¨åˆ°äº†polling crateã€‚è¿™ä¸ªåº“å®ç°äº†è·¨å¹³å°çš„pollï¼Œæä¾›äº†å¾ˆå¤šæ¥å£ã€‚\nPortable interface to epoll, kqueue, event ports, and wepoll. Supported platforms:\nepoll : Linux, Android kqueue : macOS, iOS, FreeBSD, NetBSD, OpenBSD, DragonFly BSD event ports : illumos, Solaris poll : VxWorks, Fuchsia, other Unix systems wepoll : Windows ä¸‹é¢çœ‹çœ‹ async_io/reactor.rs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 pub(crate) struct Reactor { /// Portable bindings to epoll/kqueue/event ports/wepoll. /// /// This is where I/O is polled, producing I/O events. poller: Poller, /// Ticker bumped before polling. /// /// This is useful for checking what is the current \u0026#34;round\u0026#34; of `ReactorLock::react()` when /// synchronizing things in `Source::readable()` and `Source::writable()`. Both of those /// methods must make sure they don\u0026#39;t receive stale I/O events - they only accept events from a /// fresh \u0026#34;round\u0026#34; of `ReactorLock::react()`. ticker: AtomicUsize, /// Registered sources. sources: Mutex\u0026lt;Slab\u0026lt;Arc\u0026lt;Source\u0026gt;\u0026gt;\u0026gt;, /// Temporary storage for I/O events when polling the reactor. /// /// Holding a lock on this event list implies the exclusive right to poll I/O. events: Mutex\u0026lt;Vec\u0026lt;Event\u0026gt;\u0026gt;, /// An ordered map of registered timers. /// /// Timers are in the order in which they fire. The `usize` in this type is a timer ID used to /// distinguish timers that fire at the same time. The `Waker` represents the task awaiting the /// timer. timers: Mutex\u0026lt;BTreeMap\u0026lt;(Instant, usize), Waker\u0026gt;\u0026gt;, /// A queue of timer operations (insert and remove). /// /// When inserting or removing a timer, we don\u0026#39;t process it immediately - we just push it into /// this queue. Timers actually get processed when the queue fills up or the reactor is polled. timer_ops: ConcurrentQueue\u0026lt;TimerOp\u0026gt;, } è¿˜æœ‰ async_io/driver.rsï¼Œå…¶ä¸­æœ‰main_loopå‡½æ•°ï¼Œå¯¹async_ioçº¿ç¨‹è¿›è¡Œä¸»è¦çš„å¾ªç¯ï¼Œå¦å¤–è¿˜æœ‰block_onå‡½æ•°ï¼Œåœ¨æœ‰å¼‚æ­¥ä»»åŠ¡æ—¶é˜»å¡å½“å‰çš„çº¿ç¨‹ï¼Œåœ¨ç©ºé—²çš„æ—¶å€™å¤„ç†IOäº‹ä»¶ã€‚\nasync_task æ–‡æ¡£ï¼š async_task\nTask abstraction for building executors.\nTo spawn a future onto an executor, we first need to allocate it on the heap and keep some state attached to it. The state indicates whether the future is ready for polling, waiting to be woken up, or completed. Such a stateful future is called a task.\nAll executors have a queue that holds scheduled tasks:\n1 let (sender, receiver) = flume::unbounded(); è¿™é‡Œç”¨åˆ°äº†ç¬¬ä¸‰æ–¹åº“flumeã€‚å®ƒæ¯” crossbeam-channel æ›´åŠ è½»é‡ï¼Œå®ç°äº†mpmcã€‚\næ¥ç€æ¥çœ‹ async_task çš„å‡½æ•°ï¼š\nspawn\tåˆ›å»ºä¸€ä¸ªæ–°ä»»åŠ¡ã€‚ spawn_local åˆ›å»ºä¸€ä¸ªæ–°çš„æœ¬åœ°ä»»åŠ¡ã€‚ spawn_uncheckedâš \tCreates a new task without Send, Sync, and \u0026lsquo;static bounds. async_task çš„ç»“æ„ï¼š\nFallibleTask:\tA spawned task with a fallible response. Runnable:\tA handle to a runnable task. Task:\tA spawned task. åœ¨ async_task/raw.rs ä¸­å®šä¹‰äº†åº•å±‚çš„TaskVTableã€TaskLayoutã€RawTaskã€‚\nåœ¨ async_task/header.rs ä¸­å®šä¹‰äº†ç»“æ„ä½“Headerã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 pub(crate) struct Header { /// Current state of the task. /// /// Contains flags representing the current state and the reference count. pub(crate) state: AtomicUsize, /// The task that is blocked on the `Task` handle. /// /// This waker needs to be woken up once the task completes or is closed. pub(crate) awaiter: UnsafeCell\u0026lt;Option\u0026lt;Waker\u0026gt;\u0026gt;, /// The virtual table. /// /// In addition to the actual waker virtual table, it also contains pointers to several other /// methods necessary for bookkeeping the heap-allocated task. pub(crate) vtable: \u0026amp;\u0026#39;static TaskVTable, } ç›¸å½“äºåšä¸€äº›ä»»åŠ¡çš„å¤„ç†ï¼Œæä¾›äº†notifyã€takeã€registerä¸‰ä¸ªå‡½æ•°ã€‚\nè¿™é‡Œé¢ä»»åŠ¡çš„çŠ¶æ€stateæ˜¯åœ¨state.rsä¸­å®šä¹‰çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /// Set if the task is scheduled for running. pub(crate) const SCHEDULED: usize = 1 \u0026lt;\u0026lt; 0; /// Set if the task is running. pub(crate) const RUNNING: usize = 1 \u0026lt;\u0026lt; 1; /// Set if the task has been completed. pub(crate) const COMPLETED: usize = 1 \u0026lt;\u0026lt; 2; /// Set if the task is closed. pub(crate) const CLOSED: usize = 1 \u0026lt;\u0026lt; 3; /// Set if the `Task` still exists. pub(crate) const TASK: usize = 1 \u0026lt;\u0026lt; 4; /// Set if the `Task` is awaiting the output. pub(crate) const AWAITER: usize = 1 \u0026lt;\u0026lt; 5; /// Set if an awaiter is being registered. pub(crate) const REGISTERING: usize = 1 \u0026lt;\u0026lt; 6; /// Set if the awaiter is being notified. pub(crate) const NOTIFYING: usize = 1 \u0026lt;\u0026lt; 7; /// A single reference. pub(crate) const REFERENCE: usize = 1 \u0026lt;\u0026lt; 8; async_executor å¼‚æ­¥æ‰§è¡Œå™¨ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 use async_executor::Executor; use futures_lite::future; // Create a new executor. let ex = Executor::new(); // Spawn a task. let task = ex.spawn(async { println!(\u0026#34;Hello world\u0026#34;); }); // Run the executor until the task completes. future::block_on(ex.run(task)); blocking æ–‡æ¡£ï¼šblocking\nåœ¨å¼‚æ­¥ç¨‹åºé‡Œæä¾›äº†ä¸€ä¸ªçº¿ç¨‹æ± ç”¨äºéš”ç¦»é˜»å¡çš„IOã€‚\nunblock å‡½æ•°ï¼šå¯¹é˜»å¡çš„ä»£ç è¿›è¡Œå¼‚æ­¥åŒ–ã€‚\nUnblock ç±»å‹ï¼šå¯¹é˜»å¡çš„IOè¿›è¡Œå¼‚æ­¥åŒ–ã€‚é€šè¿‡ç»´æŠ¤ä¸€ä¸ªç¯å½¢é˜Ÿåˆ—æ¥è¿›è¡Œå¤„ç†ã€‚\nasync-fs å…¶ä¸­ç”¨åˆ°äº† blocking è¿™ä¸ªåº“ã€‚\nasync-std æ–‡æ¡£ï¼šasync_stdï¼Œrustæ ‡å‡†åº“çš„å¼‚æ­¥ç‰ˆæœ¬ã€‚\ntaskçš„ä½¿ç”¨ä»¥åŠæŠ½è±¡å‡ºæ¥çš„APIæ¥å£ç±»ä¼¼çº¿ç¨‹ï¼Œæ˜“äºä¸Šæ‰‹ã€‚\nasync_std å’Œ smol è¿è¡Œæ—¶ä¸€äº›æ¶æ„ä»¥åŠç»„ä»¶éƒ½æ˜¯å…¬ç”¨çš„ï¼Œå¹¶ä¸”å®ƒæä¾›äº†ä¸€ä¸ªç±»ä¼¼äºçº¿ç¨‹çš„ä¸€ä¸ªå¼‚æ­¥ task çš„æŠ½è±¡ï¼Œå¹¶ä¸”å®ƒè¿˜å…¼å®¹ tokioã€‚\ntokio githubä»“åº“åœ°å€ï¼štokio\nå®˜æ–¹ç½‘ç«™ï¼štokio.rs\næ–‡æ¡£ï¼štokio\nå®˜æ–¹æ–‡æ¡£ä»‹ç»ï¼š\nA runtime for writing reliable network applications without compromising speed.\nTokio is an event-driven, non-blocking I/O platform for writing asynchronous applications with the Rust programming language. At a high level, it provides a few major components:\nTools for working with asynchronous tasks, including synchronization primitives and channels and timeouts, sleeps, and intervals. APIs for performing asynchronous I/O, including TCP and UDP sockets, filesystem operations, and process and signal management. A runtime for executing asynchronous code, including a task scheduler, an I/O driver backed by the operating systemâ€™s event queue (epoll, kqueue, IOCP, etcâ€¦), and a high performance timer. Remark: loom æ¨¡å—ç”¨æ¥æ£€æµ‹å¼‚æ­¥å¹¶å‘ï¼Œä¹Ÿå¯ä»¥æ£€æµ‹åŒæ­¥å¹¶å‘ã€‚\nmini-redis githubä»“åº“åœ°å€ï¼šmini-redis Redisæ•™ç¨‹\n#[tokio::main]å®ï¼Œå®šä¹‰åœ¨tokio-macros/lib.rsä¸­ã€‚\n1 2 3 4 #[tokio::main] async fn main() { println!(\u0026#34;Hello world\u0026#34;); } å®å±•å¼€ä¹‹åä¸ºï¼š\n1 2 3 4 5 6 7 8 9 fn main() { tokio::runtime::Builder::new_multi_thread() .enable_all() .build() .unwrap() .block_on(async { println!(\u0026#34;Hello world\u0026#34;); }) } 1 2 3 4 5 #[proc_macro_attribute] #[cfg(not(test))] // Work around for rust-lang/rust#62127 pub fn main(args: TokenStream, item: TokenStream) -\u0026gt; TokenStream { entry::main(args, item, true) } åœ¨entry.rsä¸­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #[cfg(not(test))] // Work around for rust-lang/rust#62127 pub(crate) fn main(args: TokenStream, item: TokenStream, rt_multi_thread: bool) -\u0026gt; TokenStream { // If any of the steps for this macro fail, we still want to expand to an item that is as close // to the expected output as possible. This helps out IDEs such that completions and other // related features keep working. let input: syn::ItemFn = match syn::parse(item.clone()) { Ok(it) =\u0026gt; it, Err(e) =\u0026gt; return token_stream_with_error(item, e), }; let config = if input.sig.ident == \u0026#34;main\u0026#34; \u0026amp;\u0026amp; !input.sig.inputs.is_empty() { let msg = \u0026#34;the main function cannot accept arguments\u0026#34;; Err(syn::Error::new_spanned(\u0026amp;input.sig.ident, msg)) } else { AttributeArgs::parse_terminated .parse(args) .and_then(|args| build_config(input.clone(), args, false, rt_multi_thread)) }; match config { Ok(config) =\u0026gt; parse_knobs(input, false, config), Err(e) =\u0026gt; token_stream_with_error(parse_knobs(input, false, DEFAULT_ERROR_CONFIG), e), } } è¿˜æœ‰ä¸€ä¸ªselectå®ï¼Œå®˜æ–¹æ•™ç¨‹å‚è§Selectã€‚ä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 use tokio::sync::oneshot; #[tokio::main] async fn main() { let (tx1, rx1) = oneshot::channel(); let (tx2, rx2) = oneshot::channel(); tokio::spawn(async { let _ = tx1.send(\u0026#34;one\u0026#34;); }); tokio::spawn(async { let _ = tx2.send(\u0026#34;two\u0026#34;); }); tokio::select! { val = rx1 =\u0026gt; { println!(\u0026#34;rx1 completed first with {:?}\u0026#34;, val); } val = rx2 =\u0026gt; { println!(\u0026#34;rx2 completed first with {:?}\u0026#34;, val); } } } tokioçš„è¿è¡Œæ—¶æ˜¯é€šè¿‡Builderæ¥åˆ›å»ºçš„ã€‚tokioä¸­åˆ†ä¸¤ç§çº¿ç¨‹ï¼Œcoreçº¿ç¨‹ä¸“é—¨å¤„ç†å¼‚æ­¥ï¼Œblockingçº¿ç¨‹å¤„ç†åŒæ­¥ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 pub struct Builder { /// Runtime type kind: Kind, /// Whether or not to enable the I/O driver enable_io: bool, /// Whether or not to enable the time driver enable_time: bool, /// Whether or not the clock should start paused. start_paused: bool, /// The number of worker threads, used by Runtime. /// /// Only used when not using the current-thread executor. worker_threads: Option\u0026lt;usize\u0026gt;, // core çº¿ç¨‹ /// Cap on thread usage. max_blocking_threads: usize, // blockingçº¿ç¨‹æœ€å¤§æ•°é‡ /// Name fn used for threads spawned by the runtime. pub(super) thread_name: ThreadNameFn, /// Stack size used for threads spawned by the runtime. pub(super) thread_stack_size: Option\u0026lt;usize\u0026gt;, /// Callback to run after each thread starts. pub(super) after_start: Option\u0026lt;Callback\u0026gt;, /// To run before each worker thread stops pub(super) before_stop: Option\u0026lt;Callback\u0026gt;, /// To run before each worker thread is parked. pub(super) before_park: Option\u0026lt;Callback\u0026gt;, /// To run after each thread is unparked. pub(super) after_unpark: Option\u0026lt;Callback\u0026gt;, /// Customizable keep alive timeout for BlockingPool pub(super) keep_alive: Option\u0026lt;Duration\u0026gt;, /// How many ticks before pulling a task from the global/remote queue? pub(super) global_queue_interval: u32, /// How many ticks before yielding to the driver for timer and I/O events? pub(super) event_interval: u32, #[cfg(tokio_unstable)] pub(super) unhandled_panic: UnhandledPanic, } tokio/parkï¼š\næœ‰äº‹ä»¶å”¤é†’çº¿ç¨‹è®©å®ƒå»spawn taskï¼Œå¦‚æœæ²¡æœ‰çš„è¯å°±ç­‰å¾… parkã€‚\ntokioä¸­çš„ä»»åŠ¡é˜Ÿåˆ—tokio/src/runtime/thread_pool/worker.rsã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /// A scheduler worker pub(super) struct Worker { /// Reference to shared state shared: Arc\u0026lt;Shared\u0026gt;, /// Index holding this worker\u0026#39;s remote state index: usize, /// Used to hand-off a worker\u0026#39;s core to another thread. core: AtomicCell\u0026lt;Core\u0026gt;, } /// Core data struct Core { /// Used to schedule bookkeeping tasks every so often. tick: u32, /// When a task is scheduled from a worker, it is stored in this slot. The /// worker will check this slot for a task **before** checking the run /// queue. This effectively results in the **last** scheduled task to be run /// next (LIFO). This is an optimization for message passing patterns and /// helps to reduce latency. lifo_slot: Option\u0026lt;Notified\u0026gt;, // åè¿›å…ˆå‡ºé˜Ÿåˆ—ï¼Œåšäº†ä¼˜åŒ– /// The worker-local run queue. run_queue: queue::Local\u0026lt;Arc\u0026lt;Shared\u0026gt;\u0026gt;, // æœ¬åœ°é˜Ÿåˆ— /// True if the worker is currently searching for more work. Searching /// involves attempting to steal from other workers. is_searching: bool, /// True if the scheduler is being shutdown is_shutdown: bool, /// Parker /// /// Stored in an `Option` as the parker is added / removed to make the /// borrow checker happy. park: Option\u0026lt;Parker\u0026gt;, /// Batching metrics so they can be submitted to RuntimeMetrics. metrics: MetricsBatch, /// Fast random number generator. rand: FastRand, /// How many ticks before pulling a task from the global/remote queue? global_queue_interval: u32, /// How many ticks before yielding to the driver for timer and I/O events? event_interval: u32, } æä¾›äº†ä¸€ä¸ªæ–¹æ³•block_in_placeï¼Œå¯ä»¥å°†å½“å‰çº¿ç¨‹å˜ä¸ºé˜»å¡çº¿ç¨‹ã€‚\n1 2 3 4 5 6 pub(crate) fn block_in_place\u0026lt;F, R\u0026gt;(f: F) -\u0026gt; R where F: FnOnce() -\u0026gt; R, { ... } æµå¤„ç† æ–‡æ¡£å‚è€ƒï¼štokio_util::codecã€‚\nAdaptors from AsyncRead/AsyncWrite to Stream/Sink\nRaw I/O objects work with byte sequences, but higher-level code usually wants to batch these into meaningful chunks, called â€œframesâ€.\nThis module contains adapters to go from streams of bytes, AsyncRead and AsyncWrite, to framed streams implementing Sink and Stream. Framed streams are also known as transports.\ntokio-streamæŠ½è±¡äº†ä¸€ç§å¸§ç»“æœï¼Œä¹Ÿæä¾›ç›¸åº”çš„é€‚é…å™¨è¿›è¡Œå¼‚æ­¥è¯»å†™ã€‚å¦‚æœæƒ³æ›´å¥½çš„è¿›è¡Œå¼‚æ­¥è¯»å†™ï¼Œå¯ä»¥ä½¿ç”¨æŠ½è±¡çš„codecï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ›´åº•å±‚çš„Sink/Streamè¿›è¡Œå¤„ç†ã€‚\ntonicï¼šå®ç°gRPCå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ï¼Œè‡ªå·±å®ç°Streamï¼Œä»è€Œæ¥è¿›è¡Œå¼‚æ­¥è¯»å†™ã€‚\nwrapï¼šå®ç°æ–‡ä»¶ä¸Šä¼ ï¼Œä¹Ÿæ˜¯é€šè¿‡è‡ªå·±å®ç°Streamã€‚\nredis-rsï¼šredis libraryã€‚è¿™é‡Œç”¨åˆ°äº†è§£æå™¨ç»„åˆå­combineã€‚\næ‰©å±•èµ„æ–™ Tokio Internals - æºç è§£æå’Œè®¾è®¡åˆ†æ å‚è€ƒèµ„æ–™ å¼ æ±‰ä¸œçš„Rustå®æˆ˜è¯¾\nå¼ æ±‰ä¸œçš„Rustå®æˆ˜è¯¾è§†é¢‘è¯¾ç¨‹ä»£ç ç¤ºä¾‹\n","date":"2022-07-07T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/07/Rust-async/","title":"Rustå¼‚æ­¥ç¼–ç¨‹"},{"content":"è®°å½•äº†å­¦ä¹ ã€ŠProgramming Rustã€‹ç¬”è®°ã€‚\nChapter 3. Fundamental Types Rustæœ‰ç±»å‹æ¨æ–­ å‡½æ•°å¯ä»¥æ˜¯æ³›å‹çš„ Rustçš„ç±»å‹\nType Description i8,i16,i32,i64,i128,u8,u16,u32,u64,u128 isize,usize f32,f64 bool char (char, u8, i32) å…ƒç»„ () struct S { x: f32, y:f32 } ç»“æ„ä½“ struct T (i32, char); Tuple-like struct struct E; Unit-like struct; has no fields enum Attend { OnTime, Late(u32) } Box\u0026lt;Attend\u0026gt; \u0026amp;i32,\u0026amp;mut i32 String \u0026amp;str [f64; 4], [u8; 256] Vec\u0026lt;f64\u0026gt; \u0026amp;[u8], \u0026amp;mut [u8] Option\u0026lt;\u0026amp;str\u0026gt; Result\u0026lt;u64, Error\u0026gt; \u0026amp;dyn Any, \u0026amp;mut dyn Read fn(\u0026amp;str) -\u0026gt; bool (Clousure types have no written form) Clousure Fixed-Width Numerical Types å¦‚æœéœ€è¦ä»»æ„ç²¾åº¦è¡¨ç¤ºçš„ä¸€äº›æ•°å€¼ï¼Œå¯ä»¥æŸ¥çœ‹ num åŒ…ã€‚\nInteger Types ä¸åƒCå’ŒC++ï¼ŒRustå°†å­—ç¬¦çœ‹ä½œæ˜¯å’Œæ•°å€¼ä¸åŒçš„ç±»å‹ï¼Œä¸€ä¸ª char ä¸æ˜¯ u8ï¼Œä¹Ÿä¸æ˜¯ u32ï¼ˆå°½ç®¡å­—ç¬¦æ˜¯32ä½é•¿çš„ï¼‰ã€‚\nRustè¦æ±‚æ•°ç»„çš„ç´¢å¼•å¿…é¡»æ˜¯ usize ç±»å‹çš„å€¼ã€‚\nåœ¨Rustæ•´æ•°å¯ä»¥å¸¦ä¸€ä¸ªåç¼€æ¥è¡¨ç¤ºå®ƒä»¬çš„ç±»å‹ï¼Œæ¯”å¦‚42u8ã€‚å¦‚æœæ²¡æœ‰ç»™æ•´æ•°æŒ‡å®šå…·ä½“çš„ç±»å‹ï¼ŒRustä¼šå°†å€¼å­˜æ”¾åœ¨ä¸€ä¸ªç‰¹å®šçš„ç±»å‹ä¸­ï¼Œä¼ ç»™å‡½æ•°æœŸæœ›çš„å‚æ•°ï¼Œæ¯”è¾ƒå¦ä¸€ä¸ªæœ‰åˆ«çš„ç‰¹å®šç±»å‹çš„å€¼ï¼Œæœ€åï¼Œå¦‚æœæœ‰å¤šä¸ªå¯èƒ½ï¼Œè€Œ i32æ˜¯å…¶ä¸­ä¸€ä¸ªçš„è¯ï¼Œå°±é»˜è®¤æ˜¯ i32ç±»å‹ï¼Œå¦åˆ™å°±ä¼šæŠ¥é”™ã€‚\nå‰ç¼€0xï¼Œ0oå’Œ0bè¡¨ç¤ºåå…­è¿›åˆ¶ã€å…«è¿›åˆ¶å’ŒäºŒè¿›åˆ¶ã€‚\nä¸ºäº†æ›´æ¸…æ¥šåœ°è¡¨ç¤ºå¾ˆé•¿çš„æ•°å­—ï¼Œè¿˜å¯ä»¥ç»™æ•°å­—åŠ ä¸‹åˆ’çº¿ï¼Œæ¯”å¦‚4_294_967_295ã€‚æœ‰å‰ç¼€å’Œåç¼€çš„æ•°å­—ä¾ç„¶å¯ä»¥åŠ ä¸‹åˆ’çº¿ã€‚\nå°½ç®¡Rustä¸­æ•°å­—å’Œå­—ç¬¦æ˜¯ä¸åŒçš„ç±»å‹ï¼Œä½†æ˜¯ä¹Ÿæä¾›äº† å­—èŠ‚å­—é¢é‡ï¼ˆ byte literalsï¼‰ï¼Œå³ç”¨ç±»å­—ç¬¦å­—é¢é‡è¡¨ç¤ºu8å€¼ï¼šb'X'ä»£è¡¨çš„ASCIIç¼–ç çš„å­—ç¬¦Xï¼Œå®ƒæ˜¯ä¸€ä¸ªu8å€¼ã€‚æ¯”å¦‚ï¼Œç”±äºå­—ç¬¦Açš„ASCIIç¼–ç æ˜¯65ï¼Œå› æ­¤b'A'ç­‰ä»·äº65u8ã€‚å­—èŠ‚å­—é¢é‡ä¸­åªèƒ½å‡ºç°åœ¨ASCIIç¼–ç çš„å­—ç¬¦ã€‚\nç‰¹æ®Šçš„ACSIIç¼–ç çš„å­—ç¬¦\nCharacter Byte literal å•å¼•å· b'\\'' åæ–œæ  b'\\\\' æ¢è¡Œ b'\\n' å›è½¦ b'\\r' åˆ¶è¡¨ç¬¦ b'\\t' å¯¹äºä¸€äº›ASCIIç¼–ç çš„å­—ç¬¦å¯ä»¥ç”¨åå…­è¿›åˆ¶æ¥è¡¨ç¤ºï¼Œè¿™æ ·æ›´å®¹æ˜“é˜…è¯»ã€‚æ¯”å¦‚b'\\x1b'ã€‚\næ•´æ•°ç±»å‹ä¹‹é—´è½¬æ¢å¯ä»¥ç”¨ as æ“ä½œç¬¦ã€‚æ¯”å¦‚ 10_i8 as u16ã€‚\næ•´æ•°çš„ä¸€äº›æ–¹æ³•ï¼Œå‚è§ std::i32ã€‚\n1 2 3 assert_eq!(2_u16.pow(4), 16); assert_eq!((-4_i32).abs(), 4); assert_eq!(0b101101_u8.count_ones(), 4); çœ‹ä¸‹é¢è¿™æ®µä»£ç \n1 println!(\u0026#34;{}\u0026#34;, (-4).abs()); è¿™é‡Œæ²¡æœ‰ç»™å‡ºæ•°å€¼çš„ç±»å‹ï¼Œæ˜¯ä¸æ˜¯é»˜è®¤ i32 å‘¢ï¼Ÿä½†å…¶å®ä¼šæŠ¥é”™ï¼š\n1 error: can\u0026#39;t call method `abs` on ambiguous numeric type `{integer}` ä¸ºä»€ä¹ˆä¼šè¿™æ ·å­å‘¢ï¼Ÿå› ä¸ºRustæƒ³è¦åœ¨è°ƒç”¨ä¸€ä¸ªç±»å‹è‡ªå·±çš„æ–¹æ³•ä¹‹å‰æ˜ç¡®åœ°çŸ¥é“ä¸€ä¸ªå€¼çš„æ•´æ•°ç±»å‹ã€‚i32 çš„é»˜è®¤å€¼ä»…é€‚ç”¨äºåœ¨æ‰€æœ‰æ–¹æ³•è°ƒç”¨éƒ½å·²è§£å†³åç±»å‹ä»ç„¶ä¸æ˜ç¡®çš„æƒ…å†µï¼Œåœ¨è¿™é‡Œå°±å¤ªæ™šäº†ï¼Œå› æ­¤ä¼šæŠ¥é”™ã€‚æ¢å¥è¯è¯´ï¼Œå°±æ˜¯è¿™é‡Œæˆ‘è¦å…ˆè°ƒç”¨ abs()æ–¹æ³•ï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦ç¡®å®šç±»å‹ï¼Œè¿˜æ²¡ç­‰æ¨æ–­å‡ºé»˜è®¤ç±»å‹ï¼Œå°±å·²ç»æŠ¥é”™äº†ã€‚è§£å†³æ–¹æ¡ˆï¼š\n1 2 println!(\u0026#34;{}\u0026#34;, (-4_i32).abs()); println!(\u0026#34;{}\u0026#34;, i32::abs(-4)); æ³¨æ„æ–¹æ³•è°ƒç”¨ä¼šå‘ç”Ÿåœ¨ä¸€å…ƒå‰ç¼€æ“ä½œç¬¦ä¹‹å‰ï¼Œæ‰€ä»¥å¤„ç†è´Ÿæ•°çš„æ—¶å€™è¦å½“å¿ƒã€‚æ¯”å¦‚-4_i32.abs()ï¼Œè¿™é‡Œæ²¡æœ‰æ‹¬å·ï¼Œä¼šå…ˆè°ƒç”¨å‡½æ•°4_i32.abs()ï¼Œç„¶åå†å–è´Ÿå·ï¼Œæœ€ç»ˆç»“æœä¸º-4ã€‚\nChecked, Wrapping, Saturating, and Overflowing Arithmetic åœ¨Debugæ¨¡å¼ä¸‹ï¼Œå¦‚æœæ•´æ•°æ•°å€¼æ“ä½œæº¢å‡ºï¼Œä¼šæŠ¥é”™ã€‚ä½†æ˜¯åœ¨å‘å¸ƒæ¨¡å¼æ„å»ºçš„æ—¶å€™ï¼Œä¼š wrapsã€‚\nIn a release build, the operation wraps around: it produces the value equivalent to the mathematically correct result modulo the range of the value. (In neither case is overflow undefined behavior, as it is in C and C++.)\nä¸Šè¿°æ˜¯é»˜è®¤çš„ï¼Œå¦‚æœè¿™ä¸æ˜¯ä½ æƒ³è¦çš„ï¼Œå¯ä»¥è°ƒç”¨ä¸€äº›æ–¹æ³•ï¼Œä¸»è¦æœ‰å››ç±»ã€‚\nChecked operations return an Option of the result: Some(v) if the mathematically correct result can be represented as a value of that type, or None if it cannot. Wrapping operations return the value equivalent to the mathematically correct result modulo the range of the value. Saturating operations return the representable value that is closest to the mathematically correct result. In other words, the result is â€œclampedâ€ to the maximum and minimum values the type can represent. Overflowing operations return a tuple (result, overflowed), where result is what the wrapping version of the function would return, and overflowed is a bool indicating whether an overflow occurred. Operation Name suffix Example Addition add 100_i8.checked_add(27) == Some(127) Subtraction sub 10_u8.checked_sub(11) == None Multiplication mul 128_u8.saturating_mul(3) == 255 Division div 64_u16.wrapping_div(8) == 8 Remainder rem (-32768_i16).wrapping_rem(-1) == 0 Negation neg (-128_i8).checked_neg() == None Absolute value abs (-32768_i16).wrapping_abs() == -32768 Exponentiation pow 3_u8.checked_pow(4) == Some(81) Bitwise left shift shl 10_u32.wrapping_shl(34) == 40 Bitwise right shift shr 40_u64.wrapping_shr(66) == 10 Floating-Point Types æ•´æ•°éƒ¨åˆ†åçš„åˆ†æ•°éƒ¨åˆ†ï¼ŒæŒ‡æ•°æˆ–è€…ç±»å‹åç¼€è‡³å°‘åŒ…å«ä¸€ä¸ªï¼Œæ¥åŒºåˆ«äºæ•´æ•°å­—é¢é‡ã€‚5.æ•´æ•°éƒ¨åˆ†ä¹‹ååªæœ‰ä¸€ä¸ªå°æ•°ç‚¹ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æµ®ç‚¹æ•°å¸¸æ•°ã€‚\næµ®ç‚¹æ•°é»˜è®¤ç±»å‹æ˜¯ f64 ã€‚\nä¸ºäº†ç±»å‹æ¨æ–­çš„ç›®çš„ï¼ŒRustä¸­æ•´æ•°å’Œæµ®ç‚¹æ•°ä¹‹é—´ä¸ä¼šè¿›è¡Œç›¸äº’æ¨æ–­ã€‚\nf32å’Œf64éƒ½æœ‰ä¸€äº›ç‰¹æ®Šå€¼ï¼Œå¦‚ INFINITYï¼ŒNEG_INFINITYï¼ŒNANï¼ˆthat not-a-number valueï¼‰ï¼ŒMINå’ŒMAXã€‚\nstd::f32å’Œstd::f64æä¾›äº†å¾ˆå¤šæ–¹æ³•ã€‚\nstd::f32::constså’Œstd::f64::constsæä¾›ä¸€äº›æ•°å­¦å¸¸é‡ã€‚\nRustæ˜¯æ²¡æœ‰æ•°å€¼çš„éšå¼è½¬æ¢çš„ï¼Œæ‰€ä»¥å¦‚æœä¼ å…¥çš„å‚æ•°ç±»å‹å’Œå‡½æ•°çš„å‚æ•°ç±»å‹ä¸ä¸€è‡´ï¼Œè¿™é‡Œä¸ä¼šå‘ç”Ÿéšå¼è½¬æ¢ï¼Œå› æ­¤ä¼šæŠ¥é”™ã€‚æƒ³è¦è½¬æ¢åªèƒ½æ˜¾å¼åœ°ç”¨ as æ“ä½œç¬¦ã€‚\nThe bool Type åœ¨Rustä¸­ï¼Œboolç±»å‹çš„å€¼ä¸º true å’Œ falseã€‚\nRustä¸­åœ¨è¦æ±‚ä¸€ä¸ªBooleanå€¼çš„ä¸Šä¸‹æ–‡ä¸­æ˜¯éå¸¸ä¸¥æ ¼çš„ã€‚æ§åˆ¶ç»“æ„ifå’Œwhileè¦æ±‚æ¡ä»¶å¿…é¡»æ˜¯ bool è¡¨è¾¾å¼ï¼Œ çŸ­è·¯é€»è¾‘æ“ä½œç¬¦ \u0026amp;\u0026amp; å’Œ || ä¹Ÿè¦æ±‚å¿…é¡»æ˜¯ bool è¡¨è¾¾å¼ã€‚å¿…é¡» if x!= 0 { ... }è¿™æ ·å†™ï¼Œè€Œä¸èƒ½ç®€å•åœ°å†™ä¸º if x { ... }ã€‚\nRustå¯ä»¥ç”¨ as æ“ä½œç¬¦å°† bool å€¼è½¬æ¢ä¸ºæ•°å­—ï¼Œä½†æ˜¯ä¸èƒ½åè¿‡æ¥å°†æ•°å€¼è½¬æ¢ä¸º bool å€¼ã€‚\n1 2 assert_eq!(false as i32, 0); assert_eq!(true as i32, 1); è™½ç„¶å¯ä»¥åªæœ‰ä¸€ä½å°±è¡¨ç¤º bool å€¼ï¼Œä½†æ˜¯Ruståº•å±‚ç”¨ä¸€æ•´ä¸ªå­—èŠ‚æ¥å­˜å‚¨ bool å€¼ï¼Œè¿™æ ·çš„è¯å°±å¯ä»¥åˆ›å»ºä¸€ä¸ªæŒ‡é’ˆæ¥æŒ‡å‘å®ƒã€‚\nCharacters char ç±»å‹è¡¨ç¤ºå•ä¸ªUnicodeå­—ç¬¦ï¼Œå  32 ä½ã€‚\nå­—ç¬¦å¯ä»¥ç”¨åå…­è¿›åˆ¶æ¥è¡¨ç¤ºæˆ–è€…\\u{}æ¥è¡¨ç¤ºã€‚\nå¦‚æœå­—ç¬¦ç¼–ç åœ¨ASCIIç¼–ç èŒƒå›´å†…ï¼Œå¯ä»¥ç”¨åå…­è¿›åˆ¶ã€‚ä¾‹å¦‚'\\xHH'ã€‚ ä¹Ÿå¯ä»¥ç”¨\\u{}æ¥è¡¨ç¤ºä»»ä½•çš„Unicodeç¼–ç å­—ç¬¦ã€‚ä¾‹å¦‚'\\u{HHHHHH}'ã€‚ å­—ç¬¦å¿…é¡»åœ¨æœ‰æ•ˆçš„ Unicode ç ç‚¹èŒƒå›´å†…ã€‚\nchar å’Œå…¶ä»–ç±»å‹ä¹‹é—´æ²¡æœ‰éšå¼åœ°è½¬æ¢ã€‚å½“ç„¶å¯ä»¥æ˜¾å¼ç”¨ as æ“ä½œç¬¦å°† char ç±»å‹è½¬æ¢æˆä¸€ä¸ªæ•´æ•°ç±»å‹ï¼Œå¦‚æœç±»å‹å°äº32ä½ï¼Œä¼šè¿›è¡Œæˆªæ–­ã€‚ç›¸ååœ°ï¼Œåªæœ‰ u8 ç±»å‹èƒ½ç”¨ as æ“ä½œç¬¦æ˜¾å¼åœ°è½¬æ¢ä¸º char ç±»å‹ã€‚è¿™ä¸€ç‚¹ä¹Ÿå¾ˆè‡ªç„¶ï¼ŒRustè¦ä¿è¯å¯é ï¼Œå…¶ä»–æ•°å€¼ç±»å‹è½¬æ¢æˆ char ç±»å‹æ—¶ï¼Œå¯èƒ½æ˜¯æ— æ•ˆçš„å­—ç¬¦ã€‚ä¸è¿‡std::char::from_u32å¯ä»¥å°†ä»»ä½• u32 ç±»å‹çš„å€¼è½¬æ¢ï¼Œè¿”å›çš„æ˜¯ Option\u0026lt;char\u0026gt;ã€‚\nchar(primitive type)æ–‡æ¡£æœ‰ç›¸å…³çš„æ–¹æ³•ã€‚\nTuples å…ƒç»„å¯ä»¥å°†ä¸åŒç±»å‹çš„å€¼ç»„åˆåœ¨ä¸€èµ·ï¼Œå¯ä»¥ç”¨åœ¨è¿”å›å¤šä¸ªä¸åŒç±»å‹çš„å€¼çš„å‡½æ•°ä¸­ã€‚\nç”¨ a.0å¯ä»¥æ¥è·å–å…·ä½“çš„å…ƒç´ ã€‚\nå…ƒç»„çš„ç´¢å¼•å¿…é¡»æ˜¯å¸¸æ•°ï¼Œä¸å¯ä»¥æ˜¯å˜é‡ï¼Œæ¯”å¦‚t[i]æˆ–è€…t.iå°±æ˜¯é”™è¯¯çš„ã€‚\nå¯ä»¥ç”¨æ¨¡å¼åŒ¹é…å¾—åˆ°å…ƒç»„å¯¹åº”çš„å€¼ã€‚åœ¨æŒ‡å®šå˜é‡å€¼æˆ–è€…å‡½æ•°è¿”å›å¤šä¸ªå€¼æ—¶å¾ˆæœ‰ç”¨ã€‚ç”¨å…ƒç»„æ¥è¡¨ç¤ºç›¸å…³çš„å˜é‡æ˜¯å¾ˆæ¸…æ™°çš„ï¼Œæ¯”å¦‚å®½å’Œé«˜ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªå…ƒç»„æŠŠå®ƒä»¬æ”¾åœ¨ä¸€èµ·ï¼Œè¯­ä¹‰æ›´åŠ æ¸…æ™°ã€‚\nunit type ()å¯ä»¥ç”¨äºå‡½æ•°çš„è¿”å›ç±»å‹ï¼Œè¡¨ç¤ºä»€ä¹ˆä¹Ÿä¸è¿”å›ã€‚\nå¯ä»¥åœ¨å…ƒç»„çš„æœ€ååŠ ä¸Šé€—å·ï¼Œå®¹æ˜“çœ‹å‡ºåˆ—è¡¨åˆ é™¤æˆ–æ·»åŠ äº†å…ƒç´ ã€‚å¦‚æœæ˜¯å•ä¸ªå€¼ï¼Œ(\u0026quot;lonely hearts\u0026quot;,)ç›¸æ¯” (\u0026quot;lonely hearts\u0026quot;)æ›´åŠ æ¸…æ™°ï¼Œå¯ä»¥åˆ¤æ–­æ˜¯å…ƒç»„è€Œä¸æ˜¯æ‹¬å·è¡¨è¾¾å¼ã€‚\nPointer Types References \u0026amp;x äº§ç”Ÿäº†å¯¹ x çš„ä¸€ä¸ªå¼•ç”¨ï¼Œç”¨Rustçš„æœ¯è¯­æ¥è¯´æ˜¯å‘ x å€Ÿäº†ä¸€ä¸ªå¼•ç”¨ã€‚\nåœ¨Rustä¸­ï¼Œå¼•ç”¨å§‹ç»ˆä¸ä¸ºç©ºã€‚Rustä¼šè·Ÿè¸ªå€¼çš„æ‰€æœ‰æƒå’Œç”Ÿå‘½å‘¨æœŸï¼Œåœ¨ç¼–è¯‘æ—¶æœŸä¼šæ£€æŸ¥å‡ºæ‚¬å‚æŒ‡é’ˆï¼ŒäºŒæ¬¡é‡Šæ”¾ä»¥åŠæŒ‡é’ˆæ— æ•ˆçš„é”™è¯¯ã€‚\n\u0026amp; Tï¼šä¸å¯å˜çš„å…±äº«å¼•ç”¨ \u0026amp;mut Tï¼šå¯å˜çš„ç‹¬å å¼•ç”¨ å°†ä¸å¯å˜å¼•ç”¨å’Œå¯å˜å¼•ç”¨çœ‹ä½œå•ä¸ªè¯»-å†™è€…å’Œå¤šä¸ªè¯»è€…ã€‚\nBoxes ç”¨äºå †åˆ†é…çš„æŒ‡é’ˆç±»å‹ã€‚\n1 2 let t = (12, \u0026#34;eggs\u0026#34;); let b = Box::new(t); // åœ¨å †ä¸Šåˆ†é…å†…å­˜ï¼Œç±»å‹ä¸º Box\u0026lt;(i32, \u0026amp;str)\u0026gt; Raw Pointers *const T *mut T åªèƒ½åœ¨ unsafe å—ä¸­å¯¹åŸå§‹æŒ‡é’ˆè§£å¼•ç”¨ã€‚\nArrays, Vectors, and Slices æœ‰ä¸‰ç§ç±»å‹è¡¨ç¤ºå†…å­˜ä¸­è¿ç»­çš„ä¸€å—æ•°æ®ã€‚\n[T; N]è¡¨ç¤ºæ•°ç»„ã€‚æ•°ç»„çš„é•¿åº¦å¿…é¡»è¦åœ¨ç¼–è¯‘æ—¶æœŸå°±ç¡®å®šã€‚ Vec\u0026lt;T\u0026gt; è¡¨ç¤º T ç±»å‹çš„å‘é‡ã€‚åŠ¨æ€åˆ†é…çš„ï¼Œå…ƒç´ å­˜æ”¾åœ¨å †ä¸Šã€‚ \u0026amp;[T]å’Œ\u0026amp;mut [T] ç§°ä¸º T çš„å…±äº«åˆ‡ç‰‡æˆ–å¯å˜åˆ‡ç‰‡ã€‚å¯ä»¥æŠŠåˆ‡ç‰‡çœ‹ä½œæ˜¯ä¸€ä¸ªèƒ–æŒ‡é’ˆï¼ŒæŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ŒåŒæ—¶è¿˜åŒ…å«å¯ä»¥è®¿é—®åˆ°çš„å…ƒç´ çš„ä¸ªæ•°ã€‚ ä¸€äº›æ–¹æ³•ï¼š\nv.len() è¿”å›å…ƒç´ çš„ä¸ªæ•°ã€‚ v[i] è¡¨ç¤º v çš„ç¬¬ i ä¸ªå…ƒç´ ï¼Œæ³¨æ„è¿™é‡Œç´¢å¼• i å¿…é¡»æ˜¯ usize ç±»å‹çš„ã€‚Rustæ€»æ˜¯ä¼šå»æ£€æŸ¥ i æœ‰æ²¡æœ‰åœ¨æœ‰æ•ˆçš„èŒƒå›´å†…ã€‚ Arrays ç›´æ¥ç”¨æ–¹æ‹¬å·ç”Ÿæˆæ•°ç»„ï¼Œæˆ–è€…[T; N]ç”Ÿæˆæ•°ç»„ï¼ŒRustä¸æä¾›æœªåˆå§‹åŒ–çš„æ•°ç»„ã€‚\næ•°ç»„çš„é•¿åº¦å¿…é¡»åœ¨ç¼–è¯‘æ—¶å°±ç¡®å®šï¼Œä¸å¯ä»¥ç”¨å˜é‡ï¼Œæ¯”å¦‚[true; n] è¿™å°±æ˜¯é”™è¯¯çš„ã€‚å¦‚æœæƒ³åœ¨è¿è¡ŒæœŸé—´è·å¾—æ•°ç»„çš„é•¿åº¦ï¼Œåº”è¯¥ç”¨å‘é‡ã€‚\nåœ¨è°ƒç”¨ä¸€äº›æ•°ç»„çš„æ–¹æ³•æ—¶ï¼ŒRustä¼šéšå¼åœ°å°†ä¸€ä¸ªæ•°ç»„çš„å¼•ç”¨è½¬æ¢ä¸ºåˆ‡ç‰‡ï¼Œè¿™æ ·å¯ä»¥ç›´æ¥åœ¨ä¸€ä¸ªæ•°ç»„ä¸Šä½¿ç”¨ä»»ä½•åˆ‡ç‰‡çš„æ–¹æ³•ã€‚\n1 2 3 let mut chaos = [3, 5, 4, 1, 2]; chaos.sort(); // è¿™é‡Œéšå¼åœ°è½¬æ¢ä¸º \u0026amp;mut [i32]ï¼Œè°ƒç”¨äº†åˆ‡ç‰‡çš„ sort æ–¹æ³• assert_eq!(chaos, [1, 2, 3, 4, 5]); å…³äºè¿™ä¸€ç‚¹ï¼Œå®˜æ–¹æ–‡æ¡£æ˜¯è¿™æ ·è¯´çš„ã€‚\næ•°ç»„å¼ºåˆ¶è½¬æ¢ä¸º slices ([T]) ï¼Œå› æ­¤å¯ä»¥åœ¨æ•°ç»„ä¸Šè°ƒç”¨ slice æ–¹æ³•ã€‚å®é™…ä¸Šï¼Œè¿™æä¾›äº†ç”¨äºå¤„ç†æ•°ç»„çš„å¤§å¤šæ•° APIã€‚ åˆ‡ç‰‡å…·æœ‰åŠ¨æ€å¤§å°ï¼Œå¹¶ä¸”ä¸å¼ºåˆ¶è½¬æ¢ä¸ºæ•°ç»„ã€‚\nVectors åœ¨å †ä¸Šåˆ†é…çš„å®¹å™¨ã€‚\nå¯ä»¥ç”¨ vec!æˆ–è€…Vec::new()æ¥ç”Ÿæˆæ–°çš„ vectorã€‚\nå¯ä»¥åŠ¨æ€æ·»åŠ å…ƒç´ :\n1 2 let mut primes = vec![2, 3, 5, 7]; primes.push(11); å¯ä»¥ç”¨é‡å¤è¡¨è¾¾å¼æ¥åˆ›å»º vectorï¼š\n1 2 3 fn new_pixel_buffer(rows: usize, cols: usize) -\u0026gt; Vec\u0026lt;u8\u0026gt; { vec![0; rows * cols] } è¿­ä»£å™¨æ„é€ ï¼š\n1 2 let v: Vec\u0026lt;i32\u0026gt; = (0..5).collect(); // è¿™é‡Œå¿…é¡»æŒ‡å®š v çš„ç±»å‹ï¼Œå› ä¸º collect æ–¹æ³•æœ‰å¾ˆå¤šç§ assert_eq!(v, [0, 1, 2, 3, 4]); å’Œæ•°ç»„ä¸€æ ·ï¼Œå‘é‡ä¹Ÿä¼šåœ¨è°ƒç”¨ä¸€äº›æ–¹æ³•æ—¶éšå¼åœ°è½¬æ¢ä¸ºåˆ‡ç‰‡ç±»å‹ã€‚\nä¸€ä¸ª Vec\u0026lt;T\u0026gt; åŒ…å«ä¸‰ä¸ªå€¼ï¼šæŒ‡å‘å…ƒç´ çš„å † buffer çš„æŒ‡é’ˆï¼Œè¿™ä¸ªæ˜¯è¢« Vec\u0026lt;T\u0026gt; æ‰€åˆ›å»ºå’Œæ‹¥æœ‰çš„ï¼› buffer ä¸­çš„å®¹é‡ï¼›åŒ…å«å…ƒç´ çš„ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯é•¿åº¦ã€‚\nçŸ¥é“å‘é‡çš„å®¹é‡ï¼Œå¯ä»¥ç”¨Vec::with_capacityæ¥åˆ›å»ºã€‚æå‡æ•ˆç‡ï¼Œå‡å°‘é‡æ–°åˆ†é…ç©ºé—´ã€‚\ncapacityæ–¹æ³•è¿”å›å‘é‡ä¸éœ€è¦å†åˆ†é…æ—¶å‘é‡çš„å®¹é‡ã€‚\nä¸€äº›æ–¹æ³•ï¼š\ninsert remove pop å¯ä»¥ç”¨ for åœ¨å‘é‡ä¸Šè¿›è¡Œè¿­ä»£ã€‚\nSlices åˆ‡ç‰‡ï¼Œç›´æ¥æŒ‡å‘å¼•ç”¨çš„æ•°æ®ï¼Œçœ‹ä½œä¸€ä¸ªèƒ–æŒ‡é’ˆï¼ŒæŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä»¥åŠåŒ…å« lenã€‚\nString Types String Literals å­—ç¬¦ä¸²å­—é¢é‡åœ¨åŒå¼•å·å†…ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // ç©ºæ ¼å’Œæ¢è¡Œç…§æ ·è¾“å‡º println!(\u0026#34;In the room the women come and go, Singing of Mount Abora\u0026#34;); // å»æ‰æ¢è¡Œ println!(\u0026#34;It was a bright, cold day in April, and \\ there were four of usâ€”\\ more or less.\u0026#34;) // raw strings let default_win_install_path = r\u0026#34;C:\\Program Files\\Gorillas\u0026#34;; let pattern = Regex::new(r\u0026#34;\\d+(\\.\\d+)*\u0026#34;); // åŒ…å«åŒå¼•å· println!(r###\u0026#34; This raw string started with \u0026#39;r###\u0026#34;\u0026#39;. Therefore it does not end until we reach a quote mark (\u0026#39;\u0026#34;\u0026#39;) followed immediately by three pound signs (\u0026#39;###\u0026#39;): \u0026#34;###); Byte Strings å¸¦æœ‰ b å‰ç¼€çš„æ˜¯ä¸€ä¸ªå­—èŠ‚å­—é¢é‡ã€‚\n1 2 let method = b\u0026#34;GET\u0026#34;; // \u0026amp;[u8; 3] ç±»å‹ assert_eq!(method, \u0026amp;[b\u0026#39;G\u0026#39;, b\u0026#39;E\u0026#39;, b\u0026#39;T\u0026#39;]); Strings in Memory å†…å­˜ä¸­ä»¥UTF-8ç¼–ç å­˜å‚¨ã€‚\n1 2 3 let noodles = \u0026#34;noodles\u0026#34;.to_string(); // String åº•å±‚æ˜¯ Vec\u0026lt;u8\u0026gt; let oodles = \u0026amp;noodles[1..]; // \u0026amp;str let poodles = \u0026#34;à² _à² \u0026#34;; // \u0026amp;str å†…å­˜å¸ƒå±€ï¼š\nString \u0026amp;stråƒ\u0026amp;[T]ï¼Œè€Œ StringåƒVec\u0026lt;T\u0026gt;ã€‚\nåˆ›å»º String:\n1 2 3 4 5 6 7 8 9 10 11 // to_string æ–¹æ³• let error_message = \u0026#34;too many pets\u0026#34;.to_string(); // format! assert_eq!(format!(\u0026#34;{}Â°{:02}â€²{:02}â€²â€²N\u0026#34;, 24, 5, 23), \u0026#34;24Â°05â€²23â€²â€²N\u0026#34;.to_string()); // æ•°ç»„ã€å‘é‡çš„ concatã€join æ–¹æ³• let bits = vec![\u0026#34;veni\u0026#34;, \u0026#34;vidi\u0026#34;, \u0026#34;vici\u0026#34;]; assert_eq!(bits.concat(), \u0026#34;venividivici\u0026#34;); assert_eq!(bits.join(\u0026#34;, \u0026#34;), \u0026#34;veni, vidi, vici\u0026#34;); Using Strings Strings support the == and != operators. Two strings are equal if they contain the same characters in the same order (regardless of whether they point to the same location in memory).\nOther String-Like Types Stick to String and \u0026amp;str for Unicode text. When working with filenames, use std::path::PathBuf and \u0026amp;Path instead. When working with binary data that isnâ€™t UTF-8 encoded at all, use Vec\u0026lt;u8\u0026gt; and \u0026amp;[u8]. When working with environment variable names and command-line arguments in the native form presented by the operating system, use OsString and \u0026amp;OsStr. When interoperating with C libraries that use null-terminated strings, use std::ffi::CString and \u0026amp;CStr. Type Aliases ç±»å‹åˆ«åç”¨ type ï¼š\n1 type Bytes = Vec\u0026lt;u8\u0026gt;; Chapter 4. Ownership and Moves ç®¡ç†å†…å­˜ï¼Œæƒ³è¾¾åˆ°çš„æ•ˆæœï¼š\nå½“æˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªæ—¶é—´æ—¶ï¼Œå†…å­˜å¯ä»¥åŠæ—¶é‡Šæ”¾ å†…å­˜é‡Šæ”¾åï¼Œä¸å†æœ‰æŒ‡é’ˆæŒ‡å‘å®ƒ ç›®å‰çš„å†…å­˜ç®¡ç†æ–¹æ¡ˆï¼š\nGCï¼Œåƒåœ¾å›æ”¶ã€‚è§£å†³äº†æ‚¬å‚æŒ‡é’ˆçš„é—®é¢˜ï¼Œä½†æ˜¯ä¼šå‡ºç°ä¸–ç•Œåœæ—¶ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬æœŸæœ›é‡Šæ”¾å†…å­˜çš„æ—¶å€™ï¼Œå®ƒè¿˜æ²¡æœ‰é‡Šæ”¾ã€‚ è‡ªå·±å®Œå…¨æ§åˆ¶å†…å­˜ï¼Œæ¯”å¦‚Cå’ŒC++ã€‚ä½†æ˜¯å¯¹ç¨‹åºå‘˜è¦æ±‚é«˜ï¼Œä½¿ç”¨ä¸å½“æœ‰æ—¶ä¹Ÿä¼šå‘ç”Ÿé”™è¯¯ã€‚ Rustæ˜¯æ€ä¹ˆè§£å†³è¿™ä¸ªé—®é¢˜çš„å‘¢ï¼Ÿç§˜å¯†æ­¦å™¨å°±æ˜¯é™åˆ¶ä½ çš„ç¨‹åºå¯¹æŒ‡é’ˆçš„ä½¿ç”¨ã€‚ç»™çš„è¿™äº›é™åˆ¶ä¼šä¿è¯å®‰å…¨ï¼Œä½†ä¹Ÿä¸ä¼šä¸§å¤±è‡ªç”±åº¦ã€‚ä¹¦ä¸­è¿™æ ·å†™é“ï¼š\nRustâ€™s radical wager, the claim on which it stakes its success and that forms the root of the language, is that even with these restrictions in place, youâ€™ll find the language more than flexible enough for almost every task and that the benefitsâ€”the elimination of broad classes of memory management and concurrency bugsâ€”will justify the adaptations youâ€™ll need to make to your style. The authors of this book are bullish on Rust exactly because of our extensive experience with C and C++. For us, Rustâ€™s deal is a no-brainer.\nOwnership åœ¨Rustä¸­ï¼Œæ‰€æœ‰æƒçš„æ¦‚å¿µæ˜¯å†…å»ºåœ¨è¯­è¨€ä¸­çš„ï¼Œå¹¶ä¸”ä¼šé€šè¿‡ç¼–è¯‘å™¨æ£€æŸ¥å¼ºåˆ¶æ‰§è¡Œã€‚æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œè¿™ä¸ªæ‰€æœ‰è€…å†³å®šå®ƒçš„ç”Ÿå‘½å‘¨æœŸã€‚å½“æ‰€æœ‰è€…è¢«é‡Šæ”¾æ—¶ï¼Œå®ƒæ‰€æ‹¥æœ‰çš„å€¼ä¹Ÿä¼šè¢«é‡Šæ”¾ã€‚\n1 2 3 4 5 { let point = Box::new((0.625, 0.5)); // point allocated here let label = format!(\u0026#34;{:?}\u0026#34;, point); // label allocated here , è¿™é‡Œè¿”å› String assert_eq!(label, \u0026#34;(0.625, 0.5)\u0026#34;); }\t// both dropped here å†…å­˜å¸ƒå±€ï¼š\nåƒå˜é‡ä¼šæ‹¥æœ‰å®ƒçš„å€¼ï¼Œç»“æ„ä½“ä¼šæ‹¥æœ‰å®ƒä»¬çš„å­—æ®µï¼Œå…ƒç»„ã€æ•°ç»„ä»¥åŠå‘é‡ä¼šæ‹¥æœ‰å®ƒä»¬çš„å…ƒç´ ã€‚\nå†çœ‹ä¸€ä¸ªå¤æ‚çš„ä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 struct Person { name: String, birth: i32 } let mut composers = Vec::new(); composers.push(Person { name: \u0026#34;Palestrina\u0026#34;.to_string(), birth: 1525 }); composers.push(Person { name: \u0026#34;Dowland\u0026#34;.to_string(), birth: 1563 }); composers.push(Person { name: \u0026#34;Lully\u0026#34;.to_string(), birth: 1632 }); for composer in \u0026amp;composers { println!(\u0026#34;{}, born {}\u0026#34;, composer.name, composer.birth); } å†…å­˜å¸ƒå±€ï¼š\næ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå•ç‹¬çš„æ‰€æœ‰è€…ï¼Œè¿™ä¸ªæ‰€æœ‰è€…å¾ˆå®¹æ˜“æ¥å†³å®šä»€ä¹ˆæ—¶å€™ drop å®ƒæ‰€æ‹¥æœ‰çš„å€¼ã€‚ä½†æ˜¯ä¸€ä¸ªå•ç‹¬çš„å€¼å¯èƒ½ä¼šæ‹¥æœ‰å¾ˆå¤šå…¶ä»–çš„å€¼ï¼Œå¦‚ä¸Šé¢è¿™ä¸ªä¾‹å­ä¸­çš„å‘é‡ composersã€‚æ‰€æœ‰è€…å’Œå®ƒä»¬æ‰€æ‹¥æœ‰çš„å€¼ä¼šå½¢æˆä¸€ä¸ªæ ‘ã€‚åœ¨æ¯ä¸ªæ ‘çš„æ ¹éƒ¨æ˜¯ä¸€ä¸ªå˜é‡ï¼Œå½“è¿™ä¸ªå˜é‡ç¦»å¼€å®ƒçš„ä½œç”¨èŒƒå›´ï¼Œæ•´æ£µæ ‘ä¹Ÿä¼šè·Ÿç€ç¦»å¼€ã€‚\nRusté€šå¸¸ä¸ä¼šæ˜¾å¼åœ° drop å®ƒçš„å€¼ï¼Œè€Œæ˜¯é€šè¿‡ï¼šç¦»å¼€å˜é‡çš„ä½œç”¨åŸŸï¼Œä»å‘é‡ä¸­åˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼Œæˆ–è€…å…¶ä»–çš„ã€‚\nRustæ€ä¹ˆåœ¨è¿™äº›ä¸¥æ ¼çš„é™åˆ¶ä¸‹å®ç°çµæ´»æ€§å‘¢ï¼Ÿå¦‚ä¸‹åˆ—å‡ºäº†ä¸€äº›æ–¹å¼ï¼š\nYou can move values from one owner to another. This allows you to build, rearrange, and tear down the tree. Very simple types like integers, floating-point numbers, and characters are excused from the ownership rules. These are called Copy types. The standard library provides the reference-counted pointer types Rc and Arc, which allow values to have multiple owners, under some restrictions. You can â€œborrow a referenceâ€ to a value; references are non-owning pointers, with limited lifetimes. Moves In Rust, for most types, operations like assigning a value to a variable, passing it to a function, or returning it from a function donâ€™t copy the value: they move it. The source relinquishes ownership of the value to the destination and becomes uninitialized; the destination now controls the valueâ€™s lifetime. Rust programs build up and tear down complex structures one value at a time, one move at a time.\nçœ‹çœ‹Pythonä¸­çš„å˜é‡èµ‹å€¼ã€‚\n1 2 3 s = [\u0026#39;udon\u0026#39;, \u0026#39;ramen\u0026#39;, \u0026#39;soba\u0026#39;] t=s u=s å¼€å§‹çš„å†…å­˜å¸ƒå±€ï¼š\næ‰§è¡Œä»£ç åçš„å†…å­˜å¸ƒå±€ï¼š\nPython has copied the pointer from s into t and u and updated the listâ€™s reference count to 3. Assignment in Python is cheap, but because it creates a new reference to the object, we must maintain reference counts to know when we can free the value.\næ¥çœ‹çœ‹C++ä¸­çš„å®ç°ï¼š\n1 2 3 4 using namespace std; vector\u0026lt;string\u0026gt; s = { \u0026#34;udon\u0026#34;, \u0026#34;ramen\u0026#34;, \u0026#34;soba\u0026#34; }; vector\u0026lt;string\u0026gt; t = s; vector\u0026lt;string\u0026gt; u = s; å¼€å§‹çš„å†…å­˜å¸ƒå±€\nä»£ç æ‰§è¡Œåçš„å†…å­˜å¸ƒå±€ï¼š\nDepending on the values involved, assignment in C++ can consume unbounded amounts of memory and processor time. The advantage, however, is that itâ€™s easy for the program to decide when to free all this memory: when the variables go out of scope, everything allocated here gets cleaned up automatically.\nRustä¸­çš„å®ç°ï¼š\n1 2 3 let s = vec![\u0026#34;udon\u0026#34;.to_string(), \u0026#34;ramen\u0026#34;.to_string(), \u0026#34;soba\u0026#34;.to_string()]; let t = s; let u = s; å¼€å§‹çš„å†…å­˜åˆ†å¸ƒï¼š\nåœ¨let t = s;ä¹‹åï¼Œs çš„æ‰€æœ‰æƒå°± move åˆ° t ä¸Šäº†ã€‚\nè¿™æ—¶ s å˜æˆæœªåˆå§‹åŒ–çŠ¶æ€ï¼Œå†æ‰§è¡Œ let u = s; å°±ä¼šæŠ¥é”™ï¼Œå› ä¸ºä½¿ç”¨äº†æœªåˆå§‹åŒ–çš„å˜é‡ã€‚\nConsider the consequences of Rustâ€™s use of a move here. Like Python, the assignment is cheap: the program simply moves the three-word header of the vector from one spot to another. But like C++, ownership is always clear: the program doesnâ€™t need reference counting or garbage collection to know when to free the vector elements and string contents.\nå¦‚æœæƒ³å®ç°Pythoné‚£æ ·çš„å¼•ç”¨è®¡æ•°ï¼Œå¯ä»¥ç”¨ Rc å’Œ Arcï¼Œå¦‚æœæƒ³å®ç°C++é‚£æ ·çš„æ·±æ‹·è´ï¼Œå¯ä»¥æ˜¾å¼è°ƒç”¨ clone() æ–¹æ³•ã€‚\nMore Operations That Move moveè¯­ä¹‰çš„å‘ç”Ÿï¼š\nç»™ä¸€ä¸ªå‡½æ•°ä¼ é€’å‚æ•°ï¼Œä¼šå°†æ‰€æœ‰æƒç»™å‚æ•° ä»å‡½æ•°è¿”å›ä¸€ä¸ªå€¼ä¼šå°†æ‰€æœ‰æƒç»™è°ƒç”¨è€… åˆ›å»ºä¸€ä¸ªå…ƒç»„ï¼Œä¼šå°†å€¼çš„æ‰€æœ‰æƒç»™å…ƒç»„ Moving values around like this may sound inefficient, but there are two things to keep in mind. First, the moves always apply to the value proper, not the heap storage they own. For vectors and strings, the value proper is the three-word header alone; the potentially large element arrays and text buffers sit where they are in the heap. Second, the Rust compilerâ€™s code generation is good at â€œseeing throughâ€ all these moves; in practice, the machine code often stores the value directly where it belongs.\nMoves and Control Flow If itâ€™s possible for a variable to have had its value moved away and it hasnâ€™t definitely been given a new value since, itâ€™s considered uninitialized.\nMoves and Indexed Content Weâ€™ve mentioned that a move leaves its source uninitialized, as the destination takes ownership of the value. But not every kind of value owner is prepared to become uninitialized.\n1 2 3 4 5 6 7 // Build a vector of the strings \u0026#34;101\u0026#34;, \u0026#34;102\u0026#34;, ... \u0026#34;105\u0026#34; let mut v = Vec::new(); for i in 101 .. 106 { v.push(i.to_string()); } // Pull out random elements from the vector. let third = v[2]; // error: Cannot move out of index of Vec let fifth = v[4]; // here too è¦å°† vector çœ‹ä½œä¸€ä¸ªæ•´ä½“ï¼Œè¿™é‡Œä¸èƒ½å•ç‹¬å°† v[2] move å‡ºæ¥ã€‚å¦‚æœç¡®å®æƒ³æ‹¿å‡ºå…¶ä¸­çš„å…ƒç´ ï¼Œæœ‰ä¸‹é¢ä¸€äº›æ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Build a vector of the strings \u0026#34;101\u0026#34;, \u0026#34;102\u0026#34;, ... \u0026#34;105\u0026#34; let mut v = Vec::new(); for i in 101 .. 106 { v.push(i.to_string()); } // 1. Pop a value off the end of the vector: let fifth = v.pop().expect(\u0026#34;vector empty!\u0026#34;); assert_eq!(fifth, \u0026#34;105\u0026#34;); // [\u0026#34;101\u0026#34;, \u0026#34;102\u0026#34;, \u0026#34;103\u0026#34;, \u0026#34;104\u0026#34;] // 2. Move a value out of a given index in the vector, // and move the last element into its spot: let second = v.swap_remove(1); assert_eq!(second, \u0026#34;102\u0026#34;); // [\u0026#34;101\u0026#34;, \u0026#34;104\u0026#34;, \u0026#34;103\u0026#34;] // 3. Swap in another value for the one we\u0026#39;re taking out: let third = std::mem::replace(\u0026amp;mut v[2], \u0026#34;substitute\u0026#34;.to_string()); assert_eq!(third, \u0026#34;103\u0026#34;); // [\u0026#34;101\u0026#34;, \u0026#34;104\u0026#34;, \u0026#34;substitute\u0026#34;] // Let\u0026#39;s see what\u0026#39;s left of our vector. assert_eq!(v, vec![\u0026#34;101\u0026#34;, \u0026#34;104\u0026#34;, \u0026#34;substitute\u0026#34;]); æ¥çœ‹çœ‹å¾ªç¯\n1 2 3 4 5 6 7 8 let v = vec![\u0026#34;libertÃ©\u0026#34;.to_string(), \u0026#34;Ã©galitÃ©\u0026#34;.to_string(), \u0026#34;fraternitÃ©\u0026#34;.to_string()]; for mut s in v { s.push(\u0026#39;!\u0026#39;); println!(\u0026#34;{}\u0026#34;, s); } è¿™é‡Œåœ¨forå¾ªç¯ä¸­ï¼Œv çš„æ‰€æœ‰æƒç»™äº†forå¾ªç¯ï¼Œv å°±å˜æˆæœªåˆå§‹åŒ–çš„çŠ¶æ€ï¼Œç„¶å for å¾ªç¯åˆ†ç¦»æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå°†æ‰€æœ‰æƒç»™æ¯ä¸€ä¸ªã€‚å› ä¸º s æœ‰æ‰€æœ‰æƒï¼Œå°±å¯ä»¥åœ¨å†…éƒ¨ä¿®æ”¹å­—ç¬¦ä¸²äº†ã€‚\nç”±äºåœ¨å¾ªç¯ä¸­å°† v çš„æ‰€æœ‰æƒç»™äº†å¾ªç¯ï¼Œå› æ­¤åé¢å°±ä¸èƒ½å†ä½¿ç”¨ v äº†ï¼Œä¸‹é¢ä»£ç å°±ä¼šæŠ¥é”™ã€‚\n1 2 3 4 5 6 7 8 9 let v = vec![\u0026#34;libertÃ©\u0026#34;.to_string(), \u0026#34;Ã©galitÃ©\u0026#34;.to_string(), \u0026#34;fraternitÃ©\u0026#34;.to_string()]; for mut s in v { s.push(\u0026#39;!\u0026#39;); println!(\u0026#34;{}\u0026#34;, s); } let _u = v; // error[E0382]: use of moved value: `v` å¦‚æœæƒ³å¾—åˆ°ç»“æ„ä½“ä¸­çš„å…ƒç´ å€¼ï¼Œå¯ä»¥è°ƒç”¨ std::mem::replaceæ–¹æ³•ï¼Œå°†åŸæ¥çš„å€¼ç”¨Noneæ¥å ä½ã€‚\n1 2 3 4 5 6 7 8 9 struct Person { name: Option\u0026lt;String\u0026gt;, birth: i32 } let mut composers = Vec::new(); composers.push(Person { name: Some(\u0026#34;Palestrina\u0026#34;.to_string()), birth: 1525 }); let first_name = std::mem::replace(\u0026amp;mut composers[0].name, None); // let first_name = composers[0].name.take(); // å’Œä¸Šè¿°è¯­å¥è¾¾åˆ°çš„æ•ˆæœä¸€æ · assert_eq!(first_name, Some(\u0026#34;Palestrina\u0026#34;.to_string())); assert_eq!(composers[0].name, None); Copy Types: The Exception to Moves Assigning a value of a Copy type copies the value, rather than moving it. The source of the assignment remains initialized and usable, with the same value it had before. Passing Copy types to functions and constructors behaves similarly.\nThe standard Copy types include all the machine integer and floating-point numeric types, the char and bool types, and a few others. A tuple or fixed-size array of Copy types is itself a Copy type.\nOnly types for which a simple bit-for-bit copy suffices can be Copy. As a rule of thumb, any type that needs to do something special when a value is dropped cannot be Copy.\nè‡ªå®šä¹‰çš„ç»“æ„ä½“æˆ–è€…æšä¸¾ç±»å‹å¯ä»¥ç”¨å±æ€§å®å®ç° Copy traitã€‚\n1 2 #[derive(Copy, Clone)] struct Label { number: u32 } In Rust, every move is a byte-for-byte, shallow copy that leaves the source uninitialized. Copies are the same, except that the source remains initialized.\nOne of Rustâ€™s principles is that costs should be apparent to the programmer. Basic operations must remain simple. Potentially expensive operations should be explicit, like the calls to clone in the earlier example that make deep copies of vectors and the strings they contain.\nRc and Arc: Shared Ownership The Rc and Arc types are very similar; the only difference between them is that an Arc is safe to share between threads directlyâ€”the name Arc is short for atomic reference countâ€”whereas a plain Rc uses faster non-thread-safe code to update its reference count.\nå‰é¢çš„ä¾‹å­ç”¨Rustå®ç°Pythonä¸­å¼•ç”¨è®¡æ•°çš„æ•ˆæœï¼š\n1 2 3 4 5 6 use std::rc::Rc; // Rust can infer all these types; written out for clarity let s: Rc\u0026lt;String\u0026gt; = Rc::new(\u0026#34;shirataki\u0026#34;.to_string()); let t: Rc\u0026lt;String\u0026gt; = s.clone(); let u: Rc\u0026lt;String\u0026gt; = s.clone(); å†…å­˜å¸ƒå±€ï¼š\nRustâ€™s memory and thread-safety guarantees depend on ensuring that no value is ever simultaneously shared and mutable. Rust assumes the referent of an Rc pointer might in general be shared, so it must not be mutable.\nHowever, Rust does provide ways to create mutable portions of otherwise immutable values; this is called interior mutability. è¿™å¯èƒ½é€ æˆå¾ªç¯å¼•ç”¨ã€‚\næƒ³è¦ç”¨Rcé¿å…å¾ªç¯å¼•ç”¨ã€‚You can sometimes avoid creating cycles of Rc pointers by using weak pointers, std::rc::Weak, for some of the links instead.\nChapter 5. References Rust also has non-owning pointer types called references, which have no effect on their referentsâ€™ lifetimes.\nIn fact, itâ€™s rather the opposite: references must never outlive their referents. You must make it apparent in your code that no reference can possibly outlive the value it points to. To emphasize this, Rust refers to creating a reference to some value as borrowing the value: what you have borrowed, you must eventually return to its owner.\nReferences to Values A reference lets you access a value without affecting its ownership. References come in two kinds:\nA shared reference lets you read but not modify its referent. However, you can have as many shared references to a particular value at a time as you like. The expression \u0026amp;e yields a shared reference to eâ€™s value; if e has the type T, then \u0026amp;e has the type \u0026amp;T, pronounced â€œref T.â€ Shared references are Copy. If you have a mutable reference to a value, you may both read and modify the value. However, you may not have any other references of any sort to that value active at the same time. The expression \u0026amp;mut e yields a mutable reference to eâ€™s value; you write its type as \u0026amp;mut T, which is pronounced â€œref mute T.â€ Mutable references are not Copy. 1 2 3 4 5 6 7 8 fn show(table: \u0026amp;Table) { for (artist, works) in table { println!(\u0026#34;works by {}:\u0026#34;, artist); for work in works { println!(\u0026#34; {}\u0026#34;, work); } } } Iterating over a shared reference to a HashMap is defined to produce shared references to each entryâ€™s key and value: artist has changed from a String to a \u0026amp;String, and works from a Vec\u0026lt;String\u0026gt; to a \u0026amp;Vec\u0026lt;String\u0026gt;.\nThe inner loop is changed similarly. Iterating over a shared reference to a vector is defined to produce shared references to its elements, so work is now a \u0026amp;String. No ownership changes hands anywhere in this function; itâ€™s just passing around non-owning references.\nWhen we pass a value to a function in a way that moves ownership of the value to the function, we say that we have passed it by value. If we instead pass the function a reference to the value, we say that we have passed the value by reference.\nWorking with References Rust References Versus C++ References In Rust, references are created explicitly with the \u0026amp; operator, and dereferenced explicitly with the * operator.\nSince references are so widely used in Rust, the . operator implicitly dereferences its left operand, if needed.\n1 2 3 4 5 6 7 struct Anime { name: \u0026amp;\u0026#39;static str, bechdel_pass: bool }; let aria = Anime { name: \u0026#34;Aria: The Animation\u0026#34;, bechdel_pass: true }; let anime_ref = \u0026amp;aria; assert_eq!(anime_ref.name, \u0026#34;Aria: The Animation\u0026#34;); // Equivalent to the above, but with the dereference written out: assert_eq!((*anime_ref).name, \u0026#34;Aria: The Animation\u0026#34;); The println! macro used in the show function expands to code that uses the . operator.\nThe . operator can also implicitly borrow a reference to its left operand, if needed for a method call.\n1 2 3 let mut v = vec![1973, 1968]; v.sort(); // implicitly borrows a mutable reference to v (\u0026amp;mut v).sort(); // equivalent, but more verbose Assigning References 1 2 3 4 5 6 7 let x = 10; let y = 20; let mut r = \u0026amp;x; if b { r = \u0026amp;y; } assert!(*r == 10 || *r == 20); The reference r initially points to x. But if b is true, the code points it at y instead.\nReferences to References 1 2 3 4 5 struct Point { x: i32, y: i32 } let point = Point { x: 1000, y: 729 }; let r: \u0026amp;Point = \u0026amp;point; let rr: \u0026amp;\u0026amp;Point = \u0026amp;r; let rrr: \u0026amp;\u0026amp;\u0026amp;Point = \u0026amp;rr; The . operator follows as many references as it takes to find its target.\n1 assert_eq!(rrr.y, 729); So the expression rrr.y, guided by the type of rrr, actually traverses three references to get to the Point before fetching its y field.\nComparing References 1 2 3 4 5 6 7 8 9 10 11 let x = 10; let y = 10; let rx = \u0026amp;x; let ry = \u0026amp;y; let rrx = \u0026amp;rx; let rry = \u0026amp;ry; assert!(rrx \u0026lt;= rry); assert!(rrx == rry); æ¯”è¾ƒæ“ä½œç¬¦å’Œ.æ“ä½œç¬¦ä¸€æ ·å¯ä»¥è§£å¼•ç”¨åˆ°æœ€ç»ˆçš„ç›®æ ‡å€¼ã€‚\nå¯ä»¥ç”¨std::ptr::eqæ¥æ¯”è¾ƒåœ°å€æ˜¯å¦ç›¸ç­‰ï¼š\n1 2 assert!(rx == ry); // their referents are equal assert!(!std::ptr::eq(rx, ry)); // but occupy different addresses æ¯”è¾ƒæ“ä½œç¬¦ä¸¤ç«¯çš„ç±»å‹å¿…é¡»ç›¸åŒï¼š\n1 2 assert!(rx == rrx); // error: type mismatch: `\u0026amp;i32` vs `\u0026amp;\u0026amp;i32` assert!(rx == *rrx); // this is okay References Are Never Null Rust references are never null. There is no default initial value for a reference (you canâ€™t use any variable until itâ€™s been initialized, regardless of its type) and Rust wonâ€™t convert integers to references (outside of unsafe code), so you canâ€™t convert zero into a reference.\nIn Rust, if you need a value that is either a reference to something or not, use the type Option\u0026lt;\u0026amp;T\u0026gt;.\nBorrowing References to Arbitrary Expressions Rust lets you borrow a reference to the value of any sort of expression at all:\n1 2 3 4 5 6 7 fn factorial(n: usize) -\u0026gt; usize { (1..n+1).product() } let r = \u0026amp;factorial(6); // Arithmetic operators can see through one level of references. assert_eq!(r + \u0026amp;1009, 1729); Rust simply creates an anonymous variable to hold the expressionâ€™s value and makes the reference point to that. The lifetime of this anonymous variable depends on what you do with the reference:\nIf you immediately assign the reference to a variable in a let statement (or make it part of some struct or array that is being immediately assigned), then Rust makes the anonymous variable live as long as the variable the let initializes. Otherwise, the anonymous variable lives to the end of the enclosing statement. References to Slices and Trait Objects fat pointers:\nA reference to a slice is a fat pointer, carrying the starting address of the slice and its length. Rustâ€™s other kind of fat pointer is a trait object, a reference to a value that implements a certain trait. A trait object carries a valueâ€™s address and a pointer to the traitâ€™s implementation appropriate to that value, for invoking the traitâ€™s methods. Reference Safety Borrowing a Local Variable You canâ€™t borrow a reference to a local variable and take it out of the variableâ€™s scope:\n1 2 3 4 5 6 7 8 { let r; { let x = 1; r = \u0026amp;x; } assert_eq!(*r, 1); // bad: reads memory `x` used to occupy } The variables r and x both have a lifetime, extending from the point at which theyâ€™re initialized until the point that the compiler can prove they are no longer in use. The third lifetime is that of a reference type: the type of the reference we borrow to x and store in r.\nWe say that the variableâ€™s lifetime must contain or enclose that of the reference borrowed from it. å˜é‡çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»åŒ…å«æˆ–æ¶µç›–ä»å®ƒé‚£é‡Œå€Ÿæ¥çš„å¼•ç”¨çš„ç”Ÿå‘½æœŸã€‚\nHereâ€™s another kind of constraint: if you store a reference in a variable r, the referenceâ€™s type must be good for the entire lifetime of the variable, from its initialization until its last us.\nWe say that the referenceâ€™s lifetime must contain or enclose the variableâ€™s. å¼•ç”¨çš„ç”Ÿå‘½æœŸå¿…é¡»åŒ…å«æˆ–æ¶µç›–ä¿å­˜å®ƒçš„å˜é‡çš„ç”Ÿå‘½æœŸã€‚\nThe first kind of constraint limits how large a referenceâ€™s lifetime can be, while the second kind limits how small it can be.\nä¸‹é¢çš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ­£ç¡®çš„ï¼š\nFirst, understand the constraints arising from the way the program uses references; then, find lifetimes that satisfy them.\nReceiving References as Function Arguments Every static must be initialized. Mutable statics are inherently not thread-safe (after all, any thread can access a static at any time), and even in single-threaded programs, they can fall prey to other sorts of reentrancy problems. For these reasons, you may access a mutable static only within an unsafe block. In this example weâ€™re not concerned with those particular problems, so weâ€™ll just throw in an unsafe block and move on. fn f\u0026lt;'a\u0026gt;(p: \u0026amp;'a i32), weâ€™re defining a function that takes a reference to an i32 with any given lifetime \u0026lsquo;a.\nIn other words, we were unable to write a function that stashed a reference in a global variable without reflecting that intention in the functionâ€™s signature. In Rust, a functionâ€™s signature always exposes the bodyâ€™s behavior.\nIf we do see a function with a signature like g(p: \u0026amp;i32) (or with the lifetimes written out, g\u0026lt;'a\u0026gt;(p: \u0026amp;'a i32)), we can tell that it does not stash its argument p anywhere that will outlive the call.\nPassing References to Functions 1 2 3 4 5 6 // This could be written more briefly: fn g(p: \u0026amp;i32), // but let\u0026#39;s write out the lifetimes for now. fn g\u0026lt;\u0026#39;a\u0026gt;(p: \u0026amp;\u0026#39;a i32) { ... } let x = 10; g(\u0026amp;x); ä»gçš„ç­¾åçœ‹ï¼ŒRustçŸ¥é“å®ƒä¸ä¼šæŠŠpä¿å­˜åˆ°è¶…å‡ºè°ƒç”¨ç”Ÿå‘½å‘¨æœŸçš„å˜é‡é‡Œï¼›ä»»ä½•æ¶µç›–è°ƒç”¨çš„ç”Ÿå‘½å‘¨æœŸéƒ½æ»¡è¶³'aã€‚\n1 2 3 4 fn f(p: \u0026amp;\u0026#39;static i32) { ... } let x = 10; f(\u0026amp;x); // error è¿™é‡Œ \u0026amp;xä¸èƒ½å­˜æ´»å¾—æ¯”xé•¿ï¼Œè€Œå‡½æ•°ç­¾åè¦æ±‚\u0026amp;xæ´»å¾—å’Œ\u0026amp;'staticä¸€æ ·é•¿ï¼Œè¿™å°±æ— æ³•å¾—åˆ°æ»¡è¶³ï¼Œå› æ­¤æŠ¥é”™ã€‚\nReturning References 1 2 3 4 5 6 7 8 // v should have at least one element. fn smallest(v: \u0026amp;[i32]) -\u0026gt; \u0026amp;i32 { let mut s = \u0026amp;v[0]; for r in \u0026amp;v[1..] { if *r \u0026lt; *s { s = r; } } s } å¦‚æœä¸€ä¸ªå‡½æ•°åªæœ‰ä¸€ä¸ªå¼•ç”¨ä½œä¸ºå‚æ•°å¹¶è¿”å›ä¸€ä¸ªå¼•ç”¨ï¼Œåˆ™å®ƒä»¬æ‹¥æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸã€‚\nStructs Containing References å½“å¼•ç”¨ç±»å‹å‡ºç°åœ¨å¦ä¸€ä¸ªç±»å‹çš„å®šä¹‰ä¸­æ—¶ï¼Œå¿…é¡»å†™å‡ºå…¶ç”Ÿå‘½å‘¨æœŸã€‚\n1 2 3 struct S { r: \u0026amp;\u0026#39;static i32 // è¿™é‡Œ r å¿…é¡»å†™ä¸Šç”Ÿå‘½å‘¨æœŸ } æˆ–è€…\n1 2 3 struct S\u0026lt;\u0026#39;a\u0026gt;{ r: \u0026amp;\u0026#39;a i32 } ä¿å­˜åœ¨rä¸­çš„ä»»ä½•å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæœ€å¥½åŒ…å«'aï¼Œè€Œ'aä¹Ÿå¿…é¡»æ¯”ä¿å­˜åœ¨Sçš„ä»»ä½•å€¼éƒ½é•¿å¯¿ã€‚\nThe lifetime of any reference you store in r had better enclose \u0026lsquo;a, and \u0026lsquo;a must outlast the lifetime of wherever you store the S.\nThe assignment s = S { \u0026hellip; } stores this S in a variable whose lifetime extends to the end of the example, constraining \u0026lsquo;a to outlast the lifetime of s.\nAnd now Rust has arrived at the same contradictory constraints as before: \u0026lsquo;a must not outlive x, yet must live at least as long as s.\nDistinct Lifetime Parameters 1 2 3 4 struct S\u0026lt;\u0026#39;a\u0026gt; { x: \u0026amp;\u0026#39;a i32, y: \u0026amp;\u0026#39;a i32 } å¦‚ä¸‹ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 let x = 10; let r; { let y = 20; { let s = S { x: \u0026amp;x, y: \u0026amp;y }; r = s.x; } } println!(\u0026#34;{}\u0026#34;, r); If you work through the code carefully, you can follow its reasoning:\nBoth fields of S are references with the same lifetime \u0026lsquo;a, so Rust must find a single lifetime that works for both s.x and s.y. We assign r = s.x, requiring \u0026lsquo;a to enclose râ€™s lifetime. (r \u0026lt;= \u0026lsquo;a) We initialized s.y with \u0026amp;y, requiring \u0026lsquo;a to be no longer than yâ€™s lifetime. (\u0026lsquo;a \u0026lt;= y) Omitting Lifetime Parameters ä¸‰æ¡è§„åˆ™ï¼ˆè§ç”Ÿå‘½å‘¨æœŸä¸å¼•ç”¨æœ‰æ•ˆæ€§ï¼‰ï¼š\nç¬¬ä¸€æ¡è§„åˆ™æ˜¯æ¯ä¸€ä¸ªæ˜¯å¼•ç”¨çš„å‚æ•°éƒ½æœ‰å®ƒè‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚æ¢å¥è¯è¯´å°±æ˜¯ï¼Œæœ‰ä¸€ä¸ªå¼•ç”¨å‚æ•°çš„å‡½æ•°æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šfn foo\u0026lt;'a\u0026gt;(x: \u0026amp;'a i32)ï¼Œæœ‰ä¸¤ä¸ªå¼•ç”¨å‚æ•°çš„å‡½æ•°æœ‰ä¸¤ä¸ªä¸åŒçš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œfn foo\u0026lt;'a, 'b\u0026gt;(x: \u0026amp;'a i32, y: \u0026amp;'b i32)ï¼Œä¾æ­¤ç±»æ¨ã€‚\nç¬¬äºŒæ¡è§„åˆ™æ˜¯å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆå®ƒè¢«èµ‹äºˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šfn foo\u0026lt;'a\u0026gt;(x: \u0026amp;'a i32) -\u0026gt; \u0026amp;'a i32ã€‚\nç¬¬ä¸‰æ¡è§„åˆ™æ˜¯å¦‚æœæ–¹æ³•æœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°å¹¶ä¸”å…¶ä¸­ä¸€ä¸ªå‚æ•°æ˜¯ \u0026amp;self æˆ– \u0026amp;mut selfï¼Œè¯´æ˜æ˜¯ä¸ªå¯¹è±¡çš„æ–¹æ³•(method)(è¯‘è€…æ³¨ï¼š è¿™é‡Œæ¶‰åŠ Rust çš„é¢å‘å¯¹è±¡å‚è§ 17 ç« ), é‚£ä¹ˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°è¢«èµ‹äºˆ self çš„ç”Ÿå‘½å‘¨æœŸã€‚ç¬¬ä¸‰æ¡è§„åˆ™ä½¿å¾—æ–¹æ³•æ›´å®¹æ˜“è¯»å†™ï¼Œå› ä¸ºåªéœ€æ›´å°‘çš„ç¬¦å·ã€‚\nSharing Versus Mutation Throughout its lifetime, a shared reference makes its referent read-only: you may not assign to the referent or move its value elsewhere.\nShared access is read-only access.\nValues borrowed by shared references are read-only. Across the lifetime of a shared reference, neither its referent, nor anything reachable from that referent, can be changed by anything. There exist no live mutable references to anything in that structure, its owner is held read-only, and so on. Itâ€™s really frozen.\nMutable access is exclusive access.\nA value borrowed by a mutable reference is reachable exclusively via that reference. Across the lifetime of a mutable reference, there is no other usable path to its referent or to any value reachable from there. The only references whose lifetimes may overlap with a mutable reference are those you borrow from the mutable reference itself.\nTaking Arms Against a Sea of Objects Chapter 6. Expressions Rustä¸­ç»å¤§å¤šæ•°éƒ½æ˜¯è¡¨è¾¾å¼ã€‚\nAn Expression Language åœ¨Rustä¸­ï¼Œif å’Œ match éƒ½å¯ä»¥äº§ç”Ÿå€¼ã€‚ä¸€ä¸ªmatchè¡¨è¾¾å¼å¯ä»¥ç»™ä¸€ä¸ªå‡½æ•°æˆ–è€…å®æ¥ä¼ å‚ã€‚ Rust ä¸­æ²¡æœ‰ä¸‰å…ƒæ“ä½œç¬¦ã€‚ Rustä¸­æ‰€æœ‰çš„æ§åˆ¶æµç¨‹å·¥å…·æ˜¯è¡¨è¾¾å¼ã€‚ Precedence and Associativity é—­åŒ…çš„ä¼˜å…ˆçº§åœ¨æœ€åã€‚ All of the operators that can usually be chained are left-associative. æ‰€æœ‰è¿™äº›æ“ä½œç¬¦åœ¨é“¾å¼æ“ä½œæ—¶éƒ½å…·æœ‰å·¦å…³è”æ€§ã€‚ æ¯”è¾ƒæ“ä½œç¬¦ï¼Œèµ‹å€¼æ“ä½œç¬¦ï¼ˆassignment iperatorsï¼‰ä»¥åŠèŒƒå›´æ“ä½œç¬¦ï¼ˆ..range operatorsï¼‰ä¸èƒ½é“¾å¼é“¾æ¥ã€‚ Blocks and Semicolons block çš„å€¼æ˜¯æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ã€‚ let å£°æ˜å¿…é¡»è¦æœ‰åˆ†å·ã€‚ å¦‚æœ if è¡¨è¾¾å¼æ²¡æœ‰ elseï¼Œé‚£ä¹ˆæ€»æ˜¯è¿”å› ()ã€‚ Declarations let å£°æ˜å¿…é¡»è¦æœ‰åˆ†å·ã€‚ let å£°æ˜å¯ä»¥åªå£°æ˜å˜é‡è€Œä¸åˆå§‹åŒ–å®ƒã€‚ åœ¨æ²¡æœ‰åˆå§‹åŒ–ä¸€ä¸ªå˜é‡ä¹‹å‰æ˜¯ä¸èƒ½ä½¿ç”¨å®ƒçš„ã€‚ å˜é‡é®è”½ï¼Œå¯ä»¥æ˜¯ä¸åŒçš„ç±»å‹ã€‚ ä¸€ä¸ªå—å¯ä»¥åŒ…å«ç‰¹æ€§é¡¹ï¼ˆ itemï¼‰ declarationsï¼Œå°±æ˜¯æŒ‡ä»»ä½•å¯ä»¥åœ¨ç¨‹åºæˆ–æ¨¡å—çš„å…¨å±€ä¸­å‡ºç°çš„å£°æ˜ï¼Œæ¯”å¦‚ fnï¼Œstruct æˆ–è€… useã€‚ åµŒå¥—çš„ fn ä¸èƒ½ä½¿ç”¨ scope ä¸­çš„å±€éƒ¨å˜é‡ã€‚ å—ä¸­ç”šè‡³å¯ä»¥åŒ…å«ä¸€ä¸ªå®Œæ•´çš„æ¨¡å—ã€‚ if and match if è¡¨è¾¾å¼çš„ condition å¿…é¡»æ˜¯ bool ç±»å‹çš„ï¼ŒRust ä¸ä¼šå°†æ•°å€¼æˆ–è€…æŒ‡é’ˆéšå¼è½¬æ¢æˆ Boolean ç±»å‹ã€‚ åœ¨ if è¡¨è¾¾å¼å½¢å¼ä¸­ï¼Œå›´ç»•æ¡ä»¶çš„åœ†æ‹¬å·ä¸æ˜¯å¿…éœ€çš„ã€‚äº‹å®ä¸Šï¼Œrustcåœ¨å‘ç°ä¸å¿…è¦çš„åœ†æ‹¬å·æ—¶ä¼šç»™å‡ºè­¦å‘Šã€‚ä½†èŠ±æ‹¬å·æ˜¯å¿…éœ€çš„ã€‚ ä¸€ä¸ªåªæœ‰ if æ²¡æœ‰ else çš„è¡¨è¾¾å¼ç›¸å½“äºæœ‰ä¸€ä¸ª ç©ºçš„else å—ã€‚å› æ­¤å¦‚æœ if è¡¨è¾¾å¼æ²¡æœ‰ elseï¼Œé‚£ä¹ˆæ€»æ˜¯è¿”å› ()ã€‚ ç¼–è¯‘å™¨å¯ä»¥ç”¨ä¸€ä¸ªè·³è½¬è¡¨ï¼ˆ jump table ï¼‰æ¥ä¼˜åŒ– match è¡¨è¾¾å¼ã€‚å¦‚æœ match çš„æ¯ä¸ªåˆ†æ”¯éƒ½äº§ç”Ÿä¸€ä¸ªå¸¸é‡å€¼ï¼Œé‚£ä¹ˆä¹Ÿå¯ä»¥åº”ç”¨åŒæ ·çš„ä¼˜åŒ–ã€‚æ­¤æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ„å»ºä¸€ä¸ªè¿™äº›å€¼çš„æ•°ç»„ï¼Œè€Œ match ä¼šè¢«ç¼–è¯‘ä¸ºå¯¹æ•°ç»„çš„è®¿é—®ã€‚é™¤äº†è¾¹ç•Œæ£€æŸ¥ï¼Œç¼–è¯‘åçš„ä»£ç ä¸­æ ¹æœ¬æ²¡æœ‰åˆ†æ”¯ã€‚ Rust ç¦æ­¢ match è¡¨è¾¾å¼æ²¡æœ‰è¦†ç›–åˆ°æ‰€æœ‰æƒ…å†µã€‚ ä¸€ä¸ª if è¡¨è¾¾å¼çš„æ‰€æœ‰å—å¿…é¡»äº§ç”Ÿç›¸åŒç±»å‹çš„å€¼ï¼Œå¯¹äº match è¡¨è¾¾å¼ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œmatch è¡¨è¾¾å¼çš„æ‰€æœ‰åˆ†æ”¯ä¹Ÿéƒ½å¿…é¡»è¿”å›ç›¸åŒç±»å‹çš„å€¼ã€‚ if let 1 2 3 4 5 if let pattern = expr { block1 } else { block2 } ç­‰ä»·äº\n1 2 3 4 match expr { pattern =\u0026gt; { block1 } _ =\u0026gt; { block2 } } Loops æœ‰å››ç§ looping è¡¨è¾¾å¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 while condition { block } while let pattern = expr { block } loop { block } for pattern in iterable { block } while å’Œ for çš„å€¼ä¸€ç›´éƒ½æ˜¯ ()ï¼Œå¾ªç¯çš„å€¼æ˜¯()ã€‚ ç”¨ loop å¯ä»¥æ— é™å¾ªç¯ï¼Œé™¤éé‡åˆ° breakï¼Œreturnæˆ–è€…çº¿ç¨‹ panicsã€‚ for å¾ªç¯æ¯è¿­ä»£ä¸€ä¸ªå€¼å°±ä¼šæ¶ˆè€—ä¸€ä¸ªå€¼ï¼Œæœ‰æ—¶å€™å¯ä»¥ä½¿ç”¨å¼•ç”¨ã€‚ Control Flow in Loops break åªèƒ½åœ¨ loop ä¸­ï¼Œä¸èƒ½åœ¨ match ä¸­ã€‚ å¯ä»¥ç»™ break ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè¿™ä¸ªè¡¨è¾¾å¼çš„å€¼å°±æ˜¯ loop çš„å€¼ã€‚ è‡ªç„¶åœ°ï¼Œæ‰€æœ‰ break è¡¨è¾¾å¼åœ¨ä¸€ä¸ªå¾ªç¯ä¸­å¿…é¡»æ˜¯ç›¸åŒç±»å‹çš„ï¼Œå¹¶ä¸”è¿™ä¸ªç±»å‹å°±æ˜¯ loop çš„ç±»å‹ã€‚ å¾ªç¯å¯ä»¥åŠ ä¸Šç”Ÿå‘½å‘¨æœŸçš„æ ‡ç­¾ï¼Œç„¶åå¯ä»¥ break è¿™ä¸ªæ ‡ç­¾ï¼Œbreak ä¹Ÿå¯ä»¥åŒæ—¶å¸¦ä¸Šå€¼è¡¨è¾¾å¼ã€‚ æ ‡ç­¾åŒæ ·å¯ä»¥ç”¨äº continueã€‚ return Expressions return è¡¨è¾¾å¼ä¼šé€€å‡ºå½“å‰å‡½æ•°ï¼Œå¹¶ä¸”ç»™è°ƒç”¨è€…è¿”å›ä¸€ä¸ªå€¼ã€‚ å¯ä»¥å°†å‡½æ•°ä½“çœ‹æˆä¸€ä¸ªå—è¡¨è¾¾å¼ã€‚ return å¯ä»¥æ”¾å¼ƒæ­£åœ¨è¿è¡Œä¸­çš„å·¥ä½œã€‚ Why Rust Has loop Rustç¼–è¯‘å™¨åˆ†æä½ çš„ç¨‹åºçš„æ§åˆ¶æµç¨‹ï¼š\næ£€æŸ¥è¿”å›ç±»å‹ æ£€æŸ¥å±€éƒ¨å˜é‡ä¸ä¼šä½¿ç”¨æœªåˆå§‹åŒ–çš„å€¼ è­¦å‘Šä¸å¯åˆ°è¾¾çš„ä»£ç  ä»¥ä¸Šè¿™äº›ç§°ä¸ºæµæ•æ„Ÿï¼ˆflow-sensitiveï¼‰åˆ†æã€‚\nRustè¿½æ±‚ç®€å•ï¼Œå…¶æµæ•æ„Ÿåˆ†æå‹æ ¹ä¸ä¼šæ£€æŸ¥å¾ªç¯æ¡ä»¶ï¼Œè€Œåªæ˜¯å‡è®¾ç¨‹åºä¸­çš„ä»»ä½•æ¡ä»¶ä¸æ˜¯trueå°±æ˜¯falseã€‚\n! è¡¨ç¤ºæ˜¯ä¸€ä¸ªå‘æ•£å‡½æ•°ã€‚æ¯”å¦‚ breakï¼Œreturnï¼Œpanic!()ï¼Œæ— ç©·å¾ªç¯ï¼Œstd::process::exit() ï¼Œå®ƒä»¬éƒ½ä¸ä»¥æƒ¯å¸¸çš„æ–¹å¼ç»“æŸï¼Œè¿™äº›å¯ä»¥è·³è¿‡ä¹‹å‰è¯´çš„ç±»å‹ä¸€è‡´è§„åˆ™ã€‚\nFunction and Method Calls .location() æ–¹æ³•å¯èƒ½å– player çš„å€¼æˆ–è€…å¼•ç”¨ã€‚ . æ“ä½œç¬¦å¯ä»¥è‡ªåŠ¨çš„è§£å¼•ç”¨ playeræˆ–è€…å€Ÿä¸€ä¸ªå¼•ç”¨ã€‚å¯ä»¥æ¥æ”¶å€¼æˆ–å¼•ç”¨ã€‚ é™æ€æ–¹æ³•Vec::new() ï¼Œéé™æ€æ–¹æ³•é€šè¿‡å€¼è°ƒç”¨ï¼šmy_vec.len()ã€‚ å¯¹äºæ³›å‹ï¼Œå‡½æ•°æˆ–è€…æ–¹æ³•è°ƒç”¨è¦ç”¨æ¯”ç›®é±¼ turbofish æ“ä½œç¬¦ï¼Œæ¯”å¦‚ï¼šreturn Vec::\u0026lt;i32\u0026gt;::with_capcity(1000); Fields and Elements ç‚¹æ“ä½œç¬¦æˆ–è€…æ–¹æ‹¬å·çš„å·¦ä¾§æ˜¯ä¸€ä¸ªå¼•ç”¨æˆ–è€…æ™ºèƒ½æŒ‡é’ˆï¼Œé‚£ä¹ˆå®ƒå¯ä»¥è¢«è‡ªåŠ¨åœ°è§£å¼•ç”¨ï¼Œè¿™æ ·çš„è¡¨è¾¾å¼è¢«ç§°ä¸º lvaluesï¼Œå®ƒä»¬å¯ä»¥å‡ºç°åœ¨ä¸€ä¸ª assignment çš„å·¦ä¾§ã€‚\næ“ä½œç¬¦ï¼š\n1 2 3 4 5 6 .. a .. .. b a .. b ..= b a ..= b Reference Operators \u0026amp; \u0026amp; mut *æ“ä½œç¬¦å¯ä»¥ç”¨æ¥è§£å¼•ç”¨ Arithmetic, Bitwise, Comparsion, and Logical Operators ä¸èƒ½å°†-å’Œ+ ç”¨åˆ°æ— ç¬¦å·çš„æ•°å€¼ç±»å‹ä¸Šã€‚ %ä¹Ÿå¯ä»¥ç”¨åœ¨æµ®ç‚¹æ•°ä¸Šã€‚ !è¡¨ç¤ºæŒ‰ä½éã€‚ ä½æ“ä½œç¬¦çš„ä¼˜å…ˆçº§é«˜äºæ¯”è¾ƒæ“ä½œç¬¦çš„ä¼˜å…ˆçº§ã€‚ æ¯”è¾ƒæ“ä½œç¬¦ä¸¤ç«¯çš„ç±»å‹å¿…é¡»éƒ½æ˜¯ bool ç±»å‹ã€‚ Assignment Rustä¸­å¯ä»¥æœ‰å¤åˆæ“ä½œç¬¦ï¼š+= -= *= Rustä¸æ”¯æŒé“¾å¼ assignmentï¼Œæ¯”å¦‚ a = b = 3 Rustæ²¡æœ‰è‡ªå¢å’Œè‡ªå‡æ“ä½œç¬¦ï¼š++å’Œ--ã€‚ Type Casts å¯ä»¥ç”¨ as è¿›è¡Œç±»å‹è½¬æ¢ã€‚å‡ ç§ç±»å‹è½¬æ¢æ˜¯å…è®¸çš„ï¼š\nä»»ä½•å†…ç½®çš„æ•°å€¼ä¹‹é—´å¯ä»¥è½¬æ¢ã€‚ boolã€char æˆ–è€… C-like enum ç±»å‹å¯ä»¥è½¬æ¢ä¸ºæ•´æ•°ã€‚u8 å¯èƒ½è½¬æ¢ä¸º char ç±»å‹ã€‚ æœ‰äº›å«æœ‰ unsafe çš„æŒ‡é’ˆç±»å‹çš„è½¬æ¢ä¹Ÿæ˜¯å…è®¸çš„ã€‚ ä¸€äº›è‡ªåŠ¨è½¬æ¢ï¼Œè¢«ç§°ä¸ºè§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢ï¼ˆderef coercionsï¼‰ï¼š\n\u0026amp;String -\u0026gt; \u0026amp;str \u0026amp;Vec\u0026lt;i32\u0026gt; -\u0026gt; \u0026amp;[i32] \u0026amp;Box[Chessboard] -\u0026gt; \u0026amp;Chessboard å®ƒä»¬å®ç°äº†å†…ç½®çš„ Deref traitã€‚\nClosures 1 let is_even = |x| x % 2 == 0; Rustè‡ªåŠ¨æ¨æ–­ç±»å‹ã€‚è°ƒç”¨é—­åŒ…å°±åƒè°ƒç”¨ä¸€ä¸ªå‡½æ•°é‚£æ ·ï¼š\n1 assert_eq!(is_even(14), true); Onward è¡¨è¾¾å¼åªæ˜¯æˆ‘ä»¬æ€è€ƒ running codeã€‚\nChapter 7. Error Handling Panic panic æ˜¯ç¨‹åºæœ¬èº«å‡ºç°ä¸€ä¸ªbugã€‚æ¯”å¦‚ï¼š\næ•°ç»„è¶Šç•Œ æ•´æ•°é™¤é›¶ å¯¹äºä¸€ä¸ª Resultè°ƒç”¨.expect()ã€‚ æ–­è¨€å¤±è´¥ panicæ—¶è¦ä¹ˆå±•å¼€æ ˆï¼Œè¦ä¹ˆä¸­æ­¢ç¨‹åºï¼Œå±•å¼€æ ˆæ˜¯é»˜è®¤çš„ã€‚\nUnwinding panicå‘ç”Ÿï¼š\nç»ˆç«¯æ‰“å°é”™è¯¯ä¿¡æ¯ è¿è¡Œ RUST_BACKTRACE=1ä¼šå°†æ ˆå±•å¼€ã€‚èµ„æºä¼šå…³é—­ï¼Œä¼šè°ƒç”¨dropæ–¹æ³•ã€‚ æœ€åï¼Œçº¿ç¨‹é€€å‡ºã€‚ panicä¸æ˜¯å´©æºƒï¼Œä¸æ˜¯æœªå®šä¹‰è¡Œä¸ºã€‚panicåƒJavaä¸­çš„è¿è¡Œæ—¶å¼‚å¸¸ï¼Œå…¶è¡Œä¸ºæ˜¯æ˜ç¡®å®šä¹‰çš„ï¼Œåªæ˜¯ä¸åº”è¯¥å‘ç”Ÿè€Œå·²ã€‚\npanicæ˜¯å®‰å…¨çš„ï¼Œå®ƒä¸è¿åä»»ä½•Rustçš„å®‰å…¨è§„åˆ™ã€‚ä¸ä¼šåœ¨å†…å­˜ä¸­å¯¼è‡´æ‚¬ç©ºæŒ‡é’ˆæˆ–åˆå§‹åŒ–ä¸€åŠçš„å€¼ï¼ŒRustå±•å¼€æ ˆåï¼Œè¿›ç¨‹çš„å…¶ä»–éƒ¨åˆ†è¿˜å¯ä»¥è¿è¡Œã€‚\npanicæ˜¯çº¿ç¨‹çº§åˆ«çš„ã€‚\næœ‰ä¸€ç§æ–¹æ³•å¯ä»¥æ•è·æ ˆå±•å¼€ï¼Œè¿è¡Œpanicçº¿ç¨‹å­˜æ´»å¹¶ç»§ç»­è¿è¡Œã€‚ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„std::panic::catch_unwind()å‡½æ•°ã€‚\nAborting å¦‚æœ.drop()æ–¹æ³•è§¦å‘äº†ç¬¬äºŒä¸ªpanicå½“Ruståœ¨ç¬¬ä¸€ä¸ªpanicåå°è¯• clean upï¼Œè¿™ä¼šè¢«å½“ä½œæ˜¯è‡´å‘½çš„ã€‚Rustä¼šåœæ­¢å±•å¼€å¹¶ä¸”ç›´æ¥ç»ˆæ­¢æ•´ä¸ªæµç¨‹ã€‚ ç¼–è¯‘åŠ ä¸Š-C panic=abortï¼Œç¬¬ä¸€ä¸ª panic å°±ç«‹é©¬ç»ˆæ­¢ç¨‹åºã€‚ Result å¦‚æœä¸ä½¿ç”¨Resultå€¼ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªè­¦å‘Šã€‚\nCatching Errors ç”¨ match æ¥å¤„ç† error\n1 2 3 4 5 6 7 8 9 match get_weather(hometown) { Ok(report) =\u0026gt; { display_weather(hometown, \u0026amp;report); } Err(err) =\u0026gt; { println!(\u0026#34;error querying the weather: {}\u0026#34;, err); schedule_weather_retry(); } } ä½†æ˜¯ä¸Šé¢è¿™ç§æ–¹å¼å¤ªå†—é•¿äº†ã€‚è¿™é‡Œæœ‰ä¸€äº›æ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1. è¿”å›ä¸€ä¸ªboolå€¼ result.is_ok() result.is_err() // 2. è¿”å›æˆåŠŸçš„å€¼ï¼Œè¿”å› Option\u0026lt;T\u0026gt;, æˆåŠŸå°±è¿”å›å€¼ï¼Œå¤±è´¥å°±è¿”å› None result.ok() // 3. è¿”å›å¤±è´¥çš„å€¼ result.err() // 4. è¿”å›æˆåŠŸçš„å€¼ï¼Œå¦åˆ™å°±è¿”å› fallbackï¼ŒæŠ›å¼ƒé”™è¯¯çš„å€¼ï¼Œåªæœ‰åœ¨å­˜åœ¨é€‚å½“åå¤‡å€¼çš„æƒ…å†µä¸‹æ‰å¯ä»¥ä½¿ç”¨è¿™ä¸ªæ–¹æ³• result.unwrap_or(fallback) // 5. è¿”å›æˆåŠŸçš„å€¼ï¼Œå¦åˆ™è¿”å› fallback_fnï¼Œè¿™é‡Œå¯ä»¥æ˜¯ä¸€ä¸ªå‡½æ•°æˆ–è€…é—­åŒ…ï¼Œè¿™ä¸ªæ–¹æ³•é€‚åˆè®¡ç®— // åå¤‡å€¼å¦‚æœç”¨ä¸ä¸Šä¼šæµªè´¹çš„æƒ…å†µã€‚åªæœ‰åœ¨è¿”å›é”™è¯¯ç»“æœæ—¶æ‰ä¼šè°ƒç”¨ fallback_fn result.unwrap_or_else(fallback_fn) // 6. è¿”å›æˆåŠŸçš„å€¼ï¼Œå¦åˆ™å°± panic result.unwrap() result.expect(message) // panic æ—¶æ‰“å°ä¿¡æ¯ // 7. å°† Result\u0026lt;T, E\u0026gt; è½¬æ¢ä¸º Result\u0026lt;\u0026amp;T, \u0026amp;E\u0026gt;ï¼Œè¿™å¯¹äºè¿˜è¦ç”¨åŸæ¥çš„ result çš„å€¼å¾ˆæœ‰ç”¨ result.as_ref() // 8. å°† Result\u0026lt;T, E\u0026gt; è½¬æ¢ä¸º Result\u0026lt;\u0026amp;mut T, \u0026amp;mut E\u0026gt; result.as_mut() Result Type Aliases åœ¨æ ‡å‡†åº“ std::io æ¨¡å—ä¸­æœ‰ï¼š\n1 pub type Result\u0026lt;T\u0026gt; = result::Result\u0026lt;T, Error\u0026gt;; è¿™é‡Œç”¨äº† type aliasesã€‚\nPrinting Errors std::io::Errorã€std::fmt::Errorã€std::str::Utf8Errorç­‰ç­‰å®ç°äº†std::error::Error traitã€‚ä¸€äº›å…¬ç”¨çš„æ–¹æ³•ï¼š\nprintln!()\næ‰“å°é”™è¯¯ï¼Œç”¨{}å¯ä»¥æ‰“å°ç®€çŸ­çš„é”™è¯¯ä¿¡æ¯ï¼Œç”¨{:?}çš„Debugæ¨¡å¼æ‰“å°å‡ºé”™è¯¯ã€‚\nerr.to_string()\nè¿”å›é”™è¯¯ä¿¡æ¯å­—ç¬¦ä¸²ã€‚\nerr.source()\nè¿”å›ä¸€ä¸ªOptionï¼ŒåŒ…å«æ½œåœ¨çš„é”™è¯¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use std::error::Error; use std::io::{Write, stderr}; /// Dump an error message to `stderr`. /// /// If another error happens while building the error message or /// writing to `stderr`, it is ignored. fn print_error(mut err: \u0026amp;dyn Error) { let _ = writeln!(stderr(), \u0026#34;error: {}\u0026#34;, err); while let Some(source) = err.source() { let _ = writeln!(stderr(), \u0026#34;caused by: {}\u0026#34;, source); err = source; } } æƒ³è¦å±•å¼€é”™è¯¯ï¼Œåœ¨Rustä¸ç¨³å®šç‰ˆæœ¬ä¸‹ï¼Œå¯ä»¥ä½¿ç”¨anyhowåŒ…ã€‚\nPropagating Errors å¦‚æœé”™è¯¯å‘ç”Ÿï¼Œæˆ‘ä»¬å¸Œæœ›è°ƒç”¨è€…æ¥å¤„ç†ã€‚\n1 2 let weather = get_weather(hometown)?; let weather = try!(get_weather(hometown)); ?æ“ä½œç¬¦çš„è¡Œä¸ºå–å†³äºè¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼š\nå¦‚æœæ˜¯æˆåŠŸç»“æœï¼Œé‚£ä¹ˆå®ƒä¼šæ‰“å¼€Resultå¹¶å–å‡ºå…¶ä¸­çš„æˆåŠŸå€¼ã€‚ å¦‚æœæ˜¯é”™è¯¯ç»“æœï¼Œé‚£ä¹ˆå®ƒä¼šç«‹å³ä»é—­åˆå‡½æ•°ä¸­è¿”å›ï¼Œå°†é”™è¯¯ç»“æœæ²¿è°ƒç”¨é“¾å‘ä¸Šä¼ æ’­ã€‚ ?æ“ä½œç¬¦ä¸€æ ·å¯ä»¥ä½¿ç”¨matchè¡¨è¾¾å¼å®ç°ã€‚\n?å¯ä»¥ç±»ä¼¼åœ°ç”¨åœ¨Optionç±»å‹çš„å€¼ä¸Šé¢ã€‚In a function that returns Option, you can use ? to unwrap a value and return early in the case of None.\nWorking with Multiple Error Types ?ä¸èƒ½å°†std::num::ParseIntErrorè½¬æ¢ä¸ºstd::io::Errorç±»å‹ã€‚ æ‰€æœ‰æ ‡å‡†åº“ä¸­çš„é”™è¯¯éƒ½å¯ä»¥è½¬æˆBox\u0026lt;dyn std::error::Error + Send + Sync + 'static'\u0026gt;ç±»å‹ã€‚ 1 2 type GenericError = Box\u0026lt;dyn std::error::Error + Send + Sync + \u0026#39;static\u0026gt;; type GenericResult = Result\u0026lt;T, GenericError\u0026gt;; ?ä¼šè°ƒç”¨GenericError::from()æ–¹æ³•æ¥è¿›è¡Œè‡ªåŠ¨è½¬æ¢ã€‚\nå¦‚æœæƒ³è¦å…¶ä¸­ä¸€ç§ç‰¹åˆ«çš„é”™è¯¯ç±»å‹è¿›è¡Œå¤„ç†ï¼Œå…¶å®ƒçš„é”™è¯¯è¿›è¡Œä¼ æ’­çš„è¯ï¼Œå¯ä»¥ç”¨æ³›å‹æ–¹æ³•error.downcast_ref::\u0026lt;ErrorType\u0026gt;() Dealing with Errors That \u0026ldquo;Can\u0026rsquo;t Happen\u0026rdquo; å½“æˆ‘ä»¬ä¸æƒ³å¤„ç†ä¸ä¼šå‘ç”Ÿçš„é”™è¯¯æ—¶ï¼Œç”¨.unwrap()æ–¹æ³•ã€‚ ä¹Ÿå¯ä»¥ç”¨.expect(message)æ–¹æ³•ã€‚ Ingoring Errors 1 let _ = writeln!(stderr(), \u0026#34;error: {}\u0026#34;, err); ç”¨ let _ = ...ç”¨æ¥ç¦æ­¢è­¦å‘Šã€‚\nHandling Errors in main() ä¸€èˆ¬æƒ…å†µä¸‹åœ¨ main å‡½æ•°ä¸­ä¸èƒ½ç”¨ ? ï¼Œå› ä¸º main() å‡½æ•°çš„è¿”å›ç±»å‹ä¸æ˜¯ Resultã€‚ æœ€ç®€å•çš„æ–¹æ³•æ˜¯ç”¨ .expect()æ–¹æ³•ã€‚å‘ç”Ÿé”™è¯¯æ—¶ä¼š panic å¹¶ä¸”è¿”å›ä¸€ä¸ªéé›¶çš„é€€å‡ºä»£ç ã€‚ æˆ–è€…å¯ä»¥è¿”å›ä¸€ä¸ª Result ç±»å‹ï¼Œè¿™æ ·å°±èƒ½ç”¨?ï¼ŒåŒæ—¶ç”¨debug {:?}æ–¹å¼æ‰“å°å‡ºé”™è¯¯ã€‚ 1 fn main() -\u0026gt; Result\u0026lt;(), TideCalcError\u0026gt; { } æˆ–è€…è‡ªå·±å¤„ç†ç›¸åº”çš„é”™è¯¯ã€‚ç”¨print_error()æ–¹æ³•ç»“åˆif let æ‰“å°ç®€ä»‹çš„é”™è¯¯ä¿¡æ¯ã€‚ Declaring a Custom Error Type å¯ä»¥è‡ªå®šä¹‰Errorç±»å‹ï¼Œç”¨ struct å®ç°ã€‚Errors åº”è¯¥å®ç°fmt::Displayå’Œ std::error::Error traitã€‚ æˆ–è€…ç›´æ¥ç”¨thiserror ä¸­çš„ï¼ŒåŠ ä¸Šå±æ€§å®#[derive(Error)]ã€‚ 1 2 3 4 5 6 7 8 use thiserror::Error; #[derive(Error, Debug)] #[error(\u0026#34;{message:} ({line:}, {column})\u0026#34;)] pub struct JsonError { message: String, line: usize, column: usize, } Why Results? åœ¨ä»£ç ä¸­è®°å½•é”™è¯¯ï¼Œå¯¹é”™è¯¯åšå‡ºå†³å®šã€‚ å…è®¸é”™è¯¯ä¼ æ’­ï¼Œä¼ æ’­è·¯å¾„å¯è§ã€‚ æ¯ä¸€ä¸ªå‡½æ•°éƒ½æœ‰è¿”å›ç±»å‹ï¼Œè¿™æ ·æ›´æ¸…æ¥šå‡½æ•°å¯ä¸å¯èƒ½å¤±è´¥ã€‚ Rust ä¼šæ£€æŸ¥ Result ç±»å‹çš„å€¼æ˜¯å¦è¢«ä½¿ç”¨ã€‚ å› ä¸º Result æ˜¯ä¸€ä¸ªæ•°æ®ç±»å‹ï¼Œå› æ­¤æ›´å®¹æ˜“å¤„ç†ä¸€ç³»åˆ—æˆåŠŸæˆ–è€…å¤±è´¥çš„å€¼ï¼Œä¹Ÿæ›´å®¹æ˜“å­˜å‚¨ã€‚ Chapter 8. Crates and Modules Crates Rust programs are made of crates. Each crate is a complete, cohesive unit: all the source code for a single library or executable, plus any associated tests, examples, tools, configuration, and other junk.\nè¦äº†è§£åŒ…æ˜¯ä»€ä¹ˆï¼Œä»¥åŠå®ƒä»¬å¦‚ä½•åä½œï¼Œå¯ä»¥å¯¹ä¸€ä¸ªä½¿ç”¨äº†ä¾èµ–çš„å·²æœ‰é¡¹ç›®è¿è¡Œ cargo build å‘½ä»¤ï¼ŒåŒæ—¶åŠ ä¸Š --verbose æ ‡è®°ã€‚\nCargo çš„ä¾èµ–ä¼šå½¢æˆ dependency graph ã€‚\nCargo ä¼šä½¿ç”¨ --crate-type libé€‰é¡¹ï¼Œä¼šå‘Šè¯‰ rustc ä¸è¦å»æ‰¾ main() å‡½æ•°ï¼Œè€Œæ˜¯ç”Ÿæˆä¸€ä¸ª .rlib æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«ç¼–è¯‘åçš„ä»£ç ï¼Œå¯ä»¥ä¾›ä»¥ååœ¨åˆ›å»ºåº“æˆ–è€….rlibæ–‡ä»¶ä½¿ç”¨ã€‚\nWhen compiling libraries, Cargo uses the \u0026ndash; crate-type lib option. This tells rustc not to look for a main() function but instead to produce an .rlib file containing compiled code that can be used to create binaries and other .rlib files.\nCargoä½¿ç”¨ --crate-type bin é€‰é¡¹ï¼Œç¼–è¯‘ç»“æœå°†æ˜¯ä¸€ä¸ªé’ˆå¯¹ç›®æ ‡å¹³å°çš„äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ã€‚\nè¿è¡Œæ¯ä¸ª rustc å‘½ä»¤æ—¶ï¼ŒCargoä¼šé€šè¿‡--externé€‰é¡¹ç»™å‡ºå½“å‰åŒ…ç”¨åˆ°çš„æ¯ä¸ªåº“çš„æ–‡ä»¶åã€‚è¿™æ ·ï¼Œå½“rustcçœ‹åˆ°use image::png::PNGEncoderè¿™è¡Œä»£ç æ—¶ï¼Œå®ƒå°±çŸ¥é“åˆ°ç£ç›˜çš„ä»€ä¹ˆä½ç½®å»æ‰¾è¿™ä¸ªåº“ç¼–ç åçš„ä»£ç äº†ã€‚Rustç¼–è¯‘å™¨éœ€è¦è®¿é—®.rlibæ–‡ä»¶ï¼Œå› ä¸ºå…¶ä¸­åŒ…å«ç¬¬ä¸‰æ–¹åº“ç¼–è¯‘åçš„ä»£ç ã€‚Rustä¼šå°†è¿™äº›ä»£ç é™æ€é“¾æ¥åˆ°æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸Šã€‚.rlibæ–‡ä»¶ä¹ŸåŒ…å«ç±»å‹ä¿¡æ¯ï¼ŒRustå¯ä»¥æ®æ­¤æ£€æŸ¥æˆ‘ä»¬ä»£ç ä¸­ç”¨åˆ°çš„åº“ç‰¹æ€§ç¡®å®åœ¨å¯¹åº”çš„åŒ…é‡Œå­˜åœ¨ï¼Œä»è€Œä¿è¯æ­£ç¡®åœ°ä½¿ç”¨å®ƒä»¬ã€‚è¿™ä¸ªæ–‡ä»¶é‡Œè¿˜åŒ…å«åŒ…çš„å…¬å…±å†…è”å‡½æ•°ã€æ³›å‹å’Œå®çš„ä¸€ä¸ªå‰¯æœ¬ï¼Œè¿™äº›ç‰¹æ€§ç›´åˆ°Rusté‡åˆ°è°ƒç”¨å®ƒä»¬çš„ä»£ç æ—¶æ‰ä¼šç¼–è¯‘ä¸ºæœºå™¨ç ã€‚\ncargo build --releaseäº§ç”Ÿä¼˜åŒ–ä»£ç ï¼Œä¼˜åŒ–ä»£ç çš„è¿è¡Œé€Ÿåº¦æ›´å¿«ï¼Œä½†ç¼–è¯‘æ—¶é—´æ¯”è¾ƒé•¿ï¼Œè€Œä¸”ä¸ä¼šæ£€æŸ¥æ•´å‹æº¢å‡ºï¼Œè¿˜ä¼šè·³è¿‡debug_assert!()æ–­è¨€ï¼Œå¦å¤–å®ƒä»¬é’ˆå¯¹ panic ç”Ÿæˆçš„æ ˆè¿½è¸ªä¿¡æ¯ä¸€èˆ¬ä¸å¤ªå¯é ã€‚\nEditions To evolve without breaking existing code, Rust uses editions. The 2015 edition of Rust is compatible with Rust 1.0. The 2018 edition changed async and await into keywords, streamlined the module system, and introduced various other language changes that are incompatible with the 2015 edition.\nRust promises that the compiler will always accept all extant editions of the language, and programs can freely mix crates written in different editions. Itâ€™s even fine for a 2015 edition crate to depend on a 2018 edition crate. In other words, a crateâ€™s edition only affects how its source code is construed; edition distinctions are gone by the time the code has been compiled. This means thereâ€™s no pressure to update old crates just to continue to participate in the modern Rust ecosystem. Similarly, thereâ€™s no pressure to keep your crate on an older edition to avoid inconveniencing its users. You only need to change editions when you want to use new language features in your own code.\nIf you have a crate written in an older edition of Rust, the cargo fix command may be able to help you automatically upgrade your code to the newer edition. The Rust Edition Guide explains the cargo fix command in detail.\nBuild Profiles æ„å»ºåˆ†æ\nå‘½ä»¤è¡Œ Cargo.tomlä½¿ç”¨çš„åŒºå— cargo build [profile.dev] cargo build \u0026ndash;realse [profile.realse] cargo test [profile.test] æƒ³è¦åŒæ—¶å¯ç”¨ä¼˜åŒ–å’Œè°ƒè¯•ï¼Œå¯ä»¥è¿™æ ·è®¾ç½®ï¼š\n1 2 [profile.realse] debug = true # åœ¨å‘å¸ƒæ„å»ºä¸­å¯ç”¨è°ƒè¯•æ ‡è®° è¿™é‡Œdebugè®¾ç½®æ§åˆ¶ rustc ä¸­çš„ -g é€‰é¡¹ã€‚æœ‰äº†è¿™ä¸ªé…ç½®ï¼Œå†æ‰§è¡Œ cargo build --realseï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªå¸¦æœ‰è°ƒè¯•ç¬¦å·çš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚ä¼˜åŒ–è®¾ç½®ä¸å—å½±å“ã€‚\nModules 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 mod spores { use cells::{Cell, Gene}; /// A cell made by an adult fern. It disperses on the wind as part of /// the fern life cycle. A spore grows into a prothallus -- a whole /// separate organism, up to 5mm across -- which produces the zygote /// that grows into a new fern. (Plant sex is complicated.) pub struct Spore { ... } /// Simulate the production of a spore by meiosis. pub fn produce_spore(factory: \u0026amp;mut Sporangium) -\u0026gt; Spore { ... } /// Extract the genes in a particular spore. pub(crate) fn genes(spore: \u0026amp;Spore) -\u0026gt; Vec\u0026lt;Gene\u0026gt; { ... } /// Mix genes to prepare for meiosis (part of interphase). fn recombine(parent: \u0026amp;mut Cell) { ... } ... } One function is marked pub(crate), meaning that it is available anywhere inside this crate, but isnâ€™t exposed as part of the external interface. It canâ€™t be used by other crates, and it wonâ€™t show up in this crateâ€™s documentation.\nAnything that isnâ€™t marked pub is private and can only be used in the same module in which it is defined, or any child modules.\nNested Modules modå¯ä»¥åµŒå¥—ã€‚\nItâ€™s also possible to specifypub(super), making an item visible to the parent module only, and pub(in \u0026lt;path\u0026gt;), which makes it visible in a specific parent module and its descendants.\nModules in Separate Files These three optionsâ€”modules in their own file, modules in their own directory with a mod.rs, and modules in their own file with a supplementary directory containing submodulesâ€”give the module system enough flexibility to support almost any project structure you might desire.\nPaths and Imports ç”¨::æ“ä½œç¬¦ã€‚\n1 2 3 if s1 \u0026gt; s2 { std::mem::swap(\u0026amp;mut s1, \u0026amp;mut s2); } æˆ–è€…ç”¨useå¯¼å…¥ã€‚\n1 2 3 4 5 use std::mem; if s1 \u0026gt; s2 { mem::swap(\u0026amp;mut s1, \u0026amp;mut s2); } ä¸€æ¬¡å¯¼å…¥å¤šä¸ªæ¨¡å—ï¼š\n1 2 3 use std::collections::{HashMap, HashSet}; // import both use std::fs::{self, File}; // import both `std::fs` and `std::fs::File`. use std::io::prelude::*; // import everything å¯¼å…¥æ—¶èµ·åˆ«å\n1 2 3 4 5 use std::io::Result as IOResult; // This return type is just another way to write `std::io::Result\u0026lt;()\u0026gt;`: fn save_spore(spore: \u0026amp;Spore) -\u0026gt; IOResult\u0026lt;()\u0026gt; ... æ¨¡å—ä¸ä¼šè‡ªåŠ¨ä»è‡ªå·±çš„çˆ¶æ¨¡å—ç»§æ‰¿åå­—ã€‚å…³é”®å­—superæ˜¯çˆ¶æ¨¡å—çš„ä¸€ä¸ªåˆ«åï¼Œselfåˆ™æ˜¯å½“å‰æ¨¡å—çš„ä¸€ä¸ªåˆ«åï¼Œå…³é”®è¯ crate è¡¨ç¤ºåŒ…å«å½“å‰æ¨¡å—çš„åŒ…ã€‚\n1 2 3 4 5 // proteins/synthesis.rs use crate::proteins::AminoAcid; // explicitly import relative to crate root pub fn synthesize(seq: \u0026amp;[AminoAcid]) // ok ... ä½¿ç”¨ç›¸å¯¹äºæ ¹çš„è·¯å¾„ï¼Œè¿™æ ·å½“æ¨¡å—ç§»åŠ¨æ—¶ï¼Œä¹Ÿæ˜¯æœ‰æ•ˆçš„ã€‚\nuse super::*å¯ä»¥è®©å­æ¨¡å—è·å¾—çˆ¶æ¨¡å—çš„ç§æœ‰é¡¹ã€‚\nç»å¯¹è·¯å¾„ï¼š\n1 2 3 4 // å¤–éƒ¨ crate use ::image::Pixels; // the `image` crate\u0026#39;s `Pixels` // è‡ªå·±å®šä¹‰çš„æ¨¡å— use self::image::Sampler; // the `image` module\u0026#39;s `Sampler` The Standard Prelude Furthermore, a few particularly handy names, like Vec and Result, are included in the standard prelude and automatically imported. Rust behaves as though every module, including the root module, started with the following import:\n1 use std::prelude::v1::*; The standard prelude contains a few dozen commonly used traits and types.\nå‚è€ƒstd::preludeã€‚\nMaking use Declarations pub 1 2 3 4 // in plant_structures/mod.rs ... pub use self::leaves::Leaf; pub use self::roots::Root; This means that Leaf and Root are public items of the plant_structures module. They are still simple aliases for plant_structures::leaves::Leaf and plant_structures::roots::Root.\nMaking Struct Fields pub 1 2 3 4 pub struct Fern { pub roots: RootSet, pub stems: StemSet } Outside the module, only public fields are accessible.\nStatics and Constants 1 2 pub const ROOM_TEMPERATURE: f64 = 20.0; // degrees Celsius pub static ROOM_TEMPERATURE: f64 = 68.0; // degrees Fahrenheit A constant is a bit like a C++ #define: the value is compiled into your code every place itâ€™s used. A static is a variable thatâ€™s set up before your program starts running and lasts until it exits. Use constants for magic numbers and strings in your code. Use statics for larger amounts of data, or any time you need to borrow a reference to the constant value.\nThere are no mut constants.\nTurning a Program into a Library The first step is to factor your existing project into two parts: a library crate, which contains all the shared code, and an executable, which contains the code thatâ€™s only needed for your existing command-line program.\nBy default, cargo build looks at the files in our source directory and figures out what to build. When it sees the file src/lib.rs, it knows to build a library. The code in src/lib.rs forms the root module of the library. Other crates that use our library can only access the public items of this root module.\nThe src/bin Directory We can keep our program and our library in the same crate, too. Put this code into a file named src/bin/efern.rs:\n1 2 3 4 5 6 7 8 9 use fern_sim::{Fern, run_simulation}; fn main() { let mut fern = Fern { size: 1.0, growth_rate: 0.001 }; run_simulation(\u0026amp;mut fern, 1000); println!(\u0026#34;final fern size: {}\u0026#34;, fern.size); } Because weâ€™ve put this file into src/bin, Cargo will compile both the fern_sim library and this program the next time we run cargo build. We can run the efern program using cargo run \u0026ndash;bin efern. Hereâ€™s what it looks like, using \u0026ndash;verbose to show the commands Cargo is running.\n1 2 [dependencies] fern_sim = { path = \u0026#34;../fern_sim\u0026#34; } å¯ä»¥å°† fern_sim ä½œä¸ºä¸€ä¸ªå•ç‹¬çš„é¡¹ç›®ï¼Œç„¶ååœ¨ Cargo.toml ä¸ŠåŠ ä¸Šä¾èµ–ã€‚\nAttributes Rustç¨‹åºä¸­çš„ä»»ä½• item éƒ½å¯ä»¥ç”¨å±æ€§æ¥ä¿®é¥°ã€‚\n#[allow(non_camel_case_types)] å¯ä»¥ä¸ä½¿ç”¨é©¼å³°å‘½åæ³•ã€‚ #[cfg] æ¡ä»¶ç¼–è¯‘ #[inline] å†…è”å‡½æ•°ã€‚å½“å‡ºç°ä¸€ä¸ªå‡½æ•°æˆ–è€…ä¸€ä¸ªæ–¹æ³•å®šä¹‰åœ¨ä¸€ä¸ª crate ä¸­ï¼Œè€Œæˆ‘ä»¬åœ¨å¦ä¸€ä¸ª crate ä¸­å»è°ƒç”¨ï¼Œå¯ä»¥æ˜¾å¼ä½¿ç”¨è¿™ä¸ªå±æ€§ã€‚ #[inline(always)] è¦æ±‚å‡½æ•°åœ¨æ¯ä¸€æ¬¡è°ƒç”¨çš„ç‚¹éƒ½å±•å¼€å†…è” #[inline(never)] è¦æ±‚ä¸€ä¸ªå‡½æ•°ä»ä¸è¿›è¡Œå†…è” #[cfg]å’Œ#[allow]å¯ä»¥ç”¨åœ¨ä¸€æ•´ä¸ªæ¨¡å—æˆ–è€…é‡Œé¢çš„ä»»ä½•ä¸œè¥¿ï¼Œä½†æ˜¯ #[inline] å’Œ #[test]åªèƒ½ç”¨åœ¨å•ä¸ªé¡¹ä¸Šé¢ã€‚ æƒ³åœ¨æ•´ä¸ª crate ä¸Šé¢ç»‘å®šå±æ€§ï¼Œåœ¨main.rsæˆ–è€…lib.rsæ–‡ä»¶é¡¶éƒ¨ä¸­ç”¨#!ã€‚#!ä¹Ÿå¯ä»¥ç”¨åœ¨å‡½æ•°ï¼Œç»“æ„ä½“ä¸­ï¼Œä½†æ˜¯å®ƒåªèƒ½ä¸€è´¯åœ°ç”¨åœ¨æ–‡ä»¶çš„å¼€å¤´ï¼Œæ¥ç»‘å®šç»™æ•´ä¸ªæ¨¡å—æˆ–è€… crate ç»‘å®šä¸€ä¸ªå±æ€§ã€‚è€Œæœ‰çš„å±æ€§æ€»æ˜¯ç”¨ #!ï¼Œå› ä¸ºå®ƒåªèƒ½ä½œç”¨åœ¨æ•´ä¸ª crate ä¸Šï¼Œæ¯”å¦‚ #![feature]ã€‚ #![feature] ç”¨æ¥è¡¨ç¤º Rust è¯­è¨€ä¸ç¨³å®šçš„ featuresï¼Œè¿™äº›æ˜¯å®éªŒæ€§è´¨çš„ã€‚å½“åé¢è¿™ä¸ª feature ç¨³å®šä¹‹åï¼Œç¼–è¯‘å™¨å°±ä¼šè­¦å‘Šï¼Œå»ºè®®ç§»é™¤ #![feature]ã€‚ Tests and Documention #[test] æ ‡è®°å‡½æ•°ï¼Œè¡¨æ˜è¿™ä¸ªæ˜¯æµ‹è¯•å‡½æ•°ï¼Œç”¨cargo test å¯ä»¥æµ‹è¯•æ‰€æœ‰æµ‹è¯•å‡½æ•°ï¼Œå¦‚æœåªæƒ³æµ‹è¯•æŸä¸€ä¸ªï¼Œå¯ä»¥ç”¨cargo test nameæ¥æµ‹è¯•å…·ä½“çš„å‡½æ•°ã€‚ assert!(expr)ï¼šå¦‚æœè¡¨è¾¾å¼ä¸ºçœŸå°±é€šè¿‡æµ‹è¯•ï¼Œå¦åˆ™ panicã€‚ assert_eq!(v1, v2)ï¼šåˆ¤åˆ« v1 å’Œ v2 æ˜¯å¦ç›¸ç­‰ã€‚ å¦‚æœåªæƒ³åœ¨ debug æ¨¡å¼ä¸‹æ£€éªŒæ˜¯å¦ç›¸ç­‰ï¼Œå¯ä»¥ç”¨ debug_assert! å’Œ debug_assert_eq!ã€‚ #[should_panic] è¡¨ç¤ºä¼š panicã€‚æˆ–è€…è¿”å›Result\u0026lt;(), E\u0026gt;ã€‚ cargo buildå’Œcargo build --realseä¼šè·³è¿‡#[test]æµ‹è¯•ä»£ç ã€‚ å½“è¿è¡Œ cargo test ï¼Œcargo ä¼šç¼–è¯‘ä¸¤æ¬¡ä»£ç ã€‚ä¸€æ¬¡æ˜¯å¸¸è§„çš„ï¼Œè¿˜æœ‰ä¸€æ¬¡æ˜¯æµ‹è¯•ç¨‹åºå¹¶å¯ç”¨æµ‹è¯•å¥—ä»¶ã€‚ #[cfg(test)]æ ‡è®°æ•´ä¸ªæ¨¡å—ã€‚ ä¸€èˆ¬ cargo test ä¼šå¯ç”¨å¤šçº¿ç¨‹æ¥ä¸€æ¬¡è¿è¡Œå¤šä¸ªæµ‹è¯•ï¼Œç”¨ cargo test name å’Œ cargo test -- --test-threads 1æ¥é™åˆ¶åªç”¨ä¸€ä¸ªçº¿ç¨‹æµ‹è¯•ã€‚ cargo test -- --no-captureï¼šä¹Ÿè¾“å‡ºé‚£äº›é€šè¿‡çš„æµ‹è¯•ã€‚ Integration Tests é›†æˆæµ‹è¯•ï¼Œå¯ä»¥ç”¨æ¥æµ‹è¯•ä¸€äº›å…¬å…±çš„APIï¼Œç«™åœ¨ç”¨æˆ·çš„è§’åº¦ã€‚ å•ç‹¬å»ºç«‹ä¸€ä¸ª testsçš„æ–‡ä»¶å¤¹ï¼Œæ”¾åœ¨å’Œ src åŒä¸€ä¸ªè·¯å¾„ä¸‹ï¼Œå½“è¿è¡Œ cargo test çš„æ—¶å€™ï¼Œé›†æˆæµ‹è¯•å’Œå•å…ƒæµ‹è¯•éƒ½ä¼šè¿è¡Œã€‚å¦‚æœåªæƒ³è¿è¡Œé›†æˆæµ‹è¯•ï¼Œå¯ä»¥ç”¨å‘½ä»¤cargo test --test unfurlæ¥è¿è¡Œä¸€ä¸ªå…·ä½“çš„é›†æˆæµ‹è¯•ã€‚ Documentation 1 cargo doc --no-deps --open \u0026ndash;no-deps ï¼šåªç”Ÿæˆè‡ªå·±çš„æ–‡æ¡£ï¼Œä¸ç”Ÿæˆæ‰€æœ‰å®ƒä¾èµ–çš„ cratesã€‚ \u0026ndash;openï¼šåœ¨æµè§ˆå™¨ä¸­æ‰“å¼€æ–‡æ¡£ã€‚ ç”Ÿæˆçš„æ–‡æ¡£æ”¾åœ¨ target/doc ç›®å½•ä¸‹ã€‚ ///çš„æ–‡æ¡£æ³¨é‡Šç±»ä¼¼#[doc]å±æ€§ã€‚è€Œ//!å’Œ#![doc]ä¸€æ ·ã€‚ æ–‡æ¡£æ³¨é‡Šä¸­markdown çš„é“¾æ¥ä¹Ÿå¯ä»¥é“¾æ¥åˆ°ç›¸åº”ä»£ç çš„æ–‡æ¡£ã€‚ One special feature of doc comments in Rust is that Markdown links can use Rust item paths, like leaves::Leaf, instead of relative URLs, to indicate what they refer to. 1 2 3 4 5 6 7 /// Create and return a [`VascularPath`] which represents the path of /// nutrients from the given [`Root`][r] to the given [`Leaf`](leaves::Leaf). /// /// [r]: roots::Root pub fn trace_path(leaf: \u0026amp;leaves::Leaf, root: \u0026amp;roots::Root) -\u0026gt; VascularPath { ... } You can also add search aliases to make it easier to find things using the built-in search feature.\n1 2 3 4 #[doc(alias = \u0026#34;route\u0026#34;)] pub struct VascularPath { ... } æ–‡æ¡£ä¸­çš„ä»£ç ï¼š\n1 2 3 4 5 /// A block of code in a doc comment: /// ////\tif samples::everything().works() { ////\tprintln!(\u0026#34;ok\u0026#34;); ////\t} æˆ–è€…ç”¨Markdownæ ¼å¼ï¼š\n1 2 3 4 5 6 7 /// Another snippet, the same code, but written differently: /// /// ``` /// if samples::everything().works() { /// println!(\u0026#34;ok\u0026#34;); /// } /// ``` Doc-Tests Rust ä¹Ÿä¼šæµ‹è¯•åœ¨æ–‡æ¡£æ³¨é‡Šä¸­çš„ä»£ç ï¼Œä¼šéšå¼çš„åŠ åœ¨ fn main() å‡½æ•°é‡Œé¢ã€‚ The idea behind doc-tests is not to put all your tests into comments. Rather, you write the best possible documentation, and Rust makes sure the code samples in your documentation actually compile and run. To hide a line of a code sample, put a # followed by a space at the beginning of that line. rustdoc therefore treats any code block containing the exact string fn main as a complete program and doesnâ€™t add anything to it. To tell Rust to compile your example, but stop short of actually running it, use a fenced code block with the no_run annotation. If the code isnâ€™t even expected to compile, use ignore instead of no_run. Blocks marked with ignore donâ€™t show up in the output of cargo run, but no_run tests show up as having passed if they compile. If the code block isnâ€™t Rust code at all, use the name of the language, like c++ or sh, or text for plain text. Specifying Dependencies ç”¨ç‰ˆæœ¬å·ï¼š\n1 image = \u0026#34;0.6.1\u0026#34; Gitä»“åº“åœ°å€å’Œä¿®è®¢ç‰ˆæœ¬å·ï¼š\n1 image = { git = \u0026#34;https://github.com/Piston/image.git\u0026#34;, rev = \u0026#34;528f19c\u0026#34; } å¯ä»¥æŒ‡å®šä½¿ç”¨å“ªä¸ª revã€tag æˆ– branchã€‚\nå¦ä¸€ç§æ–¹å¼æ˜¯æŒ‡å®šåŒ…å«ä¾èµ–åŒ…æºä»£ç çš„ç›®å½•ï¼š\n1 image = { path = \u0026#34;vendor/image\u0026#34; } Versions å¯¹äºåœ¨ Cargo.toml ä¸­å†™çš„ image = \u0026quot;0.6.1\u0026quot; ï¼ŒCargo çš„è§£é‡Šå¹¶æ²¡æœ‰é‚£ä¹ˆä¸¥æ ¼ã€‚å®ƒä¼šä½¿ç”¨ä¸ 0.6.1 ç‰ˆå…¼å®¹çš„æœ€æ–°ç‰ˆæœ¬çš„ image ã€‚\nå…¼å®¹æ€§çš„åˆ¤æ–­åŸºæœ¬ä¸Šéµå¾ªâ€œè¯­ä¹‰åŒ–ç‰ˆæœ¬â€çš„æ€æƒ³ã€‚\nä»¥0.0å¼€å¤´çš„ç‰ˆæœ¬è¿‡äºåŸå§‹ï¼ŒCargoä¸ä¼šå‡è®¾å®ƒä¸ä»»ä½•å…¶ä»–ç‰ˆæœ¬å…¼å®¹ã€‚ ä»¥0.xï¼ˆåŸºæœ¬xä¸æ˜¯0ï¼‰å¼€å¤´çš„ç‰ˆæœ¬ï¼Œä¼šè¢«è®¤ä¸ºåŒå…¶ä»–ä»¥0.xå¼€å¤´çš„ç‰ˆæœ¬å…¼å®¹ã€‚ å¦‚æœé¡¹ç›®è¾¾åˆ°1.0ç‰ˆï¼Œåˆ™åªæœ‰æ–°çš„ä¸»ç‰ˆæœ¬å·æ‰ä¼šç ´åå…¼å®¹æ€§ã€‚ ä¸åŒé¡¹ç›®å¯¹ä¾èµ–å’Œç‰ˆæœ¬æœ‰ä¸åŒçš„éœ€æ±‚ã€‚å› æ­¤ï¼ŒæŒ‡å®šç‰ˆæœ¬æ—¶å¯ä»¥ä½¿ç”¨æ“ä½œç¬¦ã€‚ä¾‹å¦‚\u0026gt;ã€\u0026gt;=ã€\u0026lt;=ã€‚\nä½¿ç”¨é€šé…ç¬¦*è¡¨ç¤ºä»»ä½•ç‰ˆæœ¬éƒ½å¯ä»¥ï¼Œè¿™ä¸ªå¹¶ä¸å¤šè§ã€‚\nCargo.lock åœ¨ç¬¬ä¸€æ¬¡æ„å»ºé¡¹ç›®æ—¶ï¼ŒCargoä¼šè¾“å‡ºä¸€ä¸ªCargo.lockæ–‡ä»¶ï¼Œè®°å½•å®ƒä½¿ç”¨çš„æ¯ä¸ªåŒ…çš„ç¡®åˆ‡çš„ç‰ˆæœ¬å·ã€‚å¦‚æœæ‰‹åŠ¨ä¿®æ”¹äº†Cargo.tomlæ–‡ä»¶ä¸­çš„ç‰ˆæœ¬å·æˆ–è€…è¿è¡Œcargo updateæ—¶ï¼Œä¼šæŠŠæ–°ç‰ˆæœ¬å·ä¿å­˜åˆ°Cargo.lockæ–‡ä»¶ä¸­ã€‚\nå¯¹äºä¿å­˜åœ¨Gitä»£ç åº“çš„ä¾èµ–ä¹Ÿæ˜¯ç±»ä¼¼çš„ã€‚\nå¦‚æœä½ çš„é¡¹ç›®æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œåº”è¯¥æŠŠCargo.lockæäº¤åˆ°ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿã€‚å¦‚æœæ˜¯ä¸€ä¸ªæ™®é€šçš„Ruståº“ï¼Œå°±ä¸ç”¨æäº¤Cargo.lockäº†ã€‚å¦‚æœæ°å¥½ä½ çš„é¡¹ç›®æ˜¯ä¸€ä¸ªå…±äº«åº“ï¼Œæ²¡æœ‰è¿™ç§ä¸‹æ¸¸çš„cargoç”¨æˆ·ï¼Œé‚£å°±åº”è¯¥æä¾›Cargo.lockã€‚\nPublishing Crates to crates.io cargo package è®©Cargoæ‰“åŒ…ã€‚ä¼šåˆ›å»ºä¸€ä¸ª.crateæ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«åº“çš„æºæ–‡ä»¶ä»¥åŠCargo.tomlã€‚\ncargo package --listå¯ä»¥æŸ¥çœ‹å…¶ä¸­åŒ…å«ä»€ä¹ˆæ–‡ä»¶ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 [package] name = \u0026#34;fern_sim\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2018\u0026#34; authors = [\u0026#34;You \u0026lt;you@example.com\u0026gt;\u0026#34;] license = \u0026#34;MIT\u0026#34; homepage = \u0026#34;https://fernsim.example.com/\u0026#34; repository = \u0026#34;https://gitlair.com/sporeador/fern_sim\u0026#34; documentation = \u0026#34;http://fernsim.example.com/docs\u0026#34; description = \u0026#34;\u0026#34;\u0026#34; Fern simulation, from the cellular level up. \u0026#34;\u0026#34;\u0026#34; å¯ä»¥åŒæ—¶æŒ‡å®šæœ¬åœ°ä¾èµ–å’Œç‰ˆæœ¬å·ï¼Œä¸è¿‡è¦ä¿è¯äºŒè€…åŒæ­¥ï¼š\n1 image = { path = \u0026#34;vendor/image\u0026#34;, version = \u0026#34;0.13.0\u0026#34; } æ¥ç€å°±æ˜¯å‘å¸ƒäº†ï¼š\n1 2 3 4 $ cargo login 5j0dV54BjlXBpUUbfIj7G9DvNl1vsWW1 $ cargo publish Updating registry `https://github.com/rust-lang/crates.io-index` Uploading fern_sim v0.1.0 (file:///.../fern_sim) Workspace ä½¿ç”¨Cargoå·¥ä½œç©ºé—´å¯ä»¥èŠ‚çœç¼–è¯‘æ—¶é—´å’Œç£ç›˜ç©ºé—´ã€‚æ‰€è°“å·¥ä½œç©ºé—´ï¼Œå°±æ˜¯å…±äº«ç›¸åŒæ„å»ºç›®å½•å’ŒCargo.lockæ–‡ä»¶çš„ä¸€ç»„åŒ…ã€‚\nè¦ä½¿ç”¨å·¥ä½œç©ºé—´ï¼Œåªéœ€åœ¨å­˜å‚¨åº“çš„æ ¹ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªCargo.tomlæ–‡ä»¶ï¼Œå¹¶æŠŠä¸‹é¢å‡ è¡Œæ”¾è¿›å»ï¼š\n1 2 [workspace] members = [\u0026#34;fern_sim\u0026#34;, \u0026#34;fern_img\u0026#34;, \u0026#34;fern_video\u0026#34;] Here fern_sim etc. are the names of the subdirectories containing your crates. Delete any leftover Cargo.lock files and target directories that exist in those subdirectories.\nThe command cargo build --workspace builds all crates in the current workspace. cargo test and cargo doc accept the --workspace option as well.\nChapter 9. Structs Rust has three kinds of struct types, named-field, tuple-like, and unit-like, which differ in how you refer to their components: a named-field struct gives a name to each component, whereas a tuple- like struct identifies them by the order in which they appear. Unit-like structs have no components at all; these are not common, but more useful than you might think.\nNamed-Field Structs 1 2 3 4 5 /// A rectangle of eight-bit grayscale pixels. struct GrayscaleMap { pixels: Vec\u0026lt;u8\u0026gt;, size: (usize, usize) } ç»“æ„ä½“çš„åå­—ç”¨é©¼å³°å‘½åæ³•ï¼Œå…¶ä¸­çš„å­—æ®µç”¨è›‡å½¢æ‹¼å†™æ³•ã€‚\nYou can use key: value syntax for some fields and shorthand for others in the same struct expression.\nTo access a structâ€™s fields, use the familiar . operator.\nå¯ä»¥å°†ç»“æ„ä½“è®¾ä¸ºpubï¼Œä½†æ˜¯å­—æ®µé»˜è®¤ç§æœ‰ã€‚è¿™æ ·å¯ä»¥é€šè¿‡ä¸€äº›å…¬æœ‰çš„æ–¹æ³•åˆ›å»ºç»“æ„ä½“æˆ–è€…ä¿®æ”¹å®ƒã€‚\nä½¿ç”¨.. EXPRï¼Œä»»ä½•æ²¡æœ‰å‡ºç°çš„å­—æ®µéƒ½å°†ä»EXPRä¸­å–å¾—è‡ªå·±çš„å€¼ï¼Œå‰ææ˜¯EXPRå¿…é¡»ä¸ºåŒä¸€ç»“æ„ä½“ç±»å‹çš„å¦ä¸€ä¸ªå€¼ã€‚\nTuple-Like Structs ç±»å…ƒç»„ç»“æ„ä½“ï¼š\n1 struct Bounds(usize, usize); é€šè¿‡.æ“ä½œç¬¦æ¥è®¿é—®ã€‚\nå®šä¹‰æ­¤ç»“æ„ä½“ä¼šéšå¼å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼š\n1 fn Bounds(elem0: usize, elem1: usize) -\u0026gt; Bounds { ... } newtypesï¼Œå³åªåŒ…å«ä¸€ä¸ªè¦ç»è¿‡æ›´ä¸¥æ ¼ç±»å‹æ£€æŸ¥çš„ç»„ä»¶çš„ç»“æ„ä½“ã€‚\n1 struct Ascii(Vec\u0026lt;u8\u0026gt;); Unit-Like Structs 1 struct Onesuch; è¿™ç§ç±»å‹çš„å€¼ä¸å ä»»ä½•å†…å­˜ï¼Œåƒ()ã€‚\nRust doesnâ€™t bother actually storing unit-like struct values in memory or generating code to operate on them, because it can tell everything it might need to know about the value from its type alone. But logically, an empty struct is a type with values like any otherâ€”or more precisely, a type of which there is only a single value.\nStruct Layout 1 2 3 4 struct GrayscaleMap { pixels: Vec\u0026lt;u8\u0026gt;, size: (usize, usize) } ä¸€ç§å¯èƒ½çš„å†…å­˜å¸ƒå±€ï¼š\nRustä¸ä¿è¯ç»“æ„ä½“çš„å­—æ®µæˆ–å…ƒç´ åœ¨å†…å­˜ä¸­ä¼šä»¥æŸç§é¡ºåºå­˜å‚¨ï¼Œä½†æ˜¯ä¿è¯æŠŠå­—æ®µçš„å€¼ç›´æ¥å­˜å‚¨åœ¨ç»“æ„ä½“çš„å†…å­˜å—ä¸­ã€‚\nDefining Methods with impl Functions defined in an impl block are called associated functions, since theyâ€™re associated with a specific type. The opposite of an associated function is a free function, one that is not defined as an impl blockâ€™s item.\nself \u0026amp;self \u0026amp;mut self å½“è°ƒç”¨æ–¹æ³•æ—¶ï¼Œ. æ“ä½œç¬¦ä¼šéšå¼è½¬æ¢ï¼Œå¦‚æœæ–¹æ³•å®šä¹‰çš„æ˜¯å€Ÿç”¨ï¼Œå°±ä¼šéšå¼è½¬æ¢ä¸ºå¼•ç”¨ã€‚æ³¨æ„selfä¼šç§»åŠ¨æ‰€æœ‰æƒã€‚\nPassing Self as a Box, Rc, or Arc A methodâ€™s self argument can also be a Box\u0026lt;Self\u0026gt;, Rc\u0026lt;Self\u0026gt;, or Arc\u0026lt;Self\u0026gt;. Such a method can only be called on a value of the given pointer type. Calling the method passes ownership of the pointer to it.\n1 2 3 4 5 6 let mut bq = Box::new(Queue::new()); // `Queue::push` expects a `\u0026amp;mut Queue`, but `bq` is a `Box\u0026lt;Queue\u0026gt;`. // This is fine: Rust borrows a `\u0026amp;mut Queue` from the `Box` for the // duration of the call. bq.push(\u0026#39;â– \u0026#39;); Rust automatically borrows a reference from pointer types like Box, Rc, and Arc, so \u0026amp;self and \u0026amp;mut self are almost always the right thing in a method signature, along with the occasional self.\n1 2 3 4 5 impl Node { fn append_to(self: Rc\u0026lt;Self\u0026gt;, parent: \u0026amp;mut Node) { parent.children.push(self); } } If the caller has an Rc\u0026lt;Node\u0026gt; at hand, it can call append_to directly, passing the Rc by value:\n1 2 let shared_node = Rc::new(Node::new(\u0026#34;first\u0026#34;)); shared_node.append_to(\u0026amp;mut parent); Again, for most methods, \u0026amp;self, \u0026amp;mut self, and self (by value) are all you need. But if a methodâ€™s purpose is to affect the ownership of the value, using other pointer types for self can be just the right thing.\nType-Associated Functions 1 2 3 4 5 impl Queue { pub fn new() -\u0026gt; Queue { Queue { older: Vec::new(), younger: Vec::new() } } } Separating a typeâ€™s methods from its definition may seem unusual, but there are several advantages to doing so:\nItâ€™s always easy to find a typeâ€™s data members. Pulling methods out into an impl block allows a single syntax for all three. In fact, Rust uses this same syntax for defining methods on types that are not structs at all, such as enum types and primitive types like i32. The same impl syntax also serves neatly for implementing traits, which weâ€™ll go into in Chapter 11. Associated Consts 1 2 3 4 5 6 7 8 9 pub struct Vector2 { x: f32, y: f32, } impl Vector2 { const ZERO: Vector2 = Vector2 { x: 0.0, y: 0.0 }; const UNIT: Vector2 = Vector2 { x: 1.0, y: 0.0 }; } ä½¿ç”¨ï¼š\n1 let scaled = Vector2::UNIT.scaled_by(2.0); // scaled_by() æ–¹æ³•éœ€è¦è‡ªå·±å®šä¹‰ï¼Œè¿™é‡Œæ²¡æœ‰åˆ—å‡º Generic Structs 1 2 3 4 pub struct Queue\u0026lt;T\u0026gt; { older: Vec\u0026lt;T\u0026gt;, younger: Vec\u0026lt;T\u0026gt; } ç›¸å…³æ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 impl\u0026lt;T\u0026gt; Queue\u0026lt;T\u0026gt; { pub fn new() -\u0026gt; Queue\u0026lt;T\u0026gt; { Queue { older: Vec::new(), younger: Vec::new() } } pub fn push(\u0026amp;mut self, t: T) { self.younger.push(t); } pub fn is_empty(\u0026amp;self) -\u0026gt; bool { self.older.is_empty() \u0026amp;\u0026amp; self.younger.is_empty() } ... } ä½¿ç”¨Selfï¼š\n1 2 3 pub fn new() -\u0026gt; Self { Queue { older: Vec::new(), younger: Vec::new() } } For associated function calls, you can supply the type parameter explicitly using the ::\u0026lt;\u0026gt; (turbofish) notation:\n1 let mut q = Queue::\u0026lt;char\u0026gt;::new(); Structs with Lifetime Parameters 1 2 3 4 5 6 7 8 9 10 fn find_extrema\u0026lt;\u0026#39;s\u0026gt;(slice: \u0026amp;\u0026#39;s [i32]) -\u0026gt; Extrema\u0026lt;\u0026#39;s\u0026gt; { let mut greatest = \u0026amp;slice[0]; let mut least = \u0026amp;slice[0]; for i in 1..slice.len() { if slice[i] \u0026lt; *least { least = \u0026amp;slice[i]; } if slice[i] \u0026gt; *greatest { greatest = \u0026amp;slice[i]; } } Extrema { greatest, least } } å½“ç„¶è¿™é‡Œç”Ÿå‘½å‘¨æœŸå‚æ•°ä¹Ÿå¯ä»¥çœç•¥ï¼Œå› ä¸ºå¯ä»¥æ ¹æ®ä¸‰æ¡è§„åˆ™è¿›è¡Œæ¨æ–­ã€‚\nDeriving Common Traits for Struct Types 1 2 3 4 5 #[derive(Copy, Clone, Debug, PartialEq)] struct Point { x: f64, y: f64 } Interior Mutability æ”¯æŒå†…éƒ¨å¯å˜æ€§ï¼Œç”¨Cell\u0026lt;T\u0026gt;å’ŒRefCell\u0026lt;T\u0026gt;ï¼Œå®šä¹‰åœ¨std::cellæ¨¡å—ä¸­ã€‚\nCell\u0026lt;T\u0026gt;æ˜¯åªåŒ…å«ä¸€ä¸ªTç±»å‹ç§æœ‰å€¼çš„ç»“æ„ä½“ã€‚Cellå”¯ä¸€ç‰¹åˆ«çš„åœ°æ–¹æ˜¯ä¸éœ€è¦å¯¹å…¶è‡ªèº«çš„mutå¼•ç”¨ï¼Œä½ ä¹Ÿèƒ½å–å¾—æˆ–è®¾ç½®å…¶ç§æœ‰å­—æ®µçš„å€¼ã€‚\nCell::new(value)ï¼šåˆ›å»ºä¸€ä¸ªæ–°Cellï¼Œå°†valueè½¬ç§»åˆ°å…¶ä¸­ã€‚ cell.get()ï¼šè¿”å›cellä¸­å€¼çš„å‰¯æœ¬ã€‚è¦æ±‚ cell å®ç° Copy traitã€‚ cell.set(value)ï¼šæŠŠvalueä¿å­˜åˆ°cellï¼Œä¸¢å¼ƒä¹‹é—´ä¿å­˜çš„å€¼ã€‚ RefCell\u0026lt;T\u0026gt;æ˜¯åªåŒ…å«ä¸€ä¸ªTç±»å‹å€¼çš„æ³›å‹ç±»å‹ã€‚ä½†ä¸Cellä¸åŒï¼ŒRefCell\u0026lt;T\u0026gt;æ”¯æŒå€Ÿç”¨å®ƒçš„Tç±»å‹å€¼çš„å¼•ç”¨ã€‚\nRefCell::new(value)ï¼šåˆ›å»ºä¸€ä¸ªæ–°RefCellï¼Œå°†valueè½¬ç§»åˆ°å…¶ä¸­ã€‚ ref_cell.borrow()ï¼šè¿”å›ä¸€ä¸ªRef\u0026lt;T\u0026gt;ï¼ŒåŸºæœ¬ä¸Šæ˜¯å¯¹ ref_cell ä¸­å€¼çš„å…±äº«å¼•ç”¨ã€‚This method panics if the value is already mutably borrowed. ref_cell.borrow_mut(): Returns a RefMut\u0026lt;T\u0026gt;, essentially a mutable reference to the value in ref_cell. This method panics if the value is already borrowed. ref_cell.try_borrow(), ref_cell.try_borrow_mut() : Work just like borrow() and borrow_mut(), but return a Result. Instead of panicking if the value is already mutably borrowed, they return an Err value. This is a lot like how normal references work. The only difference is that normally, when you borrow a reference to a variable, Rust checks at compile time to ensure that youâ€™re using the reference safely. If the checks fail, you get a compiler error. RefCell enforces the same rule using run-time checks. So if youâ€™re breaking the rules, you get a panic (or an Err, for try_borrow and try_borrow_mut).\nThe other drawback is less obvious and more serious: cellsâ€”and any types that contain themâ€”are not thread-safe.\nè¡¥å……ï¼šå‚è€ƒRefCell å’Œå†…éƒ¨å¯å˜æ€§æ¨¡å¼ã€‚\nå› ä¸º RefCell\u0026lt;T\u0026gt; å…è®¸åœ¨è¿è¡Œæ—¶æ‰§è¡Œå¯å˜å€Ÿç”¨æ£€æŸ¥ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨å³ä¾¿ RefCell\u0026lt;T\u0026gt; è‡ªèº«æ˜¯ä¸å¯å˜çš„æƒ…å†µä¸‹ä¿®æ”¹å…¶å†…éƒ¨çš„å€¼ã€‚ ç»“æ„ä½“æ˜¯â€œä¸â€çš„é€»è¾‘ï¼Œè€Œæšä¸¾æ˜¯â€œæˆ–â€çš„é€»è¾‘ã€‚\nChapter 10. Enums and Patterns Enums 1 2 3 4 5 enum Ordering { Less, Equal, Greater, } è¿™ä¸ªæ˜¯æ ‡å‡†åº“ä¸­çš„ï¼Œå¯¼å…¥ç”¨useã€‚ä¹Ÿå¯ä»¥è‡ªå·±å®šä¹‰æšä¸¾ï¼Œè‡ªå·±å¯¼å…¥ã€‚\n1 2 3 4 5 6 7 enum Pet { Orca, Giraffe, ... } use self::Pet::*; In memory, values of C-style enums are stored as integers. Occasionally itâ€™s useful to tell Rust which integers to use:\n1 2 3 4 5 6 enum HttpStatus { Ok = 200, NotModified = 304, NotFound = 404, ... } Otherwise Rust will assign the numbers for you, starting at 0.\nBy default, Rust stores C-style enums using the smallest built-in integer type that can accommodate them. Most fit in a single byte.\n#[repr]å¯ä»¥è‡ªå·±é€‰æ‹©æšä¸¾çš„å†…å­˜è¡¨ç¤ºã€‚\nå¯ä»¥å°†Cå¼æšä¸¾è½¬æ¢ä¸ºæ•´æ•°ï¼Œä½†æ˜¯åè¿‡æ¥ä¸å¯ä»¥ã€‚\nå’Œç»“æ„ä½“ä¸€æ ·ï¼Œå¯ä»¥ç»™æšä¸¾åŠ ä¸Šå±æ€§ï¼Œå®šä¹‰ç›¸å…³æ–¹æ³•ã€‚\nEnums with Data ä¸€ä¸ªæšä¸¾å¯ä»¥åŒæ—¶åŒ…å«ä¸‰ç§å˜ä½“ï¼š\n1 2 3 4 5 6 7 8 9 enum RelationshipStatus { Single, InARelationship, ItsComplicated(Option\u0026lt;String\u0026gt;), ItsExtremelyComplicated { car: DifferentialEquation, cdr: EarlyModernistPoem, }, } All constructors and fields of an enum share the same visibility as the enum itself.\nEnums in Memory åœ¨å†…å­˜ä¸­ï¼Œå¸¦æ•°æ®çš„æ¯ä¸ªæ„é€ å¼éƒ½éœ€è¦ä¸€ä¸ªå°æ•´æ•°æ ‡ç­¾ã€‚\nRoughTimeçš„æ¯ä¸ªæ„é€ å¼å ç”¨8ä¸ªå­—èŠ‚ã€‚\nä¸ºäº†æ–¹ä¾¿ä¼˜åŒ–ï¼ŒRustå¹¶æœªå¯¹æšä¸¾çš„å†…å­˜å¸ƒå±€æ–¹å¼åšå‡ºä»»ä½•æ‰¿è¯ºã€‚For instance, some generic structs can be stored without a tag at all, as weâ€™ll see later.\nRich Data Structures Using Enums 1 2 3 4 5 6 7 8 9 10 use std::collections::HashMap; enum Json { Null, Boolean(bool), Number(f64), String(String), Array(Vec\u0026lt;Json\u0026gt;), Object(Box\u0026lt;HashMap\u0026lt;String, Json\u0026gt;\u0026gt;), } å†…å­˜å¸ƒå±€ï¼š\nåœ¨å†…å­˜ä¸­ï¼ŒJsonç±»å‹çš„å€¼å 4ä¸ªæœºå™¨å­—ã€‚Stringå’ŒVecå€¼å 3ä¸ªæœºå™¨å­—ï¼ŒRustè¿˜ä¼šåŠ ä¸€ä¸ªæ ‡ç­¾å­—èŠ‚ã€‚Nullå’ŒBooleanå€¼ç”¨ä¸äº†é‚£ä¹ˆå¤šå†…å­˜ç©ºé—´ï¼Œä½†æ‰€æœ‰Jsonå€¼çš„å¤§å°å¿…é¡»ç›¸åŒã€‚\nBox\u0026lt;HashMap\u0026gt;åªå ä¸€ä¸ªæœºå™¨å­—ï¼Œå› ä¸ºå®ƒåªæ˜¯ä¸€ä¸ªæŒ‡å‘åˆ†é…åˆ°å †å†…å­˜æ•°æ®çš„æŒ‡é’ˆã€‚\nGeneric Enums 1 2 3 4 5 6 7 8 9 enum Option\u0026lt;T\u0026gt; { None, Some(T), } enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } **å¦‚æœç±»å‹Tæ˜¯å¼•ç”¨æˆ–Boxæˆ–å…¶ä»–æ™ºèƒ½æŒ‡é’ˆç±»å‹ï¼ŒRustå°±ä¼šçœæ‰Option\u0026lt;T\u0026gt;çš„æ ‡ç­¾å­—æ®µã€‚**å› æ­¤Option\u0026lt;Box\u0026lt;i32\u0026gt;\u0026gt;åœ¨å†…å­˜ä¸­åªç”¨1ä¸ªæœºå™¨å­—èŠ‚å­˜å‚¨ã€‚0è¡¨ç¤ºNoneï¼Œéé›¶è¡¨ç¤ºSomeå°è£…çš„å€¼ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 // An ordered collection of `T`s. enum BinaryTree\u0026lt;T\u0026gt; { Empty, NonEmpty(Box\u0026lt;TreeNode\u0026lt;T\u0026gt;\u0026gt;), } // A part of a BinaryTree. struct TreeNode\u0026lt;T\u0026gt; { element: T, left: BinaryTree\u0026lt;T\u0026gt;, right: BinaryTree\u0026lt;T\u0026gt;, } è®¿é—®æšä¸¾æ•°æ®å”¯ä¸€çš„æ–¹å¼æ˜¯ä¸€ç§å®‰å…¨çš„æ–¹å¼ï¼šä½¿ç”¨æ¨¡å¼ã€‚\nPatterns åœ¨æšä¸¾ä¸­ä¸èƒ½ç›´æ¥é€šè¿‡.æ“ä½œç¬¦è®¿é—®æšä¸¾çš„å­—æ®µã€‚å¯ä»¥ç”¨matchè¡¨è¾¾å¼æ¥è¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚\nè¡¨è¾¾å¼äº§ç”Ÿå€¼ï¼Œæ¨¡å¼æ¶ˆè´¹å€¼ã€‚\næ¨¡å¼åŒ¹é…ä¼šä»å·¦åˆ°å³å¯¹æ¯”æ¨¡å¼çš„æ¯ä¸ªç»„ä»¶ï¼Œä¾æ¬¡æ£€æŸ¥å½“å‰å€¼æ˜¯å¦ä¸ä¹‹åŒ¹é…ã€‚å¦‚æœä¸åŒ¹é…ï¼Œå°±å‰è¿›åˆ°ä¸‹ä¸€ä¸ªæ¨¡å¼ã€‚\næ¨¡å¼ç±»å‹ ç¤ºä¾‹ è¯´æ˜ Literal Range Wildcard Variable ref variable Binding with subpattern Enum pattern Tuple pattern Array pattern Slice pattern Struct pattern Reference Multiple patterns `\u0026lsquo;a\u0026rsquo; \u0026lsquo;A\u0026rsquo;` Guard expression x if x * x \u0026lt;= r2 In match only (not valid in let, etc.) Literals, Variables, and Wildcards in Patterns 1 2 3 4 5 6 let calendar = match settings.get_string(\u0026#34;calendar\u0026#34;) { \u0026#34;gregorian\u0026#34; =\u0026gt; Calendar::Gregorian, \u0026#34;chinese\u0026#34; =\u0026gt; Calendar::Chinese, \u0026#34;ethiopian\u0026#34; =\u0026gt; Calendar::Ethiopian, other =\u0026gt; return parse_error(\u0026#34;calendar\u0026#34;, other), }; å¯ä»¥ä½¿ç”¨é€šé…ç¬¦_ã€‚\n1 2 3 4 5 6 let caption = match photo.tagged_pet() { Pet::Tyrannosaur =\u0026gt; \u0026#34;RRRAAAAAHHHHHH\u0026#34;, Pet::Samoyed =\u0026gt; \u0026#34;*dog thoughts*\u0026#34;, _ =\u0026gt; \u0026#34;I\u0026#39;m cute, love me\u0026#34;, // generic caption, works for any pet }; å³ä¾¿ä½ éå¸¸ç¡®å®šå…¶ä»–æƒ…å†µä¸ä¼šå‘ç”Ÿï¼Œä¹Ÿå¿…é¡»è‡³å°‘åŠ ä¸Šä¸€ä¸ªåå¤‡çš„panicåˆ†æ”¯ï¼š\n1 2 3 4 5 6 7 8 // There are many Shapes, but we only support \u0026#34;selecting\u0026#34; // either some text, or everything in a rectangular area. // You can\u0026#39;t select an ellipse or trapezoid. match document.selection() { Shape::TextSpan(start, end) =\u0026gt; paint_text_selection(start, end), Shape::Rectangle(rect) =\u0026gt; paint_rect_selection(rect), _ =\u0026gt; panic!(\u0026#34;unexpected selection type\u0026#34;), } Tuple and Struct Patterns å…ƒç»„æ¨¡å¼åŒ¹é…å…ƒç»„ï¼š\n1 2 3 4 5 6 7 8 9 10 11 fn describe_point(x: i32, y: i32) -\u0026gt; \u0026amp;\u0026#39;static str { use std::cmp::Ordering::*; match (x.cmp(\u0026amp;0), y.cmp(\u0026amp;0)) { (Equal, Equal) =\u0026gt; \u0026#34;at the origin\u0026#34;, (_, Equal) =\u0026gt; \u0026#34;on the x axis\u0026#34;, (Equal, _) =\u0026gt; \u0026#34;on the y axis\u0026#34;, (Greater, Greater) =\u0026gt; \u0026#34;in the first quadrant\u0026#34;, (Less, Greater) =\u0026gt; \u0026#34;in the second quadrant\u0026#34;, _ =\u0026gt; \u0026#34;somewhere else\u0026#34;, } } ç»“æ„ä½“æ¨¡å¼ä½¿ç”¨èŠ±æ‹¬å·ï¼š\n1 2 3 4 5 6 match balloon.location { Point { x: 0, y: height } =\u0026gt; println!(\u0026#34;straight up {} meters\u0026#34;, height), Point { x: x, y: y } =\u0026gt; println!(\u0026#34;at ({}m, {}m)\u0026#34;, x, y), } åœ¨ç»“æ„ä½“æ¨¡å¼åŒ¹é…ä¸­ï¼Œå¯ä»¥ä½¿ç”¨...æ¥å‘Šè¯‰Rustä½ å¹¶ä¸å…³å¿ƒå…¶ä»–å­—æ®µï¼š\n1 2 Some(Account { name, language, .. }) =\u0026gt; language.show_custom_greeting(name), Array and Slice Patterns æ•°ç»„åŒ¹é…ï¼š\n1 2 3 4 5 6 7 fn hsl_to_rgb(hsl: [u8; 3]) -\u0026gt; [u8; 3] { match hsl { [_, _, 0] =\u0026gt; [0, 0, 0], [_, _, 255] =\u0026gt; [255, 255, 255], ... } } åˆ‡ç‰‡åŒ¹é…ï¼š\n1 2 3 4 5 6 7 8 fn greet_people(names: \u0026amp;[\u0026amp;str]) { match names { [] =\u0026gt; { println!(\u0026#34;Hello, nobody.\u0026#34;) }, [a] =\u0026gt; { println!(\u0026#34;Hello, {}.\u0026#34;, a) }, [a, b] =\u0026gt; { println!(\u0026#34;Hello, {} and {}.\u0026#34;, a, b) }, [a, .., b] =\u0026gt; { println!(\u0026#34;Hello, everyone from {} to {}.\u0026#34;, a, b) } } } Reference Patterns å¯¹äºå¼•ç”¨ï¼ŒRustæ”¯æŒä¸¤ç§æ¨¡å¼ï¼šrefæ¨¡å¼å’Œ\u0026amp;æ¨¡å¼ã€‚å‰è€…å€Ÿç”¨åŒ¹é…å€¼çš„å…ƒç´ ï¼Œåè€…åŒ¹é…å¼•ç”¨ã€‚\néœ€è¦ä¸€ç§æ¨¡å¼æ¥å€Ÿç”¨è€Œä¸moveåŒ¹é…çš„å€¼ã€‚ç”¨å…³é”®å­—refã€‚\n1 2 3 4 5 6 match account { Account { ref name, ref language, .. } =\u0026gt; { ui.greet(name, language); ui.show_settings(\u0026amp;account); // ok } } ä½¿ç”¨ref mutå€Ÿç”¨mutå¼•ç”¨ï¼š\n1 2 3 4 5 6 7 match line_result { Err(ref err) =\u0026gt; log_error(err), // `err` is \u0026amp;Error (shared ref) Ok(ref mut line) =\u0026gt; { // `line` is \u0026amp;mut String (mut ref) trim_comments(line); // modify the String in place handle(line); } } ä»¥\u0026amp;å¼€å¤´çš„æ¨¡å¼åŒ¹é…å¼•ç”¨ã€‚\n1 2 3 match sphere.center() { \u0026amp;Point3d { x, y, z } =\u0026gt; ... // è¿™é‡Œ x, y, z æ˜¯å€¼ï¼Œå®ç°äº† Copy trait } è¡¨è¾¾å¼å’Œæ¨¡å¼å¤©ç”Ÿæ˜¯ç›¸åçš„ã€‚è¡¨è¾¾å¼(x, y)ç”¨ä¸¤ä¸ªå€¼åˆ›å»ºä¸€ä¸ªæ–°å…ƒç»„ï¼Œæ¨¡å¼(x, y)åˆ™ç›¸åï¼šå®ƒåŒ¹é…å…ƒç»„å¹¶ç ´ååå–å‡ºä¸¤ä¸ªå€¼ã€‚å¯¹\u0026amp;è€Œè¨€ä¹Ÿä¸€æ ·ï¼šè¡¨è¾¾å¼\u0026amp;åˆ›å»ºå¼•ç”¨ï¼Œæ¨¡å¼ä¸­çš„\u0026amp;åŒ¹é…å¼•ç”¨ã€‚åŒ¹é…å¼•ç”¨ä¸­ï¼Œç”Ÿå‘½å‘¨æœŸæ˜¯å¿…è¦æ¡ä»¶ã€‚ä¸èƒ½å¯¹å…±äº«å¼•ç”¨é‡‡å–mutæ“ä½œã€‚ä¸èƒ½ä»å¼•ç”¨ï¼ˆåŒ…æ‹¬mutå¼•ç”¨ï¼‰ä¸­moveå‡ºå€¼ã€‚\n1 2 3 4 5 match friend.borrow_car() { Some(\u0026amp;Car { engine, .. }) =\u0026gt; // error: can\u0026#39;t move out of borrow è¿™é‡Œ engine æ²¡æœ‰å®ç° Copy trait ... None =\u0026gt; {} } ä¿®æ”¹ï¼š\n1 Some(\u0026amp;Car { ref engine, .. }) =\u0026gt; // ok, engine is a reference å¯ä»¥ä½¿ç”¨\u0026amp;æ¨¡å¼å–å¾—å¼•ç”¨æ‰€æŒ‡å‘çš„å­—ç¬¦ï¼š\n1 2 3 4 match chars.peek() { // chars.peek() è¿”å› Option\u0026lt;\u0026amp;char\u0026gt; Some(\u0026amp;c) =\u0026gt; println!(\u0026#34;coming up: {:?}\u0026#34;, c), None =\u0026gt; println!(\u0026#34;end of chars\u0026#34;), } Match Guards 1 2 3 4 5 6 7 8 9 10 match point_to_hex(click) { None =\u0026gt; Err(\u0026#34;That\u0026#39;s not a game space.\u0026#34;), Some(hex) =\u0026gt; { if hex == current_hex { Err(\u0026#34;You are already there! You must click somewhere else\u0026#34;) } else { Ok(hex) } } } But Rust also provides match guards, extra conditions that must be true in order for a match arm to apply, written as if CONDITION, between the pattern and the armâ€™s =\u0026gt; token:\n1 2 3 4 5 6 match point_to_hex(click) { None =\u0026gt; Err(\u0026#34;That\u0026#39;s not a game space.\u0026#34;), Some(hex) if hex == current_hex =\u0026gt; Err(\u0026#34;You are already there! You must click somewhere else\u0026#34;), Some(hex) =\u0026gt; Ok(hex) } If the pattern matches, but the condition is false, matching continues with the next arm.\nMatching Multiple Possibilities 1 2 3 4 let at_end = match chars.peek() { Some(\u0026amp;\u0026#39;\\r\u0026#39;) | Some(\u0026amp;\u0026#39;\\n\u0026#39;) | None =\u0026gt; true, _ =\u0026gt; false, }; æˆ–è€…\n1 2 3 4 5 6 match next_char { \u0026#39;0\u0026#39;..=\u0026#39;9\u0026#39; =\u0026gt; self.read_number(), \u0026#39;a\u0026#39;..=\u0026#39;z\u0026#39; | \u0026#39;A\u0026#39;..=\u0026#39;Z\u0026#39; =\u0026gt; self.read_word(), \u0026#39; \u0026#39; | \u0026#39;\\t\u0026#39; | \u0026#39;\\n\u0026#39; =\u0026gt; self.skip_whitespace(), _ =\u0026gt; self.handle_punctuation(), } Binding with @ Patterns x @ patternåŒ¹é…ç»™å®šçš„ patternï¼Œä½†æˆåŠŸä¹‹åï¼Œä¸æ˜¯åŸºäºåŒ¹é…å€¼çš„å…ƒç´ æ¥åˆ›å»ºå˜é‡ï¼Œè€Œæ˜¯æŠŠåŒ¹é…å€¼æ•´ä¸ªç§»åŠ¨æˆ–å¤åˆ¶åˆ°ä¸€ä¸ªå˜é‡ x ä¸­ã€‚\n1 2 3 rect @ Shape::Rect(..) =\u0026gt; { optimized_paint(\u0026amp;rect) } @ patterns are also useful with ranges:\n1 2 3 4 match chars.next() { Some(digit @ \u0026#39;0\u0026#39;..=\u0026#39;9\u0026#39;) =\u0026gt; read_number(digit, chars), ... }, Where Patterns Are Allowed The meaning is always the same: instead of just storing a value in a single variable, Rust uses pattern matching to take the value apart.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ...unpack a struct into three new local variables let Track { album, track_number, title, .. } = song; // ...unpack a function argument that\u0026#39;s a tuple fn distance_to((x, y): (f64, f64)) -\u0026gt; f64 { ... } // ...iterate over keys and values of a HashMap for (id, document) in \u0026amp;cache_map { println!(\u0026#34;Document #{}: {}\u0026#34;, id, document.title); } // ...automatically dereference an argument to a closure // (handy because sometimes other code passes you a reference // when you\u0026#39;d rather have a copy) let sum = numbers.fold(0, |a, \u0026amp;num| a + num); ä¸Šé¢çš„éƒ½æ˜¯ irrefutable patternsï¼Œä¸‹é¢çš„æ˜¯refutable patternã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // ...handle just one enum variant specially if let RoughTime::InTheFuture(_, _) = user.date_of_birth() { user.set_time_traveler(true); } // ...run some code only if a table lookup succeeds if let Some(document) = cache_map.get(\u0026amp;id) { return send_cached_response(document); } // ...repeatedly try something until it succeeds while let Err(err) = present_cheesy_anti_robot_task() { log_robot_attempt(err); // let the user try again (it might still be a human) } // ...manually loop over an iterator while let Some(_) = lines.peek() { read_paragraph(\u0026amp;mut lines); } Populating a Binary Tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 enum BinaryTree\u0026lt;T\u0026gt; { Empty, NonEmpty(Box\u0026lt;TreeNode\u0026lt;T\u0026gt;\u0026gt;), } struct TreeNode\u0026lt;T\u0026gt; { element: T, left: BinaryTree\u0026lt;T\u0026gt;, right: BinaryTree\u0026lt;T\u0026gt;, } impl\u0026lt;T: Ord\u0026gt; BinaryTree\u0026lt;T\u0026gt; { fn add(\u0026amp;mut self, value: T) { match *self { BinaryTree::Empty =\u0026gt; *self = BinaryTree::NonEmpty(Box::new(TreeNode{ element: value, left: BinaryTree::Empty, right: BinaryTree::Empty, })), BinaryTree::NonEmpty(ref mut node) =\u0026gt; if value \u0026lt;= node.element { node.left.add(value); } else { node.right.add(value); } } } } fn main() { let mut tree = BinaryTree::Empty; tree.add(\u0026#34;Mercury\u0026#34;); tree.add(\u0026#34;Venus\u0026#34;); } Chapter 11. Traits and Generics Rust supports polymorphism with two related features: traits and generics.\nGenerics and traits are closely related: generic functions use traits in bounds to spell out what types of arguments they can be applied to. So weâ€™ll also talk about how \u0026amp;mut dyn Write and \u0026lt;T: Write\u0026gt; are similar, how theyâ€™re different, and how to choose between these two ways of using traits.\nUsing Traits A value that implements std::io::Write can write out bytes. A value that implements std::iter::Iterator can produce a sequence of values. A value that implements std::clone::Clone can make clones of itself in memory. A value that implements std::fmt::Debug can be printed using println!() with the {:?} format specifier. traitæœ¬èº«å¿…é¡»åœ¨ä½œç”¨åŸŸä¸­ã€‚å¦åˆ™ï¼Œtraitçš„æ‰€æœ‰æ–¹æ³•éƒ½æ˜¯éšè—çš„ã€‚\nBut since Rust makes you import the traits you plan to use, crates are free to take advantage of this superpower. To get a conflict, youâ€™d have to import two traits that add a method with the same name to the same type. This is rare in practice. (If you do run into a conflict, you can spell out what you want using fully qualified method syntax, covered later in the chapter.)\nThe reason Clone and Iterator methods work without any special imports is that theyâ€™re always in scope by default: theyâ€™re part of the standard prelude, names that Rust automatically imports into every module.\nTrait Objects Rust doesnâ€™t permit variables of type dyn Write:\n1 2 3 4 use std::io::Write; let mut buf: Vec\u0026lt;u8\u0026gt; = vec![]; let writer: dyn Write = buf; // error: `Write` does not have a constant size A variableâ€™s size has to be known at compile time, and types that implement Write can be any size.\n1 2 let mut buf: Vec\u0026lt;u8\u0026gt; = vec![]; let writer: \u0026amp;mut dyn Write = \u0026amp;mut buf; // ok A reference to a trait type, like writer, is called a trait object. Like any other reference, a trait object points to some value, it has a lifetime, and it can be either mut or shared.\nTrait object layout In memory, a trait object is a fat pointer consisting of a pointer to the value, plus a pointer to a table representing that valueâ€™s type. Each trait object therefore takes up two machine words.\nIn Rust, as in C++, the vtable is generated once, at compile time, and shared by all objects of the same type. Everything shown in the darker shade in Figure 11-1, including the vtable, is a private implementation detail of Rust. Again, these arenâ€™t fields and data structures that you can access directly. Instead, the language automatically uses the vtable when you call a method of a trait object, to determine which implementation to call.\nRust automatically converts ordinary references into trait objects when needed.\n1 2 let mut local_file = File::create(\u0026#34;hello.txt\u0026#34;)?; say_hello(\u0026amp;mut local_file)?; Likewise, Rust will happily convert a Box\u0026lt;File\u0026gt; to a Box\u0026lt;dyn Write\u0026gt;, a value that owns a writer in the heap:\n1 let w: Box\u0026lt;dyn Write\u0026gt; = Box::new(local_file); This kind of conversion is the only way to create a trait object. What the compiler is actually doing here is very simple. At the point where the conversion happens, Rust knows the referentâ€™s true type (in this case, File), so it just adds the address of the appropriate vtable, turning the regular pointer into a fat pointer.\nGeneric Functions and Type Parameters 1 2 fn say_hello(out: \u0026amp;mut dyn Write) // plain function fn say_hello\u0026lt;W: Write\u0026gt;(out: \u0026amp;mut W) // generic function 1 2 3 4 fn say_hello\u0026lt;W: Write\u0026gt;(out: \u0026amp;mut W) // generic function say_hello(\u0026amp;mut local_file)?; // calls say_hello::\u0026lt;File\u0026gt; say_hello(\u0026amp;mut bytes)?; // calls say_hello::\u0026lt;Vec\u0026lt;u8\u0026gt;\u0026gt; This process is known as monomorphization, and the compiler handles it all automatically.\n1 2 3 // calling a generic method collect\u0026lt;C\u0026gt;() that takes no arguments let v1 = (0 .. 1000).collect(); // error: can\u0026#39;t infer type let v2 = (0 .. 1000).collect::\u0026lt;Vec\u0026lt;i32\u0026gt;\u0026gt;(); // ok 1 2 3 4 fn run_query\u0026lt;M, R\u0026gt;(data: \u0026amp;DataSet, map: M, reduce: R) -\u0026gt; Results where M: Mapper + Serialize, R: Reducer + Serialize { ... } ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼š\n1 2 3 4 5 6 7 /// Return a reference to the point in `candidates` that\u0026#39;s /// closest to the `target` point. fn nearest\u0026lt;\u0026#39;t, \u0026#39;c, P\u0026gt;(target: \u0026amp;\u0026#39;t P, candidates: \u0026amp;\u0026#39;c [P]) -\u0026gt; \u0026amp;\u0026#39;c P where P: MeasureDistance { ... } ç”Ÿå‘½å‘¨æœŸä¸ä¼šå¯¹æœºå™¨ç æœ‰ä»»ä½•å½±å“ã€‚\nAll the features introduced in this sectionâ€”bounds, where clauses, lifetime parameters, and so forthâ€”can be used on all generic items, not just functions.\nWhich to Use 1 2 3 4 5 6 7 trait Vegetable { ... } struct Salad\u0026lt;V: Vegetable\u0026gt; { veggies: Vec\u0026lt;V\u0026gt; } æ²™æ‹‰ç»“æ„ä½“ç”¨æ³›å‹å‡½æ•°å®ç°ï¼Œä½†æ˜¯åªèƒ½æ”¾ä¸€ç§è”¬èœã€‚\nè€ƒè™‘åˆ°è”¬èœå€¼çš„å¤§å°å¯èƒ½å·®åˆ«æ¯”è¾ƒå¤§ï¼Œä¸èƒ½ç›´æ¥ç”¨ Vecã€‚\n1 2 3 4 struct Salad { veggies: Vec\u0026lt;dyn Vegetable\u0026gt; // error: `dyn Vegetable` does // not have a constant size } å¯ä»¥è¿™æ ·å®ç°ï¼š\n1 2 3 struct Salad { veggies: Vec\u0026lt;Box\u0026lt;dyn Vegetable\u0026gt;\u0026gt; } Another possible reason to use trait objects is to reduce the total amount of compiled code.\né‚£ä¹ˆåœ¨ä¸è€ƒè™‘æ²™æ‹‰æˆ–è€…low-resource environmentsè¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œé€‰æ‹©æ³›å‹å‡½æ•°æœ‰ä¸‰ä¸ªä¼˜ç‚¹ï¼š\nThe first advantage is speed. ä¼šé€šè¿‡é™æ€åˆ†å‘çš„æ–¹å¼ï¼Œæ¶ˆé™¤åŠ¨æ€æŸ¥æ‰¾çš„æ—¶é—´ã€‚ The second advantage of generics is that not every trait can support trait objects. The third advantage of generics is that itâ€™s easy to bound a generic type parameter with several traits at once, as our top_ten function did when it required its T parameter to implement Debug + Hash + Eq. Trait objects canâ€™t do this: types like \u0026amp;mut (dyn Debug + Hash + Eq) arenâ€™t supported in Rust. (You can work around this with subtraits, defined later in this chapter, but itâ€™s a bit involved.) Defining and Implementing Traits å®šä¹‰traitï¼š\n1 2 3 4 5 6 7 8 /// A trait for characters, items, and scenery - /// anything in the game world that\u0026#39;s visible on screen. trait Visible { /// Render this object on the given canvas. fn draw(\u0026amp;self, canvas: \u0026amp;mut Canvas); /// Return true if clicking at (x, y) should /// select this object. fn hit_test(\u0026amp;self, x: i32, y: i32) -\u0026gt; bool; } å®ç°traitï¼Œç”¨impl TraitName for Typeã€‚\nEverything defined in a trait impl must actually be a feature of the trait.\nä¸åœ¨traité‡Œçš„è¾…åŠ©æ–¹æ³•è¦å•ç‹¬æ”¾åœ¨impl Typeé‡Œé¢å®ç°ã€‚è€Œä¸”å®ç°traitæ—¶ä¹Ÿå¯ä»¥è°ƒç”¨è¿™ä¸ªè¾…åŠ©æ–¹æ³•ã€‚\nDefault Methods traitçš„é»˜è®¤å®ç°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 trait Write { fn write(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;usize\u0026gt;; fn flush(\u0026amp;mut self) -\u0026gt; Result\u0026lt;()\u0026gt;; fn write_all(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;()\u0026gt; { let mut bytes_written = 0; while bytes_written \u0026lt; buf.len() { bytes_written += self.write(\u0026amp;buf[bytes_written..])?; } Ok(()) } ... } Traits and Other Peopleâ€™s Types Rust lets you implement any trait on any type, as long as either the trait or the type is introduced in the current crate.\nThe sole purpose of this particular trait is to add a method to an existing type, char. This is called an extension trait.\n1 2 3 4 5 6 7 8 9 10 11 trait IsEmoji { fn is_emoji(\u0026amp;self) -\u0026gt; bool; } /// Implement IsEmoji for the built-in character type. impl IsEmoji for char { fn is_emoji(\u0026amp;self) -\u0026gt; bool { ... } } assert_eq!(\u0026#39;$\u0026#39;.is_emoji(), false); You can even use a generic impl block to add an extension trait to a whole family of types at once.\n1 2 3 4 5 6 /// You can write HTML to any std::io writer. impl\u0026lt;W: Write\u0026gt; WriteHtml for W { fn write_html(\u0026amp;mut self, html: \u0026amp;HtmlDocument) -\u0026gt; io::Result\u0026lt;()\u0026gt; { ... } } We said earlier that when you implement a trait, either the trait or the type must be new in the current crate. This is called the orphan rule. It helps Rust ensure that trait implementations are unique.\nSelf in Traits 1 2 3 4 pub trait Clone { fn clone(\u0026amp;self) -\u0026gt; Self; ... } Selfä½œä¸ºè¿”å›ç±»å‹æ„å‘³ç€x.clone()çš„ç±»å‹å°±æ˜¯xçš„ç±»å‹ï¼Œä¸ç®¡å…·ä½“ä»€ä¹ˆç±»å‹ã€‚\nä½¿ç”¨Selfç±»å‹çš„traitä¸trait objectsä¸èƒ½å…±å­˜ã€‚\n1 2 3 4 5 6 7 8 9 pub trait Spliceable { fn splice(\u0026amp;self, other: \u0026amp;Self) -\u0026gt; Self; } // error: the trait `Spliceable` cannot be made into an object fn splice_anything(left: \u0026amp;dyn Spliceable, right: \u0026amp;dyn Spliceable) { let combo = left.splice(right); // ... } Rust rejects this code because it has no way to type-check the call left.splice(right). The whole point of trait objects is that the type isnâ€™t known until run time. Rust has no way to know at compile time if left and right will be the same type, as required.\n1 2 3 pub trait MegaSpliceable { fn splice(\u0026amp;self, other: \u0026amp;dyn MegaSpliceable) -\u0026gt; Box\u0026lt;dyn MegaSpliceable\u0026gt;; } Thereâ€™s no problem type-checking calls to this .splice() method because the type of the argument other is not required to match the type of self, as long as both types are MegaSpliceable.\nSubtraits 1 2 3 4 5 6 7 /// Someone in the game world, either the player or some other /// pixie, gargoyle, squirrel, ogre, etc. trait Creature: Visible { fn position(\u0026amp;self) -\u0026gt; (i32, i32); fn facing(\u0026amp;self) -\u0026gt; Direction; ... } Here, we say that Creature is a subtrait of Visible, and that Creature is Visibleâ€™s supertrait.\nBut in Rust, a subtrait does not inherit the associated items of its supertrait; each trait still needs to be in scope if you want to call its methods.\nIn fact, Rustâ€™s subtraits are really just a shorthand for a bound on Self. A definition of Creature like this is exactly equivalent to the one shown earlier:\n1 2 3 trait Creature where Self: Visible { ... } Type-Associated Functions Traits can include type-associated functions, Rustâ€™s analog to static methods:\n1 2 3 4 5 6 7 8 9 10 11 12 13 trait StringSet { /// Return a new empty set. fn new() -\u0026gt; Self; // æ²¡æœ‰ self å‚æ•° /// Return a set that contains all the strings in `strings`. fn from_slice(strings: \u0026amp;[\u0026amp;str]) -\u0026gt; Self; // æ²¡æœ‰ self å‚æ•° /// Find out if this set contains a particular `value`. fn contains(\u0026amp;self, string: \u0026amp;str) -\u0026gt; bool; /// Add a string to this set. fn add(\u0026amp;mut self, string: \u0026amp;str); } If you want to use \u0026amp;dyn StringSet trait objects, you must change the trait, adding the bound where Self: Sized to each associated function that doesnâ€™t take a self argument by reference:\n1 2 3 4 5 6 7 8 9 10 11 trait StringSet { fn new() -\u0026gt; Self where Self: Sized; fn from_slice(strings: \u0026amp;[\u0026amp;str]) -\u0026gt; Self where Self: Sized; fn contains(\u0026amp;self, string: \u0026amp;str) -\u0026gt; bool; fn add(\u0026amp;mut self, string: \u0026amp;str); } With these additions, StringSet trait objects are allowed; they still donâ€™t support new or from_slice, but you can create them and use them to call .contains() and .add().\nFully Qualified Method Calls 1 2 3 4 5 6 7 \u0026#34;hello\u0026#34;.to_string() str::to_string(\u0026#34;hello\u0026#34;) ToString::to_string(\u0026#34;hello\u0026#34;) \u0026lt;str as ToString\u0026gt;::to_string(\u0026#34;hello\u0026#34;) // a fully qualified method call With fully qualified calls, you can say exactly which method you mean, and that can help in a few odd cases:\nWhen two methods have the same name. 1 2 3 4 outlaw.draw(); // error: draw on screen or draw pistol? Visible::draw(\u0026amp;outlaw); // ok: draw on screen HasPistol::draw(\u0026amp;outlaw); // ok: corral When the type of the self argument canâ€™t be inferred: 1 2 3 4 5 6 let zero = 0; // type unspecified; could be `i8`, `u8`, ... zero.abs(); // error: can\u0026#39;t call method `abs` // on ambiguous numeric type i64::abs(zero); // ok When using the function itself as a function value: 1 2 3 4 let words: Vec\u0026lt;String\u0026gt; = line.split_whitespace() // iterator produces \u0026amp;str values .map(ToString::to_string) // ok .collect(); When calling trait methods in macros. Traits That Define Relationships Between Types Traits can also be used in situations where there are multiple types that have to work together. They can describe relationships between types.\nAssociated Types (or How Iterators Work) 1 2 3 4 5 pub trait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; ... } The first feature of this trait, type Item;, is an associated type.\n1 2 3 4 5 6 use std::fmt::Debug; fn dump\u0026lt;I\u0026gt;(iter: I) where I: Iterator, I::Item: Debug { ... } trait object:\n1 2 3 4 5 fn dump(iter: \u0026amp;mut dyn Iterator\u0026lt;Item=String\u0026gt;) { for (index, s) in iter.enumerate() { println!(\u0026#34;{}: {:?}\u0026#34;, index, s); } } Generic Traits (or How Operator Overloading Works) 1 2 3 4 5 6 7 8 /// std::ops::Mul, the trait for types that support `*`. pub trait Mul\u0026lt;RHS\u0026gt; { /// The resulting type after applying the `*` operator type Output; /// The method for the `*` operator fn mul(self, rhs: RHS) -\u0026gt; Self::Output; } The type parameter here means the same thing that it means on a struct or function: Mul is a generic trait, and its instances Mul\u0026lt;f64\u0026gt;, Mul\u0026lt;String\u0026gt;, Mul\u0026lt;Size\u0026gt;, etc., are all different traits.\nGeneric traits get a special dispensation when it comes to the orphan rule: you can implement a foreign trait for a foreign type, so long as one of the traitâ€™s type parameters is a type defined in the current crate.\n1 2 3 pub trait Mul\u0026lt;RHS=Self\u0026gt; { ... } The syntax RHS=Self means that RHS defaults to Self. If I write impl Mul for Complex, without specifying Mulâ€™s type parameter, it means impl Mul\u0026lt;Complex\u0026gt; for Complex. In a bound, if I write where T: Mul, it means where T: Mul\u0026lt;T\u0026gt;.\nimpl Trait 1 2 3 4 5 6 use std::iter; use std::vec::IntoIter; fn cyclical_zip(v: Vec\u0026lt;u8\u0026gt;, u: Vec\u0026lt;u8\u0026gt;) -\u0026gt; iter::Cycle\u0026lt;iter::Chain\u0026lt;IntoIter\u0026lt;u8\u0026gt;, IntoIter\u0026lt;u8\u0026gt;\u0026gt;\u0026gt; { v.into_iter().chain(u.into_iter()).cycle() } è¿™ç§å†™æ³•å¤ªç¹çï¼Œå¯ä»¥è¿™æ ·å†™ï¼š\n1 2 3 fn cyclical_zip(v: Vec\u0026lt;u8\u0026gt;, u: Vec\u0026lt;u8\u0026gt;) -\u0026gt; Box\u0026lt;dyn Iterator\u0026lt;Item=u8\u0026gt;\u0026gt; { Box::new(v.into_iter().chain(u.into_iter()).cycle()) } ä½†æ˜¯è¿™æ˜¯åŠ¨æ€åˆ†å‘ï¼Œå½±å“æ•ˆç‡ã€‚å¯ä»¥ä½¿ç”¨ impl Traitã€‚\n1 2 3 fn cyclical_zip(v: Vec\u0026lt;u8\u0026gt;, u: Vec\u0026lt;u8\u0026gt;) -\u0026gt; impl Iterator\u0026lt;Item=u8\u0026gt; { v.into_iter().chain(u.into_iter()).cycle() } 1 2 3 4 5 6 7 fn make_shape(shape: \u0026amp;str) -\u0026gt; impl Shape { match shape { \u0026#34;circle\u0026#34; =\u0026gt; Circle::new(), \u0026#34;triangle\u0026#34; =\u0026gt; Triangle::new(), // error: incompatible types \u0026#34;shape\u0026#34; =\u0026gt; Rectangle::new(), } } Itâ€™s important to note that Rust doesnâ€™t allow trait methods to use impl Trait return values.\n1 2 3 4 5 6 7 fn print\u0026lt;T: Display\u0026gt;(val: T) { println!(\u0026#34;{}\u0026#34;, val); } fn print(val: impl Display) { println!(\u0026#34;{}\u0026#34;, val); } There is one important exception. Using generics allows callers of the function to specify the type of the generic arguments, like print::\u0026lt;i32\u0026gt;(42), while using impl Trait does not.\nAssociated Consts 1 2 3 4 trait Greet { const GREETING: \u0026amp;\u0026#39;static str = \u0026#34;Hello\u0026#34;; fn greet(\u0026amp;self) -\u0026gt; String; } 1 2 3 4 5 6 7 fn fib\u0026lt;T: Float + Add\u0026lt;Output=T\u0026gt;\u0026gt;(n: usize) -\u0026gt; T { match n { 0 =\u0026gt; T::ZERO, 1 =\u0026gt; T::ONE, n =\u0026gt; fib::\u0026lt;T\u0026gt;(n - 1) + fib::\u0026lt;T\u0026gt;(n - 2) } } Reverse-Engineering Bounds å’Œç¼–è¯‘å™¨åšæ–—äº‰ï¼ŒåŠ ä¸Š Boundsã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std::ops::{Add, Mul}; fn dot\u0026lt;N\u0026gt;(v1: \u0026amp;[N], v2: \u0026amp;[N]) -\u0026gt; N where N: Add\u0026lt;Output=N\u0026gt; + Mul\u0026lt;Output=N\u0026gt; + Default + Copy { let mut total = N::default(); for i in 0 .. v1.len() { total = total + v1[i] * v2[i]; } total } #[test] fn test_dot() { assert_eq!(dot(\u0026amp;[1, 2, 3, 4], \u0026amp;[1, 1, 1, 1]), 10); assert_eq!(dot(\u0026amp;[53.0, 7.0], \u0026amp;[1.0, 5.0]), 88.0); } æˆ–è€…ç”¨ç¬¬ä¸‰æ–¹åº“numã€‚\n1 2 3 4 5 6 7 8 9 use num::Num; fn dot\u0026lt;N: Num + Copy\u0026gt;(v1: \u0026amp;[N], v2: \u0026amp;[N]) -\u0026gt; N { let mut total = N::zero(); for i in 0 .. v1.len() { total = total + v1[i] * v2[i]; } total } Rustä¸ºä»€ä¹ˆè¦è¿™æ ·è®¾è®¡å‘¢ï¼Ÿä¸ºä»€ä¹ˆä¸æ¨¡ä»¿â€œé¸­å­ç±»å‹â€ï¼Ÿè¿™æ ·è®¾è®¡çš„ä¼˜ç‚¹æ˜¯ï¼š\nå¯ä»¥è®©æ³›å‹ä»£ç å…·æœ‰å‘å‰å…¼å®¹çš„èƒ½åŠ›ã€‚ ä½ èƒ½é€šè¿‡ç¼–è¯‘å™¨ä¿å­˜å°±çŸ¥é“è¦è§£å†³çš„éº»çƒ¦åœ¨å“ªé‡Œã€‚ æˆ–è®¸ï¼Œæ˜ç¡®å†™å‡ºç»‘å®šæœ€é‡è¦çš„å¥½å¤„æ˜¯å®ƒä»¬åœ¨ä»£ç å’Œæ–‡æ¡£é‡Œéƒ½å­˜åœ¨ã€‚ Traits as a Foundation Traits are one of the main organizing features in Rust, and with good reason. Thereâ€™s nothing better to design a program or library around than a good interface.\nChapter 12. Operator Overloading The traits for operator overloading fall into a few categories depending on what part of the language they support.\nç±»åˆ« Trait æ“ä½œç¬¦ Unary operators std::ops::Neg -x std::ops::Not !x Arithmetic operators std::ops::Add x + y std::ops::Sub x - y std::ops::Mul x * y std::ops::Div x / y std::ops::Rem x % y Bitwise operators std::ops::BitAnd x \u0026amp; y std::ops::BitOr `x std::ops::BitXor x ^ y std::ops::Shl x \u0026lt;\u0026lt; y std::ops::Shr x \u0026gt;\u0026gt; y Compound assignment std::ops::AddAssign x += y arithmetic operators std::ops::SubAssign x -= y std::ops::MulAssign x *= y std::ops::DivAssign x /= y std::ops::RemAssign x %= y Compound assignment std::ops::BitAddAssign x \u0026amp;= y bitwise operators std::ops::BitOrAssign `x std::ops::BitXorAssign x ^= y std::ops::ShlAssign x \u0026lt;\u0026lt;= y std::ops::ShrAssign x \u0026gt;\u0026gt;= y Comparison std::cmp::PartialEq x == y, x != y std::cmp::PartialOrd x \u0026lt; y, x \u0026lt;= y, x \u0026gt; y, x \u0026gt;= y Indexing std::ops::Index x[y]ã€\u0026amp;x[y] std::ops::IndexMut x[y] = zã€\u0026amp;mut x[y] Arithmetic and Bitwise Operators std::ops::Addå®šä¹‰ï¼š\n1 2 3 4 trait Add\u0026lt;Rhs = Self\u0026gt; { type Output; fn add(self, rhs: Rhs) -\u0026gt; Self::Output; } å®ç°:\n1 2 3 4 5 6 7 8 9 10 11 12 13 use std::ops::Add; impl\u0026lt;T\u0026gt; Add for Complex\u0026lt;T\u0026gt; where T: Add\u0026lt;Output = T\u0026gt;, { type Output = Self; fn add(self, rhs: Self) -\u0026gt; Self { Complex { re: self.re + rhs.re, im: self.im + rhs.im, } } } æ··åˆå®ç°ï¼ŒåŠ æ³•çš„å·¦è¾¹å’Œå³è¾¹ä¸è¦æ±‚æ˜¯åŒä¸€ç±»å‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 use std::ops::Add; impl\u0026lt;L, R\u0026gt; Add\u0026lt;Complex\u0026lt;R\u0026gt;\u0026gt; for Complex\u0026lt;L\u0026gt; where L: Add\u0026lt;R\u0026gt;, { type Output = Complex\u0026lt;L::Output\u0026gt;; fn add(self, rhs: Complex\u0026lt;R\u0026gt;) -\u0026gt; Self::Output { Complex { re: self.re + rhs.re, im: self.im + rhs.im, } } } Unary Operators Note that ! complements bool values and performs a bitwise complement (that is, flips the bits) when applied to integers; it plays the role of both the ! and ~ operators from C and C++.\n1 2 3 4 5 6 7 8 9 trait Neg { type Output; fn neg(self) -\u0026gt; Self::Output; } trait Not { type Output; fn not(self) -\u0026gt; Self::Output; } å¤æ•°çš„å®ç°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 use std::ops::Neg; impl\u0026lt;T\u0026gt; Neg for Complex\u0026lt;T\u0026gt; where T: Neg\u0026lt;Output = T\u0026gt;, { type Output = Complex\u0026lt;T\u0026gt;; fn neg(self) -\u0026gt; Complex\u0026lt;T\u0026gt; { Complex { re: -self.re, im: -self.im, } } } Binary Operators All of Rustâ€™s numeric types implement the arithmetic operators. Rustâ€™s integer types and bool implement the bitwise operators. There are also implementations that accept references to those types as either or both operands.\nYou can use the + operator to concatenate a String with a \u0026amp;str slice or another String. However, Rust does not permit the left operand of + to be a \u0026amp;str, to discourage building up long strings by repeatedly concatenating small pieces on the left. (This performs poorly, requiring time quadratic in the final length of the string.)\nCompound Assignment Operators A compound assignment expression is one like x += y or x \u0026amp;= y: it takes two operands, performs some operation on them like addition or a bitwise AND, and stores the result back in the left operand. In Rust, the value of a compound assignment expression is always (), never the value stored.\nMany languages have operators like these and usually define them as shorthand for expressions like x = x + y or x = x \u0026amp; y. However, Rust doesnâ€™t take that approach. Instead, x += y is shorthand for the method call x.add_assign(y), where add_assign is the sole method of the std::ops::AddAssign trait:\n1 2 3 trait AddAssign\u0026lt;Rhs = Self\u0026gt; { fn add_assign(\u0026amp;mut self, rhs: Rhs); } The built-in trait for a compound assignment operator is completely independent of the built-in trait for the corresponding binary operator.\nEquivalence Comparisons 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 pub trait PartialEq\u0026lt;Rhs: ?Sized = Self\u0026gt; { /// This method tests for `self` and `other` values to be equal, and is used /// by `==`. #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn eq(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool; /// This method tests for `!=`. #[inline] #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[default_method_body_is_const] fn ne(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { !self.eq(other) } } ç”¨å±æ€§å¿«é€Ÿå®ç°ï¼š\n1 2 3 4 #[derive(Clone, Copy, Debug, PartialEq)] struct Complex\u0026lt;T\u0026gt; { ... } Rustâ€™s automatically generated implementation is essentially identical to our hand-written code, comparing each field or element of the type in turn.\nThis means that comparing non-Copy values like Strings, Vecs, or HashMaps doesnâ€™t cause them to be moved, which would be troublesome:\n1 2 3 4 5 6 let s = \u0026#34;d\\x6fv\\x65t\\x61i\\x6c\u0026#34;.to_string(); let t = \u0026#34;\\x64o\\x76e\\x74a\\x69l\u0026#34;.to_string(); assert!(s == t); // s and t are only borrowed... // ... so they still have their values here. assert_eq!(format!(\u0026#34;{} {}\u0026#34;, s, t), \u0026#34;dovetail dovetail\u0026#34;); Why is this trait called PartialEq? The traditional mathematical definition of an equivalence relation, of which equality is one instance, imposes three requirements. For any values x and y:\nå¯¹ç§°æ€§ï¼šIf x == y is true, then y == x must be true as well. In other words, swapping the two sides of an equality comparison doesnâ€™t affect the result.\nä¼ é€’æ€§ï¼šIf x == y and y == z, then it must be the case thatx == z. Given any chain of values, each equal to the next, each value in the chain is directly equal to every other. Equality is contagious.\nè‡ªåæ€§ï¼šIt must always be true that x == x.\nPartialEqåªå®ç°äº†å‰ä¸¤æ¡ï¼Œè‡ªåæ€§ä¸ä¿è¯ï¼Œæ¯”å¦‚f32å’Œf64å°±ä¸æ»¡è¶³ã€‚0.0/0.0ä¼šäº§ç”Ÿéæ•°å­—çš„å€¼NaNã€‚\n1 2 3 4 5 6 7 8 assert!(f64::is_nan(0.0 / 0.0)); assert_eq!(0.0 / 0.0 == 0.0 / 0.0, false); assert_eq!(0.0 / 0.0 != 0.0 / 0.0, true); assert_eq!(0.0 / 0.0 \u0026lt; 0.0 / 0.0, false); assert_eq!(0.0 / 0.0 \u0026gt; 0.0 / 0.0, false); assert_eq!(0.0 / 0.0 \u0026lt;= 0.0 / 0.0, false); assert_eq!(0.0 / 0.0 \u0026gt;= 0.0 / 0.0, false); Eq Traitï¼š\n1 trait Eq: PartialEq\u0026lt;Self\u0026gt; {} ä¹Ÿå¯ä»¥ç”¨å±æ€§æ¥å¿«é€Ÿå®ç°ï¼š\n1 2 3 4 #[derive(Clone, Copy, Debug, Eq, PartialEq)] struct Complex\u0026lt;T\u0026gt; { ... } Ordered Comparisons std::cmp::PartialOrdï¼š\n1 2 3 4 5 6 7 8 9 10 11 trait PartialOrd\u0026lt;Rhs = Self\u0026gt;: PartialEq\u0026lt;Rhs\u0026gt; where Rhs: ?Sized, { fn partial_cmp(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; Option\u0026lt;Ordering\u0026gt;; fn lt(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { ... } fn le(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { ... } fn gt(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { ... } fn ge(\u0026amp;self, other: \u0026amp;Rhs) -\u0026gt; bool { ... } } 1 2 3 4 5 6 7 8 9 10 11 pub enum Ordering { /// An ordering where a compared value is less than another. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] Less = -1, /// An ordering where a compared value is equal to another. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] Equal = 0, /// An ordering where a compared value is greater than another. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] Greater = 1, } But if partial_cmp returns None, that means self and other are unordered with respect to each other: neither is greater than the other, nor are they equal. Among all of Rustâ€™s primitive types, only comparisons between floating-point values ever return None: specifically, comparing a NaN (not-a-number) value with anything else returns None.\nIf you know that values of two types are always ordered with respect to each other, then you can implement the stricter std::cmp::Ord trait:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 pub trait Ord: Eq + PartialOrd\u0026lt;Self\u0026gt; { /// This method returns an [`Ordering`] between `self` and `other`. /// /// By convention, `self.cmp(\u0026amp;other)` returns the ordering matching the expression /// `self \u0026lt;operator\u0026gt; other` if true. /// /// # Examples /// /// ``` /// use std::cmp::Ordering; /// /// assert_eq!(5.cmp(\u0026amp;10), Ordering::Less); /// assert_eq!(10.cmp(\u0026amp;5), Ordering::Greater); /// assert_eq!(5.cmp(\u0026amp;5), Ordering::Equal); /// ``` #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn cmp(\u0026amp;self, other: \u0026amp;Self) -\u0026gt; Ordering; // ... } Almost all types that implement PartialOrd should also implement Ord. In the standard library, f32 and f64 are the only exceptions to this rule.\næ’åºåº”è¯¥åŒæ—¶å®ç° Partial Ord å’Œ Ord ã€‚You might want to sort by upper bound, for instance, and itâ€™s easy to do that with sort_by_key:\n1 intervals.sort_by_key(|i| i.upper); The Reverse wrapper type takes advantage of this by implementing Ord with a method that simply inverts any ordering.\n1 2 use std::cmp::Reverse; intervals.sort_by_key(|i| Reverse(i.lower)); Index and IndexMut On any other type, the expression a[i] is normally shorthand for *a.index(i), where index is a method of the std::ops::Index trait. However, if the expression is being assigned to or borrowed mutably, itâ€™s instead shorthand for *a.index_mut(i), a call to the method of the std::ops::IndexMut trait.\n1 2 3 4 5 6 7 8 trait Index\u0026lt;Idx\u0026gt; { type Output: ?Sized; fn index(\u0026amp;self, index: Idx) -\u0026gt; \u0026amp;Self::Output; } trait IndexMut\u0026lt;Idx\u0026gt;: Index\u0026lt;Idx\u0026gt; { fn index_mut(\u0026amp;mut self, index: Idx) -\u0026gt; \u0026amp;mut Self::Output; } You can refer to a subslice with an expression like a[i..j] because they also implement Index\u0026lt;Range\u0026lt;usize\u0026gt;\u0026gt;. That expression is shorthand for:\n1 *a.index(std::ops::Range { start: i, end: j }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use std::collections::HashMap; let mut m = HashMap::new(); // HashMap\u0026lt;\u0026amp;str, i32\u0026gt;, å®ç°äº† Index\u0026lt;\u0026amp;str\u0026gt; trait m.insert(\u0026#34;å\u0026#34;, 10); m.insert(\u0026#34;ç™¾\u0026#34;, 100); m.insert(\u0026#34;åƒ\u0026#34;, 1000); m.insert(\u0026#34;ä¸‡\u0026#34;, 1_0000); m.insert(\u0026#34;å„„\u0026#34;, 1_0000_0000); assert_eq!(m[\u0026#34;å\u0026#34;], 10); assert_eq!(m[\u0026#34;åƒ\u0026#34;], 1000); // ç­‰ä»·äº use std::ops::Index; assert_eq!(*m.index(\u0026#34;å\u0026#34;), 10); assert_eq!(*m.index(\u0026#34;åƒ\u0026#34;), 1000); The Index traitâ€™s associated type Output specifies what type an indexing expression produces: for our HashMap, the Index implementationâ€™s Output type is i32.\nRust automatically selects index_mut when the indexing expression occurs in a context where itâ€™s necessary.\n1 2 3 4 let mut desserts = vec![\u0026#34;Howalon\u0026#34;.to_string(), \u0026#34;Soan papdi\u0026#34;.to_string()]; desserts[0].push_str(\u0026#34; (fictional)\u0026#34;); desserts[1].push_str(\u0026#34; (real)\u0026#34;); åä¸¤è¡Œå’Œä¸‹é¢çš„ä»£ç ä¸€æ ·ï¼š\n1 2 use std::ops::IndexMut; (*desserts.index_mut(0)).push_str(\u0026#34; (fictional)\u0026#34;); (*desserts.index_mut(1)).push_str(\u0026#34; (real)\u0026#34;); One limitation of IndexMut is that, by design, it must return a mutable reference to some value.\nThe most common use of indexing is for collections.\nThis is how Index and IndexMut implementations are supposed to behave: out-of-bounds access is detected and causes a panic, the same as when you index an array, slice, or vector out of bounds.\nOther Operators Not all operators can be overloaded in Rust. As of Rust 1.50, the error-checking ? operator works only with Result and Option values, though work is in progress to expand this to user-defined types as well. Similarly, the logical operators \u0026amp;\u0026amp; and || are limited to Boolean values only. The .. and ..= operators always create a struct representing the rangeâ€™s bounds, the \u0026amp; operator always borrows references, and the = operator always moves or copies values. None of them can be overloaded.\nRust does not support overloading the function call operator, f(x). Instead, when you need a callable value, youâ€™ll typically just write a closure.\nChapter 13. Utility Traits Language extension traits\nDrop, Deref and DerefMut From and Into Marker traits\nSized Copy Public vocabulary traits\nDefault AsRef, AsMut, Borrow and BorrowMut TryFrom and TryInto ToOwned Trait Description Drop Destructors. Cleanup code that Rust runs automatically whenever a value is dropped. Sized Marker trait for types with a fixed size known at compile time, as opposed to types (such as slices) that are dynamically sized. Clone Types that support cloning values. Copy Marker trait for types that can be cloned simply by making a byte-for-byte copy of the memory containing the value. Deref and DerefMut Traits for smart pointer types. Default Types that have a sensible â€œdefault value.â€ AsRef and AsMut Conversion traits for borrowing one type of reference from another. Borrow and BorrowMut Conversion traits, like AsRef/AsMut, but additionally guaranteeing consistent hashing, ordering, and equality. From and Into Conversion traits for transforming one type of value into another. TryFrom and TryInto Conversion traits for transforming one type of value into another, for transformations that might fail. ToOwned Conversion trait for converting a reference to an owned value. Drop std::ops::Drop trait\n1 2 3 trait Drop { fn drop(\u0026amp;mut self); } This implicit invocation of drop is the only way to call that method; if you try to invoke it explicitly yourself, Rust flags that as an error.\nIf a variableâ€™s value gets moved elsewhere, so that the variable is uninitialized when it goes out of scope, then Rust will not try to drop that variable: there is no value in it to drop. Although a value may be moved from place to place, Rust drops it only once.\nYou usually wonâ€™t need to implement std::ops::Drop unless youâ€™re defining a type that owns resources Rust doesnâ€™t already know about.\nIf a type implements Drop, it cannot implement the Copy trait. If a type is Copy, that means that simple byte-for-byte duplication is sufficient to produce an independent copy of the value. But it is typically a mistake to call the same drop method more than once on the same data.\nThe standard prelude includes a function to drop a value, drop, but its definition is anything but magical:\n1 fn drop\u0026lt;T\u0026gt;(_x: T) { } ä»è°ƒç”¨è€…é‚£é‡Œè·å¾—æ‰€æœ‰æƒï¼Œç„¶åä»€ä¹ˆä¹Ÿä¸åšã€‚Rustä¼šåœ¨è¶…å‡ºä½œç”¨åŸŸæ—¶æ¸…æ¥š_xçš„å€¼ï¼Œè·Ÿæ¸…é™¤å…¶ä»–å˜é‡çš„å€¼ä¸€æ ·ã€‚\nSized A sized type is one whose values all have the same size in memory.\nAll sized types implement the std::marker::Sized trait, which has no methods or associated types. Rust implements it automatically for all types to which it applies; you canâ€™t implement it yourself. The only use for Sized is as a bound for type variables: a bound like T: Sized requires T to be a type whose size is known at compile time. Traits of this sort are called marker traits, because the Rust language itself uses them to mark certain types as having characteristics of interest.\nRust canâ€™t store unsized values in variables or pass them as arguments. You can only deal with them through pointers like \u0026amp;str or Box\u0026lt;dyn Write\u0026gt;, which themselves are sized.\nIn fact, this is necessary so often that it is the implicit default in Rust: if you write struct S\u0026lt;T\u0026gt; { ... }, Rust understands you to mean struct S\u0026lt;T: Sized\u0026gt; { ... }. If you do not want to constrain T this way, you must explicitly opt out, writing struct S\u0026lt;T: ?Sized\u0026gt; { ... }. The ?Sized syntax is specific to this case and means â€œnot necessarily Sized.â€ For example, if you write struct S\u0026lt;T: ?Sized\u0026gt; { b: Box\u0026lt;T\u0026gt; }, then Rust will allow you to write S\u0026lt;str\u0026gt; and S\u0026lt;dyn Write\u0026gt;, where the box becomes a fat pointer, as well as S\u0026lt;i32\u0026gt; and S\u0026lt;String\u0026gt;, where the box is an ordinary pointer.\nAside from slices and trait objects, there is one more kind of unsized type. A struct typeâ€™s last field (but only its last) may be unsized, and such a struct is itself unsized.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;Rc\u0026#34;)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_insignificant_dtor] pub struct Rc\u0026lt;T: ?Sized\u0026gt; { ptr: NonNull\u0026lt;RcBox\u0026lt;T\u0026gt;\u0026gt;, phantom: PhantomData\u0026lt;RcBox\u0026lt;T\u0026gt;\u0026gt;, } // This is repr(C) to future-proof against possible field-reordering, which // would interfere with otherwise safe [into|from]_raw() of transmutable // inner types. #[repr(C)] struct RcBox\u0026lt;T: ?Sized\u0026gt; { strong: Cell\u0026lt;usize\u0026gt;, weak: Cell\u0026lt;usize\u0026gt;, value: T, } Clone std::clone::Clone\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 pub trait Clone: Sized { /// Returns a copy of the value. /// /// # Examples /// /// ``` /// # #![allow(noop_method_call)] /// let hello = \u0026#34;Hello\u0026#34;; // \u0026amp;str implements Clone /// /// assert_eq!(\u0026#34;Hello\u0026#34;, hello.clone()); /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[must_use = \u0026#34;cloning is often expensive and is not expected to have side effects\u0026#34;] fn clone(\u0026amp;self) -\u0026gt; Self; /// Performs copy-assignment from `source`. /// /// `a.clone_from(\u0026amp;b)` is equivalent to `a = b.clone()` in functionality, /// but can be overridden to reuse the resources of `a` to avoid unnecessary /// allocations. #[inline] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[default_method_body_is_const] #[cfg_attr(not(bootstrap), allow(drop_bounds))] // FIXME remove `~const Drop` and this attr when bumping fn clone_from(\u0026amp;mut self, source: \u0026amp;Self) where Self: ~const Drop + ~const Destruct, { *self = source.clone() } } clone_fromæ–¹æ³•å°†selfä¿®æ”¹ä¸ºsourceçš„ä¸€ä¸ªå‰¯æœ¬ã€‚è¿™ä¸ªæ–¹æ³•çš„é»˜è®¤å®šä¹‰çŸ¥è¯†ç®€å•åœ°å…‹éš†äº†sourceï¼Œç„¶åå°†å‰¯æœ¬è½¬ç§»åˆ°*selfä¸­ã€‚è¯­å¥s = t.clone();å¿…é¡»å…ˆå…‹éš†tï¼Œæ¸…é™¤såŸæ¥çš„å€¼ï¼Œç„¶åå†å°†å…‹éš†çš„å€¼è½¬ç§»åˆ°sä¸­ã€‚è¿™æ¶‰åŠä¸€æ¬¡å †åˆ†é…å’Œä¸€æ¬¡å †é‡Šæ”¾ã€‚åœ¨æ³›å‹ä»£ç ä¸­ï¼Œåº”è¯¥å°½å¯èƒ½ä½¿ç”¨clone_fromï¼Œä»è€Œåœ¨å¯èƒ½çš„æƒ…å†µä¸‹åº”ç”¨è¿™ç§ä¼˜åŒ–ã€‚\nåŠ ä¸Š#[derive(Clone)]å®ç°ã€‚\næ²¡æœ‰å®ç°Cloneï¼šstd::sync::Mutexã€stf::file::Fileï¼ˆä½†æ˜¯æä¾›äº†ä¸€ä¸ªtry_clone()æ–¹æ³•ï¼‰ã€‚\nCopy A type is Copy if it implements the std::marker::Copy marker trait, which is defined as follows:\n1 2 3 pub trait Copy: Clone { // Empty. } But because Copy is a marker trait with special meaning to the language, Rust permits a type to implement Copy only if a shallow byte-for-byte copy is all it needs. Types that own any other resources, like heap buffers or operating system handles, cannot implement Copy. Any type that implements the Drop trait cannot be Copy. Rust presumes that if a type needs special cleanup code, it must also require special copying code and thus canâ€™t be Copy.\nAs with Clone, you can ask Rust to derive Copy for you, using #[derive(Copy)]. You will often see both derived at once, with #[derive(Copy, Clone)].\nDeref and DerefMut std::ops::Deref\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #[lang = \u0026#34;deref\u0026#34;] #[doc(alias = \u0026#34;*\u0026#34;)] #[doc(alias = \u0026#34;\u0026amp;*\u0026#34;)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_diagnostic_item = \u0026#34;Deref\u0026#34;] pub trait Deref { /// The resulting type after dereferencing. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_diagnostic_item = \u0026#34;deref_target\u0026#34;] #[lang = \u0026#34;deref_target\u0026#34;] type Target: ?Sized; /// Dereferences the value. #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_diagnostic_item = \u0026#34;deref_method\u0026#34;] fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target; } std::ops::DerefMut\n1 2 3 4 5 6 7 8 #[lang = \u0026#34;deref_mut\u0026#34;] #[doc(alias = \u0026#34;*\u0026#34;)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] pub trait DerefMut: Deref { /// Mutably dereferences the value. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn deref_mut(\u0026amp;mut self) -\u0026gt; \u0026amp;mut Self::Target; } Since the methods return a reference with the same lifetime as \u0026amp;self, self remains borrowed for as long as the returned reference lives.\nç”±äºderefæ¥æ”¶\u0026amp;selfå¼•ç”¨å¹¶è¿”å›\u0026amp;Self::Targetå¼•ç”¨ï¼Œå› æ­¤Rustä¼šåˆ©ç”¨è¿™ä¸€ç‚¹è‡ªåŠ¨å°†å‰ä¸€ç§ç±»å‹çš„å¼•ç”¨è½¬æ¢ä¸ºåä¸€ç§ç±»å‹çš„å¼•ç”¨ã€‚æ¢ä¸€å¥è¯è¯´ï¼Œå¦‚æœæ’å…¥ä¸€æ¬¡derefè°ƒç”¨å¯ä»¥é˜²æ­¢ç±»å‹é”™é…ï¼Œé‚£Rustä¼šä¸ºä½ æ’å…¥ä¸€æ¬¡ã€‚å®ç°DerefMutå¯ä»¥å®ç°å¯¹å¯ä¿®æ”¹å¼•ç”¨çš„ç±»å‹è½¬æ¢ã€‚è¿™ç§ç±»å‹è½¬æ¢ç§°ä¸ºè§£å¼•ç”¨å¼ºåˆ¶è½¬å‹(deref coercion)ï¼Œå³ä¸€ç§ç±»å‹è¢«â€œå¼ºåˆ¶â€è¡¨ç°å‡ºå¦ä¸€ç§ç±»å‹çš„è¡Œä¸ºã€‚\nä½¿ç”¨è§£å¼•ç”¨å¼ºåˆ¶ç±»å‹è½¬æ¢å¾ˆæ–¹ä¾¿ï¼š\nRc\u0026lt;T\u0026gt;å®ç°äº†Deref\u0026lt;Target=T\u0026gt; Stringå®ç°äº†Deref\u0026lt;Target=str\u0026gt; Vec\u0026lt;T\u0026gt;å®ç°äº†Deref\u0026lt;Target=[T]\u0026gt; å¿…è¦æƒ…å†µä¸‹ï¼ŒRustä¼šè¿ç»­å¤šæ¬¡åº”ç”¨è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢ã€‚\nDerefå’ŒDerefMut traitçš„è®¾è®¡åˆè¡·æ˜¯ä¸ºäº†å®ç°æ™ºèƒ½æŒ‡é’ˆç±»å‹ï¼ˆå¦‚Boxã€Rcå’ŒArcï¼‰ï¼Œä»¥åŠæŸäº›é¢‘ç¹é€šè¿‡å¼•ç”¨æ¥ä½¿ç”¨çš„ç±»å‹çš„æ‰€æœ‰è€…ç‰ˆæœ¬ï¼ˆå¦‚Vec\u0026lt;T\u0026gt;å’ŒStringå°±æ˜¯[T]å’Œstrçš„æ‰€æœ‰è€…ç‰ˆæœ¬ï¼‰ã€‚\nRusté€šè¿‡åº”ç”¨è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢æ¥è§£å†³ç±»å‹å†²çªï¼Œä½†ä¸ä¼šåº”ç”¨å®ƒæ¥æ»¡è¶³ç±»å‹å˜é‡çš„ç»‘å®šã€‚\n1 2 use std::fmt::Display; fn show_it_generic\u0026lt;T: Display\u0026gt;(thing: T) { println!(\u0026#34;{}\u0026#34;, thing); } show_it_generic(\u0026amp;s); // error Rustä¸ä¼šåœ¨æ»¡è¶³ç±»å‹å˜é‡çš„ç»‘å®šæ—¶åº”ç”¨è§£å¼•ç”¨å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œæ‰€ä»¥æ£€æŸ¥å¤±è´¥ã€‚\n1 2 3 4 // è§£å†³è¿™ä¸ªé—®é¢˜ show_it_generic(\u0026amp;s as \u0026amp;str); // Or show_it_generic(\u0026amp;*s); Default std::default::Default\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;Default\u0026#34;)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] pub trait Default: Sized { /// Returns the \u0026#34;default value\u0026#34; for a type. /// /// Default values are often some kind of initial value, identity value, or anything else that /// may make sense as a default. /// /// # Examples /// /// Using built-in default values: /// /// ``` /// let i: i8 = Default::default(); /// let (x, y): (Option\u0026lt;String\u0026gt;, f64) = Default::default(); /// let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default(); /// ``` /// /// Making your own: /// /// ``` /// # #[allow(dead_code)] /// enum Kind { /// A, /// B, /// C, /// } /// /// impl Default for Kind { /// fn default() -\u0026gt; Self { Kind::A } /// } /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn default() -\u0026gt; Self; } 1 2 3 4 5 6 7 use std::collections::HashSet; let squares = [4, 9, 16, 25, 36, 49, 64]; let (powers_of_two, impure): (HashSet\u0026lt;i32\u0026gt;, HashSet\u0026lt;i32\u0026gt;) = squares.iter().partition(|\u0026amp;n| n \u0026amp; (n-1) == 0); assert_eq!(powers_of_two.len(), 3); assert_eq!(impure.len(), 4); But of course, partition isnâ€™t specific to HashSets; you can use it to produce any sort of collection you like, as long as the collection type implements Default, to produce an empty collection to start with, and Extend\u0026lt;T\u0026gt;, to add a T to the collection. String implements Default and Extend\u0026lt;char\u0026gt;, so you can write:\n1 2 3 4 let (upper, lower): (String, String) = \u0026#34;Great Teacher Onizuka\u0026#34;.chars().partition(|\u0026amp;c| c.is_uppercase()); assert_eq!(upper, \u0026#34;GTO\u0026#34;); assert_eq!(lower, \u0026#34;reat eacher nizuka\u0026#34;); Another common use of Default is to produce default values for structs that represent a large collection of parameters, most of which you wonâ€™t usually need to change.\n1 2 3 4 5 6 7 let params = glium::DrawParameters { line_width: Some(0.02), point_size: Some(0.02), .. Default::default() }; target.draw(..., \u0026amp;params).unwrap(); If a type T implements Default, then the standard library implements Default automatically for Rc\u0026lt;T\u0026gt;, Arc\u0026lt;T\u0026gt;, Box\u0026lt;T\u0026gt;, Cell\u0026lt;T\u0026gt;, RefCell\u0026lt;T\u0026gt;, Cow\u0026lt;T\u0026gt;, Mutex\u0026lt;T\u0026gt;, and RwLock\u0026lt;T\u0026gt;. The default value for the type Rc\u0026lt;T\u0026gt;, for example, is an Rc pointing to the default value for type T.\nå¦‚æœå…ƒç»„ç±»å‹çš„æ‰€æœ‰ç±»å‹éƒ½å®ç°äº†Defaultï¼Œä¸”è¯¥è¯¥å…ƒç»„ç±»å‹ä¹Ÿå®ç°äº†Defaultï¼Œé‚£ä¹ˆè¿™ä¸ªå…ƒç»„é»˜è®¤ä¼šæŒæœ‰æ¯ä¸ªå…ƒç´ çš„é»˜è®¤å€¼ã€‚\nRust does not implicitly implement Default for struct types, but if all of a structâ€™s fields implement Default, you can implement Default for the struct automatically using # [derive(Default)].\nAsRef and AsMut std::convert::AsRef\n1 2 3 4 5 6 7 #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;AsRef\u0026#34;)] pub trait AsRef\u0026lt;T: ?Sized\u0026gt; { /// Converts this type into a shared reference of the (usually inferred) input type. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn as_ref(\u0026amp;self) -\u0026gt; \u0026amp;T; } std::convert::RefMut\n1 2 3 4 5 6 7 #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;AsMut\u0026#34;)] pub trait AsMut\u0026lt;T: ?Sized\u0026gt; { /// Converts this type into a mutable reference of the (usually inferred) input type. #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn as_mut(\u0026amp;mut self) -\u0026gt; \u0026amp;mut T; } So, for example, Vec\u0026lt;T\u0026gt; implements AsRef\u0026lt;[T]\u0026gt;, and String implements AsRef\u0026lt;str\u0026gt;. You can also borrow a Stringâ€™s contents as an array of bytes, so String implements AsRef\u0026lt;[u8]\u0026gt; as well.\nBut this canâ€™t be the whole story. A string literal is a \u0026amp;str, but the type that implements AsRef\u0026lt;Path\u0026gt; is str, without an \u0026amp;. And as we explained in â€œDeref and DerefMutâ€, Rust doesnâ€™t try deref coercions to satisfy type variable bounds, so they wonâ€™t help here either.\nFortunately, the standard library includes the blanket implementation:\n1 2 3 4 5 6 7 8 impl\u0026lt;\u0026#39;a, T, U\u0026gt; AsRef\u0026lt;U\u0026gt; for \u0026amp;\u0026#39;a T where T: AsRef\u0026lt;U\u0026gt;, T: ?Sized, U: ?Sized { fn as_ref(\u0026amp;self) -\u0026gt; \u0026amp;U { (*self).as_ref() } } In other words, for any types T and U, if T: AsRef\u0026lt;U\u0026gt;, then \u0026amp;T: AsRef\u0026lt;U\u0026gt; as well: simply follow the reference and proceed as before.\nYou might assume that if a type implements AsRef, it should also implement AsMut. However, there are cases where this isnâ€™t appropriate.\nBorrow and BorrowMut The std::borrow::Borrow trait is similar to AsRef: if a type implements Borrow\u0026lt;T\u0026gt;, then its borrow method efficiently borrows a \u0026amp;T from it. But Borrow imposes more restrictions: a type should implement Borrow only when a \u0026amp;T hashes and compares the same way as the value itâ€™s borrowed from. (Rust doesnâ€™t enforce this; itâ€™s just the documented intent of the trait.) This makes Borrow valuable in dealing with keys in hash tables and trees or when dealing with values that will be hashed or compared for some other reason.\n1 2 3 4 5 6 #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_diagnostic_item = \u0026#34;Borrow\u0026#34;] pub trait Borrow\u0026lt;Borrowed: ?Sized\u0026gt; { #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] fn borrow(\u0026amp;self) -\u0026gt; \u0026amp;Borrowed; } Borrow is designed to address a specific situation with generic hash tables and other associative collection types.\n1 2 3 4 5 6 7 impl\u0026lt;K, V\u0026gt; HashMap\u0026lt;K, V\u0026gt; where K: Eq + Hash { fn get\u0026lt;Q: ?Sized\u0026gt;(\u0026amp;self, key: \u0026amp;Q) -\u0026gt; Option\u0026lt;\u0026amp;V\u0026gt; where K: Borrow\u0026lt;Q\u0026gt;, Q: Eq + Hash { ... } } Vec and [T: N] implement Borrow\u0026lt;[T]\u0026gt;. Every string-like type allows borrowing its corresponding slice type: String implements Borrow, PathBuf implements Borrow, and so on. And all the standard libraryâ€™s associative collection types use Borrow to decide which types can be passed to their lookup functions.\nThe standard library includes a blanket implementation so that every type T can be borrowed from itself: T: Borrow. This ensures that \u0026amp;K is always an acceptable type for looking up entries in a HashMap\u0026lt;K, V\u0026gt;.\nstd::borrow::BorrowMut\n1 2 3 trait BorrowMut\u0026lt;Borrowed: ?Sized\u0026gt;: Borrow\u0026lt;Borrowed\u0026gt; { fn borrow_mut(\u0026amp;mut self) -\u0026gt; \u0026amp;mut Borrowed; } From and Into The std::convert::From and std::convert::Into traits represent conversions that consume a value of one type and return a value of another.\n1 2 3 4 5 6 trait Into\u0026lt;T\u0026gt;: Sized { fn into(self) -\u0026gt; T; } trait From\u0026lt;T\u0026gt;: Sized { fn from(other: T) -\u0026gt; Self; } The standard library automatically implements the trivial conversion from each type to itself: every type T implements From\u0026lt;T\u0026gt; and Into\u0026lt;T\u0026gt;.\nYou generally use Into to make your functions more flexible in the arguments they accept.\nThe from method serves as a generic constructor for producing an instance of a type from some other single value.\nGiven an appropriate From implementation, the standard library automatically implements the corresponding Into trait.\nHowever, cheap conversions are not part of Into and Fromâ€™s contract. Whereas AsRef and AsMut conversions are expected to be cheap, From and Into conversions may allocate, copy, or otherwise process the valueâ€™s contents.\nThe ? operator uses From and Into to help clean up code in functions that could fail in multiple ways by automatically converting from specific error types to general ones when needed.\n1 2 3 4 5 6 type GenericError = Box\u0026lt;dyn std::error::Error + Send + Sync + \u0026#39;static\u0026gt;; type GenericResult\u0026lt;T\u0026gt; = Result\u0026lt;T, GenericError\u0026gt;; fn parse_i32_bytes(b: \u0026amp;[u8]) -\u0026gt; GenericResult\u0026lt;i32\u0026gt; Ok(std::str::from_utf8(b)?.parse::\u0026lt;i32\u0026gt;()?) }\t1 2 3 4 5 6 impl\u0026lt;\u0026#39;a, E: Error + Send + Sync + \u0026#39;a\u0026gt; From\u0026lt;E\u0026gt; for Box\u0026lt;dyn Error + Send + Sync + \u0026#39;a\u0026gt; { fn from(err: E) -\u0026gt; Box\u0026lt;dyn Error + Send + Sync + \u0026#39;a\u0026gt; { Box::new(err) } } From and Into are infallible traitsâ€”their API requires that conversions will not fail.\nTryFrom and TryInto Instead, i32 implements TryFrom. TryFrom and TryInto are the fallible cousins of From and Into and are similarly reciprocal; implementing TryFrom means that TryInto is implemented as well.\n1 2 3 4 5 6 7 8 9 pub trait TryFrom\u0026lt;T\u0026gt;: Sized { type Error; fn try_from(value: T) -\u0026gt; Result\u0026lt;Self, Self::Error\u0026gt;; } pub trait TryInto\u0026lt;T\u0026gt;: Sized { type Error; fn try_into(self) -\u0026gt; Result\u0026lt;T, Self::Error\u0026gt;; } Where From and Into relate types with simple conversions, TryFrom and TryInto extend the simplicity of From and Into conversions with the expressive error handling afforded by Result. These four traits can be used together to relate many types in a single crate.\nToOwned The std::borrow::ToOwned trait provides a slightly looser way to convert a reference to an owned value:\n1 2 3 4 trait ToOwned { type Owned: Borrow\u0026lt;Self\u0026gt;; fn to_owned(\u0026amp;self) -\u0026gt; Self::Owned; } Borrow and ToOwned at Work: The Humble Cow But in some cases you cannot decide whether to borrow or own until the program is running ; the std::borrow::Cow type (for â€œclone on writeâ€) provides one way to do this.\n1 2 3 4 5 6 enum Cow\u0026lt;\u0026#39;a, B: ?Sized\u0026gt; where B: ToOwned { Borrowed(\u0026amp;\u0026#39;a B), Owned(\u0026lt;B as ToOwned\u0026gt;::Owned), } A Cow\u0026lt;B\u0026gt; either borrows a shared reference to a B or owns a value from which we could borrow such a reference. Since Cow implements Deref, you can call methods on it as if it were a shared reference to a B: if itâ€™s Owned, it borrows a shared reference to the owned value; and if itâ€™s Borrowed, it just hands out the reference itâ€™s holding.\nYou can also get a mutable reference to a Cowâ€™s value by calling its to_mut method, which returns a \u0026amp;mut B. If the Cow happens to be Cow::Borrowed, to_mut simply calls the referenceâ€™s to_owned method to get its own copy of the referent, changes the Cow into a Cow::Owned, and borrows a mutable reference to the newly owned value. This is the â€œclone on writeâ€ behavior the typeâ€™s name refers to.\nOne common use for Cow is to return either a statically allocated string constant or a computed string.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use std::path::PathBuf; use std::borrow::Cow; fn describe(error: \u0026amp;Error) -\u0026gt; Cow\u0026lt;\u0026#39;static, str\u0026gt; { match *error { Error::OutOfMemory =\u0026gt; \u0026#34;out of memory\u0026#34;.into(), Error::StackOverflow =\u0026gt; \u0026#34;stack overflow\u0026#34;.into(), Error::MachineOnFire =\u0026gt; \u0026#34;machine on fire\u0026#34;.into(), Error::Unfathomable =\u0026gt; \u0026#34;machine bewildered\u0026#34;.into(), Error::FileNotFound(ref path) =\u0026gt; { format!(\u0026#34;file not found: {}\u0026#34;, path.display()).into() } } } Chapter 14. Closures Itâ€™s more concise to write the helper function as a closure, an anonymous function expression:\n1 2 3 fn sort_cities(cities: \u0026amp;mut Vec\u0026lt;City\u0026gt;) { cities.sort_by_key(|city| - city.population); } Capturing Variables A closure can use data that belongs to an enclosing function.\n1 2 3 fn sort_cities(cities: \u0026amp;mut Vec\u0026lt;City\u0026gt;) { cities.sort_by_key(|city| - city.population); } Closures That Borrow In this case, when Rust creates the closure, it automatically borrows a reference to stat. It stands to reason: the closure refers to stat, so it must have a reference to it.\nIn short, Rust ensures safety by using lifetimes instead of garbage collection. Rustâ€™s way is faster: even a fast GC allocation will be slower than storing stat on the stack, as Rust does in this case.\nClosures That Steal 1 2 3 4 5 6 7 8 9 10 fn start_sorting_thread(mut cities: Vec\u0026lt;City\u0026gt;, stat: Statistic) -\u0026gt; thread::JoinHandle\u0026lt;Vec\u0026lt;City\u0026gt;\u0026gt; { let key_fn = move |city: \u0026amp;City| -\u0026gt; i64 { -city.get_statistic(stat) }; thread::spawn(move || { cities.sort_by_key(key_fn); cities }) } The only thing weâ€™ve changed is to add the move keyword before each of the two closures. The move keyword tells Rust that a closure doesnâ€™t borrow the variables it uses: it steals them.\nRust thus offers two ways for closures to get data from enclosing scopes: moves and borrowing.\nWe get something important by accepting Rustâ€™s strict rules: thread safety. It is precisely because the vector is moved, rather than being shared across threads, that we know the old thread wonâ€™t free the vector while the new thread is modifying it.\nFunction and Closure Types 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// Given a list of cities and a test function, /// return how many cities pass the test. fn count_selected_cities(cities: \u0026amp;Vec\u0026lt;City\u0026gt;, test_fn: fn(\u0026amp;City) -\u0026gt; bool) -\u0026gt; usize { let mut count = 0; for city in cities { if test_fn(city) { count += 1; } } count } /// An example of a test function. Note that the type of /// this function is `fn(\u0026amp;City) -\u0026gt; bool`, the same as /// the `test_fn` argument to `count_selected_cities`. fn has_monster_attacks(city: \u0026amp;City) -\u0026gt; bool { city.monster_attack_risk \u0026gt; 0.0 } // How many cities are at risk for monster attack? let n = count_selected_cities(\u0026amp;my_cities, has_monster_attacks); 1 2 3 4 5 6 7 8 9 10 fn count_selected_cities\u0026lt;F\u0026gt;(cities: \u0026amp;Vec\u0026lt;City\u0026gt;, test_fn: F) -\u0026gt; usize where F: Fn(\u0026amp;City) -\u0026gt; bool { let mut count = 0; for city in cities { if test_fn(city) { count += 1; } } count } 1 2 fn(\u0026amp;City) -\u0026gt; bool // fn type (functions only) Fn(\u0026amp;City) -\u0026gt; bool // Fn trait (both functions and closures) In fact, every closure you write has its own type, because a closure may contain data: values either borrowed or stolen from enclosing scopes. This could be any number of variables, in any combination of types. So every closure has an ad hoc type created by the compiler, large enough to hold that data. No two closures have exactly the same type. But every closure implements an Fn trait; the closure in our example implements Fn(\u0026amp;City) -\u0026gt; i64.\nClosure Performance As the figure shows, these closures donâ€™t take up much space. But even those few bytes are not always needed in practice. Often, the compiler can inline all calls to a closure, and then even the small structs shown in this figure are optimized away.\nClosures and Safety Closures That Kill 1 2 3 4 5 let my_str = \u0026#34;hello\u0026#34;.to_string(); let f = || drop(my_str); f(); // ok f(); // error: use of moved value A closure that can be called only once may seem like a rather extraordinary thing, but weâ€™ve been talking throughout this book about ownership and lifetimes. The idea of values being used up (that is, moved) is one of the core concepts in Rust. It works the same with closures as with everything else.\nFnOnce The first time you call a FnOnce closure, the closure itself is used up. Itâ€™s as though the two traits, Fn and FnOnce, were defined like this:\n1 2 3 4 5 6 7 8 // Pseudocode for `Fn` and `FnOnce` traits with no arguments. trait Fn() -\u0026gt; R { fn call(\u0026amp;self) -\u0026gt; R; } trait FnOnce() -\u0026gt; R { fn call_once(self) -\u0026gt; R; } Just as an arithmetic expression like a + b is shorthand for a method call, Add::add(a, b), Rust treats closure() as shorthand for one of the two trait methods shown in the preceding example. For an Fn closure, closure() expands to closure.call(). This method takes self by reference, so the closure is not moved. But if the closure is only safe to call once, then closure() expands to closure.call_once(). That method takes self by value, so the closure is used up.\nFnMut Therefore, Rust has one more category of closure, FnMut, the category of closures that write. FnMut closures are called by mut reference, as if they were defined like this:\n1 2 3 4 5 6 7 8 9 10 11 12 // Pseudocode for `Fn`, `FnMut`, and `FnOnce` traits. trait Fn() -\u0026gt; R { fn call(\u0026amp;self) -\u0026gt; R; } trait FnMut() -\u0026gt; R { fn call_mut(\u0026amp;mut self) -\u0026gt; R; } trait FnOnce() -\u0026gt; R { fn call_once(self) -\u0026gt; R; } Any closure that requires mut access to a value, but doesnâ€™t drop any values, is an FnMut closure.\nFn is the family of closures and functions that you can call multiple times without restriction. This highest category also includes all fn functions. FnMut is the family of closures that can be called multiple times if the closure itself is declared mut. FnOnce is the family of closures that can be called once, if the caller owns the closure. Copy and Clone for Closures Just as Rust automatically figures out which closures can be called only once, it can figure out which closures can implement Copy and Clone, and which cannot.\nA non-move closure that doesnâ€™t mutate variables holds only shared references, which are both Clone and Copy, so that closure is both Clone and Copy as well.\nOn the other hand, a non-move closure that does mutate values has mutable references within its internal representation. Mutable references are neither Clone nor Copy, so neither is a closure that uses them.\nFor a move closure, the rules are even simpler. If everything a move closure captures is Copy, itâ€™s Copy. If everything it captures is Clone, itâ€™s Clone.\nCallbacks Closures have unique types because each one captures different variables, so among other things, theyâ€™re each a different size. If they donâ€™t capture anything, though, thereâ€™s nothing to store. By using fn pointers in functions that take callbacks, you can restrict a caller to use only these noncapturing closures, gaining some perfomance and flexibility within the code using callbacks at the cost of flexibility for the users of your API.\nUsing Closures Effectively MVC\næ›¿ä»£æ–¹æ¡ˆï¼š\nChapter 15. Iterators 1 2 3 4 5 6 7 fn triangle(n: i32) -\u0026gt; i32 { let mut sum = 0; for i in 1..=n { sum += i; } sum } è¿™é‡Œ1..=næ˜¯ä¸€ä¸ªRangeInclusive\u0026lt;i32\u0026gt;çš„å€¼ã€‚A RangeInclusive\u0026lt;i32\u0026gt; is an iterator that produces the integers from its start value to its end value (both inclusive), so you can use it as the operand of the for loop to sum the values from 1 to n.\nä¹Ÿå¯ä»¥ç”¨é—­åŒ…å†™ï¼Œæ›´ç®€æ´å’Œä¼˜é›…ï¼š\n1 2 3 fn triangle(n: i32) -\u0026gt; i32 { (1..=n).fold(0, |sum, item| sum + item) } The Iterator and IntoIterator Traits std::iter::Iterator\n1 2 3 4 5 trait Iterator { type Item; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; ... // many default methods } std::iter::IntoIterator\n1 2 3 4 5 trait IntoIterator where Self::IntoIter: Iterator\u0026lt;Item=Self::Item\u0026gt; { type Item; type IntoIter: Iterator; fn into_iter(self) -\u0026gt; Self::IntoIter; } è¿™ä¸ªè¡¨ç¤ºå¯è¿­ä»£çš„ï¼Œå¯ä»¥è°ƒç”¨ into_iter() æ–¹æ³•äº§ç”Ÿä¸€ä¸ªè¿­ä»£å™¨ã€‚\n1 2 3 4 5 println!(\u0026#34;There\u0026#39;s:\u0026#34;); let v = vec![\u0026#34;antimony\u0026#34;, \u0026#34;arsenic\u0026#34;, \u0026#34;aluminum\u0026#34;, \u0026#34;selenium\u0026#34;]; for element in \u0026amp;v { println!(\u0026#34;{}\u0026#34;, element); } ç­‰ä»·äº\n1 2 3 4 let mut iterator = (\u0026amp;v).into_iter(); while let Some(element) = iterator.next() { println!(\u0026#34;{}\u0026#34;, element); } Although a for loop always calls into_iter on its operand, you can also pass iterators to for loops directly; this occurs when you loop over a Range, for example. All iterators automatically implement IntoIterator, with an into_iter method that simply returns the iterator.\nCreating Iterators iter and iter_mut Methods Most collection types provide iter and iter_mut methods that return the natural iterators over the type, producing a shared or mutable reference to each item.\n1 2 3 4 5 6 7 8 let v = vec![4, 20, 12, 8, 6]; let mut iterator = v.iter(); assert_eq!(iterator.next(), Some(\u0026amp;4)); assert_eq!(iterator.next(), Some(\u0026amp;20)); assert_eq!(iterator.next(), Some(\u0026amp;12)); assert_eq!(iterator.next(), Some(\u0026amp;8)); assert_eq!(iterator.next(), Some(\u0026amp;6)); assert_eq!(iterator.next(), None); This iteratorâ€™s item type is \u0026amp;i32: each call to next produces a reference to the next element, until we reach the end of the vector.\nFor example, there is no iter method on the \u0026amp;str string slice type. Instead, if s is a \u0026amp;str, then s.bytes() returns an iterator that produces each byte of s, whereas s.chars() interprets the contents as UTF-8 and produces each Unicode character.\nIntoIterator Implementations Most collections actually provide several implementations of IntoIterator, for shared references (\u0026amp;T), mutable references (\u0026amp;mut T), and moves (T):\nGiven a shared reference to the collection, into_iter returns an iterator that produces shared references to its items. For example, in the preceding code, (\u0026amp;favorites).into_iter() would return an iterator whose Item type is \u0026amp;String. Given a mutable reference to the collection, into_iter returns an iterator that produces mutable references to the items. For example, if vector is some Vec, the call (\u0026amp;mut vector).into_iter() returns an iterator whose Item type is \u0026amp;mut String. When passed the collection by value, into_iter returns an iterator that takes ownership of the collection and returns items by value; the itemsâ€™ ownership moves from the collection to the consumer, and the original collection is consumed in the process. For example, the call favorites.into_iter() in the preceding code returns an iterator that produces each string by value; the consumer receives ownership of each string. When the iterator is dropped, any elements remaining in the BTreeSet are dropped too, and the setâ€™s now-empty husk is disposed of. The general principle is that iteration should be efficient and predictable, so rather than providing implementations that are expensive or could exhibit surprising behavior (for example, rehashing modified HashSet entries and potentially encountering them again later in the iteration), Rust omits them entirely.\nç”¨åœ¨æ³›å‹ä¸Šï¼š\n1 2 3 4 5 6 7 8 9 10 use std::fmt::Debug; fn dump\u0026lt;T, U\u0026gt;(t: T) where T: IntoIterator\u0026lt;Item=U\u0026gt;, U: Debug { for u in t { println!(\u0026#34;{:?}\u0026#34;, u); } } from_fn and successors std::iter::from_fn\n1 2 3 4 5 6 7 8 pub fn from_fn\u0026lt;T, F\u0026gt;(f: F) -\u0026gt; FromFn\u0026lt;F\u0026gt; where F: FnMut() -\u0026gt; Option\u0026lt;T\u0026gt;, impl\u0026lt;T, F\u0026gt; Iterator for FromFn\u0026lt;F\u0026gt; where F: FnMut() -\u0026gt; Option\u0026lt;T\u0026gt;, type Item = T; 1 2 3 4 5 6 7 8 9 10 11 use rand::random; // In Cargo.toml dependencies: rand = \u0026#34;0.7\u0026#34; use std::iter::from_fn; // Generate the lengths of 1000 random line segments whose endpoints // are uniformly distributed across the interval [0, 1]. (This isn\u0026#39;t a // distribution you\u0026#39;re going to find in the `rand_distr` crate, but // it\u0026#39;s easy to make yourself.) let lengths: Vec\u0026lt;f64\u0026gt; = from_fn(|| Some((random::\u0026lt;f64\u0026gt;() - random::\u0026lt;f64\u0026gt;()).abs())) .take(1000) .collect(); If each item depends on the one before, std::iter::successors.\n1 2 3 4 5 6 7 8 pub fn successors\u0026lt;T, F\u0026gt;(first: Option\u0026lt;T\u0026gt;, succ: F) -\u0026gt; Successors\u0026lt;T, F\u0026gt;â“˜ where F: FnMut(\u0026amp;T) -\u0026gt; Option\u0026lt;T\u0026gt;, impl\u0026lt;T, F\u0026gt; Iterator for Successors\u0026lt;T, F\u0026gt; where F: FnMut(\u0026amp;T) -\u0026gt; Option\u0026lt;T\u0026gt;, type Item = T; 1 2 3 4 5 6 7 8 9 10 11 use num::Complex; use std::iter::successors; fn escape_time(c: Complex\u0026lt;f64\u0026gt;, limit: usize) -\u0026gt; Option\u0026lt;usize\u0026gt; { let zero = Complex { re: 0.0, im: 0.0 }; successors(Some(zero), |\u0026amp;z| { Some(z * z + c) }) .take(limit) .enumerate() .find(|(_i, z)| z.norm_sqr() \u0026gt; 4.0) .map(|(i, _z)| i) } æ–æ³¢é‚£å¥‘æ•°åˆ—\n1 2 3 4 5 6 7 8 9 10 fn fibonacci() -\u0026gt; impl Iterator\u0026lt;Item=usize\u0026gt; { let mut state = (0, 1); std::iter::from_fn(move || { state = (state.1, state.0 + state.1); Some(state.0) }) } assert_eq!(fibonacci().take(8).collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(), vec![1, 1, 2, 3, 5, 8, 13, 21]); drain Methods Many collection types provide a drain method that takes a mutable reference to the collection and returns an iterator that passes ownership of each element to the consumer. However, unlike the into_iter() method, which takes the collection by value and consumes it, drain merely borrows a mutable reference to the collection, and when the iterator is dropped, it removes any remaining elements from the collection and leaves it empty.\n1 2 3 4 use std::iter::FromIterator; let mut outer = \u0026#34;Earth\u0026#34;.to_string(); let inner = String::from_iter(outer.drain(1..4)); assert_eq!(outer, \u0026#34;Eh\u0026#34;); assert_eq!(inner, \u0026#34;art\u0026#34;); Other Iterator Sources çœç•¥\nIterator Adapters map and filter The Iterator traitâ€™s map adapter lets you transform an iterator by applying a closure to its items. The filter adapter lets you filter out items from an iterator, using a closure to decide which to keep and which to drop.\n1 2 3 4 5 let text = \u0026#34; ponies \\n giraffes\\niguanas \\nsquid\u0026#34;.to_string(); let v: Vec\u0026lt;\u0026amp;str\u0026gt; = text.lines() .map(str::trim) .collect(); assert_eq!(v, [\u0026#34;ponies\u0026#34;, \u0026#34;giraffes\u0026#34;, \u0026#34;iguanas\u0026#34;, \u0026#34;squid\u0026#34;]); 1 2 3 4 5 let text = \u0026#34; ponies \\n giraffes\\niguanas \\nsquid\u0026#34;.to_string(); let v: Vec\u0026lt;\u0026amp;str\u0026gt; = text.lines() .map(str::trim) .filter(|s| *s != \u0026#34;iguanas\u0026#34;) .collect(); assert_eq!(v, [\u0026#34;ponies\u0026#34;, \u0026#34;giraffes\u0026#34;, \u0026#34;squid\u0026#34;]); 1 2 3 4 5 6 7 // æ ‡å‡†åº“ä¸­è¿”å›çš„æ˜¯ std::iter::Map fn map\u0026lt;B, F\u0026gt;(self, f: F) -\u0026gt; impl Iterator\u0026lt;Item=B\u0026gt; where Self: Sized, F: FnMut(Self::Item) -\u0026gt; B; // æ ‡å‡†åº“ä¸­è¿”å›çš„æ˜¯ std::iter::Filter fn filter\u0026lt;P\u0026gt;(self, predicate: P) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized, P: FnMut(\u0026amp;Self::Item) -\u0026gt; bool; First, simply calling an adapter on an iterator doesnâ€™t consume any items; it just returns a new iterator, ready to produce its own items by drawing from the first iterator as needed. In a chain of adapters, the only way to make any work actually get done is to call next on the final iterator.\nThe term â€œlazyâ€ in the error message is not a disparaging term; itâ€™s just jargon for any mechanism that puts off a computation until its value is needed. It is Rustâ€™s convention that iterators should do the minimum work necessary to satisfy each call to next; in the example, there are no such calls at all, so no work takes place.\nThe second important point is that iterator adapters are a zero-overhead abstraction.\nfilter_map and flat_map 1 2 fn filter_map\u0026lt;B, F\u0026gt;(self, f: F) -\u0026gt; impl Iterator\u0026lt;Item=B\u0026gt; where Self: Sized, F: FnMut(Self::Item) -\u0026gt; Option\u0026lt;B\u0026gt;; 1 2 3 4 5 6 7 use std::str::FromStr; let text = \u0026#34;1\\nfrond .25 289\\n3.1415 estuary\\n\u0026#34;; for number in text .split_whitespace() .filter_map(|w| f64::from_str(w).ok()) { println!(\u0026#34;{:4.2}\u0026#34;, number.sqrt()); } 1 2 fn flat_map\u0026lt;U, F\u0026gt;(self, f: F) -\u0026gt; impl Iterator\u0026lt;Item=U::Item\u0026gt; where F: FnMut(Self::Item) -\u0026gt; U, U: IntoIterator; 1 2 3 4 5 6 7 8 use std::collections::HashMap; let mut major_cities = HashMap::new(); major_cities.insert(\u0026#34;Japan\u0026#34;, vec![\u0026#34;Tokyo\u0026#34;, \u0026#34;Kyoto\u0026#34;]); major_cities.insert(\u0026#34;The United States\u0026#34;, vec![\u0026#34;Portland\u0026#34;, \u0026#34;Nashville\u0026#34;]); major_cities.insert(\u0026#34;Brazil\u0026#34;, vec![\u0026#34;SÃ£o Paulo\u0026#34;, \u0026#34;BrasÃ­lia\u0026#34;]); major_cities.insert(\u0026#34;Kenya\u0026#34;, vec![\u0026#34;Nairobi\u0026#34;, \u0026#34;Mombasa\u0026#34;]); major_cities.insert(\u0026#34;The Netherlands\u0026#34;, vec![\u0026#34;Amsterdam\u0026#34;, \u0026#34;Utrecht\u0026#34;]); let countries = [\u0026#34;Japan\u0026#34;, \u0026#34;Brazil\u0026#34;, \u0026#34;Kenya\u0026#34;]; for \u0026amp;city in countries.iter().flat_map(|country| \u0026amp;major_cities[country]) { println!(\u0026#34;{}\u0026#34;, city); } è¿è¡Œç»“æœï¼š\n1 2 3 4 5 6 Tokyo Kyoto SÃ£o Paulo BrasÃ­lia Nairobi Mombasa flatten 1 2 3 4 5 6 7 8 9 10 11 12 13 use std::collections::BTreeMap; // A table mapping cities to their parks: each value is a vector. let mut parks = BTreeMap::new(); parks.insert(\u0026#34;Portland\u0026#34;, vec![\u0026#34;Mt. Tabor Park\u0026#34;, \u0026#34;Forest Park\u0026#34;]); parks.insert(\u0026#34;Kyoto\u0026#34;, vec![\u0026#34;Tadasu-no-Mori Forest\u0026#34;, \u0026#34;Maruyama Koen\u0026#34;]); parks.insert(\u0026#34;Nashville\u0026#34;, vec![\u0026#34;Percy Warner Park\u0026#34;, \u0026#34;Dragon Park\u0026#34;]); // Build a vector of all parks. `values` gives us an iterator producing // vectors, and then `flatten` produces each vector\u0026#39;s elements in turn. let all_parks: Vec\u0026lt;_\u0026gt; = parks.values().flatten().cloned().collect(); assert_eq!(all_parks, vec![\u0026#34;Tadasu-no-Mori Forest\u0026#34;, \u0026#34;Maruyama Koen\u0026#34;, \u0026#34;Percy Warner Park\u0026#34;, \u0026#34;Dragon Park\u0026#34;, \u0026#34;Mt. Tabor Park\u0026#34;, \u0026#34;Forest Park\u0026#34;]); 1 2 fn flatten(self) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item::Item\u0026gt; where Self::Item: IntoIterator; take and take_while The Iterator traitâ€™s take and take_while adapters let you end an iteration after a certain number of items or when a closure decides to cut things off.\n1 2 3 4 fn take(self, n: usize) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized; fn take_while\u0026lt;P\u0026gt;(self, predicate: P) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized, P: FnMut(\u0026amp;Self::Item) -\u0026gt; bool; 1 2 3 4 5 6 7 8 let message = \u0026#34;To: jimb\\r\\n\\ From: superego \u0026lt;editor@oreilly.com\u0026gt;\\r\\n\\ \\r\\n\\ Did you get any writing done today?\\r\\n\\ When will you stop wasting time plotting fractals?\\r\\n\u0026#34;; for header in message.lines().take_while(|l| !l.is_empty()) { println!(\u0026#34;{}\u0026#34; , header); } ç»“æœï¼š\n1 2 To: jimb From: superego \u0026lt;editor@oreilly.com\u0026gt; skip and skip_while The Iterator traitâ€™s skip and skip_while methods are the complement of take and take_while: they drop a certain number of items from the beginning of an iteration, or drop items until a closure finds one acceptable, and then pass the remaining items through unchanged.\n1 2 3 4 fn skip(self, n: usize) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized; fn skip_while\u0026lt;P\u0026gt;(self, predicate: P) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized, P: FnMut(\u0026amp;Self::Item) -\u0026gt; bool; 1 2 3 4 5 for body in message.lines() .skip_while(|l| !l.is_empty()) .skip(1) { println!(\u0026#34;{}\u0026#34; , body); } è¾“å‡ºç»“æœä¸ºï¼š\n1 2 Did you get any writing done today? When will you stop wasting time plotting fractals? peekable A peekable iterator lets you peek at the next item that will be produced without actually consuming it. You can turn any iterator into a peekable iterator by calling the Iterator traitâ€™s peekable method:\n1 2 fn peekable(self) -\u0026gt; std::iter::Peekable\u0026lt;Self\u0026gt; where Self: Sized; Here, Peekable\u0026lt;Self\u0026gt; is a struct that implements Iterator\u0026lt;Item=Self::Item\u0026gt;, and Self is the type of the underlying iterator.\nfuse fuse é€‚é…å™¨å¯ä»¥å°†ä»»ä½•é€‚é…å™¨è½¬æ¢ä¸ºç¬¬ä¸€æ¬¡è¿”å›Noneä¹‹åå§‹ç»ˆç»§ç»­è¿”å›Noneçš„è¿­ä»£å™¨ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Flaky(bool); impl Iterator for Flaky { type Item = \u0026amp;\u0026#39;static str; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { if self.0 { self.0 = false; Some(\u0026#34;totally the last item\u0026#34;) } else { self.0 = true; // D\u0026#39;oh! None } } } let mut flaky = Flaky(true); assert_eq!(flaky.next(), Some(\u0026#34;totally the last item\u0026#34;)); assert_eq!(flaky.next(), None); assert_eq!(flaky.next(), Some(\u0026#34;totally the last item\u0026#34;)); let mut not_flaky = Flaky(true).fuse(); assert_eq!(not_flaky.next(), Some(\u0026#34;totally the last item\u0026#34;)); assert_eq!(not_flaky.next(), None); assert_eq!(not_flaky.next(), None); Reversible Iterators and rev ä»åºåˆ—ä¸¤ç«¯å–å¾—é¡¹ã€‚å®ç°std::iter::DoubleEndedIterator traitã€‚\n1 2 3 trait DoubleEndedIterator: Iterator { fn next_back(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;; } 1 2 3 4 5 6 7 8 9 let bee_parts = [\u0026#34;head\u0026#34;, \u0026#34;thorax\u0026#34;, \u0026#34;abdomen\u0026#34;]; let mut iter = bee_parts.iter(); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;head\u0026#34;)); assert_eq!(iter.next_back(), Some(\u0026amp;\u0026#34;abdomen\u0026#34;)); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;thorax\u0026#34;)); assert_eq!(iter.next_back(), None); assert_eq!(iter.next(), None); If an iterator is double-ended, you can reverse it with the rev adapter:\n1 2 fn rev(self) -\u0026gt; impl Iterator\u0026lt;Item=Self\u0026gt; where Self: Sized + DoubleEndedIterator; The returned iterator is also double-ended: its next and next_back methods are simply exchanged:\n1 2 3 4 5 6 7 let meals = [\u0026#34;breakfast\u0026#34;, \u0026#34;lunch\u0026#34;, \u0026#34;dinner\u0026#34;]; let mut iter = meals.iter().rev(); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;dinner\u0026#34;)); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;lunch\u0026#34;)); assert_eq!(iter.next(), Some(\u0026amp;\u0026#34;breakfast\u0026#34;)); assert_eq!(iter.next(), None); inspect 1 2 3 4 5 6 let upper_case: String = \u0026#34;groÃŸe\u0026#34;.chars() .inspect(|c| println!(\u0026#34;before: {:?}\u0026#34;, c)) .flat_map(|c| c.to_uppercase()) .inspect(|c| println!(\u0026#34; after: {:?}\u0026#34;, c)) .collect(); assert_eq!(upper_case, \u0026#34;GROSSE\u0026#34;); chain å°†ä¸€ä¸ªè¿­ä»£å™¨åŠ åˆ°å¦ä¸€ä¸ªè¿­ä»£å™¨åé¢ã€‚\n1 2 fn chain\u0026lt;U\u0026gt;(self, other: U) -\u0026gt; impl Iterator\u0026lt;Item=Self::Item\u0026gt; where Self: Sized, U: IntoIterator\u0026lt;Item=Self::Item\u0026gt;; In other words, you can chain an iterator together with any iterable that produces the same item type.\n1 2 let v: Vec\u0026lt;i32\u0026gt; = (1..4).chain(vec![20, 30, 40]).collect(); assert_eq!(v, [1, 2, 3, 20, 30, 40]); enumerate 1 2 3 4 for (i, band) in bands.into_iter().enumerate() { let top = band_rows * i; // start a thread to render rows `top..top + band_rows` ... } You can think of the (index, item) pairs that enumerate produces as analogous to the (key, value) pairs that you get when iterating over a HashMap or other associative collection. If youâ€™re iterating over a slice or vector, the index is the â€œkeyâ€ under which the item appears.\nzip The zip adapter combines two iterators into a single iterator that produces pairs holding one value from each iterator, like a zipper joining its two sides into a single seam. The zipped iterator ends when either of the two underlying iterators ends.\n1 2 let v: Vec\u0026lt;_\u0026gt; = (0..).zip(\u0026#34;ABCD\u0026#34;.chars()).collect(); assert_eq!(v, vec![(0, \u0026#39;A\u0026#39;), (1, \u0026#39;B\u0026#39;), (2, \u0026#39;C\u0026#39;), (3, \u0026#39;D\u0026#39;)]); The argument to zip doesnâ€™t need to be an iterator itself; it can be any iterable:\n1 2 3 4 5 6 7 8 9 use std::iter::repeat; let endings = vec![\u0026#34;once\u0026#34;, \u0026#34;twice\u0026#34;, \u0026#34;chicken soup with rice\u0026#34;]; let rhyme: Vec\u0026lt;_\u0026gt; = repeat(\u0026#34;going\u0026#34;) .zip(endings) .collect(); assert_eq!(rhyme, vec![(\u0026#34;going\u0026#34;, \u0026#34;once\u0026#34;), (\u0026#34;going\u0026#34;, \u0026#34;twice\u0026#34;), (\u0026#34;going\u0026#34;, \u0026#34;chicken soup with rice\u0026#34;)]); by_ref An iteratorâ€™s by_ref method borrows a mutable reference to the iterator so that you can apply adapters to the reference. When youâ€™re done consuming items from these adapters, you drop them, the borrow ends, and you regain access to your original iterator.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let message = \u0026#34;To: jimb\\r\\n\\ From: id\\r\\n\\ \\r\\n\\ Oooooh, donuts!!\\r\\n\u0026#34;; let mut lines = message.lines(); println!(\u0026#34;Headers:\u0026#34;); for header in lines.by_ref().take_while(|l| !l.is_empty()) { println!(\u0026#34;{}\u0026#34; , header); } println!(\u0026#34;\\nBody:\u0026#34;); for body in lines { println!(\u0026#34;{}\u0026#34; , body); } cloned, copied The cloned adapter takes an iterator that produces references and returns an iterator that produces values cloned from those references, much like iter.map(|item| item.clone()). Naturally, the referent type must implement Clone.\n1 2 3 4 let a = [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;âˆ\u0026#39;]; assert_eq!(a.iter().next(), Some(\u0026amp;\u0026#39;1\u0026#39;)); assert_eq!(a.iter().cloned().next(), Some(\u0026#39;1\u0026#39;)); The copied adapter is the same idea, but more restrictive: the referent type must implement Copy. A call like iter.copied() is roughly the same as iter.map(|r| *r).\ncycle The cycle adapter returns an iterator that endlessly repeats the sequence produced by the underlying iterator. The underlying iterator must implement std::clone::Clone so that cycle can save its initial state and reuse it each time the cycle starts again.\n1 2 3 4 5 6 7 8 let dirs = [\u0026#34;North\u0026#34;, \u0026#34;East\u0026#34;, \u0026#34;South\u0026#34;, \u0026#34;West\u0026#34;]; let mut spin = dirs.iter().cycle(); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;North\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;East\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;South\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;West\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;North\u0026#34;)); assert_eq!(spin.next(), Some(\u0026amp;\u0026#34;East\u0026#34;)); Consuming Iterators Simple Accumulation: count, sum, product 1 2 3 4 5 6 7 8 9 10 fn count(self) -\u0026gt; usize where Self: Sized, { self.fold( 0, #[rustc_inherit_overflow_checks] |count, _| count + 1, ) } The count method draws items from an iterator until it returns None and tells you how many it got.\nThe sum and product methods compute the sum or product of the iteratorâ€™s items, which must be integers or floating-point numbers.\nmax, min std::iter::Iterator\n1 2 3 4 5 6 7 fn max(self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, Self::Item: Ord, { self.max_by(Ord::cmp) } max_by, min_by 1 2 3 4 fn max_by\u0026lt;F\u0026gt;(self, compare: F) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, F: FnMut(\u0026amp;Self::Item, \u0026amp;Self::Item) -\u0026gt; Ordering, 1 2 3 4 5 6 7 8 9 10 11 12 13 use std::cmp::Ordering; // Compare two f64 values. Panic if given a NaN. fn cmp(lhs: \u0026amp;f64, rhs: \u0026amp;f64) -\u0026gt; Ordering { lhs.partial_cmp(rhs).unwrap() } let numbers = [1.0, 4.0, 2.0]; assert_eq!(numbers.iter().copied().max_by(cmp), Some(4.0)); assert_eq!(numbers.iter().copied().min_by(cmp), Some(1.0)); let numbers = [1.0, 4.0, std::f64::NAN, 2.0]; assert_eq!(numbers.iter().copied().max_by(cmp), Some(4.0)); // panics max_by_key, min_by_key 1 2 3 4 5 6 7 8 9 fn max_by_key\u0026lt;B: Ord, F\u0026gt;(self, f: F) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, F: FnMut(\u0026amp;Self::Item) -\u0026gt; B, fn min_by_key\u0026lt;B: Ord, F\u0026gt;(self, f: F) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, F: FnMut(\u0026amp;Self::Item) -\u0026gt; B, 1 2 3 4 5 6 7 8 9 10 11 12 13 use std::collections::HashMap; let mut populations = HashMap::new(); populations.insert(\u0026#34;Portland\u0026#34;, 583_776); populations.insert(\u0026#34;Fossil\u0026#34;, 449); populations.insert(\u0026#34;Greenhorn\u0026#34;, 2); populations.insert(\u0026#34;Boring\u0026#34;, 7_762); populations.insert(\u0026#34;The Dalles\u0026#34;, 15_340); assert_eq!(populations.iter().max_by_key(|\u0026amp;(_name, pop)| pop), Some((\u0026amp;\u0026#34;Portland\u0026#34;, \u0026amp;583_776))); assert_eq!(populations.iter().min_by_key(|\u0026amp;(_name, pop)| pop), Some((\u0026amp;\u0026#34;Greenhorn\u0026#34;, \u0026amp;2))); Comparing Item Sequences Iterators provide the eq and ne methods for equality comparisons, and lt, le, gt, and ge methods for ordered comparisons. The cmp and partial_cmp methods behave like the corresponding methods of the Ord and PartialOrd traits.\nany and all 1 2 3 4 5 6 7 8 9 fn any\u0026lt;F\u0026gt;(\u0026amp;mut self, f: F) -\u0026gt; bool where Self: Sized, F: FnMut(Self::Item) -\u0026gt; bool, fn all\u0026lt;F\u0026gt;(\u0026amp;mut self, f: F) -\u0026gt; bool where Self: Sized, F: FnMut(Self::Item) -\u0026gt; bool, position, rposition, and ExactSizeIterator The position method applies a closure to each item from the iterator and returns the index of the first item for which the closure returns true.\nThe rposition method is the same, except that it searches from the right.\n1 2 3 4 fn rposition\u0026lt;P\u0026gt;(\u0026amp;mut self, predicate: P) -\u0026gt; Option\u0026lt;usize\u0026gt; where P: FnMut(Self::Item) -\u0026gt; bool, Self: ExactSizeIterator + DoubleEndedIterator, 1 2 3 4 trait ExactSizeIterator: Iterator { fn len(\u0026amp;self) -\u0026gt; usize { ... } // è¿”å›å‰©ä½™é¡¹æ•° fn is_empty(\u0026amp;self) -\u0026gt; bool { ... }\t// åœ¨è¿­ä»£å®Œæˆæ—¶è¿”å› true } fold and rfold 1 2 3 4 fn fold\u0026lt;B, F\u0026gt;(self, init: B, f: F) -\u0026gt; B where Self: Sized, F: FnMut(B, Self::Item) -\u0026gt; B, foldæ–¹æ³•æ˜¯ä¸€ä¸ªé€šç”¨å·¥å…·ï¼Œå¯ä»¥å¯¹è¿­ä»£å™¨äº§ç”Ÿé¡¹çš„æ•´ä¸ªåºåˆ—æ‰§è¡ŒæŸäº›ç´¯è®¡æ“ä½œã€‚è¿™ä¸ªæ–¹æ³•æ¥æ”¶ä¸€ä¸ªåä¸ºç´¯åŠ å™¨çš„åˆå§‹å€¼å’Œä¸€ä¸ªé—­åŒ…ï¼Œç„¶åå¯¹å½“å‰ç´¯åŠ å™¨å’Œè¿­ä»£å™¨çš„ä¸‹ä¸€é¡¹é‡å¤åº”ç”¨é—­åŒ…ã€‚æ¯æ¬¡é—­åŒ…çš„è¿”å›å€¼éƒ½ä¼šæˆä¸ºç´¯åŠ å™¨çš„æ–°å€¼ï¼Œç„¶åå†å’Œè¿­ä»£å™¨çš„ä¸‹ä¸€é¡¹ä¸€å—ä¼ ç»™é—­åŒ…ã€‚ç´¯åŠ å™¨çš„æœ€ç»ˆå€¼ä¹Ÿæ˜¯foldæ–¹æ³•è¿”å›çš„å€¼ã€‚å¦‚æœåºåˆ—æ˜¯ç©ºçš„ï¼Œåˆ™foldè¿”å›ç´¯åŠ å™¨çš„åˆå§‹å€¼ã€‚\n1 2 3 4 5 let a = [5, 6, 7, 8, 9, 10]; assert_eq!(a.iter().fold(0, |n, _| n+1), 6); // count assert_eq!(a.iter().fold(0, |n, i| n+i), 45); // sum assert_eq!(a.iter().fold(1, |n, i| n*i), 151200);\t// product assert_eq!(a.iter().cloned().fold(i32::min_value(), std::cmp::max), 10); // max ç´¯åŠ å™¨çš„å€¼ä¼šè½¬ç§»åˆ°é—­åŒ…ä¸­å†è½¬ç§»å‡ºæ¥ï¼Œå› æ­¤å¯ä»¥å¯¹éCopyç±»å‹çš„ç´¯åŠ å™¨ä½¿ç”¨foldï¼š\n1 2 3 4 5 6 7 8 let a = [\u0026#34;Pack\u0026#34;, \u0026#34;my\u0026#34;, \u0026#34;box\u0026#34;, \u0026#34;with\u0026#34;, \u0026#34;five\u0026#34;, \u0026#34;dozen\u0026#34;, \u0026#34;liquor\u0026#34;, \u0026#34;jugs\u0026#34;]; // See also: the `join` method on slices, which won\u0026#39;t // give you that extra space at the end. let pangram = a.iter() .fold(String::new(), |s, w| s + w + \u0026#34; \u0026#34;); assert_eq!(pangram, \u0026#34;Pack my box with five dozen liquor jugs \u0026#34;); The rfold method is the same as fold, except that it requires a double-ended iterator, and processes its items from last to first.\ntry_fold and try_rfold The try_fold method is the same as fold, except that the process of iteration can exit early, without consuming all the values from the iterator. The closure you pass to try_fold must return a Result: if it returns Err(e), try_fold returns immediately with Err(e) as its value. Otherwise, it continues folding with the success value. The closure can also return an Option: returning None exits early, and the result is an Option of the folded value.\n1 2 3 4 5 fn try_fold\u0026lt;B, F, R\u0026gt;(\u0026amp;mut self, init: B, f: F) -\u0026gt; R where Self: Sized, F: FnMut(B, Self::Item) -\u0026gt; R, R: Try\u0026lt;Output = B\u0026gt;, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use std::error::Error; use std::io::prelude::*; use std::str::FromStr; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn Error\u0026gt;\u0026gt; { let stdin = std::io::stdin(); let sum = stdin.lock() .lines() .try_fold(0, |sum, line| -\u0026gt; Result\u0026lt;u64, Box\u0026lt;dyn Error\u0026gt;\u0026gt; { Ok(sum + u64::from_str(\u0026amp;line?.trim())?) })?; println!(\u0026#34;{}\u0026#34;, sum); Ok(()) } 1 2 3 4 5 6 7 8 fn all\u0026lt;P\u0026gt;(\u0026amp;mut self, mut predicate: P) -\u0026gt; bool where P: FnMut(Self::Item) -\u0026gt; bool, Self: Sized { self.try_fold((), |_, item| { if predicate(item) { Some(()) } else { None } }).is_some() } nth, nth_back 1 fn nth(\u0026amp;mut self, n: usize) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; last 1 fn last(self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; This consumes all the iteratorâ€™s items starting from the front, even if the iterator is reversible. If you have a reversible iterator and donâ€™t need to consume all its items, you should instead just write iter.next_back().\nfind, rfind, and find_map 1 2 3 4 fn find\u0026lt;P\u0026gt;(\u0026amp;mut self, predicate: P) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; where Self: Sized, P: FnMut(\u0026amp;Self::Item) -\u0026gt; bool, 1 2 3 4 assert_eq!(populations.iter().find(|\u0026amp;(_name, \u0026amp;pop)| pop \u0026gt; 1_000_000), None); assert_eq!(populations.iter().find(|\u0026amp;(_name, \u0026amp;pop)| pop \u0026gt; 500_000), Some((\u0026amp;\u0026#34;Portland\u0026#34;, \u0026amp;583_776))); 1 2 3 4 fn find_map\u0026lt;B, F\u0026gt;(\u0026amp;mut self, f: F) -\u0026gt; Option\u0026lt;B\u0026gt; where Self: Sized, F: FnMut(Self::Item) -\u0026gt; Option\u0026lt;B\u0026gt;, Building Collections: collect and FromIterator 1 2 3 4 5 6 fn collect\u0026lt;B: FromIterator\u0026lt;Self::Item\u0026gt;\u0026gt;(self) -\u0026gt; B where Self: Sized, { FromIterator::from_iter(self) } 1 2 3 trait FromIterator\u0026lt;A\u0026gt;: Sized { fn from_iter\u0026lt;T: IntoIterator\u0026lt;Item=A\u0026gt;\u0026gt;(iter: T) -\u0026gt; Self; } åˆ†é…æ—¶æé«˜æ•ˆç‡ï¼š\n1 2 3 4 5 6 trait Iterator { ... fn size_hint(\u0026amp;self) -\u0026gt; (usize, Option\u0026lt;usize\u0026gt;) { (0, None) } } This method returns a lower bound and optional upper bound on the number of items the iterator will produce. The default definition returns zero as the lower bound and declines to name an upper bound, saying, in effect, â€œI have no idea,â€ but many iterators can do better than this. An iterator over a Range, for example, knows exactly how many items it will produce, as does an iterator over a Vec or HashMap. Such iterators provide their own specialized definitions for size_hint.\nThe Extend Trait If a type implements the std::iter::Extend trait, then its extend method adds an iterableâ€™s items to the collection.\n1 2 3 4 trait Extend\u0026lt;A\u0026gt; { fn extend\u0026lt;T\u0026gt;(\u0026amp;mut self, iter: T) where T: IntoIterator\u0026lt;Item=A\u0026gt;; } partition The partition method divides an iteratorâ€™s items among two collections, using a closure to decide where each item belongs.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 fn partition\u0026lt;B, F\u0026gt;(self, f: F) -\u0026gt; (B, B) where Self: Sized, B: Default + Extend\u0026lt;Self::Item\u0026gt;, F: FnMut(\u0026amp;Self::Item) -\u0026gt; bool, { #[inline] fn extend\u0026lt;\u0026#39;a, T, B: Extend\u0026lt;T\u0026gt;\u0026gt;( mut f: impl FnMut(\u0026amp;T) -\u0026gt; bool + \u0026#39;a, left: \u0026amp;\u0026#39;a mut B, right: \u0026amp;\u0026#39;a mut B, ) -\u0026gt; impl FnMut((), T) + \u0026#39;a { move |(), x| { if f(\u0026amp;x) { left.extend_one(x); } else { right.extend_one(x); } } } let mut left: B = Default::default(); let mut right: B = Default::default(); self.fold((), extend(f, \u0026amp;mut left, \u0026amp;mut right)); (left, right) } Other languages offer partition operations that just split the iterator into two iterators, instead of building two collections. But this isnâ€™t a good fit for Rust: items drawn from the underlying iterator but not yet drawn from the appropriate partitioned iterator would need to be buffered somewhere; you would end up building a collection of some sort internally, anyway.\nfor_each and try_for_each The for_each method simply applies a closure to each item.\n1 2 3 4 5 6 7 8 9 10 11 12 fn for_each\u0026lt;F\u0026gt;(self, f: F) where Self: Sized, F: FnMut(Self::Item), { #[inline] fn call\u0026lt;T\u0026gt;(mut f: impl FnMut(T)) -\u0026gt; impl FnMut((), T) { move |(), item| f(item) } self.fold((), call(f)); } 1 2 3 4 5 6 7 8 9 10 [\u0026#34;doves\u0026#34;, \u0026#34;hens\u0026#34;, \u0026#34;birds\u0026#34;].iter() .zip([\u0026#34;turtle\u0026#34;, \u0026#34;french\u0026#34;, \u0026#34;calling\u0026#34;].iter()) .zip(2..5) .rev() .map(|((item, kind), quantity)| { format!(\u0026#34;{} {} {}\u0026#34;, quantity, kind, item) }) .for_each(|gift| { println!(\u0026#34;You have received: {}\u0026#34;, gift); }); æ‰“å°è¾“å‡ºï¼š\n1 2 3 You have received: 4 calling birds You have received: 3 french hens You have received: 2 turtle doves If your closure needs to be fallible or exit early, you can use try_for_each.\n1 2 3 4 ... .try_for_each(|gift| { writeln!(\u0026amp;mut output_file, \u0026#34;You have received: {}\u0026#34;, gift) })?; Implementing Your Own Iterators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 use std::iter::Iterator; struct I32Range { start: i32, // å½“å‰çš„å€¼ end: i32 // è¿­ä»£ç»“æŸçš„å€¼ } impl Iterator for I32Range { type Item = i32; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;i32\u0026gt; { if self.start \u0026gt;= self.end { return None; } let result = Some(self.start); self.start += 1; result } } fn main() { let mut pi = 0.0; let mut numerator = 1.0; for k in (I32Range { start: 0, end: 14}) { pi += numerator / (2*k + 1) as f64; numerator /= -3.0; } pi *= f64::sqrt(12.0); // IEEE 754 specifies this result exactly assert_eq!(pi as f32, std::f32::consts::PI); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 use crate::BinaryTree::NonEmpty; enum BinaryTree\u0026lt;T\u0026gt; { Empty, NonEmpty(Box\u0026lt;TreeNode\u0026lt;T\u0026gt;\u0026gt;) } struct TreeNode\u0026lt;T\u0026gt; { element: T, left: BinaryTree\u0026lt;T\u0026gt;, right: BinaryTree\u0026lt;T\u0026gt; } impl\u0026lt;T: Ord\u0026gt; BinaryTree\u0026lt;T\u0026gt; { fn add(\u0026amp;mut self, value: T) { match *self { BinaryTree::Empty =\u0026gt; *self = BinaryTree::NonEmpty(Box::new(TreeNode{ element: value, left: BinaryTree::Empty, right: BinaryTree::Empty, })), BinaryTree::NonEmpty(ref mut node) =\u0026gt; if value \u0026lt;= node.element { node.left.add(value); } else { node.right.add(value); } } } } struct TreeIter\u0026lt;\u0026#39;a, T\u0026gt; { // A stack of references to tree nodes. Since we use `Vec`\u0026#39;s // `push` and `pop` methods, the top of the stack in the end of the // vector. // // The node the iterator will visit next is at the top of the stack, // with those ancestors still unvisited below it. If the stack is empty, // the iteration is over. unvisited: Vec\u0026lt;\u0026amp;\u0026#39;a TreeNode\u0026lt;T\u0026gt;\u0026gt; } impl\u0026lt;\u0026#39;a, T: \u0026#39;a\u0026gt; TreeIter\u0026lt;\u0026#39;a, T\u0026gt; { fn push_left_edge(\u0026amp;mut self, mut tree: \u0026amp;\u0026#39;a BinaryTree\u0026lt;T\u0026gt;) { while let NonEmpty(ref node) = *tree { self.unvisited.push(node); tree = \u0026amp;node.left; } } } impl\u0026lt;T\u0026gt; BinaryTree\u0026lt;T\u0026gt; { fn iter(\u0026amp;self) -\u0026gt; TreeIter\u0026lt;T\u0026gt; { let mut iter = TreeIter{ unvisited: Vec::new() }; iter.push_left_edge(self); iter } } impl\u0026lt;\u0026#39;a, T: \u0026#39;a\u0026gt; IntoIterator for \u0026amp;\u0026#39;a BinaryTree\u0026lt;T\u0026gt; { type Item = \u0026amp;\u0026#39;a T; type IntoIter = TreeIter\u0026lt;\u0026#39;a, T\u0026gt;; fn into_iter(self) -\u0026gt; Self::IntoIter { self.iter() } } impl\u0026lt;\u0026#39;a, T\u0026gt; Iterator for TreeIter\u0026lt;\u0026#39;a, T\u0026gt; { type Item = \u0026amp;\u0026#39;a T; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;\u0026amp;\u0026#39;a T\u0026gt; { // Find the node this iteration must produce, // or finish the iteration. (Use the `?` operator // to return immediately if it\u0026#39;s `None`.) let node = self.unvisited.pop()?; // After `node`, the next thing we produce must be the leftmost // child in `node`\u0026#39;s right subtree, so push the path from here // down. Our helper method turns out to be just what we need. self.push_left_edge(\u0026amp;node.right); // Produce a reference to this node\u0026#39;s value. Some(\u0026amp;node.element) } } fn main() { // Build a small tree. let mut tree = BinaryTree::Empty; tree.add(\u0026#34;jaeger\u0026#34;); tree.add(\u0026#34;robot\u0026#34;); tree.add(\u0026#34;droid\u0026#34;); tree.add(\u0026#34;mecha\u0026#34;); // Iterate over it. let mut v = Vec::new(); for kind in \u0026amp;tree { v.push(*kind); } assert_eq!(v, [\u0026#34;droid\u0026#34;, \u0026#34;jaeger\u0026#34;, \u0026#34;mecha\u0026#34;, \u0026#34;robot\u0026#34;]); assert_eq!(tree.iter() .map(|name| format!(\u0026#34;mega-{}\u0026#34;, name)) .collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(), vec![\u0026#34;mega-droid\u0026#34;, \u0026#34;mega-jaeger\u0026#34;, \u0026#34;mega-mecha\u0026#34;, \u0026#34;mega-robot\u0026#34;]); } Chapter 19. Concurrency æƒ¯ç”¨çš„å¤šçº¿ç¨‹ä»£ç å†™æ³•ï¼š\nä¸€ä¸ªåå°çº¿ç¨‹åªè´Ÿè´£ä¸€ä»¶äº‹ï¼Œè€Œä¸”å‘¨æœŸæ€§â€œé†’æ¥â€å»åšè¿™ä»¶äº‹ã€‚ é€šç”¨çº¿ç¨‹æ± é€šè¿‡ä»»åŠ¡é˜Ÿåˆ—ä¸å®¢æˆ·ç«¯é€šä¿¡ã€‚ ç®¡é“å°†æ•°æ®ä»ä¸€ä¸ªçº¿ç¨‹å¯¼å…¥åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹åªåšä¸€å°éƒ¨åˆ†å·¥ä½œã€‚ æ•°æ®å¹¶è¡Œå‡è®¾ï¼ˆä¸ç®¡æ­£ç¡®ä¸å¦ï¼‰æ•´ä¸ªè®¡ç®—æœºä¸»è¦ç”¨äºä¸€é¡¹å¤§å‹è®¡ç®—ï¼Œè¿™ä¸ªå¤§å‹è®¡ç®—è¿›è€Œåˆæ‹†åˆ†æˆnä¸ªå°ä»»åŠ¡ï¼Œåœ¨nä¸ªçº¿ç¨‹ä¸Šæ‰§è¡Œï¼Œå¸Œæœ›æ‰€æœ‰nä¸ªæœºå™¨çš„æ ¸å¿ƒåŒæ—¶å·¥ä½œã€‚ åŒæ­¥å¯¹è±¡æµ·ä¸­å¤šä¸ªçº¿ç¨‹æ‹¥æœ‰åŒä¸€ä¸ªæ•°æ®æƒé™ï¼Œä½¿ç”¨åŸºäºäº’æ–¥é‡ç­‰ä½çº§åŸè¯­çš„ä¸´æ—¶é”æ–¹æ¡ˆé¿å…äº‰ç”¨ã€‚ åŸå­æ•´æ•°æ“ä½œå…è®¸å¤šæ ¸å¿ƒé€šè¿‡ä¸€ä¸ªæœºå™¨å­—å¤§å°çš„å­—æ®µä¼ é€’ä¿¡æ¯è€Œå®ç°é€šä¿¡ã€‚ï¼ˆé™¤éè¦äº¤æ¢çš„æ•°æ®å°±æ˜¯æ•´æ•°å€¼ï¼Œå¦åˆ™è¿™ç§æ–¹æ³•æ¯”å…¶ä»–æ‰‹æ®µæ›´éš¾ä»¥ä¿è¯æ­£ç¡®ã€‚è¿™é€šå¸¸æ„å‘³ç€ä¼ é€’æŒ‡é’ˆã€‚ï¼‰ Fork-Join Parallelism Fork-join parallelism æœ‰å¦‚ä¸‹ä¼˜ç‚¹ï¼š\néå¸¸ç®€å•ã€‚ é¿å…ç“¶é¢ˆã€‚ æ€§èƒ½è®¡ç®—ç›´è§‚ã€‚ å®¹æ˜“æ¨æ–­ç¨‹åºæ˜¯å¦æ­£ç¡®ã€‚ Fork-join çš„ä¸»è¦ç¼ºç‚¹æ˜¯è¦æ±‚å·¥ä½œå•å…ƒéš”ç¦»ã€‚\nspawn and join std::thread::spawn åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ï¼š\n1 2 3 4 5 use std::thread; thread::spawn(|| { println!(\u0026#34;hello from a child thread\u0026#34;); }); å®ƒæ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼Œä¸€ä¸ª FnOnce é—­åŒ…æˆ–è€…å‡½æ•°ã€‚\nç”¨ spawn æ¥å®ç°å‰é¢çš„ process_file å‡½æ•°çš„å¹¶è¡Œç‰ˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 use std::{thread, io}; fn process_file_in_parallel(filename: Vec\u0026lt;String\u0026gt;) -\u0026gt; io::Result\u0026lt;()\u0026gt; { // Divide the work into several chunks. const NTHREADS: usize = 8; let worklists = split_vec_into_chunks(filename, NTHREADS); // Fork: Spawn a thread to handle each chunck. let mut thread_handles = vec![]; for worklist in worklists { thread_handles.push( // worklist move è¿›é—­åŒ…ä¸­ã€‚ // spawn move é—­åŒ…åˆ°å­çº¿ç¨‹ä¸­ï¼Œå½“ç„¶ä¹ŸåŒ…æ‹¬ worklist vecã€‚ thread::spawn(move || process_files(worklist)) ); } // Join: Wait for all threads to finish. // æ¯ä¸€ä¸ª handle æ˜¯ä¸€ä¸ª JoinHandleã€‚ for handle in thread_handles { handle.join().unwrap()?; } // å¾ªç¯ç»“æŸï¼Œ8ä¸ªå­çº¿ç¨‹éƒ½å·²ç»æˆåŠŸå®Œæˆã€‚ Ok(()) } spawn å‡½æ•°å®šä¹‰ï¼š\n1 2 3 4 pub fn spawn\u0026lt;F, T\u0026gt;(f: F) -\u0026gt; JoinHandle\u0026lt;T\u0026gt; where F: FnOnce() -\u0026gt; T, F: Send + \u0026#39;static, T: Send + \u0026#39;static, å› æ­¤ thread::spawn(move || process_files(worklist)) ä¼šè¿”å› JoinHandle ï¼Œå¹¶å°†å®ƒä»¬æ”¾è¿›ä¸€ä¸ª vector ä¸­ã€‚\nError Handling Across Threads 1 handle.join().unwrap()?; è¿™ä¸ª.join()æ–¹æ³•åšäº†ä¸¤ä»¶äº‹æƒ…ã€‚\né¦–å…ˆï¼Œhandle.join()è¿”å›ä¸€ä¸ª std::thread::Resultã€‚\nå…¶æ¬¡ï¼Œhandle.join() æŠŠå­çº¿ç¨‹è¿”å›çš„å€¼ä¼ ç»™äº†çˆ¶çº¿ç¨‹ã€‚handle.join() è¿”å›çš„å®Œæ•´ç±»å‹æ˜¯std::thread::Result\u0026lt;std::io::Result\u0026lt;()\u0026gt;\u0026gt;ã€‚å…¶ä¸­thread::Result æ˜¯ spawn/join APIçš„ä¸€éƒ¨åˆ†ï¼Œè€Œ io::Result æ˜¯æˆ‘ä»¬åº”ç”¨çš„ç›¸å…³ç±»å‹ã€‚\nåœ¨Rustä¸­ï¼Œé”™è¯¯æ˜¯ä¸€ç§ Result å€¼ï¼ˆæ•°æ®ï¼‰è€Œä¸æ˜¯å¼‚å¸¸ï¼ˆæ§åˆ¶æµï¼‰ã€‚å¯ä»¥åƒä»»ä½•å€¼ä¸€æ ·è·¨çº¿ç¨‹ä¼ é€å®ƒä»¬ã€‚\nSharing Immutable Data Across Threads 1 2 3 4 5 // before fn process_files(filename: Vec\u0026lt;String\u0026gt;) // after fn process_files(filename: Vec\u0026lt;String\u0026gt;, glossary: \u0026amp;GigabyteMap) å¦‚æœåƒä¹‹å‰é‚£æ ·ä¼ è¿›çº¿ç¨‹ä¼šæŠ¥é”™ã€‚\n1 2 3 4 5 6 7 8 9 fn process_file_in_parallel(filename: Vec\u0026lt;String\u0026gt;, glossary: \u0026amp;GigabyteMap) -\u0026gt; io::Result\u0026lt;()\u0026gt; { ... for worklist in worklists { thread_handles.push( thread::spawn(move || process_files(worklist, glossary)) // error ); } ... } ä¼šæŠ±æ€¨ spawn ä¸­é—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸä¸æ˜¯ 'staticã€‚spawn ä¼šå¯åŠ¨ä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ã€‚Rustæ— æ³•çŸ¥é“ä¸€ä¸ªå­çº¿ç¨‹ä¼šå…è®¸å¤šé•¿æ—¶é—´ï¼Œå› æ­¤å®ƒå‡è®¾ä¸€ç§æœ€åçš„æƒ…å†µï¼Œå³å­çº¿ç¨‹å¯èƒ½ä¼šåœ¨çˆ¶çº¿ç¨‹å·²ç»å®Œæˆä¸”çˆ¶çº¿ç¨‹ä¸­æ‰€æœ‰çš„å€¼éƒ½æ¶ˆå¤±ä¹‹åç»§ç»­è¿è¡Œã€‚\nå¯ä»¥ä½¿ç”¨ Arc æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use std::sync::Arc; fn process_file_in_parallel(filename: Vec\u0026lt;String\u0026gt;, glossary: Arc\u0026lt;GigabyteMap\u0026gt;) -\u0026gt; io::Result\u0026lt;()\u0026gt; { ... for worklist in worklists { // This call to .clone() only clones the Arc and bumps the // reference count. It does not clone the GigabyteMap. let glossary_for_child = glossary.clone(); thread_handles.push( thread::spawn(move || process_files(worklist, \u0026amp;glossary_for_child)) ); } ... } è°ƒç”¨glossary.clone()åï¼Œä¼šåˆ›å»ºArcæ™ºèƒ½æŒ‡é’ˆè€Œä¸æ˜¯æ•´ä¸ª GigabyteMap çš„ä¸€ä¸ªå‰¯æœ¬ã€‚è¿™ç›¸å½“äºå¢åŠ ä¸€æ¬¡å¼•ç”¨è®¡æ•°ã€‚\nè¿™æ ·ä¿®æ”¹ä¹‹åï¼Œç¨‹åºå°±å¯ä»¥ç¼–è¯‘é€šè¿‡å¹¶è¿è¡Œäº†ã€‚å› ä¸ºå®ƒä¸å†ä¾èµ–å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸã€‚åªè¦æœ‰ä»»ä½•çº¿ç¨‹æ‹¥æœ‰ Arc\u0026lt;GigabyteMap\u0026gt; ï¼Œæ˜ å°„å°±ä¸ä¼šé‡Šæ”¾ï¼Œå³ä½¿çˆ¶çº¿ç¨‹æ—©å°±é€€å‡ºäº†ã€‚å› ä¸º Arc ä¸­çš„æ•°æ®æ˜¯ä¸å¯ä¿®æ”¹çš„ï¼Œæ‰€ä»¥ä¹Ÿä¸ä¼šå‡ºç°ä»»ä½•æ•°æ®äº‰ç”¨ã€‚\nRayon Rayon åº“ï¼š\n1 2 3 4 5 6 7 8 9 use rayon::prelude::*; // \u0026#34;do 2 things in parallel\u0026#34; let (v1, v2) = rayon::join(fn1, fn2); // \u0026#34;do N things in parallel\u0026#34; giant_vector.par_iter().for_each(|value| { do_thing_with_value(value); }); rayon::join(fn1, fn2) å°±æ˜¯è°ƒç”¨ä¸¤ä¸ªå‡½æ•°å¹¶è¿”å›ä¸¤ä¸ªç»“æœã€‚è€Œ.par_iter() æ–¹æ³•ä¼šåˆ›å»ºä¸€ä¸ª ParallelIterator ï¼Œè¿™ä¸ªå€¼æœ‰ mapã€filterå’Œå…¶ä»–æ–¹æ³•ï¼Œéå¸¸ç±»ä¼¼äºRustçš„Iteratorã€‚\nä¸‹å›¾å±•ç¤ºäº†ä¸¤ç§ç†è§£ giant_vector.par_iter().for_each(...) è°ƒç”¨çš„æ–¹å¼ã€‚(a) è¡¨é¢ä¸Šçœ‹ï¼ŒRayonä¼šä¸ºå‘é‡ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹ã€‚(b)åœ¨åå°ï¼ŒRayonä¼šè®©æ¯ä¸ªå·¥ä½œçº¿ç¨‹å¯¹åº”ä¸€ä¸ªCPUæ ¸å¿ƒï¼Œè¿™æ ·æ•ˆç‡æ›´é«˜ã€‚è¿™ä¸ªå·¥ä½œçº¿ç¨‹æ± ç”±ç¨‹åºçš„æ‰€æœ‰çº¿ç¨‹å…±äº«ã€‚åœ¨åŒæ—¶æ•°åƒä¸ªä»»åŠ¡æ—¶ï¼ŒRayonä¼šè‡ªåŠ¨æ‹†åˆ†å·¥ä½œã€‚\nç”¨Rayonå†™process_files_in_parallelã€‚\n1 2 3 4 5 6 7 8 9 10 11 use rayon::prelude::*; fn process_files_in_parallel(filenames: Vec\u0026lt;String\u0026gt;, glossary: \u0026amp;GiabyteMap) -\u0026gt; io::Result\u0026lt;()\u0026gt; { filenames.par_iter() .map(|filename| process_file(filename, glossary)) .reduce_with(|r1, r2| { if r1.is_err() { r1 } else { r2 } }) .unwrap_or(Ok(())) } First, we use filenames.par_iter() to create a parallel iterator.\n.map() å¯¹æ¯ä¸ªæ–‡ä»¶åè°ƒç”¨ process_fileã€‚è¿™æ ·ä¼šå¾—åˆ° io::Result\u0026lt;()\u0026gt;å€¼çš„ä¸€ä¸ª ParallelIteratorã€‚\nç„¶åç”¨ .reduce_with() ç»„åˆç»“æœã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¿ç•™ç¬¬ä¸€ä¸ªé”™è¯¯ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œç„¶åä¸¢å¼ƒå…¶ä»–é”™è¯¯ã€‚\nThe .reduce_with() method is also handy when you pass a .map() closure that returns a useful value on success. Then you can pass .reduce_with() a closure that knows how to combine two success results.\nreduce_with returns an Option that is None only if filenames was empty. We use the Optionâ€™s .unwrap_or() method to make the result Ok(()) in that case.\nChannels A channel is a one-way conduit for sending values from one thread to another. In other words, itâ€™s a thread-safe queue.\nå›¾ç‰‡ä¸­åº”è¯¥æœ‰è¯¯ï¼Œä¸‹é¢ä¸€ä¸ªçº¿ç¨‹åº”è¯¥æ˜¯ thread 2ã€‚\nRust channels are faster than Unix pipes. Sending a value moves it rather than copying it, and moves are fast even when youâ€™re moving data structures that contain many megabytes of data.\nSending Values The code to start our file-reading thread looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std::{fs, thread}; use std::sync::mpsc; let (sender, receiver) = mpsc::channel(); let handle = thread::spawn(move || { for filename in documents { let text = fs::read_to_string(filename)?; // å°† text å€¼ move è¿› channelï¼Œ // æœ€ç»ˆï¼Œå®ƒä¼šå†æ¬¡ move åˆ°æ¥æ”¶åˆ°è¿™ä¸ªå€¼çš„åœ°æ–¹ã€‚ if sender.send(text).is_err() { break; } } Ok(()) }); Whether text contains 10 lines of text or 10 megabytes, this operation copies three machine words (the size of a String struct), and the corresponding receiver.recv() call will also copy three machine words.\nThe send and recv methods both return Results, but these methods fail only if the other end of the channel has been dropped.\nIn our code, sender.send(text) will fail only if the receiverâ€™s thread has exited early. This is typical for code that uses channels. Whether that happened deliberately or due to an error, itâ€™s OK for our reader thread to quietly shut itself down.\n1 2 3 4 5 6 7 8 9 10 11 fn start_file_reader_thread(documents: Vec\u0026lt;PathBuf\u0026gt;) -\u0026gt; (mpsc::Receiver\u0026lt;String\u0026gt;, thread::JoinHandle\u0026lt;io::Result\u0026gt;) { let (sender, receiver) = mpsc::channel(); let handle = thread::spawn(move || { ... }); (receiver, handle) } Receiving Values 1 2 3 while let Ok(text) = receiver.recv() { do_something_with(text); } ç­‰ä»·äº\n1 2 3 for text in receiver { do_something_with(text); } The loop will exit normally when the channel is empty and the Sender has been dropped.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fn start_file_indexing_thread(texts: mpsc::Receiver\u0026lt;String\u0026gt;) -\u0026gt; (mpsc::Receiver\u0026lt;InMemoryIndex\u0026gt;, thread::JoinHandle\u0026lt;()\u0026gt;) { let (sender, receiver) = mpsc::channel(); let handle = thread::spawn(move || { for (doc_id, text) in texts.into_iter().enumerate() { let index = InMemoryIndex::from_single_document(doc_id, text); if sender.send(index).is_err() { break; } } }); (receiver, handle) } Running the Pipeline Stage3:\n1 2 fn start_in_memory_merge_thread(file_indexs: mpsc::Receiver\u0026lt;InMemoryIndex\u0026gt;) -\u0026gt; (mpsc::Receiver\u0026lt;InMemoryIndex\u0026gt;, thread::JoinHandle\u0026lt;()\u0026gt;) Stage 4:\n1 2 fn start_index_writer_thread(big_indexs: mpsc::Receiver\u0026lt;InMemoryIndex\u0026gt;, output_dir: \u0026amp;Path) -\u0026gt; (mpsc::Receiver\u0026lt;PathBuf\u0026gt;, thread::JoinHandle\u0026lt;io::Result\u0026lt;()\u0026gt;\u0026gt;) Stage 5:\n1 2 fn merge_index_files(files: mpsc::Receiver\u0026lt;PathBuf\u0026gt;, output_dir: \u0026amp;Path) -\u0026gt; io::Result\u0026lt;()\u0026gt; æœ€ç»ˆè¿è¡Œä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn run_pipeline(documents: Vec\u0026lt;PathBuf\u0026gt;, output_dir: PathBuf) -\u0026gt; io::Result\u0026lt;()\u0026gt; { // Launch all five stages of the pipeline. let (texts, h1) = start_file_reader_thread(documents); let (pints, h2) = start_file_indexing_thread(texts); let (gallons, h3) = start_in_memory_merge_thread(pints); let (files, h4) = start_index_writer_thread(gallons, \u0026amp;output_dir); let result = merge_index_files(files, \u0026amp;output_dir); // Wait for threads to finish, holding on to any errors that they encounter. let r1 = h1.join().unwrap(); h2.join().unwrap(); h3.join().unwrap(); let r4 = h4.join().unwrap(); // Return the first error encountered, if any. // (As it happens, h2 and h3 can\u0026#39;t fail: those threads // are pure in-memory data processing.) r1?; r4?; result } Channel Features and Performance std::sync::mpsc å°±æ˜¯ \u0026ldquo;multiproducer, single-consumer\u0026rdquo;ã€‚\nSender\u0026lt;T\u0026gt; implements the Clone trait. To get a channel with multiple senders, simply create a regular channel and clone the sender as many times as you like. You can move each Sender value to a different thread.\nA Receiver\u0026lt;T\u0026gt; canâ€™t be cloned, so if you need to have multiple threads receiving values from the same channel, you need a Mutex.\nRusté€šé“æ˜¯ç»è¿‡è®¤çœŸä¼˜åŒ–çš„ã€‚åœ¨åˆšåˆ›å»ºé€šé“æ—¶ï¼ŒRustä½¿ç”¨â€œä¸€æ¬¡æ€§â€é˜Ÿåˆ—å®ç°ã€‚å¦‚æœåªæ˜¯ç”¨è¿™ä¸ªé€šé“å‘é€ä¸€ä¸ªå¯¹è±¡ï¼Œé‚£å¯ä»¥ä¿è¯å¼€é”€æœ€å°ã€‚å¦‚æœå†å‘é€ç¬¬äºŒä¸ªå€¼ï¼ŒRuståˆ™ä¼šåˆ‡æ¢åˆ°ä¸€ä¸ªä¸åŒçš„é˜Ÿåˆ—å®ç°ã€‚è¿™ä¸ªå®ç°ä¼šä»é•¿è¿œè€ƒè™‘ï¼Œå‡†å¤‡è®©é€šé“ä¼ è¾“å¾ˆå¤šå€¼ï¼ŒåŒæ—¶åˆä¿æŒåˆ†é…å¼€é”€æœ€å°åŒ–ã€‚å¦‚æœä½ é€‰æ‹©å…‹éš† Sender ï¼ŒRuståˆ™å¿…é¡»å›é€€åˆ°å¦å¤–ä¸€ä¸ªå®ç°ï¼Œè¯¥å®ç°å¯ä»¥ä¿è¯å¤šä¸ªçº¿ç¨‹åŒæ—¶å‘é€å€¼æ—¶çš„å®‰å…¨ã€‚ä¸è¿‡å³ä½¿æ˜¯è¿™3ä¸ªå®ç°ä¸­æœ€æ…¢çš„å®ç°ä¹Ÿæ˜¯æ²¡æœ‰é”çš„é˜Ÿåˆ—ï¼Œå› æ­¤å‘é€å’Œæ¥æ”¶å€¼æœ€å¤šåªæ˜¯å‡ ä¸ªåŸå­æ“ä½œï¼Œæ¶‰åŠä¸€æ¬¡å †å†…å­˜åˆ†é…ï¼Œå¤–åŠ è½¬ç§»è‡ªèº«ã€‚åªæœ‰åœ¨é˜Ÿåˆ—ä¸ºç©ºä¸”æ¥æ”¶çº¿ç¨‹éœ€è¦ä¼‘çœ æ—¶æ‰éœ€è¦ç³»ç»Ÿè°ƒç”¨ã€‚å½“ç„¶ï¼Œæ­¤æ—¶ç»è¿‡é€šé“çš„æµé‡æ— è®ºå¦‚ä½•ä¹Ÿä¸æ˜¯æœ€å¤§çš„ã€‚\nå‘é€è‡³çš„é€Ÿåº¦è¶…è¿‡æ¥æ”¶å’Œå¤„ç†å€¼çš„é€Ÿåº¦ã€‚è¿™ä¼šå¯¼è‡´é€šé“å†…éƒ¨çš„å€¼è¶Šç§¯è¶Šå¤šã€‚Rustå€Ÿç”¨Unixç®¡é“ã€‚Unixä½¿ç”¨ backpressure ï¼Œä»è€Œå¼ºè¿«å¿«é€Ÿå‘é€ç«¯æ”¾æ…¢é€Ÿåº¦ã€‚Unixç³»ç»Ÿçš„æ¯ä¸ªç®¡é“éƒ½æœ‰å›ºå®šå¤§å°ï¼Œå¦‚æœä¸€ä¸ªè¿›ç¨‹å°è¯•å‘éšæ—¶å¯èƒ½æ»¡çš„ç®¡é“å†™å…¥æ•°æ®ï¼Œç³»ç»Ÿå°±ä¼šç›´æ¥é˜»å¡è¯¥è¿›ç¨‹ï¼Œç›´è‡³ç®¡é“ä¸­æœ‰äº†ç©ºé—´ã€‚Rustä¸­çš„ç­‰ä»·æœºåˆ¶åŠ  synchronous channel:\n1 2 3 use std::sync::mpsc; let (sender, receiver) = mpsc::sync_channel(1000); åŒæ­¥é€šé“å°±åƒå¸¸è§„é€šé“ä¸€æ ·ï¼Œåªæ˜¯åœ¨åˆ›å»ºæ—¶éœ€è¦æŒ‡å®šå®ƒå¯ä»¥ä¿å­˜å¤šå°‘å€¼ã€‚å¯¹äºåŒæ­¥é€šé“è€Œè¨€ï¼Œsender.send(value) æ˜¯ä¸€ä¸ªæ½œåœ¨çš„é˜»å¡æ“ä½œã€‚\nThread Safety: Send and Sync This is mostly true, but Rustâ€™s full thread safety story hinges on two built-in traits, std::marker::Send and std::marker::Sync.\nTypes that implement Send are safe to pass by value to another thread. They can be moved across threads. Types that implement Sync are safe to pass by non-mut reference to another thread. They can be shared across threads. By safe here, we mean the same thing we always mean: free from data races and other undefined behavior.\nThe few types that are neither Send nor Sync are mostly those that use mutability in a way that isnâ€™t thread-safe. For example, consider std::rc::Rc\u0026lt;T\u0026gt;, the type of reference-counting smart pointers.\nPiping Almost Any Iterator to a Channel ç»Ÿä¸€è¿­ä»£å™¨ç®¡é“å’Œçº¿ç¨‹ç®¡é“ã€‚\n1 2 3 4 5 6 7 documents.into_iter() .map(read_whole_file) .errors_to(error_sender) // filter out error results .off_thread() // spawn a thread for the above work .map(make_single_file_index) .off_thread() // spawn another thread for stage 2 ... å¯ä»¥å®šä¹‰ä¸€ä¸ª traitã€‚\n1 2 3 4 5 6 7 8 use std::sync::mpsc; pub trait OffThreadExt: Iterator { /// Transform this iterator into an off-thread iterator: the /// `next()` calls happen to a separate worker thread, so the /// iterator and the body of your loop run concurrently. fn off_thread(self) -\u0026gt; mpsc::IntoIter\u0026lt;Self::Item\u0026gt;; } ç„¶åä¸ºè¿™ä¸ªè¿­ä»£å™¨å®ç°è¿™ä¸ª traitã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 use std::thread; impl\u0026lt;T\u0026gt; OffThreadExt for T where T: Iterator + Send + \u0026#39;static, T::Item: Send + \u0026#39;static { fn off_thread(self) -\u0026gt; mpsc::IntoIter\u0026lt;Self::Item\u0026gt; { // Create a channel to transfer items from the worker thread. let (sender, receiver) = mpsc::sync_channel(1024); // Move this iterator to a new worker thread and run it there. thread::spawn(move || { for item in self { if sender.send(item).is_err() { break; } } }); // Return an iterator that pulls values from the channel. receiver.into_iter() } } Beyond Pipelines é€šé“ä¸ä»…åœ¨ç®¡é“ä¸­æœ‰ç”¨ï¼Œå®ƒä»¬ä¹Ÿæ˜¯åœ¨ç›¸åŒè¿›ç¨‹ä¸­ä¸ºå…¶ä»–çº¿ç¨‹æä¾›å¼‚æ­¥æœåŠ¡çš„å¿«é€Ÿè€Œç®€å•çš„æ–¹å¼ã€‚\né€šé“ä¹Ÿé€‚ç”¨äºä¸€ä¸ªçº¿ç¨‹å‘å¦ä¸€ä¸ªçº¿ç¨‹å‘é€è¯·æ±‚å¹¶æœŸå¾…å¾—åˆ°æŸç§å“åº”çš„æƒ…å½¢ã€‚\nShared Mutable State What Is a Mutex? äº’æ–¥é‡ï¼ˆæˆ–è€…å«é”ï¼‰ç”¨äºå¼ºåˆ¶å¤šçº¿ç¨‹ä¾æ¬¡è®¿é—®ç‰¹å®šçš„æ•°æ®ã€‚\näº’æ–¥é‡ä¿æŠ¤æ•°æ®ã€‚äº’æ–¥é‡çš„ä½œç”¨ä½“ç°åœ¨ä»¥ä¸‹å‡ æ–¹é¢ã€‚\né˜²æ­¢ data racesï¼Œå³é¿å…å¤šä¸ªçº¿ç¨‹å¹¶å‘è¯»å†™åŒä¸€å—å†…å­˜ã€‚ å³ä½¿æ²¡æœ‰æ•°æ®äº‰ç”¨ï¼Œå³ä½¿æ‰€æœ‰è¯»å†™åœ¨ç¨‹åºä¸­éƒ½æ˜¯é¡ºåºæ‰§è¡Œï¼Œå¦‚æœæ²¡æœ‰äº’æ–¥é‡ï¼Œä¸åŒçº¿ç¨‹çš„æ“ä½œä¹Ÿå¯èƒ½ä»¥ä»»æ„æ–¹å¼ç›¸äº’äº¤é”™ã€‚ äº’æ–¥é‡æ”¯æŒé€šè¿‡ invariant ç¼–ç¨‹ï¼Œå³å—ä¿æŠ¤æ•°æ®ç”±ä½ è´Ÿè´£åˆå§‹åŒ–ä½†æ¯ä¸ªä¸´ç•ŒåŒºæ¥ç»´æŠ¤çš„è§„åˆ™ã€‚ Mutex\u0026lt;T\u0026gt; å› ä¸ºç­‰å¾…åˆ—è¡¨æ—¢æ˜¯å…±äº«çš„ä¹Ÿæ˜¯å¯ä¿®æ”¹çš„ï¼Œæ‰€ä»¥å¿…é¡»ç”±ä¸€ä¸ª Mutex æ¥æä¾›ä¿æŠ¤ï¼š\n1 2 3 4 5 6 7 8 use std::sync::Mutex; /// All threads have shared access to this big contex struct. struct FernEmpireApp { ... waiting_list: Mutex\u0026lt;WaitingList\u0026gt;, ... } åˆ›å»º Mutex ä»£ç ï¼š\n1 2 3 4 5 6 7 use std::sync::Arc; let app = Arc::new(FernEmpireApp { ... waiting_list: Mutex::new(vec![]), ... }); åˆ›å»ºä¸€ä¸ªæ–°çš„ Mutex å°±åƒåˆ›å»ºä¸€ä¸ªæ–° Box æˆ– Arcï¼Œä½† Box å’Œ Arc éƒ½æ„å‘³ç€å †åˆ†é…ï¼Œè€Œ Mutex å°±æ˜¯å•çº¯çš„ä¸€ç§é”ã€‚å¦‚æœæƒ³æŠŠ Mutex åˆ†é…åœ¨å †ä¸Šï¼Œåˆ™å¿…é¡»æ˜ç¡®åœ°è¡¨ç¤ºå‡ºæ¥ï¼Œå°±åƒè¿™é‡Œä½¿ç”¨ Arc::new åˆ›å»ºæ•´ä¸ªåº”ç”¨ï¼Œè€Œä½¿ç”¨ Mutex::new åªæ˜¯ä¸ºäº†ä¿æŠ¤æ•°æ®ä¸€æ ·ã€‚è¿™ä¸¤ä¸ªç±»å‹ç»å¸¸ä¸€å—ä½¿ç”¨ï¼Œ Arc æ–¹ä¾¿è·¨çº¿ç¨‹å…±äº«æ•°æ®ï¼Œè€Œ Mutex æ–¹ä¾¿è·¨çº¿ç¨‹å…±äº«å¯ä¿®æ”¹æ•°æ®ã€‚\nä½¿ç”¨ Mutex ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 impl FernEmpireApp { /// Add a player to the waiting list for the next game. /// Start a new game immediately if enough players are waiting. fn join_waiting_list(\u0026amp;self, player: PlayerId) { // Lock the mutex and gain access to the data inside. // The scope of `guard` is a critical section. let mut guard = self.waiting_list.lock().unwrap(); // Now do the game logic. guard.push(player); if guard.len() == GAME_SIZE { let players = guard.split_off(0); self.start_game(players); } } } å–å¾—æ•°æ®çš„å”¯ä¸€æ–¹æ³•æ˜¯è°ƒç”¨ .lock() æ–¹æ³•ï¼š\n1 let mut guard = self.waiting_list.lock().unwrap(); self.waiting_list.lock() ä¼šä¸€ç›´é˜»å¡åˆ°å¯ä»¥å†æ¬¡è·å¾—äº’æ–¥é‡ã€‚è¿™ä¸ªæ–¹æ³•è°ƒç”¨è¿”å›çš„ MutexGuard\u0026lt;WaitingList\u0026gt; å€¼æ˜¯å¯¹ \u0026amp;mut WaitingList çš„ä¸€ä¸ªç®€å•å°è£…ã€‚å€ŸåŠ© Deref ç±»å‹è½¬æ¢ï¼Œå¯ä»¥ç›´æ¥åœ¨è¿™ä¸ª guard ä¸Šè°ƒç”¨ WaitingList æ–¹æ³•ï¼š\n1 guard.push(player); è¿™ä¸ª guard ç”šè‡³è¿˜å…è®¸æˆ‘ä»¬ç›´æ¥å¼•ç”¨åº•å±‚æ•°æ®ã€‚Rustçš„ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿä¿è¯è¿™äº›å¼•ç”¨çš„å¯¿å‘½æ¯”ä¸ä¼šè¶…å‡º guard è‡ªèº«ã€‚å¦‚æœæ²¡æœ‰æ‹¿åˆ°é”ï¼Œåˆ™ä¸å¯èƒ½åœ¨ Mutex ä¸­è®¿é—®æ•°æ®ã€‚\nåœ¨ guard è¢«æ¸…é™¤åï¼Œé”ä¹Ÿä¼šè¢«é‡Šæ”¾ã€‚é€šå¸¸è¿™ä¼šåœ¨é˜»å¡ç»“æŸæ—¶å‘ç”Ÿï¼Œä½†ä¹Ÿå¯ä»¥æ‰‹å·¥æ¸…é™¤ï¼š\n1 2 3 4 5 if guard.len() == GAME_SIZE { let players = guard.split_off(0); drop(guard); // don\u0026#39;t keep the list locked while starting a game self.start_game(players); } mut and Mutex åœ¨Rustä¸­ï¼Œ\u0026amp;mut æ„å‘³ç€ exclusive accessã€‚Plain \u0026amp; means shared access.\nBut Mutex does have a way: the lock. In fact, a mutex is little more than a way to do exactly this, to provide exclusive (mut) access to the data inside, even though many threads may have shared (non-mut) access to the Mutex itself.\nRustâ€™s type system is telling us what Mutex does. It dynamically enforces exclusive access, something thatâ€™s usually done statically, at compile time, by the Rust compiler.\n(You may recall that std::cell::RefCell does the same, except without trying to support multiple threads. Mutex and RefCell are both flavors of interior mutability, which we covered .)\nWhy Mutexes Are Not Always a Good Idea However, threads that use mutexes are subject to some other problems that Rust doesnâ€™t fix for you:\nValid Rust programs canâ€™t have data races, but they can still have other race conditionsâ€” situations where a programâ€™s behavior depends on timing among threads and may therefore vary from run to run. Some race conditions are benign. Some manifest as general flakiness and incredibly hard-to-fix bugs. Using mutexes in an unstructured way invites race conditions. Itâ€™s up to you to make sure theyâ€™re benign. Shared mutable state also affects program design. Where channels serve as an abstraction boundary in your code, making it easy to separate isolated components for testing, mutexes encourage a â€œjust-add-a-methodâ€ way of working that can lead to a monolithic blob of interrelated code. Lastly, mutexes are just not as simple as they seem at first, as the next two sections will show. All of these problems are inherent in the tools. Use a more structured approach when you can; use a Mutex when you must.\nDeadlock 1 2 let mut guard1 = self.waiting_list.lock().unwrap(); let mut guard2 = self.waiting_list.lock().unwrap(); // deadlock Suppose the first call to self.waiting_list.lock() succeeds, taking the lock. The second call sees that the lock is held, so it blocks, waiting for it to be released. It will be waiting forever. The waiting thread is the one thatâ€™s holding the lock.\nTo put it another way, the lock in a Mutex is not a recursive lock.\nRustâ€™s borrow system canâ€™t protect you from deadlock. The best protection is to keep critical sections small: get in, do your work, and get out.\nItâ€™s also possible to get deadlock with channels.\nPoisoned Mutexes If a thread panics while holding a Mutex, Rust marks the Mutex as poisoned. Any subsequent attempt to lock the poisoned Mutex will get an error result. Our .unwrap() call tells Rust to panic if that happens, propagating panic from the other thread to this one.\nMulticonsumer Channels Using Mutexes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 pub mod shared_channel { use std::sync::{Arc, Mutex}; use std::sync::mpsc::{channel, Sender, Receiver}; /// A thread-safe wrapper around a `Receiver`. #[derive(Clone)] pub struct SharedReceiver\u0026lt;T\u0026gt;(Arc\u0026lt;Mutex\u0026lt;Receiver\u0026lt;T\u0026gt;\u0026gt;\u0026gt;); impl\u0026lt;T\u0026gt; Iterator for SharedReceiver\u0026lt;T\u0026gt; { type Item = T; /// Get the next item from the wrapped receiver. fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;T\u0026gt; { let guard = self.0.lock().unwrap(); guard.recv().ok() } } /// Create a new channel whose receiver can be shared across threads. /// This returns a sender and a receiver, just like the stdlib\u0026#39;s /// `channel()`, and sometimes works as a drop-in replacement. pub fn shared_channel\u0026lt;T\u0026gt;() -\u0026gt; (Sender\u0026lt;T\u0026gt;, SharedReceiver\u0026lt;T\u0026gt;) { let (sender, receiver) = channel(); (sender, SharedReceiver(Arc::new(Mutex::new(receiver)))) } } Read/Write Locks(RwLock\u0026lt;T\u0026gt;) Whereas a mutex has a single lock method, a read/write lock has two locking methods, read and write. The RwLock::write method is like Mutex::lock. It waits for exclusive, mut access to the protected data. The RwLock::read method provides non-mut access, with the advantage that it is less likely to have to wait, because many threads can safely read at once. With a mutex, at any given moment, the protected data has only one reader or writer (or none). With a read/write lock, it can have either one writer or many readers, much like Rust references generally.\nCondition Variables (Condvar) In Rust, the std::sync::Condvar type implements condition variables. A Condvar has methods .wait() and .notify_all(); .wait() blocks until some other thread calls .notify_all().\nAtomics The std::sync::atomic module contains atomic types for lock-free concurrent programming. These types are basically the same as Standard C++ atomics, with some extras:\nAtomicIsize and AtomicUsize are shared integer types corresponding to the single- threaded isize and usize types.\nAtomicI8, AtomicI16, AtomicI32, AtomicI64, and their unsigned variants like AtomicU8 are shared integer types that correspond to the single-threaded types i8, i16, etc.\nAn AtomicBool is a shared bool value.\nAn AtomicPtr\u0026lt;T\u0026gt; is a shared value of the unsafe pointer type *mut T.\nGlobal Variables The simplest way to support incrementing PACKETS_SERVED, while keeping it thread-safe, is to make it an atomic integer:\n1 2 3 use std::sync::atomic::AtomicUsize; static PACKETS_SERVED: AtomicUsize = AtomicUsize::new(0); Once this static is declared, incrementing the packet count is straightforward:\n1 2 3 use std::sync::atomic::Ordering; PACKETS_SERVED.fetch_add(1, Ordering::SeqCst); Atomic globals are limited to simple integers and Booleans. Still, creating a global variable of any other type amounts to solving two problems.\nFirst, the variable must be made thread-safe somehow, because otherwise it canâ€™t be global: for safety, static variables must be both Sync and non-mut. Fortunately, weâ€™ve already seen the solution for this problem. Rust has types for safely sharing values that change: Mutex, RwLock, and the atomic types. These types can be modified even when declared as non-mut. Itâ€™s what they do. (See â€œmut and Mutexâ€.)\nSecond, static initializers can only call functions specifically marked as const, which the compiler can evaluate during compile time. Put another way, their output is deterministic; it depends only on their arguments, not any other state or I/O. That way, the compiler can embed the results of that computation as a compile-time constant. This is similar to C++ constexpr.\nRust limits what const functions can do to a small set of operations, which are enough to be useful while still not allowing any nondeterministic results. const functions canâ€™t take types as generic arguments, only lifetimes, and itâ€™s not possible to allocate memory or operate on raw pointers, even in unsafe blocks. We can, however, use arithmetic operations (including wrapping and saturating arithmetic), logical operations that donâ€™t short-circuit, and other const functions. For example, we can create convenience functions to make defining statics and consts easier and reduce code duplication:\n1 2 3 4 5 6 7 8 9 10 const fn mono_to_rgba(level: u8) -\u0026gt; Color { Color { red: level, green: level, blue: level, alpha: 0xFF } } const WHITE: Color = mono_to_rgba(255); const BLACK: Color = mono_to_rgba(000); Combining these techniques, we might be tempted to write:\n1 2 3 4 static HOSTNAME: Mutex\u0026lt;String\u0026gt; = Mutex::new(String::new()); // error: calls in statics are limited to // constant functions, tuple structs, and // tuple variants Unfortunately, while AtomicUsize::new() and String::new() are const fn, Mutex::new() is not. In order to get around these limitations, we need to use the lazy_static crate.\nWe can declare a global Mutex-controlled HashMap with lazy_static like this:\n1 2 3 4 5 6 use lazy_static::lazy_static; use std::sync::Mutex; lazy_static! { static ref HOSTNAME: Mutex\u0026lt;String\u0026gt; = Mutex::new(String::new()); } Using lazy_static! imposes a tiny performance cost on each access to the static data. The implementation uses std::sync::Once, a low-level synchronization primitive designed for one-time initialization. Behind the scenes, each time a lazy static is accessed, the program executes an atomic load instruction to check that initialization has already occurred. (Once is rather special purpose, so we will not cover it in detail here. It is usually more convenient to use lazy_static! instead. However, it is handy for initializing non-Rust libraries; for an example, see â€œA Safe Interface to libgit2â€.)\nWhat Hacking Concurrent Code in Rust Is Like Rust insists on safety, so from the moment you decide to write a multithreaded program, the focus is on building safe, structured communication. Keeping threads mostly isolated is a good way to convince Rust that what youâ€™re doing is safe. It happens that isolation is also a good way to make sure what youâ€™re doing is correct and maintainable. Again, Rust guides you toward good programs.\nChapter 20. Asynchronous Programming Asynchronous tasks are similar to threads, but are much quicker to create, pass control amongst themselves more efficiently, and have memory overhead an order of magnitude less than that of a thread.\nFrom Synchronous to Asynchronous æ–‡ä¸­ä¸¾äº†åŒæ­¥çš„è·å¾—HTTPè¯·æ±‚å†è¿”å›çš„ä¾‹å­ï¼Œå¯ä»¥çœ‹åˆ°å¤§éƒ¨åˆ†æ—¶é—´éƒ½èŠ±åœ¨ç­‰å¾…ä¸Šäº†ã€‚\nFutures std::future::Future\n1 2 3 4 pub trait Future { type Output; fn poll(self: Pin\u0026lt;\u0026amp;mut Self\u0026gt;, cx: \u0026amp;mut Context\u0026lt;\u0026#39;_\u0026gt;) -\u0026gt; Poll\u0026lt;Self::Output\u0026gt;; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pub enum Poll\u0026lt;T\u0026gt; { /// Represents that a value is immediately ready. #[lang = \u0026#34;Ready\u0026#34;] #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] Ready(#[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] T), /// Represents that a value is not ready yet. /// /// When a function returns `Pending`, the function *must* also /// ensure that the current task is scheduled to be awoken when /// progress can be made. #[lang = \u0026#34;Pending\u0026#34;] #[stable(feature = \u0026#34;futures_api\u0026#34;, since = \u0026#34;1.36.0\u0026#34;)] Pending, } A Future represents an operation that you can test for completion. A futureâ€™s poll method never waits for the operation to finish: it always returns immediately. If the operation is complete, poll returns Poll::Ready(output), where output is its final result. Otherwise, it returns Pending. If and when the future is worth polling again, it promises to let us know by invoking a waker, a callback function supplied in the Context. We call this the â€œpinÌƒata modelâ€ of asynchronous programming: the only thing you can do with a future is whack it with a poll until a value falls out.\nChapter 21. Macros åœ¨ç¼–è¯‘æœŸé—´ï¼Œåœ¨ç±»å‹æ£€æŸ¥å’Œæœºå™¨ç ç”Ÿæˆä¹‹å‰ï¼Œå®ä¼šè¿›è¡Œå±•å¼€ã€‚è”ç³»rustç¼–è¯‘è¿‡ç¨‹å›¾ç†è§£ã€‚\nMacro Basics ç”¨ macro_rules! å®šä¹‰çš„å£°æ˜å®ï¼Œé€šè¿‡æ¨¡å¼åŒ¹é…æ¥å·¥ä½œã€‚ åœ¨ pattern æˆ–è€… template ä¸­ï¼Œå¯ä»¥ç”¨æ–¹æ‹¬å·æˆ–è€…èŠ±æ‹¬å·ä»£æ›¿åœ†æ‹¬å·ã€‚å®ƒä»¬æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚ 1 2 3 assert_eq!(gcd(6, 10), 2); assert_eq![gcd(6, 10), 2)]; assert_eq!{gcd(6, 10), 2}\t// æ³¨æ„ç»“å°¾è¿™é‡Œåˆ†å·æ˜¯å¯é€‰çš„ï¼Œä¹Ÿå¯ä»¥åŠ ä¸Š å¯¹äºå®çš„è°ƒç”¨ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚æŒ‰ç…§æƒ¯ä¾‹ï¼Œè°ƒç”¨ assert_eq! ç”¨åœ†æ‹¬å·ï¼Œè°ƒç”¨ vec! ç”¨æ–¹æ‹¬å·ï¼Œå¯¹äº macro_rules! ç”¨èŠ±æ‹¬å·ã€‚ Basics of Macro Expansion åœ¨ç¼–è¯‘æœŸé—´ï¼ŒRustå±•å¼€å®éå¸¸æ—©ã€‚åœ¨å®å®šä¹‰ä¹‹å‰æ˜¯ä¸èƒ½è°ƒç”¨å®ƒçš„ï¼Œå› ä¸ºRustä¼šå±•å¼€æ¯ä¸€ä¸ªå®è°ƒç”¨ï¼Œè¿™å‘ç”Ÿåœ¨æŸ¥çœ‹ç¨‹åºå‰©ä½™ä»£ç ä¹‹å‰ã€‚ æ­£åˆ™è¡¨è¾¾å¼æ˜¯åœ¨å­—ç¬¦é›†ä¸Šæ“ä½œï¼Œè€Œ pattern æ˜¯åœ¨ token ä¸Šæ“ä½œã€‚æ­£åˆ™è¡¨è¾¾å¼å’Œå®æ¨¡å¼å¦ä¸€ä¸ªé‡è¦çš„åŒºåˆ«æ˜¯åœ¨Rustä¸­åœ†æ‹¬å·ã€å—æ€»æ˜¯æˆå¯¹å‡ºç°çš„ã€‚åœ¨å®å±•å¼€ä¹‹å‰å°±ä¼šè¿›è¡Œæ£€æŸ¥ã€‚ æ³¨è§£å’Œç©ºç™½ä¸æ˜¯ token ï¼Œæ‰€ä»¥ä¸ä¼šå½±å“æ¨¡å¼åŒ¹é…ã€‚ ä¸€èˆ¬å¯èƒ½ä¼šæœ‰ä¸€äº›é”™è¯¯ï¼Œåœ¨å‚æ•°éƒ¨åˆ†ç”¨ $left:expr è€Œä¸æ˜¯ $leftã€‚Rustä¸ä¼šç«‹åˆ»å‘ç°è¿™ä¸ªé”™è¯¯ï¼Œå®ƒä¼šå°† $left å½“ä½œä¸€ä¸ªæ›¿æ¢ï¼Œç›´åˆ°è°ƒç”¨è¿™ä¸ªå®çš„æ—¶å€™ä¼šå‘ç”Ÿé”™è¯¯ã€‚ Unintended Consenquences æ­£ç¡®çš„ assert_eq! å®çš„å®šä¹‰æ˜¯è¿™æ ·çš„ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // æ ‡å‡†åº“ä¸­çš„å®šä¹‰ macro_rules! assert_eq { ($left:expr, $right:expr $(,)?) =\u0026gt; { match (\u0026amp;$left, \u0026amp;$right) {\t// è¿™é‡Œç”¨çš„æ˜¯å¼•ç”¨ (left_val, right_val) =\u0026gt; { if !(*left_val == *right_val) { let kind = $crate::panicking::AssertKind::Eq; // The reborrows below are intentional. Without them, the stack slot for the // borrow is initialized even before the values are compared, leading to a // noticeable slow down. $crate::panicking::assert_failed(kind, \u0026amp;*left_val, \u0026amp;*right_val, $crate::option::Option::None); } } } }; } ä¸ºä»€ä¹ˆä¸è¿™æ ·å†™å‘¢ï¼Ÿ\n1 2 3 4 if !($left == $right) { panic!(\u0026#34;assertion failed: `(left == right)` \\ (left: `{:?}`, right: `{:?}`)\u0026#34;, $left, $right) } å¦‚æœ assert_eq!(letters.pop(), Some('z')) è¿™æ ·è°ƒç”¨ï¼Œç”±äº letters.pop() ä¼šä»ä¸€ä¸ª vector ä¸­ç§»é™¤ä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆå½“ç¬¬äºŒæ¬¡è°ƒç”¨çš„æ—¶å€™å°±ä¼šäº§ç”Ÿä¸€ä¸ªä¸åŒçš„å€¼ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆå®é™…å®å½“ä¸­ $left å’Œ $right åªä¼šä¿å­˜ä¸€æ¬¡å®ƒä»¬çš„å€¼ã€‚\né‚£ä¸ºä»€ä¹ˆå®é‡Œé¢è¦ç”¨å¼•ç”¨ï¼Œä¸èƒ½è¿™æ ·å†™å—ï¼Ÿ\n1 2 3 4 5 6 7 8 9 10 11 macro_rules! bad_assert_eq { ($left:expr, $right:expr) =\u0026gt; { match ($left, $right) {\t// è¿™é‡Œä¸ç”¨å¼•ç”¨ (left_val, right_val) =\u0026gt; { if !(left_val == right_val) { panic!(\u0026#34;assertion failed\u0026#34; /* ... */); } } } }; } å¦‚æœä¼ å…¥çš„å‚æ•°æ˜¯ String ï¼Œé‚£ä¹ˆå°±ä¼šç§»åŠ¨æ‰€æœ‰æƒåˆ°å˜é‡é‡Œé¢ã€‚å› æ­¤è¿™é‡Œè¦ä½¿ç”¨å¼•ç”¨ã€‚\nIn short, macros can do surprising things.\nRepetition æ ‡å‡†åº“ä¸­ vec! å®\n1 2 3 4 5 6 7 8 9 10 11 macro_rules! vec { () =\u0026gt; ( $crate::__rust_force_expr!($crate::vec::Vec::new()) ); ($elem:expr; $n:expr) =\u0026gt; ( $crate::__rust_force_expr!($crate::vec::from_elem($elem, $n)) ); ($($x:expr),+ $(,)?) =\u0026gt; ( $crate::__rust_force_expr!(\u0026lt;[_]\u0026gt;::into_vec(box [$($x),+])) ); } $( PATTERN ), * ç”¨æ¥åŒ¹é…ä»»ä½•ç”¨ , åˆ†éš”çš„ç«‹æ ‡ï¼Œåœ¨åˆ—è¡¨ä¸­æ¯ä¸ªåŒ¹é…ä¸€ä¸ª PATTERNã€‚ Pattern Meaning $( \u0026hellip; )* Match 0 or more times with no separator $( \u0026hellip; ),* Match 0 or more times, separated by commas $( \u0026hellip; );* Match 0 or more times, separated by semicolons $( \u0026hellip; )+ Match 1 or more times with no separator $( \u0026hellip; ),+ Match 1 or more times, separated by commas $( \u0026hellip; );+ Match 1 or more times, separated by semicolons $( \u0026hellip; )? Match 0 or 1 times with no separator $( \u0026hellip; ),? Match 0 or 1 times, separated by commas $( \u0026hellip; );? Match 0 or 1 times, separated by semicolons æ€»ç»“ä¸€ä¸‹å•¦ï¼š\n* åŒ¹é…0æ¬¡æˆ–å¤šæ¬¡ + è‡³å°‘åŒ¹é…ä¸€æ¬¡ ? æœ€å¤šåŒ¹é…ä¸€æ¬¡ ç†è§£ç†è§£è¿™ä¸ªå¤æ‚çš„é¬¼ä¸œè¥¿\n1 \u0026lt;[_]\u0026gt;::into_vec(box [$($x),+]) åˆ›å»ºä¸€ä¸ª boxed æ•°ç»„ç„¶åç”¨ [T]::into_vec æ–¹æ³•å°† boxed æ•°ç»„è½¬æ¢æˆä¸€ä¸ª vector ã€‚ \u0026lt;[_]\u0026gt; æ˜¯ä¸€ä¸ªéå¸¸è§„çš„å†™æ³•ï¼Œç”¨æ¥è¡¨ç¤ºä¸€äº›ç±»å‹çš„åˆ‡ç‰‡ï¼ˆ\u0026ldquo;slice of something\u0026rdquo;ï¼‰ã€‚åƒ fn(),\u0026amp;str,æˆ–è€…[_]ï¼Œæ²¡æœ‰æ˜ç¡®çš„ç±»å‹ï¼Œå°±å¿…é¡»åŒ…åœ¨å°–æ‹¬å·\u0026lt;\u0026gt;é‡Œé¢ã€‚ Built-In Macros ä¸‹é¢çš„è¿™äº›å®æ˜¯å†…ç½®çš„ï¼Œç¡¬ç¼–ç åœ¨ rustc ä¸­ã€‚\nfile!(), line!(), column!() stringingfy!(...tokens...) concat!(str0, str1, ...) Chapter 22. Unsafe Code ","date":"2022-07-05T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/05/Programming-Rust/","title":"Programming Rust"},{"content":"å…ƒç¼–ç¨‹æŠ€æœ¯å¤§æ¦‚åˆ†ä¸ºï¼š\nç®€å•æ–‡æœ¬æ›¿æ¢ ç±»å‹æ¨¡æ¿ åå°„ è¯­æ³•æ‰©å±• ä»£ç è‡ªåŠ¨ç”Ÿæˆ Rustè¯­è¨€é€šè¿‡åå°„å’ŒASTè¯­æ³•æ‰©å±•ä¸¤ç§æ‰‹æ®µæ¥æ”¯æŒå…ƒç¼–ç¨‹ã€‚\nåå°„ åå°„æœºåˆ¶ä¸€èˆ¬æ˜¯æŒ‡ç¨‹åºè‡ªæˆ‘è®¿é—®ã€æ£€æµ‹å’Œä¿®æ”¹å…¶è‡ªèº«çŠ¶æ€æˆ–è¡Œä¸ºçš„èƒ½åŠ›ã€‚Rustæ ‡å‡†åº“æä¾›äº†std::any::Anyæ¥æ”¯æŒè¿è¡Œæ—¶åå°„ã€‚å¯ä»¥å…ˆçœ‹ä¸‹ä»£ç ç»“æ„ï¼š\nAnyå®šä¹‰ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[cfg_attr(not(test), rustc_diagnostic_item = \u0026#34;Any\u0026#34;)] pub trait Any: \u0026#39;static { /// Gets the `TypeId` of `self`. /// /// # Examples /// /// ``` /// use std::any::{Any, TypeId}; /// /// fn is_string(s: \u0026amp;dyn Any) -\u0026gt; bool { /// TypeId::of::\u0026lt;String\u0026gt;() == s.type_id() /// } /// /// assert_eq!(is_string(\u0026amp;0), false); /// assert_eq!(is_string(\u0026amp;\u0026#34;cookie monster\u0026#34;.to_string()), true); /// ``` #[stable(feature = \u0026#34;get_type_id\u0026#34;, since = \u0026#34;1.34.0\u0026#34;)] fn type_id(\u0026amp;self) -\u0026gt; TypeId; } #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] impl\u0026lt;T: \u0026#39;static + ?Sized\u0026gt; Any for T { fn type_id(\u0026amp;self) -\u0026gt; TypeId { TypeId::of::\u0026lt;T\u0026gt;() } } è¯¥ trait åŠ ä¸Šäº†'static ç”Ÿå‘½å‘¨æœŸé™å®šï¼Œæ„å‘³ç€è¯¥ trait ä¸èƒ½è¢«éé™æ€ç”Ÿå‘½å‘¨æœŸçš„ç±»å‹å®ç°ã€‚ impl\u0026lt;T: 'static + ?Sized\u0026gt; Any for T è¡¨ç¤º Rust ä¸­æ»¡è¶³ 'static ç”Ÿå‘½å‘¨æœŸçš„ç±»å‹å‡å®ç°äº†å®ƒã€‚ type_idæ–¹æ³•è¿”å› TypeId ç±»å‹ï¼Œä»£è¡¨ Rust ä¸­æŸä¸ªç±»å‹çš„å…¨å±€å”¯ä¸€æ ‡è¯†ï¼Œå®ƒæ˜¯åœ¨ç¼–è¯‘æ—¶ç”Ÿæˆçš„ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] pub struct TypeId { t: u64, } impl TypeId { /// Returns the `TypeId` of the type this generic function has been /// instantiated with. /// /// # Examples /// /// ``` /// use std::any::{Any, TypeId}; /// /// fn is_string\u0026lt;T: ?Sized + Any\u0026gt;(_s: \u0026amp;T) -\u0026gt; bool { /// TypeId::of::\u0026lt;String\u0026gt;() == TypeId::of::\u0026lt;T\u0026gt;() /// } /// /// assert_eq!(is_string(\u0026amp;0), false); /// assert_eq!(is_string(\u0026amp;\u0026#34;cookie monster\u0026#34;.to_string()), true); /// ``` #[must_use] #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[rustc_const_unstable(feature = \u0026#34;const_type_id\u0026#34;, issue = \u0026#34;77125\u0026#34;)] pub const fn of\u0026lt;T: ?Sized + \u0026#39;static\u0026gt;() -\u0026gt; TypeId { TypeId { t: intrinsics::type_id::\u0026lt;T\u0026gt;() } } } æ¯ä¸ª TypeId éƒ½æ˜¯ä¸€ä¸ªâ€œé»‘ç›’â€ï¼Œä¸èƒ½æ£€æŸ¥å…¶å†…éƒ¨å†…å®¹ï¼Œä½†æ˜¯å…è®¸å¤åˆ¶ã€æ¯”è¾ƒã€æ‰“å°ç­‰æ“ä½œã€‚TypeId å½“å‰ä»…é€‚ç”¨äºå½’å› äº 'static çš„ç±»å‹ï¼Œä½†æ˜¯å¯ä»¥åœ¨ future ä¸­æ¶ˆé™¤æ­¤é™åˆ¶ã€‚ é€šè¿‡ is å‡½æ•°åˆ¤æ–­ç±»å‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 impl dyn Any { /// Returns `true` if the inner type is the same as `T`. /// /// # Examples /// /// ``` /// use std::any::Any; /// /// fn is_string(s: \u0026amp;dyn Any) { /// if s.is::\u0026lt;String\u0026gt;() { /// println!(\u0026#34;It\u0026#39;s a string!\u0026#34;); /// } else { /// println!(\u0026#34;Not a string...\u0026#34;); /// } /// } /// /// is_string(\u0026amp;0); /// is_string(\u0026amp;\u0026#34;cookie monster\u0026#34;.to_string()); /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[inline] pub fn is\u0026lt;T: Any\u0026gt;(\u0026amp;self) -\u0026gt; bool { // Get `TypeId` of the type this function is instantiated with. let t = TypeId::of::\u0026lt;T\u0026gt;(); // Get `TypeId` of the type in the trait object (`self`). let concrete = self.type_id(); // Compare both `TypeId`s on equality. t == concrete } } å› ä¸º Any æ˜¯ä¸€ä¸ª trait ï¼Œæ‰€ä»¥è¿™é‡Œçš„ isæ–¹æ³•çš„ \u0026amp;self å¿…ç„¶æ˜¯ä¸€ä¸ª trait å¯¹è±¡ã€‚ TypeId::of å‡½æ•°ç”¨æ¥è·å–ç±»å‹ T çš„å…¨å±€å”¯ä¸€æ ‡è¯†ç¬¦ t ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //! ä»£ç æ¸…å• 12-3: Any ä¸­å®ç° is æ–¹æ³•æºç ç¤ºæ„ //! ã€ŠRustç¼–ç¨‹ä¹‹é“ã€‹P436 use std::any::{Any, TypeId}; enum E { H, He, Li } struct S { x: u8, y: u8, z: u16 } #[test] fn main() { let v1 = 0xc0ffee_u32; let v2 = E::He; let v3 = S { x: 0xde, y: 0xad, z: 0xbeef }; let v4 = \u0026#34;rust\u0026#34;; let mut a: \u0026amp;dyn Any; a = \u0026amp;v1; assert!(a.is::\u0026lt;u32\u0026gt;()); println!(\u0026#34;{:?}\u0026#34;, TypeId::of::\u0026lt;u32\u0026gt;()); a = \u0026amp;v2; assert!(a.is::\u0026lt;E\u0026gt;()); println!(\u0026#34;{:?}\u0026#34;, TypeId::of::\u0026lt;E\u0026gt;()); a = \u0026amp;v3; assert!(a.is::\u0026lt;S\u0026gt;()); println!(\u0026#34;{:?}\u0026#34;, TypeId::of::\u0026lt;S\u0026gt;()); a = \u0026amp;v4; assert!(a.is::\u0026lt;\u0026amp;str\u0026gt;()); println!(\u0026#34;{:?}\u0026#34;, TypeId::of::\u0026lt;\u0026amp;str\u0026gt;()); } è¾“å‡ºç»“æœï¼š\n1 2 3 4 TypeId { t: 18349839772473174998 } TypeId { t: 5500635625788377815 } TypeId { t: 4485408004367722735 } TypeId { t: 13307641874416792075 } TypeId æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œå…¶å­—æ®µ t å­˜å‚¨äº†ä¸€ä¸²æ•°å­—ï¼Œè¿™å°±æ˜¯å…¨å±€å”¯ä¸€ç±»å‹æ ‡è¯†ç¬¦ï¼Œå®é™…ä¸Šæ˜¯ u64 ç±»å‹ã€‚ä»£è¡¨å”¯ä¸€æ ‡è¯†ç¬¦çš„è¿™ä¸²æ•°å­—ï¼Œåœ¨ä¸åŒçš„ç¼–è¯‘ç¯å¢ƒä¸­ï¼Œäº§ç”Ÿçš„ç»“æœæ˜¯ä¸åŒçš„ã€‚æ‰€ä»¥åœ¨å®é™…å¼€å‘ä¸­ï¼Œæœ€å¥½ä¸è¦å°† TypeId æš´éœ²åˆ°å¤–éƒ¨æ¥å£ä¸­è¢«å½“ä½œä¾èµ–ã€‚ è½¬æ¢åˆ°å…·ä½“ç±»å‹ Any æä¾›äº† downcast_ref å’Œ downcast_mut ä¸¤ä¸ªæˆå¯¹çš„æ³›å‹æ–¹æ³•ï¼Œç”¨äºå°†æ³›å‹Tå‘ä¸‹è½¬æ¢ä¸ºå…·ä½“çš„ç±»å‹ï¼Œè¿”å›å€¼åˆ†åˆ«æ˜¯ Option\u0026lt;\u0026amp;T\u0026gt; å’Œ Option\u0026lt;\u0026amp;mut T\u0026gt; ç±»å‹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 impl dyn Any { /// Returns some reference to the inner value if it is of type `T`, or /// `None` if it isn\u0026#39;t. /// /// # Examples /// /// ``` /// use std::any::Any; /// /// fn print_if_string(s: \u0026amp;dyn Any) { /// if let Some(string) = s.downcast_ref::\u0026lt;String\u0026gt;() { /// println!(\u0026#34;It\u0026#39;s a string({}): \u0026#39;{}\u0026#39;\u0026#34;, string.len(), string); /// } else { /// println!(\u0026#34;Not a string...\u0026#34;); /// } /// } /// /// print_if_string(\u0026amp;0); /// print_if_string(\u0026amp;\u0026#34;cookie monster\u0026#34;.to_string()); /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[inline] pub fn downcast_ref\u0026lt;T: Any\u0026gt;(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;T\u0026gt; { if self.is::\u0026lt;T\u0026gt;() { // SAFETY: just checked whether we are pointing to the correct type, and we can rely on // that check for memory safety because we have implemented Any for all types; no other // impls can exist as they would conflict with our impl. unsafe { Some(self.downcast_ref_unchecked()) } } else { None } } /// Returns some mutable reference to the inner value if it is of type `T`, or /// `None` if it isn\u0026#39;t. /// /// # Examples /// /// ``` /// use std::any::Any; /// /// fn modify_if_u32(s: \u0026amp;mut dyn Any) { /// if let Some(num) = s.downcast_mut::\u0026lt;u32\u0026gt;() { /// *num = 42; /// } /// } /// /// let mut x = 10u32; /// let mut s = \u0026#34;starlord\u0026#34;.to_string(); /// /// modify_if_u32(\u0026amp;mut x); /// modify_if_u32(\u0026amp;mut s); /// /// assert_eq!(x, 42); /// assert_eq!(\u0026amp;s, \u0026#34;starlord\u0026#34;); /// ``` #[stable(feature = \u0026#34;rust1\u0026#34;, since = \u0026#34;1.0.0\u0026#34;)] #[inline] pub fn downcast_mut\u0026lt;T: Any\u0026gt;(\u0026amp;mut self) -\u0026gt; Option\u0026lt;\u0026amp;mut T\u0026gt; { if self.is::\u0026lt;T\u0026gt;() { // SAFETY: just checked whether we are pointing to the correct type, and we can rely on // that check for memory safety because we have implemented Any for all types; no other // impls can exist as they would conflict with our impl. unsafe { Some(self.downcast_mut_unchecked()) } } else { None } } } éé™æ€ç”Ÿå‘½å‘¨æœŸç±»å‹ 1 2 3 4 5 6 7 8 9 10 //! ä»£ç æ¸…å• 12-9: éé™æ€ç”Ÿå‘½å‘¨æœŸç±»å‹æ²¡æœ‰å®ç° Any use std::any::Any; struct Unstatic\u0026lt;\u0026#39;a\u0026gt; { x: \u0026amp;\u0026#39;a i32 } #[test] fn main() { let a = 42; let v = Unstatic { x: \u0026amp;a }; let mut any: \u0026amp;dyn Any; // any = \u0026amp;v; // ç¼–è¯‘é”™è¯¯ } å¸¦å¼•ç”¨å­—æ®µçš„ç»“æ„ä½“ Unstatic\u0026lt;'a\u0026gt; ï¼Œå…¶ç”Ÿå‘½å‘¨æœŸä¸æ˜¯é™æ€çš„ï¼Œç¼–è¯‘ä¼šæŠ¥é”™ã€‚ ä¿®æ”¹ï¼š\n1 2 3 4 5 6 7 8 9 10 #![allow(unused)] use std::any::Any; struct UnStatic\u0026lt;\u0026#39;a\u0026gt; { x: \u0026amp;\u0026#39;a i32 } static ANSWER: i32 = 42; fn main() { let v = UnStatic { x: \u0026amp;ANSWER }; let mut a: \u0026amp;dyn Any; a = \u0026amp;v; assert!(a.is::\u0026lt;UnStatic\u0026gt;()); } Any çš„åº”ç”¨ osoåº“åº”ç”¨ bevy_reflectåº“åº”ç”¨ Remark åœ¨2018 Edition ä¸­ï¼Œä»¥ä¸‹è¯­å¥ä¸ä¼šæŠ¥é”™ï¼š\n1 2 let mut a: \u0026amp;Any; // 2018 Edition Ok let mut a: \u0026amp;dyn Any; // 2018 Edition Ok ä½†æ˜¯åœ¨2021 Editionä¸­ï¼Œå¿…é¡»åŠ ä¸Š dyn ã€‚\n1 2 let mut a: \u0026amp;Any; // 2021 Edition Error: trait objects must include the `dyn` keyword let mut a: \u0026amp;dyn Any; // 2021 Edition Ok å®ç³»ç»Ÿ Rustç¼–è¯‘è¿‡ç¨‹ï¼š\nå£°æ˜å® å®å±•å¼€å‘½ä»¤ï¼š cargo rustc â€“ -Z unstable-options â€“pretty=expanded\nç¤ºä¾‹1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #![allow(unused)] macro_rules! unless { ($arg:expr, $branch:expr) =\u0026gt; ( if !$arg { $branch };); } fn cmp(a: i32, b: i32) { unless!( a \u0026gt; b, { println!(\u0026#34;{} \u0026lt; {}\u0026#34;, a, b); }); } fn main() { let (a, b) = (1, 2); cmp(a, b); } æ”¯æŒtokenç±»å‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 item â€” an item, like a function, struct, module, etc. block â€” a block (i.e. a block of statements and/or an expression, surrounded by braces) stmt â€” a statement pat â€” a pattern expr â€” an expression ty â€” a type ident â€” an identifier æ ‡è¯†ç¬¦ path â€” a path (e.g., foo, ::std::mem::replace, transmute::\u0026lt;_, int\u0026gt;, â€¦) meta â€” a meta item; the things that go inside #[...] and #![...] attributes tt â€” a single token tree vis â€” a possibly empty Visibility qualifier lifetime â€” æŒ‡ä»£å£°æ˜å‘¨æœŸå‚æ•° hashmap 1.0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 macro_rules! hashmap { ($($key:expr =\u0026gt; $value:expr), *) =\u0026gt; { { let mut _map = ::std::collections::HashMap::new(); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2 // \u0026#34;c\u0026#34; =\u0026gt; 3, // ä¼šæŠ¥é”™ï¼Œä¸æ”¯æŒç»“å°¾æœ‰é€—å· }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } hashmap 2.0ï¼šå¯ä»¥åŒ¹é…ç»“å°¾æœ‰é€—å·\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 macro_rules! hashmap { ($($key:expr =\u0026gt; $value:expr,)*) =\u0026gt; { hashmap!($($key =\u0026gt; $value),*) }; ($($key:expr =\u0026gt; $value:expr),*) =\u0026gt; { { let mut _map = ::std::collections::HashMap::new(); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2, \u0026#34;c\u0026#34; =\u0026gt; 3, }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } hashmap 3.0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 macro_rules! hashmap { ($($key:expr =\u0026gt; $value:expr),* $(,)*) =\u0026gt; { { let mut _map = ::std::collections::HashMap::new(); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2, \u0026#34;c\u0026#34; =\u0026gt; 3, }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } hashmap 4.0 ï¼š èŠ‚çœå­˜å‚¨ç©ºé—´\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 macro_rules! unit { ($($x:tt)*) =\u0026gt; (()); } macro_rules! count { ($($key:expr),*) =\u0026gt; (\u0026lt;[()]\u0026gt;::len(\u0026amp;[$(unit!($key)),*])); } macro_rules! hashmap { ($($key:expr =\u0026gt; $value:expr),* $(,)*) =\u0026gt; { { let _cap = count!($($key),*); let mut _map = ::std::collections::HashMap::with_capacity(_cap); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2, \u0026#34;c\u0026#34; =\u0026gt; 3, }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } hashmap 5.0ï¼šå°†å£°æ˜å®æ”¾åœ¨ä¸€èµ·\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 macro_rules! hashmap { (@unit $($x:tt)*) =\u0026gt; (()); (@count $($rest:expr),*) =\u0026gt; (\u0026lt;[()]\u0026gt;::len(\u0026amp;[$(hashmap!(@unit $rest)),*])); ($($key:expr =\u0026gt; $value:expr),* $(,)*) =\u0026gt; { { let _cap = hashmap!(@count $($key),*); let mut _map = ::std::collections::HashMap::with_capacity(_cap); $( _map.insert($key, $value); )* _map } }; } #[test] fn main() { let map = hashmap!{ \u0026#34;a\u0026#34; =\u0026gt; 1, \u0026#34;b\u0026#34; =\u0026gt; 2, \u0026#34;c\u0026#34; =\u0026gt; 3, }; assert_eq!(map[\u0026#34;a\u0026#34;], 1); } ç¤ºä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 10 macro_rules! sum { ($e:expr) =\u0026gt; ({ let a = 2; $e + a }) } fn main(){ // error[E0425]: cannot find value `a` in this scope let four = sum!(a); } æ³¨æ„è¿™é‡Œä¼šæŠ¥é”™ï¼Œå®é‡Œé¢çš„ a å˜é‡æ˜¯å±€éƒ¨çš„ã€‚ è¿‡ç¨‹å® è¿‡ç¨‹å®ä¸‰ä»¶å¥—ï¼š\nsyn quote proc-macro2 ä»‹ç»ï¼š\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. å°† token æµè½¬æ¢æˆè¯­æ³•æ ‘ã€‚ quote: This crate provides the quote! macro for turning Rust syntax tree data structures into tokens of source code. å°†è¯­æ³•æ ‘è½¬æ¢æˆ token æºç ã€‚ proc-macro2 æ¯” proc-macro æ›´åŠ çš„çµæ´»ã€‚TokenStream APIæ¥å£ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 // find_by_or!{ Person -\u0026gt; people::[name:String || company_name:String] } use super::*; pub struct DbOpByOrBy { pub model: Type, pub table: Ident, pub bracket_token: token::Bracket, pub content: FieldContentOr, } pub struct FieldContentOr { pub name1: Ident, pub ty1: Type, pub name2: Ident, pub ty2: Type, } impl Parse for DbOpByOrBy { fn parse(input: ParseStream) -\u0026gt; Result\u0026lt;Self\u0026gt; { let content; let model: Type = input.parse()?; input.parse::\u0026lt;Token![-\u0026gt;]\u0026gt;()?; let table: Ident = input.parse()?; input.parse::\u0026lt;Token![::]\u0026gt;()?; let bracket_token = bracketed!(content in input); let content = content.parse()?; Ok(DbOpByOrBy { model, table, bracket_token, content, }) } } impl Parse for FieldContentOr { fn parse(input: ParseStream) -\u0026gt; Result\u0026lt;Self\u0026gt; { let name1: Ident = input.parse()?; input.parse::\u0026lt;Token![:]\u0026gt;()?; let ty1: Type = input.parse()?; input.parse::\u0026lt;Token![||]\u0026gt;()?; let name2: Ident = input.parse()?; input.parse::\u0026lt;Token![:]\u0026gt;()?; let ty2: Type = input.parse()?; Ok(FieldContentOr { name1, ty1, name2, ty2, }) } } // in lib.rs // find_by_or!{ Person -\u0026gt; people::[name:String || company_name:String] } #[proc_macro] pub fn find_by_or(input: TokenStream) -\u0026gt; TokenStream { let DbOpByOrBy { model, table, bracket_token, content, } = parse_macro_input!(input as DbOpByOrBy); let (name1, name2) = (content.name1, content.name2); let (ty1, ty2) = (content.ty1, content.ty2); let fn_name = format!(\u0026#34;find_by_{}_or_{}\u0026#34;, name1, name2); let fn_name = Ident::new(\u0026amp;fn_name, proc_macro2::Span::call_site()); let expanded = quote! { impl #model { pub fn #fn_name(conn: \u0026amp;PgConnection, #name1: #ty1, #name2: #ty2) -\u0026gt; QueryResult\u0026lt;#model\u0026gt; { #table::table .filter(#table::dsl::#name1.eq(#name1)) .or_filter(#table::dsl::#name2.eq(#name2)) .get_result(conn) } } }; TokenStream::from(expanded) } å‚è€ƒèµ„æ–™ ã€ŠRustç¼–ç¨‹ä¹‹é“ã€‹ ","date":"2022-07-05T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/05/Rust-meta-programming/","title":"Rustå…ƒç¼–ç¨‹"},{"content":"ç¬¬1ç«  å¼•è®º 1.1 ä»€ä¹ˆæ˜¯æ“ä½œç³»ç»Ÿ æ“ä½œç³»ç»Ÿï¼ˆOperating Systemï¼Œç®€ç§° OSï¼‰æ˜¯ç®¡ç†è®¡ç®—æœºç¡¬ä»¶ä¸è½¯ä»¶èµ„æºçš„ç¨‹åºï¼Œæ˜¯è®¡ç®—æœºçš„åŸºçŸ³ã€‚ æ“ä½œç³»ç»Ÿæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªè¿è¡Œåœ¨è®¡ç®—æœºä¸Šçš„è½¯ä»¶ç¨‹åº ï¼Œç”¨äºç®¡ç†è®¡ç®—æœºç¡¬ä»¶å’Œè½¯ä»¶èµ„æºã€‚ ä¸¾ä¾‹ï¼šè¿è¡Œåœ¨ä½ ç”µè„‘ä¸Šçš„æ‰€æœ‰åº”ç”¨ç¨‹åºéƒ½é€šè¿‡æ“ä½œç³»ç»Ÿæ¥è°ƒç”¨ç³»ç»Ÿå†…å­˜ä»¥åŠç£ç›˜ç­‰ç­‰ç¡¬ä»¶ã€‚ æ“ä½œç³»ç»Ÿå­˜åœ¨å±è”½äº†ç¡¬ä»¶å±‚çš„å¤æ‚æ€§ã€‚ æ“ä½œç³»ç»Ÿå°±åƒæ˜¯ç¡¬ä»¶ä½¿ç”¨çš„è´Ÿè´£äººï¼Œç»Ÿç­¹ç€å„ç§ç›¸å…³äº‹é¡¹ã€‚ æ“ä½œç³»ç»Ÿçš„å†…æ ¸ï¼ˆKernelï¼‰æ˜¯æ“ä½œç³»ç»Ÿçš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œå®ƒè´Ÿè´£ç³»ç»Ÿçš„å†…å­˜ç®¡ç†ï¼Œç¡¬ä»¶è®¾å¤‡çš„ç®¡ç†ï¼Œæ–‡ä»¶ç³»ç»Ÿçš„ç®¡ç†ä»¥åŠåº”ç”¨ç¨‹åºçš„ç®¡ç†ã€‚ å†…æ ¸æ˜¯è¿æ¥åº”ç”¨ç¨‹åºå’Œç¡¬ä»¶çš„æ¡¥æ¢ï¼Œå†³å®šç€ç³»ç»Ÿçš„æ€§èƒ½å’Œç¨³å®šæ€§ã€‚ 1.5 æ“ä½œç³»ç»Ÿæ¦‚å¿µ 1.5.1 è¿›ç¨‹ è¿›ç¨‹æœ¬è´¨ä¸Šæ˜¯æ­£åœ¨æ‰§è¡Œçš„ä¸€ä¸ªç¨‹åºã€‚\nåœ°å€ç©ºé—´\nç¬¬2ç«  è¿›ç¨‹ä¸çº¿ç¨‹ è¿›ç¨‹æ˜¯å¯¹æ­£åœ¨è¿è¡Œç¨‹åºçš„ä¸€ä¸ªæŠ½è±¡ã€‚\n2.1 è¿›ç¨‹ ä¸¥æ ¼æ¥è¯´ï¼Œåœ¨æŸä¸€ä¸ªæ—¶åˆ»ï¼ŒCPUåªèƒ½è¿è¡Œä¸€ä¸ªè¿›ç¨‹ã€‚ä½†åœ¨1ç§’é’Ÿå†…ï¼Œå®ƒå¯èƒ½è¿è¡Œå¤šä¸ªè¿›ç¨‹ï¼Œè¿™æ ·å°±äº§ç”Ÿå¹¶è¡Œçš„é”™è§‰ã€‚\n2.1.1 è¿›ç¨‹æ¨¡å‹ ä¸€ä¸ªè¿›ç¨‹å°±æ˜¯ä¸€ä¸ªæ­£åœ¨æ‰§è¡Œç¨‹åºçš„å®ä¾‹ï¼ŒåŒ…æ‹¬ç¨‹åºè®¡æ•°å™¨ã€å¯„å­˜å™¨å’Œå˜é‡çš„å½“å‰å€¼ã€‚\næ¯ä¸ªè¿›ç¨‹æ‰§è¡Œå…¶è¿ç®—é€Ÿåº¦æ˜¯ä¸ç¡®å®šçš„ï¼Œæ‰€ä»¥ï¼Œåœ¨å¯¹è¿›ç¨‹ç¼–ç¨‹æ—¶å†³ä¸èƒ½å¯¹æ—¶åºä½œä»»ä½•æƒ³å½“ç„¶çš„å‡è®¾ã€‚\nè¿›ç¨‹å’Œç¨‹åºæœ‰å¾®å¦™çš„åŒºåˆ«ã€‚åšè›‹ç³•çš„é£Ÿè°±å°±æ˜¯ç¨‹åºï¼Œè¿›ç¨‹å°±æ˜¯å¨å¸ˆé˜…è¯»é£Ÿè°±ã€å–æ¥å„ç§åŸæ–™ä»¥åŠçƒ˜åˆ¶è›‹ç³•ç­‰ä¸€ç³»åˆ—æ“ä½œçš„æ€»å’Œã€‚\nä¸€ä¸ªè¿›ç¨‹æ˜¯æŸç§ç±»å‹çš„ä¸€ä¸ªæ´»åŠ¨ï¼Œå®ƒæœ‰ç¨‹åºã€è¾“å…¥ã€è¾“å‡ºä»¥åŠçŠ¶æ€ã€‚å•ä¸ªå¤„ç†å™¨å¯ä»¥è¢«è‹¥å¹²è¿›ç¨‹å…±äº«ï¼Œå®ƒä½¿ç”¨æŸç§è°ƒåº¦ç®—æ³•å†³å®šä½•æ—¶åœæ­¢ä¸€ä¸ªè¿›ç¨‹çš„å·¥ä½œï¼Œå¹¶è½¬è€Œä¸ºå¦ä¸€ä¸ªè¿›ç¨‹æä¾›æœåŠ¡ã€‚\n2.1.2 è¿›ç¨‹çš„åˆ›å»º 4ç§ä¸»è¦äº‹ä»¶ä¼šå¯¼è‡´è¿›ç¨‹çš„åˆ›å»ºï¼š ç³»ç»Ÿåˆå§‹åŒ– æ­£åœ¨è¿è¡Œçš„ç¨‹åºæ‰§è¡Œäº†åˆ›å»ºè¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨ ç”¨æˆ·è¯·æ±‚åˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹ ä¸€ä¸ªæ‰¹å¤„ç†ä½œä¸šçš„åˆå§‹åŒ– å®ˆæŠ¤è¿›ç¨‹ï¼š åœç•™åœ¨åå°å¤„ç†çš„è¿›ç¨‹ã€‚ æ–°è¿›ç¨‹éƒ½æ˜¯ç”±äºä¸€ä¸ªå·²å­˜åœ¨çš„è¿›ç¨‹æ‰§è¡Œäº†ä¸€ä¸ªç”¨äºåˆ›å»ºè¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨è€Œåˆ›å»ºçš„ã€‚ åœ¨UNIXç³»ç»Ÿä¸­ï¼Œåªæœ‰ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨å¯ä»¥ç”¨æ¥åˆ›å»ºæ–°è¿›ç¨‹ï¼šforkã€‚ 2.1.3 è¿›ç¨‹çš„ç»ˆæ­¢ é€šå¸¸ç”±ä¸‹åˆ—æ¡ä»¶å¼•èµ·è¿›ç¨‹çš„ç»ˆæ­¢ï¼š\næ­£å¸¸é€€å‡ºï¼ˆè‡ªæ„¿çš„ï¼‰ å‡ºé”™é€€å‡ºï¼ˆè‡ªæ„¿çš„ï¼‰ ä¸¥é‡é”™è¯¯ï¼ˆéè‡ªæ„¿ï¼‰ è¢«å…¶ä»–è¿›ç¨‹æ€æ­»ï¼ˆéè‡ªæ„¿ï¼‰ 2.1.4 è¿›ç¨‹çš„å±‚æ¬¡ç»“æ„ è¿›ç¨‹åªæœ‰ä¸€ä¸ªçˆ¶è¿›ç¨‹ï¼ˆä½†æ˜¯å¯ä»¥æœ‰é›¶ä¸ªã€ä¸€ä¸ªã€ä¸¤ä¸ªæˆ–å¤šä¸ªå­è¿›ç¨‹ï¼‰ã€‚ åœ¨UNIXä¸­ï¼Œè¿›ç¨‹å’Œå®ƒçš„æ‰€æœ‰å­è¿›ç¨‹ä»¥åŠåè£”å…±åŒç»„æˆä¸€ä¸ªè¿›ç¨‹ç»„ã€‚ åœ¨UNIXä¸­ï¼Œæ‰€æœ‰çš„è¿›ç¨‹éƒ½å±äºä»¥ init ä¸ºæ ¹çš„ä¸€æ£µæ ‘ã€‚ Windowsä¸­æ²¡æœ‰è¿›ç¨‹å±‚æ¬¡çš„æ¦‚å¿µï¼Œæ‰€æœ‰çš„è¿›ç¨‹éƒ½æ˜¯åœ°ä½ç›¸åŒçš„ã€‚ 2.1.5 è¿›ç¨‹çš„çŠ¶æ€ å½“ä¸€ä¸ªè¿›ç¨‹åœ¨é€»è¾‘ä¸Šä¸èƒ½ç»§ç»­è¿è¡Œæ—¶ï¼Œå®ƒå°±ä¼šè¢«é˜»å¡ã€‚\nP52 å›¾2-2\n2.1.6 è¿›ç¨‹çš„å®ç° ä¸ºäº†å®ç°è¿›ç¨‹æ¨¡å‹ï¼Œæ“ä½œç³»ç»Ÿç»´æŠ¤ç€ä¸€å¼ è¡¨æ ¼ï¼ˆä¸€ä¸ªç»“æ„æ•°ç»„ï¼‰ï¼Œå³è¿›ç¨‹è¡¨ã€‚æ¯ä¸ªè¿›ç¨‹å ç”¨ä¸€ä¸ªè¿›ç¨‹è¡¨é¡¹ã€‚ ä¸æ¯ä¸€I/Oç±»å…³è”çš„æ˜¯ä¸€ä¸ªç§°ä½œä¸­æ–­å‘é‡çš„ä½ç½®ï¼ˆé è¿‘å†…å­˜åº•éƒ¨çš„å›ºå®šåŒºåŸŸï¼‰ã€‚å®ƒåŒ…å«ç»ˆç«¯æœåŠ¡ç¨‹åºçš„å…¥å£åœ°å€ã€‚ 2.1.7 å¤šé“ç¨‹åºè®¾è®¡æ¨¡å‹ é‡‡ç”¨å¤šé“ç¨‹åºè®¾è®¡å¯ä»¥æé«˜CPUçš„åˆ©ç”¨ç‡ï¼Œä¸è¿‡ä¹Ÿè¦è€ƒè™‘è¿›ç¨‹ç­‰å¾…I/Oæ“ä½œçš„æ—¶é—´ã€‚\n2.2 çº¿ç¨‹ åœ¨ä¼ ç»Ÿæ“ä½œç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªè¿›ç¨‹æœ‰ä¸€ä¸ªåœ°å€ç©ºé—´å’Œä¸€ä¸ªæ§åˆ¶çº¿ç¨‹ã€‚\nä¸è¿‡ï¼Œç»å¸¸å­˜åœ¨åœ¨åŒä¸€ä¸ªåœ°å€ç©ºé—´ä¸­å‡†å¹¶è¡Œè¿è¡Œå¤šä¸ªæ§åˆ¶çº¿ç¨‹çš„æƒ…å½¢ã€‚\n2.2.1 çº¿ç¨‹çš„ä½¿ç”¨ å¼•è¿›çº¿ç¨‹çš„åŸå› ï¼š\né€šè¿‡å°†ä¸€äº›åº”ç”¨ç¨‹åºåˆ†è§£æˆå¯ä»¥å‡†å¹¶è¡Œè¿è¡Œçš„å¤šä¸ªé¡ºåºçº¿ç¨‹ï¼Œç¨‹åºè®¾è®¡æ¨¡å‹ä¼šå˜å¾—æ›´ç®€å•ã€‚å¹¶è¡Œå®ä½“æ‹¥æœ‰å…±äº«åŒä¸€ä¸ªåœ°å€ç©ºé—´å’Œæ‰€æœ‰å¯ç”¨æ•°æ®çš„èƒ½åŠ›ã€‚å¯¹äºè¿›ç¨‹æ¥è®²ï¼Œå®ƒä»¬å…·æœ‰çš„æ˜¯ä¸åŒçš„åœ°å€ç©ºé—´ï¼Œå› æ­¤éœ€è¦å¼•å…¥çº¿ç¨‹è¿™æ ·çš„æ¨¡å‹å’Œæ¦‚å¿µã€‚ çº¿ç¨‹æ¯”è¿›ç¨‹æ›´è½»é‡çº§ï¼Œæ‰€ä»¥å®ƒä»¬æ¯”è¿›ç¨‹æ›´å®¹æ˜“ï¼ˆå³æ›´å¿«ï¼‰åˆ›å»ºï¼Œä¹Ÿæ›´å®¹æ˜“æ’¤é”€ã€‚ æ€§èƒ½æ–¹é¢ã€‚å¦‚æœå­˜åœ¨ç€å¤§é‡çš„è®¡ç®—å’Œå¤§é‡çš„I/Oå¤„ç†ï¼Œæ‹¥æœ‰å¤šä¸ªçº¿ç¨‹å…è®¸è¿™äº›æ´»åŠ¨å½¼æ­¤é‡å è¿›è¡Œï¼Œä»è€Œä¼šåŠ å¿«åº”ç”¨ç¨‹åºæ‰§è¡Œçš„é€Ÿåº¦ã€‚ åœ¨å¤šCPUç³»ç»Ÿä¸­ï¼Œå¤šçº¿ç¨‹æ˜¯æœ‰ç›Šçš„ã€‚ ä¸€äº›å…¸å‹çš„ä¾‹å­æ¥ç†è§£å¼•å…¥çº¿ç¨‹çš„å¥½å¤„ï¼š\nå­—å¤„ç†è½¯ä»¶ ä¸€ä¸ªçº¿ç¨‹ä¸ç”¨æˆ·äº¤äº’ ä¸€ä¸ªçº¿ç¨‹åœ¨åå°é‡æ–°è¿›è¡Œæ ¼å¼å¤„ç† ç¬¬ä¸‰ä¸ªçº¿ç¨‹å¯ä»¥å¤„ç†ç£ç›˜å¤‡ä»½ è¿™ä¸ªä¾‹å­ç”¨ä¸‰ä¸ªä¸åŒçš„è¿›ç¨‹ä¸èƒ½åšåˆ°ï¼Œå› ä¸ºä¸‰ä¸ªçº¿ç¨‹ä¼šå¯¹åŒä¸€ä¸ªæ–‡ä»¶è¿›è¡Œæ“ä½œï¼Œå¤šä¸ªçº¿ç¨‹å¯ä»¥å…±äº«å…¬å…±å†…å­˜ã€‚ ä¸‡ç»´ç½‘æœåŠ¡å™¨ åˆ†æ´¾ç¨‹åº å·¥ä½œçº¿ç¨‹ é«˜é€Ÿç¼“å­˜ çº¿ç¨‹è¾ƒå¥½åœ°æ”¹å–„äº†WebæœåŠ¡å™¨çš„æ€§èƒ½ï¼Œè€Œä¸”æ¯ä¸ªçº¿ç¨‹æ˜¯æŒ‰é€šå¸¸æ–¹å¼é¡ºåºç¼–ç¨‹çš„ã€‚ ç¬¬ä¸‰ç§å¯èƒ½çš„è®¾è®¡ï¼šæœ‰é™çŠ¶æ€æœº ä¸‰ç§æ–¹æ¡ˆçš„æ¯”è¾ƒï¼Œè§P57 å›¾2-10 å¿…é¡»å¤„ç†æå¤§é‡æ•°æ®çš„åº”ç”¨ ä¸€ä¸ªè¾“å…¥çº¿ç¨‹ ä¸€ä¸ªå¤„ç†çº¿ç¨‹ ä¸€ä¸ªè¾“å‡ºçº¿ç¨‹ 2.2.2 ç»å…¸çš„çº¿ç¨‹æ¨¡å‹ è¿›ç¨‹æ¨¡å‹åŸºäºä¸¤ç§ç‹¬ç«‹çš„æ¦‚å¿µï¼šèµ„æºåˆ†ç»„å¤„ç†ä¸æ‰§è¡Œã€‚ ç†è§£è¿›ç¨‹çš„ä¸€ä¸ªè§’åº¦æ˜¯ï¼šç”¨æŸç§æ–¹æ³•æŠŠç›¸å…³çš„èµ„æºé›†ä¸­åœ¨ä¸€èµ·ã€‚ è¿›ç¨‹æ‹¥æœ‰ä¸€ä¸ªæ‰§è¡Œçš„çº¿ç¨‹ï¼Œé€šå¸¸ç®€å†™ä¸ºçº¿ç¨‹ã€‚ è¿›ç¨‹ç”¨äºæŠŠèµ„æºé›†ä¸­åˆ°ä¸€èµ·ï¼Œè€Œçº¿ç¨‹åˆ™æ˜¯åœ¨CPUä¸Šè¢«è°ƒåº¦æ‰§è¡Œçš„å®ä½“ã€‚ çº¿ç¨‹ç»™è¿›ç¨‹æ¨¡å‹å¢åŠ äº†ä¸€é¡¹å†…å®¹ï¼Œå³åœ¨åŒä¸€ä¸ªè¿›ç¨‹ç¯å¢ƒä¸‹ï¼Œå…è®¸å½¼æ­¤ä¹‹é—´æœ‰è¾ƒå¤§ç‹¬ç«‹æ€§çš„å¤šä¸ªçº¿ç¨‹æ‰§è¡Œã€‚ åœ¨åŒä¸€ä¸ªè¿›ç¨‹ä¸­è¿è¡Œå¤šä¸ªçº¿ç¨‹ï¼Œå¤šä¸ªçº¿ç¨‹å…±äº«åŒä¸€ä¸ªåœ°å€ç©ºé—´å’Œå…¶ä»–èµ„æºï¼Œè€Œåœ¨åŒä¸€ä¸ªè®¡ç®—æœºä¸Šè¿è¡Œå¤šä¸ªè¿›ç¨‹ï¼Œå¤šä¸ªè¿›ç¨‹å…±äº«ç‰©ç†å†…å­˜ã€ç£ç›˜ã€æ‰“å°æœºå’Œå…¶ä»–èµ„æºï¼Œå› æ­¤çº¿ç¨‹ä¹Ÿè¢«ç§°ä¸ºè½»é‡çº§è¿›ç¨‹ã€‚ å½“å¤šçº¿ç¨‹è¿›ç¨‹åœ¨å•CPUç³»ç»Ÿä¸­è¿è¡Œæ—¶ï¼Œçº¿ç¨‹è½®æµè¿è¡Œã€‚CPUåœ¨çº¿ç¨‹ä¹‹é—´çš„å¿«é€Ÿåˆ‡æ¢ï¼Œåˆ¶é€ äº†çº¿ç¨‹å¹¶è¡Œè¿è¡Œçš„å‡è±¡ã€‚ æ‰€æœ‰çš„çº¿ç¨‹éƒ½æœ‰å®Œå…¨ä¸€æ ·çš„åœ°å€ç©ºé—´ï¼Œè¿™æ„å‘³ç€å®ƒä»¬ä¹Ÿå…±äº«åŒæ ·çš„å…¨å±€å˜é‡ã€‚ç”±äºå„ä¸ªçº¿ç¨‹éƒ½å¯ä»¥è®¿é—®è¿›ç¨‹åœ°å€ç©ºé—´ä¸­çš„æ¯ä¸€ä¸ªå†…å­˜åœ°å€ï¼Œæ‰€ä»¥ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¯»ã€å†™æˆ–ç”šè‡³æ¸…æ¥šå¦ä¸€ä¸ªçº¿ç¨‹çš„å †æ ˆã€‚çº¿ç¨‹ä¹‹é—´æ˜¯æ²¡æœ‰ä¿æŠ¤çš„ã€‚ çº¿ç¨‹æ¦‚å¿µè¯•å›¾å®ç°çš„æ˜¯ï¼Œå…±äº«ä¸€ç»„èµ„æºçš„å¤šä¸ªçº¿ç¨‹çš„æ‰§è¡Œèƒ½åŠ›ï¼Œä»¥ä¾¿è¿™äº›çº¿ç¨‹å¯ä»¥ä¸ºå®ŒæˆæŸä¸€ä»»åŠ¡è€Œå…±åŒå·¥ä½œã€‚ çº¿ç¨‹å¯ä»¥å¤„äºè‹¥å¹²çŠ¶æ€çš„ä»»ä½•ä¸€ä¸ªï¼šè¿è¡Œã€é˜»å¡ã€å°±ç»ªæˆ–ç»ˆæ­¢ã€‚çº¿ç¨‹çŠ¶æ€ä¹‹é—´çš„è½¬æ¢å’Œè¿›ç¨‹çŠ¶æ€ä¹‹é—´çš„è½¬æ¢ä¼¼ä¹ä¸€æ ·çš„ã€‚ è®¤è¯†åˆ°æ¯ä¸ªçº¿ç¨‹æœ‰è‡ªå·±çš„å †æ ˆå¾ˆé‡è¦ã€‚æ¯ä¸ªçº¿ç¨‹çš„å †æ ˆæœ‰ä¸€å¸§ï¼Œä¾›å„ä¸ªè¢«è°ƒç”¨ä½†æ˜¯è¿˜æ²¡æœ‰ä»ä¸­è¿”å›çš„è¿‡ç¨‹ä½¿ç”¨ã€‚åœ¨è¯¥æ ˆå¸§ä¸­å­˜æ”¾äº†ç›¸åº”è¿‡ç¨‹çš„å±€éƒ¨å˜é‡ä»¥åŠè¿‡ç¨‹è°ƒç”¨å®Œä¹‹åä½¿ç”¨çš„è¿”å›åœ°å€ã€‚é€šå¸¸æ¯ä¸ªçº¿ç¨‹ä¼šè°ƒç”¨ä¸åŒçš„è¿‡ç¨‹ï¼Œä»è€Œæœ‰ä¸€ä¸ªå„è‡ªä¸åŒçš„æ‰§è¡Œå†å²ã€‚ è¿›ç¨‹é€šå¸¸ä¼šä»å½“å‰çš„å•ä¸ªçº¿ç¨‹å¼€å§‹ï¼Œè¿™ä¸ªçº¿ç¨‹æœ‰èƒ½åŠ›é€šè¿‡è°ƒç”¨ä¸€ä¸ªåº“å‡½æ•°ï¼ˆå¦‚ thread_create ï¼‰åˆ›å»ºæ–°çš„çº¿ç¨‹ã€‚ä¸è®ºçº¿ç¨‹ä¹‹é—´æœ‰æ— å±‚æ¬¡å…³ç³»ï¼Œåˆ›å»ºçº¿ç¨‹é€šå¸¸éƒ½è¿”å›ä¸€ä¸ªçº¿ç¨‹æ ‡è¯†ç¬¦ï¼Œè¯¥æ ‡è¯†ç¬¦å°±æ˜¯æ–°çº¿ç¨‹çš„åå­—ã€‚ çº¿ç¨‹é€€å‡ºï¼šthread_exit thread_joinï¼šä¸€ä¸ªçº¿ç¨‹å¯ä»¥ç­‰å¾…ä¸€ä¸ªï¼ˆç‰¹å®šï¼‰çº¿ç¨‹é€€å‡ºã€‚ thread_yieldï¼šå…è®¸çº¿ç¨‹è‡ªåŠ¨æ”¾å¼ƒCPUä»è€Œè®©å¦ä¸€ä¸ªçº¿ç¨‹è¿è¡Œã€‚è¿™æ ·ä¸€ä¸ªè°ƒç”¨æ˜¯å¾ˆé‡è¦çš„ï¼Œå› ä¸ºä¸åŒäºè¿›ç¨‹ï¼Œï¼ˆçº¿ç¨‹åº“ï¼‰æ— æ³•åˆ©ç”¨æ—¶é’Ÿä¸­æ–­å¼ºåˆ¶çº¿ç¨‹è®©å‡ºCPUã€‚ 2.2.3 POSIXçº¿ç¨‹ çº¿ç¨‹åŒ… pthreadã€‚\npthread_create pthread_exit pthread_join pthread_yield pthread_attr_initï¼šåˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ªçº¿ç¨‹çš„å±æ€§ç»“æ„ pthread_attr_destroyï¼šåˆ é™¤ä¸€ä¸ªçº¿ç¨‹çš„å±æ€§ç»“æ„ 2.2.4 åœ¨ç”¨æˆ·ç©ºé—´ä¸­å®ç°çº¿ç¨‹ ä¼˜ç‚¹\nç”¨æˆ·çº§çº¿ç¨‹å¯ä»¥åœ¨ä¸æ”¯æŒå¤šçº¿ç¨‹çš„æ“ä½œç³»ç»Ÿä¸Šå®ç°ã€‚ è¿›è¡Œçº¿ç¨‹åˆ‡æ¢æ¯”é™·å…¥å†…æ ¸è¦å¿«ä¸€ä¸ªæ•°é‡çº§ï¼ˆæˆ–è®¸æ›´å¤šï¼‰ã€‚ ä¿å­˜çº¿ç¨‹çŠ¶æ€çš„è¿‡ç¨‹å’Œè°ƒåº¦ç¨‹åºéƒ½åªæ˜¯æœ¬åœ°è¿‡ç¨‹ï¼Œæ‰€ä»¥å¯åŠ¨å®ƒä»¬æ¯”è¿›è¡Œå†…æ ¸è°ƒç”¨æ•ˆç‡æ›´é«˜ã€‚å¦ä¸€æ–¹é¢ï¼Œä¸éœ€è¦é™·å…¥å†…æ ¸ï¼Œä¸éœ€è¦ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œä¹Ÿä¸éœ€è¦å¯¹å†…å­˜é«˜é€Ÿç¼“å­˜è¿›è¡Œåˆ·æ–°ï¼Œè¿™å°±ä½¿å¾—çº¿ç¨‹è°ƒåº¦éå¸¸å¿«æ·ã€‚ å®ƒè¿è¡Œæ¯ä¸ªè¿›ç¨‹æœ‰è‡ªå·±å®šåˆ¶çš„è°ƒåº¦ç®—æ³•ã€‚ ç”¨æˆ·çº§çº¿ç¨‹è¿˜æœ‰è¾ƒå¥½çš„æ‰©å±•æ€§ï¼Œè¿™æ˜¯å› ä¸ºåœ¨å†…æ ¸ç©ºé—´ä¸­å†…æ ¸çº¿ç¨‹éœ€è¦ä¸€äº›å›ºå®šè¡¨æ ¼ç©ºé—´å’Œå †æ ˆç©ºé—´ï¼Œå¦‚æœå†…æ ¸çº¿ç¨‹çš„æ•°é‡éå¸¸å¤§ï¼Œå°±ä¼šå‡ºç°é—®é¢˜ã€‚ åœ¨ç”¨æˆ·ç©ºé—´å®ç°å¤šçº¿ç¨‹ï¼Œçº¿ç¨‹åœ¨ä¸€ä¸ªè¿è¡Œæ—¶ç³»ç»Ÿçš„ä¸Šå±‚è¿è¡Œï¼Œè¯¥è¿è¡Œæ—¶ç³»ç»Ÿæ˜¯ä¸€ä¸ªç®¡ç†çº¿ç¨‹çš„è¿‡ç¨‹çš„é›†åˆã€‚ åœ¨ç”¨æˆ·ç©ºé—´ç®¡ç†çº¿ç¨‹æ—¶ï¼Œæ¯ä¸ªè¿›ç¨‹éœ€è¦æœ‰å…¶ä¸“ç”¨çš„çº¿ç¨‹è¡¨ï¼Œç”¨æ¥è·Ÿè¸ªè¯¥è¿›ç¨‹ä¸­çš„çº¿ç¨‹ã€‚ ç”¨æˆ·çº§çº¿ç¨‹å‡ºç°çš„é—®é¢˜\nå¦‚ä½•å®ç°é˜»å¡ç³»ç»Ÿè°ƒç”¨ã€‚æ›¿ä»£æ–¹æ¡ˆæ˜¯æå‰é€šçŸ¥ã€‚ å¦‚æœä¸€ä¸ªçº¿ç¨‹å¼€å§‹è¿è¡Œï¼Œé‚£ä¹ˆåœ¨è¯¥è¿›ç¨‹ä¸­çš„å…¶ä»–çº¿ç¨‹å°±ä¸èƒ½è¿è¡Œã€‚ 2.2.5 åœ¨å†…æ ¸ä¸­å®ç°çº¿ç¨‹ åœ¨å†…æ ¸ä¸­æœ‰ç”¨æ¥è®°å½•ç³»ç»Ÿä¸­æ‰€æœ‰çº¿ç¨‹çš„çº¿ç¨‹è¡¨ã€‚ å†…æ ¸çš„çº¿ç¨‹è¡¨ä¿å­˜äº†æ¯ä¸ªçº¿ç¨‹çš„å¯„å­˜å™¨ã€çŠ¶æ€å’Œå…¶ä»–ä¿¡æ¯ã€‚ æ‰€æœ‰èƒ½å¤Ÿé˜»å¡çº¿ç¨‹çš„è°ƒç”¨éƒ½ä»¥ç³»ç»Ÿè°ƒç”¨çš„å½¢å¼å®ç°ï¼Œè¿™ä¸è¿è¡Œæ—¶ç³»ç»Ÿè¿‡ç¨‹ç›¸æ¯”ï¼Œä»£ä»·æ˜¯ç›¸å½“å¯è§‚çš„ã€‚ ç”±äºåœ¨å†…æ ¸ä¸­åˆ›å»ºå’Œæ’¤é”€çº¿ç¨‹çš„ä»£ä»·æ¯”è¾ƒå¤§ï¼ŒæŸäº›ç³»ç»Ÿé‡‡å–â€œç¯ä¿â€çš„å¤„ç†æ–¹å¼ï¼Œå›æ”¶å…¶çº¿ç¨‹ã€‚ å†…æ ¸çº¿ç¨‹ä¸éœ€è¦ä»»ä½•æ–°çš„ã€éé˜»å¡ç³»ç»Ÿè°ƒç”¨ã€‚ 2.2.6 æ··åˆå®ç° ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨å†…æ ¸çº§çº¿ç¨‹ï¼Œç„¶åå°†ç”¨æˆ·çº§çº¿ç¨‹ä¸æŸäº›æˆ–è€…å…¨éƒ¨å†…æ ¸çº¿ç¨‹å¤šè·¯å¤ç”¨èµ·æ¥ã€‚åœ¨è¿™ç§æ¨¡å‹ä¸­ï¼Œæ¯ä¸ªå†…æ ¸çº§çº¿ç¨‹æœ‰ä¸€ä¸ªå¯ä»¥è½®æµä½¿ç”¨çš„ç”¨æˆ·çº§çº¿ç¨‹é›†åˆã€‚ 2.2.7 è°ƒåº¦ç¨‹åºæ¿€æ´»æœºåˆ¶ è°ƒåº¦ç¨‹åºæ¿€æ´»å·¥ä½œçš„ç›®æ ‡æ˜¯æ¨¡æ‹Ÿå†…æ ¸çº¿ç¨‹çš„åŠŸèƒ½ï¼Œä½†æ˜¯ä¸ºçº¿ç¨‹åŒ…æä¾›é€šå¸¸åœ¨ç”¨æˆ·ç©ºé—´ä¸­æ‰èƒ½å®ç°çš„æ›´å¥½çš„æ€§èƒ½å’Œæ›´å¤§çš„çµæ´»æ€§ã€‚ ç”±äºé¿å…äº†åœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´ä¹‹é—´çš„ä¸å¿…è¦è½¬æ¢ï¼Œä»è€Œæé«˜äº†æ•ˆç‡ã€‚ å½“ä½¿ç”¨è°ƒåº¦ç¨‹åºæ¿€æ´»æœºåˆ¶æ—¶ï¼Œå†…æ ¸ç»™æ¯ä¸ªè¿›ç¨‹å®‰æ’ä¸€å®šæ•°é‡çš„è™šæ‹Ÿå¤„ç†å™¨ï¼Œå¹¶ä¸”è®©ï¼ˆç”¨æˆ·ç©ºé—´ï¼‰è¿è¡Œæ—¶ç³»ç»Ÿå°†çº¿ç¨‹åˆ†é…åˆ°å¤„ç†å™¨ä¸Šã€‚ 2.2.8 å¼¹å‡ºå¼çº¿ç¨‹ ä¸€ä¸ªæ¶ˆæ¯çš„åˆ°è¾¾å¯¼è‡´ç³»ç»Ÿåˆ›å»ºä¸€ä¸ªå¤„ç†è¯¥æ¶ˆæ¯çš„çº¿ç¨‹ï¼Œè¿™ç§çº¿ç¨‹ç§°ä¸ºå¼¹å‡ºå¼çº¿ç¨‹ã€‚\n2.2.9 ä½¿å•çº¿ç¨‹ä»£ç å¤šçº¿ç¨‹åŒ– ç•¥\n2.3 è¿›ç¨‹é—´é€šä¿¡ è¿›ç¨‹é—´é€šä¿¡ï¼šInter Process Communication, IPCã€‚\nè¿›ç¨‹é—´é€šä¿¡ä¸»è¦è¦è§£å†³ä¸‰ä¸ªé—®é¢˜ï¼š\nä¸€ä¸ªè¿›ç¨‹å¦‚ä½•æŠŠä¿¡æ¯ä¼ é€’ç»™å¦ä¸€ä¸ªã€‚ ç¡®ä¿ä¸¤ä¸ªæˆ–æ›´å¤šçš„è¿›ç¨‹åœ¨å…³é”®æ´»åŠ¨ä¸­ä¸ä¼šå‡ºç°äº¤å‰ã€‚ ä¸æ­£ç¡®çš„é¡ºåºæœ‰å…³ã€‚ 2.3.1 ç«äº‰æ¡ä»¶ ç«äº‰æ¡ä»¶ï¼šä¸¤ä¸ªæˆ–å¤šä¸ªè¿›ç¨‹è¯»å†™æŸäº›å…±äº«æ•°æ®ï¼Œè€Œæœ€åçš„ç»“æœå–å†³äºè¿›ç¨‹è¿è¡Œçš„ç²¾ç¡®æ—¶åºã€‚ä¾‹å¦‚ä¹¦ä¸­ä¸¾çš„è„±æœºæ‰“å°çš„ä¾‹å­ã€‚\n2.3.2 ä¸´ç•ŒåŒº é¿å…ç«äº‰æ¡ä»¶éœ€è¦äº’æ–¥ï¼Œå³ä»¥æŸç§æ‰‹æ®µç¡®ä¿å½“ä¸€ä¸ªè¿›ç¨‹åœ¨ä½¿ç”¨ä¸€ä¸ªå…±äº«å˜é‡æˆ–æ–‡ä»¶æ—¶ï¼Œå…¶ä»–è¿›ç¨‹ä¸èƒ½åšåŒæ ·çš„æ“ä½œã€‚ å¯¹å…±äº«å†…å­˜è¿›è¡Œè®¿é—®çš„ç¨‹åºç‰‡æ®µç§°ä½œä¸´ç•ŒåŒºåŸŸæˆ–ä¸´ç•ŒåŒºã€‚å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿé€‚å½“åœ°å®‰æ’ï¼Œä½¿å¾—ä¸¤ä¸ªè¿›ç¨‹ä¸å¯èƒ½åŒæ—¶å¤„äºä¸´ç•ŒåŒºä¸­ï¼Œå°±èƒ½é¿å…ç«äº‰æ¡ä»¶ã€‚ ä¸€ä¸ªå¥½çš„è§£å†³æ–¹æ¡ˆï¼Œéœ€è¦æ»¡è¶³ä»¥ä¸‹å››ä¸ªæ¡ä»¶ï¼š ä»»ä½•ä¸¤ä¸ªè¿›ç¨‹ä¸èƒ½åŒæ—¶å¤„äºå…¶ä¸´ç•ŒåŒºã€‚ ä¸åº”å¯¹CPUçš„é€Ÿåº¦å’Œæ•°é‡åšä»»ä½•å‡è®¾ã€‚ ä¸´ç•ŒåŒºå¤–è¿è¡Œçš„è¿›ç¨‹ä¸å¾—é˜»å¡å…¶ä»–è¿›ç¨‹ã€‚ ä¸å¾—ä½¿è¿›ç¨‹æ— é™æœŸç­‰å¾…è¿›å…¥ä¸´ç•ŒåŒºã€‚ 2.3.3 å¿™ç­‰å¾…çš„äº’æ–¥ 1.å±è”½ä¸­æ–­ åœ¨å•å¤„ç†å™¨ç³»ç»Ÿä¸­ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯ä½¿æ¯ä¸ªè¿›ç¨‹åœ¨åˆšåˆšè¿›å…¥ä¸´ç•ŒåŒºåç«‹å³å±è”½æ‰€æœ‰ä¸­æ–­ï¼Œå¹¶åœ¨å°±è¦ç¦»å¼€ä¹‹å‰å†æ‰“å¼€ä¸­æ–­ã€‚ è¿™ä¸ªæ–¹æ³•å¹¶ä¸å¥½ã€‚å±è”½ä¸­æ–­å¯¹äºæ“ä½œç³»ç»Ÿæœ¬èº«è€Œè¨€æ˜¯ä¸€é¡¹å¾ˆæœ‰ç”¨çš„æŠ€æœ¯ï¼Œä½†å¯¹äºç”¨æˆ·è¿›ç¨‹åˆ™ä¸æ˜¯ä¸€ç§åˆé€‚çš„é€šç”¨äº’æ–¥æœºåˆ¶ã€‚ 2.é”å˜é‡ è®¾æƒ³æœ‰ä¸€ä¸ªå…±äº«ï¼ˆé”ï¼‰å˜é‡ï¼Œå…¶åˆå§‹å€¼ä¸º0ã€‚0å°±è¡¨ç¤ºä¸´ç•ŒåŒºå†…æ²¡æœ‰è¿›ç¨‹ï¼Œ1è¡¨ç¤ºå·²ç»æœ‰æŸä¸ªè¿›ç¨‹è¿›å…¥ä¸´ç•ŒåŒºã€‚ ç–æ¼ä¹‹å¤„ï¼šä¸€ä¸ªè¿›ç¨‹è¯»å‡ºé”å˜é‡çš„å€¼ä¸º0ï¼Œåœ¨å°†å®ƒè®¾ä¸º1ä¹‹å‰ï¼Œå¦ä¸€ä¸ªè¿›ç¨‹è¢«è°ƒåº¦è¿è¡Œï¼Œå°†è¯¥é”å˜é‡è®¾ç½®ä¸º1ã€‚ç¬¬ä¸€ä¸ªè¿›ç¨‹å†æ¬¡è¿è¡Œï¼Œå°†é”å˜é‡è®¾ç½®ä¸º1ï¼Œè¿™æ ·å°±æœ‰ä¸¤ä¸ªè¿›ç¨‹åœ¨ä¸´ç•ŒåŒºä¸­ã€‚ 3.ä¸¥æ ¼è½®æ¢æ³• å¯¹äºç¼–å†™æ“ä½œç³»ç»Ÿè€Œè¨€ï¼ŒCè¯­è¨€æ˜¯å¼ºå¤§ã€æœ‰æ•ˆã€å¯é¢„çŸ¥å’Œæœ‰ç‰¹æ€§çš„è¯­è¨€ã€‚ è¿ç»­æµ‹è¯•ä¸€ä¸ªå˜é‡ç›´åˆ°æŸä¸ªå€¼å‡ºç°ä¸ºæ­¢ï¼Œç§°ä¸ºå¿™ç­‰å¾…ã€‚ ç”±äºè¿™ç§æ–¹å¼æµªè´¹CPUæ—¶é—´ï¼Œæ‰€ä»¥é€šå¸¸åº”è¯¥é¿å…ã€‚åªæœ‰åœ¨æœ‰ç†ç”±è®¤ä¸ºç­‰å¾…æ—¶é—´éå¸¸çŸ­çš„æƒ…å½¢ä¸‹ï¼Œæ‰ä½¿ç”¨å¿™ç­‰å¾…ã€‚ç”¨äºå¿™ç­‰å¾…çš„é”ï¼Œç§°ä¸ºè‡ªæ—‹é”ã€‚ ç¼ºç‚¹ï¼šåœ¨ä¸€ä¸ªè¿›ç¨‹æ¯”å¦ä¸€ä¸ªæ…¢äº†å¾ˆå¤šçš„æƒ…å†µä¸‹ï¼Œè½®æµè¿›å…¥ä¸´ç•ŒåŒºå¹¶ä¸æ˜¯ä¸€ä¸ªå¥½åŠæ³•ã€‚è¿™ç§æƒ…å†µè¿åäº†å‰é¢å™è¿°çš„æ¡ä»¶3:è¿›ç¨‹0è¢«ä¸€ä¸ªä¸´ç•ŒåŒºä¹‹å¤–çš„è¿›ç¨‹é˜»å¡ã€‚ 4.Petersonè§£æ³• ç•¥\n5. TSLæŒ‡ä»¤ 1 TSL RX,LOCK è¿™æ¡æŒ‡ä»¤ç§°ä¸ºæµ‹è¯•å¹¶åŠ é”ï¼ˆtest and set lockï¼‰ï¼Œå®ƒå°†ä¸€ä¸ªå†…å­˜å­—lockè¯»åˆ°å¯„å­˜å™¨RXä¸­ï¼Œç„¶ååœ¨è¯¥å†…å­˜åœ°å€ä¸Šå­˜ä¸€ä¸ªéé›¶å€¼ã€‚æ‰§è¡ŒTSLæŒ‡ä»¤çš„CPUå°†é”ä½å†…å­˜æ€»çº¿ï¼Œä»¥ç¦æ­¢å…¶ä»–CPUåœ¨æœ¬æŒ‡ä»¤ç»“æŸä¹‹å‰è®¿é—®å†…å­˜ã€‚\né”ä½å­˜å‚¨æ€»çº¿ä¸åŒäºå±è”½ä¸­æ–­ã€‚äº‹å®ä¸Šï¼Œåœ¨å¤„ç†å™¨1ä¸Šå±è”½ä¸­æ–­å¯¹å¤„ç†å™¨2æ ¹æœ¬æ²¡æœ‰ä»»ä½•å½±å“ã€‚è®©å¤„ç†å™¨2è¿œç¦»å†…å­˜ç›´åˆ°å¤„ç†å™¨1å®Œæˆçš„å”¯ä¸€æ–¹æ³•å°±æ˜¯é”ä½æ€»çº¿ï¼Œè¿™éœ€è¦ä¸€ä¸ªç‰¹æ®Šçš„ç¡¬ä»¶è®¾æ–½ã€‚ ä¸ºäº†ä½¿ç”¨TSLæŒ‡ä»¤ï¼Œè¦ä½¿ç”¨ä¸€ä¸ªå…±äº«å˜é‡lockæ¥åè°ƒå¯¹å…±äº«å†…å­˜çš„è®¿é—®ã€‚ è¿›ç¨‹åœ¨è¿›å…¥ä¸´ç•ŒåŒºä¹‹å‰å…ˆè°ƒç”¨enter_regionï¼Œè¿™å°†å¯¼è‡´å¿™ç­‰å¾…ï¼Œç›´åˆ°é”ç©ºé—²ä¸ºæ­¢ï¼Œéšåå®ƒè·å¾—è¯¥é”å¹¶è¿”å›ã€‚åœ¨è¿›ç¨‹ä»ä¸´ç•ŒåŒºè¿”å›æ—¶å®ƒè°ƒç”¨leave_regionï¼Œè¿™å°†æŠŠlockè®¾ç½®ä¸º0ã€‚è¿›ç¨‹å¿…é¡»åœ¨æ­£ç¡®çš„æ—¶é—´è°ƒç”¨enter_regionå’Œleave_regionï¼Œè§£æ³•æ‰èƒ½å¥æ•ˆã€‚ ä¸€ä¸ªå¯æ›¿ä»£TSLæŒ‡ä»¤çš„æ˜¯XCHGï¼Œå®ƒåŸå­æ€§åœ°äº¤æ¢äº†ä¸¤ä¸ªä½ç½®çš„å†…å®¹ã€‚ 2.3.4 ç¡çœ ä¸å”¤é†’ Petersonè§£æ³•å’ŒTSLæˆ–XCHGè§£æ³•éƒ½æ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯å®ƒä»¬éƒ½æœ‰å¿™ç­‰å¾…çš„ç¼ºç‚¹ã€‚è¿™äº›è§£æ³•çš„æœ¬è´¨ï¼šå½“ä¸€ä¸ªè¿›ç¨‹æƒ³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå…ˆæ£€æŸ¥æ˜¯å¦å…è®¸è¿›å…¥ï¼Œè‹¥ä¸å…è®¸ï¼Œåˆ™è¯¥è¿›ç¨‹å°†åŸåœ°ç­‰å¾…ï¼Œç›´åˆ°å…è®¸ä¸ºæ­¢ã€‚è€ƒè™‘ä¼˜å…ˆçº§åè½¬é—®é¢˜ã€‚ è¿›ç¨‹é—´é€šä¿¡åŸè¯­ï¼šsleepå’Œwakeupã€‚ ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜ ä¸¤ä¸ªè¿›ç¨‹å…±äº«ä¸€ä¸ªå…¬å…±çš„å›ºå®šå¤§å°çš„ç¼“å†²åŒºã€‚å…¶ä¸­ä¸€ä¸ªæ˜¯ç”Ÿäº§è€…ï¼Œå°†ä¿¡æ¯æ”¾å…¥ç¼“å†²åŒºï¼›å¦ä¸€ä¸ªæ˜¯æ¶ˆè´¹è€…ï¼Œä»ç¼“å†²åŒºä¸­å–å‡ºä¿¡æ¯ã€‚ é—®é¢˜åœ¨äºå½“ç¼“å†²åŒºå·²æ»¡ï¼Œè€Œæ­¤æ—¶ç”Ÿäº§è€…è¿˜æƒ³å‘å…¶ä¸­æ”¾å…¥ä¸€ä¸ªæ–°çš„æ•°æ®é¡¹çš„æƒ…å†µã€‚å…¶è§£å†³åŠæ³•æ˜¯è®©ç”Ÿäº§è€…ç¡çœ ï¼Œå¾…æ¶ˆè´¹è€…ä»ç¼“å†²åŒºä¸­å–å‡ºä¸€ä¸ªæˆ–å¤šä¸ªæ•°æ®é¡¹æ—¶å†å”¤é†’å®ƒã€‚åŒæ ·åœ°ï¼Œå½“æ¶ˆè´¹è€…è¯•å›¾ä»ç¼“å†²åŒºä¸­å–æ•°æ®è€Œå‘ç°ç¼“å†²åŒºä¸ºç©ºæ—¶ï¼Œæ¶ˆè´¹è€…å°±ç¡çœ ï¼Œç›´åˆ°ç”Ÿäº§è€…å‘å…¶ä¸­æ”¾å…¥ä¸€äº›æ•°æ®æ—¶å†å°†å…¶å”¤é†’ã€‚ è¿™é‡Œæœ‰å¯èƒ½ä¼šå‡ºç°ç«äº‰æ¡ä»¶ï¼Œå…¶åŸå› æ˜¯å¯¹countçš„è®¿é—®æœªåŠ é™åˆ¶ã€‚ é—®é¢˜çš„å®è´¨åœ¨äºå‘ç»™ä¸€ä¸ªï¼ˆå°šï¼‰æœªç¡çœ è¿›ç¨‹çš„wakeupä¿¡å·ä¸¢å¤±äº†ã€‚å¿«é€Ÿå¼¥è¡¥çš„æ–¹æ³•æ˜¯ä¿®æ”¹è§„åˆ™ï¼ŒåŠ ä¸Šä¸€ä¸ªå”¤é†’ç­‰å¾…ä½ã€‚å”¤é†’ç­‰å¾…ä½å®é™…ä¸Šå°±æ˜¯wakeupä¿¡å·çš„ä¸€ä¸ªå°ä»“åº“ã€‚ä½†åŸåˆ™ä¸Šï¼Œè¿™å¹¶æ²¡æœ‰ä»æ ¹æœ¬ä¸Šè§£å†³é—®é¢˜ã€‚ 2.3.5 ä¿¡å·é‡ ä½¿ç”¨ä¸€ä¸ªæ•´å‹å˜é‡æ¥ç´¯è®¡å”¤é†’æ¬¡æ•°ï¼Œä¾›ä»¥åä½¿ç”¨ï¼Œç§°ä½œä¿¡å·é‡ã€‚ è®¾ç«‹ä¸¤ä¸ªæ“ä½œdown (Pæ“ä½œ) å’Œup (Væ“ä½œ)ï¼ˆåˆ†åˆ«ä¸ºä¸€èˆ¬åŒ–åçš„sleepå’Œwakeupï¼‰ã€‚ æ£€æŸ¥æ•°å€¼ã€ä¿®æ”¹å˜é‡å€¼ä»¥åŠå¯èƒ½å‘ç”Ÿçš„ç¡çœ æ“ä½œå‡ä½œä¸ºä¸€ä¸ªå•ä¸€çš„ã€ä¸å¯åˆ†å‰²çš„åŸå­æ“ä½œå®Œæˆã€‚ æ‰€è°“åŸå­æ“ä½œï¼Œæ˜¯æŒ‡ä¸€ç»„ç›¸å…³è”çš„æ“ä½œè¦ä¹ˆä¸é—´æ–­åœ°æ‰§è¡Œï¼Œè¦ä¹ˆéƒ½ä¸æ‰§è¡Œã€‚ upæ“ä½œå¯¹ä¿¡å·é‡çš„å€¼å¢1ã€‚ å¦‚æœä¸€ä¸ªæˆ–å¤šä¸ªè¿›ç¨‹åœ¨è¯¥ä¿¡å·é‡ä¸Šç¡çœ ï¼Œæ— æ³•å®Œæˆä¸€ä¸ªå…ˆå‰çš„downæ“ä½œï¼Œåˆ™ç”±ç³»ç»Ÿé€‰æ‹©å…¶ä¸­çš„ä¸€ä¸ªï¼ˆå¦‚éšæœºæŒ‘é€‰ï¼‰å¹¶å…è®¸è¯¥è¿›ç¨‹å®Œæˆå®ƒçš„downæ“ä½œã€‚ ç”¨ä¿¡å·é‡è§£å†³ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜ ä¸ºç¡®ä¿ä¿¡å·é‡èƒ½æ­£ç¡®å·¥ä½œï¼Œæœ€é‡è¦çš„æ˜¯è¦é‡‡ç”¨ä¸€ç§ä¸å¯åˆ†å‰²çš„æ–¹å¼æ¥å®ç°å®ƒã€‚ è¯¥æ–¹æ¡ˆä½¿ç”¨äº†ä¸‰ä¸ªä¿¡å·é‡ï¼š fullï¼šç”¨æ¥è®°å½•å……æ»¡çš„ç¼“å†²æ§½æ•°ç›®ï¼› emptyï¼šè®°å½•ç©ºçš„ç¼“å†²æ§½çš„æ•°ç›®ï¼› mutexï¼šç”¨æ¥ç¡®ä¿ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä¸ä¼šåŒæ—¶è®¿é—®ç¼“å†²åŒºã€‚å¦‚æœæ¯ä¸ªè¿›ç¨‹åœ¨è¿›å…¥ä¸´ç•ŒåŒºå‰éƒ½æ‰§è¡Œä¸€ä¸ªdownæ“ä½œï¼Œå¹¶åœ¨åˆšåˆšé€€å‡ºæ—¶æ‰§è¡Œä¸€ä¸ªupæ“ä½œï¼Œå°±èƒ½å¤Ÿå®ç°äº’æ–¥ã€‚è¯¥ä¿¡å·é‡ç”¨æˆ·äº’æ–¥ï¼Œä¿è¯ä»»ä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªè¿›ç¨‹è¯»å†™ç¼“å†²åŒºå’Œç›¸å…³å˜é‡ã€‚ fullå’Œemptyç”¨æ¥ä¿è¯æŸç§äº‹ä»¶çš„é¡ºåºå‘ç”Ÿæˆ–ä¸å‘ç”Ÿã€‚ 2.3.6 äº’æ–¥é‡ äº’æ–¥é‡ä»…ä»…é€‚ç”¨äºç®¡ç†å…±äº«èµ„æºæˆ–ä¸€å°æ®µä»£ç ã€‚ äº’æ–¥é‡æ˜¯ä¸€ä¸ªå¯ä»¥å¤„äºä¸¤æ€ä¹‹ä¸€çš„å˜é‡ï¼šè§£é”å’ŒåŠ é”ã€‚ å¸¸å¸¸ä½¿ç”¨ä¸€ä¸ªæ•´å‹é‡ï¼Œ0è¡¨ç¤ºè§£é”ï¼Œè€Œå…¶ä»–æ‰€æœ‰çš„å€¼åˆ™è¡¨ç¤ºåŠ é”ã€‚ å½“ä¸€ä¸ªçº¿ç¨‹ï¼ˆæˆ–è¿›ç¨‹ï¼‰éœ€è¦è®¿é—®ä¸´ç•ŒåŒºæ—¶ï¼Œå®ƒè°ƒç”¨mutex_lockã€‚å¦‚æœè¯¥äº’æ–¥é‡å½“å‰æ˜¯è§£é”çš„ï¼ˆå³ä¸´ç•ŒåŒºå¯ç”¨ï¼‰ï¼Œæ­¤è°ƒç”¨æˆåŠŸï¼Œè°ƒç”¨çº¿ç¨‹å¯ä»¥è‡ªç”±è¿›å…¥è¯¥ä¸´ç•ŒåŒºã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœè¯¥äº’æ–¥é‡å·²ç»åŠ é”ï¼Œè°ƒç”¨çº¿ç¨‹è¢«é˜»å¡ï¼Œç›´åˆ°åœ¨ä¸´ç•ŒåŒºä¸­çš„çº¿ç¨‹å®Œæˆå¹¶è°ƒç”¨mutex_unlockã€‚å¦‚æœå¤šä¸ªçº¿ç¨‹è¢«é˜»å¡åœ¨è¯¥äº’æ–¥é‡ä¸Šï¼Œå°†éšæœºé€‰æ‹©ä¸€ä¸ªçº¿ç¨‹å¹¶å…è®¸å®ƒè·å¾—é”ã€‚ 2.3.7 ç®¡ç¨‹ åŒæ­¥åŸè¯­ï¼šç®¡ç¨‹ã€‚ä¸€ä¸ªç®¡ç¨‹æ˜¯ä¸€ä¸ªç”±è¿‡ç¨‹ã€å˜é‡ä»¥åŠæ•°æ®ç»“æ„ç­‰ç»„æˆçš„é›†åˆï¼Œå®ƒä»¬ç»„æˆä¸€ä¸ªç‰¹æ®Šçš„æ¨¡å—æˆ–è½¯ä»¶åŒ…ã€‚è¿›ç¨‹å¯åœ¨ä»»ä½•éœ€è¦çš„æ—¶å€™è°ƒç”¨ç®¡ç¨‹ä¸­çš„è¿‡ç¨‹ï¼Œä½†å®ƒä»¬ä¸èƒ½åœ¨ç®¡ç¨‹ä¹‹å¤–å£°æ˜çš„è¿‡ç¨‹ä¸­ç›´æ¥è®¿é—®ç®¡ç¨‹å†…çš„æ•°æ®ç»“æ„ã€‚ ç®¡ç¨‹æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„ç‰¹æ€§ï¼Œå³ä»»ä¸€æ—¶åˆ»ç®¡ç¨‹ä¸­åªèƒ½æœ‰ä¸€ä¸ªæ´»è·ƒçš„è¿›ç¨‹ï¼Œè¿™ä¸€ç‰¹æ€§ä½¿ç®¡ç¨‹èƒ½æœ‰æ•ˆåœ°å®Œæˆäº’æ–¥ã€‚ ç¼–è¯‘å™¨è°ƒç”¨ç®¡ç¨‹æ—¶çš„å…¸å‹å¤„ç†æ–¹æ³•æ˜¯ï¼Œå½“ä¸€ä¸ªè¿›ç¨‹è°ƒç”¨ç®¡ç¨‹è¿‡ç¨‹æ—¶ï¼Œè¯¥è¿‡ç¨‹ä¸­çš„å‰å‡ æ¡æŒ‡ä»¤å°†æ£€æŸ¥åœ¨ç®¡ç¨‹ä¸­æ˜¯å¦æœ‰å…¶ä»–çš„æ´»è·ƒè¿›ç¨‹ã€‚å¦‚æœæœ‰ï¼Œè°ƒç”¨è¿›ç¨‹å°†è¢«æŒ‚èµ·ï¼Œç›´åˆ°å¦ä¸€ä¸ªè¿›ç¨‹ç¦»å¼€ç®¡ç¨‹å°†å…¶å”¤é†’ã€‚å¦‚æœæ²¡æœ‰æ´»è·ƒè¿›ç¨‹åœ¨ä½¿ç”¨ç®¡ç¨‹ï¼Œåˆ™è¯¥è°ƒç”¨è¿›ç¨‹å¯ä»¥è¿›å…¥ã€‚ è¿›å…¥ç®¡ç¨‹æ—¶çš„äº’æ–¥ç”±ç¼–è¯‘å™¨è´Ÿè´£ï¼Œä½†é€šå¸¸çš„åšæ³•æ˜¯ç”¨ä¸€ä¸ªäº’æ–¥é‡æˆ–äºŒå…ƒä¿¡å·é‡ã€‚ å®ç°é˜»å¡ï¼Œå¼•å…¥æ¡ä»¶å˜é‡ä»¥åŠç›¸å…³çš„ä¸¤ä¸ªæ“ä½œï¼šwaitå’Œsignalã€‚å½“ä¸€ä¸ªç®¡ç¨‹è¿‡ç¨‹å‘ç°å®ƒæ— æ³•ç»§ç»­è¿è¡Œæ—¶ï¼Œå®ƒä¼šåœ¨æŸä¸ªæ¡ä»¶å˜é‡ä¸Šæ‰§è¡Œwaitæ“ä½œã€‚å¦ä¸€ä¸ªè¿›ç¨‹ï¼Œæ¯”å¦‚æ¶ˆè´¹è€…ï¼Œå¯ä»¥å”¤é†’æ­£åœ¨ç¡çœ çš„ä¼™ä¼´è¿›ç¨‹ï¼Œè¿™å¯ä»¥é€šè¿‡å¯¹å…¶ä¼™ä¼´æ­£åœ¨ç­‰å¾…çš„ä¸€ä¸ªæ¡ä»¶å˜é‡æ‰§è¡Œsignalå®Œæˆã€‚ Brinch Hansen å»ºè®®æ‰§è¡Œsignalçš„è¿›ç¨‹å¿…é¡»ç«‹å³é€€å‡ºç®¡ç¨‹ï¼Œå³signalè¯­å¥åªå¯èƒ½ä½œä¸ºä¸€ä¸ªç®¡ç¨‹è¿‡ç¨‹çš„æœ€åä¸€ä¸ªè¯­å¥ã€‚ sleepå’Œwakeupä¹‹æ‰€ä»¥å¤±è´¥æ˜¯å› ä¸ºå½“ä¸€ä¸ªè¿›ç¨‹æƒ³ç¡çœ æ—¶å¦ä¸€ä¸ªè¿›ç¨‹è¯•å›¾å»å”¤é†’å®ƒã€‚ä½¿ç”¨ç®¡ç¨‹åˆ™ä¸ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚å¦‚æœç®¡ç¨‹è¿‡ç¨‹ä¸­çš„ç”Ÿäº§è€…å‘ç°ç¼“å†²åŒºæ»¡ï¼Œå®ƒå°†èƒ½å¤Ÿå®Œæˆwaitæ“ä½œè€Œä¸ç”¨æ‹…å¿ƒè°ƒåº¦ç¨‹åºå¯èƒ½ä¼šåœ¨waitå®Œæˆä¹‹å‰åˆ‡æ¢åˆ°æ¶ˆè´¹è€…ã€‚ç”šè‡³ï¼Œåœ¨waitæ‰§è¡Œå®Œæˆè€Œä¸”æŠŠç”Ÿäº§è€…æ ‡å¿—ä¸ºä¸å¯è¿è¡Œä¹‹å‰ï¼Œæ ¹æœ¬ä¸ä¼šå…è®¸æ¶ˆè´¹è€…è¿›å…¥ç®¡ç¨‹ã€‚ ä¿¡å·é‡å¤ªä½çº§äº†ï¼Œè€Œç®¡ç¨‹åœ¨å°‘æ•°å‡ ç§ç¼–ç¨‹è¯­è¨€ä¹‹å¤–æ— æ³•ä½¿ç”¨ï¼Œå¹¶ä¸”ï¼Œè¿™äº›åŸè¯­å‡æœªæä¾›æœºå™¨é—´çš„ä¿¡æ¯äº¤æ¢æ–¹æ³•ã€‚æ‰€ä»¥è¿˜éœ€è¦å…¶ä»–çš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯æ¶ˆæ¯ä¼ é€’ã€‚\n2.3.8 æ¶ˆæ¯ä¼ é€’ æ¶ˆæ¯ä¼ é€’çš„ä¸¤æ¡åŸè¯­sendå’Œreceiveã€‚\nå¦‚æœæ²¡æœ‰æ¶ˆæ¯å¯ç”¨ï¼Œåˆ™æ¥æ”¶è€…å¯èƒ½è¢«é˜»å¡ï¼Œç›´åˆ°ä¸€æ¡æ¶ˆæ¯çš„åˆ°è¾¾ï¼Œæˆ–è€…ï¼Œå¸¦ç€ä¸€ä¸ªé”™è¯¯ç ç«‹å³è¿”å›ã€‚\n1. æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿçš„è®¾è®¡è¦ç‚¹ ä¸ºäº†é˜²æ­¢æ¶ˆæ¯ä¸¢å¤±ï¼Œä¸€æ—¦æ¥æ”¶åˆ°ä¿¡æ¯ï¼Œæ¥æ”¶æ–¹é©¬ä¸Šå›é€ä¸€æ¡ç‰¹æ®Šçš„ç¡®è®¤æ¶ˆæ¯ã€‚å¦‚æœå‘é€æ–¹åœ¨ä¸€æ®µæ—¶é—´é—´éš”å†…æœªæ”¶åˆ°ç¡®è®¤ï¼Œåˆ™é‡å‘æ¶ˆæ¯ã€‚\nå¯¹äºæ¥æ”¶è€…æ¥è¯´ï¼Œå¦‚ä½•åŒºåˆ†æ–°çš„æ¶ˆæ¯å’Œä¸€æ¡é‡å‘çš„è€æ¶ˆæ¯æ˜¯éå¸¸é‡è¦çš„ã€‚é€šå¸¸é‡‡ç”¨åœ¨æ¯æ¡åŸå§‹æ¶ˆæ¯ä¸­åµŒå…¥ä¸€ä¸ªè¿ç»­çš„åºå·æ¥è§£å†³æ­¤é—®é¢˜ã€‚\næ¶ˆæ¯ç³»ç»Ÿè¿˜éœ€è¦è§£å†³è¿›ç¨‹å‘½åçš„é—®é¢˜ï¼Œåœ¨sendå’Œreceiveè°ƒç”¨ä¸­æ‰€æŒ‡å®šçš„è¿›ç¨‹å¿…é¡»æ˜¯æ²¡æœ‰äºŒä¹‰æ€§çš„ã€‚èº«ä»½è®¤è¯ä¹Ÿæ˜¯ä¸€ä¸ªé—®é¢˜ã€‚è¿˜æœ‰æ€§èƒ½é—®é¢˜ã€‚\n2. ç”¨æ¶ˆæ¯ä¼ é€’è§£å†³ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜ åœ¨è¯¥è§£å†³æ–¹æ¡ˆä¸­å…±ä½¿ç”¨Næ¡æ¶ˆæ¯ï¼Œç±»ä¼¼äºä¸€ä¸ªå…±äº«å†…å­˜ç¼“å†²åŒºä¸­çš„Nä¸ªæ§½ã€‚å½“ç”Ÿäº§è€…å‘æ¶ˆè´¹è€…ä¼ é€’ä¸€ä¸ªæ•°æ®é¡¹æ—¶ï¼Œå®ƒå–èµ°ä¸€æ¡ç©ºæ¶ˆæ¯å¹¶é€å›ä¸€æ¡å¡«å……äº†å†…å®¹çš„æ¶ˆæ¯ã€‚\nå¦‚ä½•å¯¹æ¶ˆæ¯è¿›è¡Œç¼–å€ã€‚ä¸€ç§æ–¹æ³•æ˜¯ä¸ºæ¯ä¸ªè¿›ç¨‹åˆ†é…ä¸€ä¸ªå”¯ä¸€çš„åœ°å€ï¼Œè®©æ¶ˆæ¯æŒ‰è¿›ç¨‹çš„åœ°å€ç¼–å€ã€‚å¦ä¸€ç§æ–¹æ³•æ˜¯å¼•å…¥ä¿¡ç®±ï¼Œæ˜¯ä¸€ä¸ªç”¨æ¥å¯¹ä¸€å®šæ•°é‡çš„æ¶ˆæ¯è¿›è¡Œç¼“å†²çš„åœ°æ–¹ã€‚\n2.3.9 å±éšœ å±éšœå¯ç”¨äºä¸€ç»„è¿›ç¨‹åŒæ­¥ã€‚æ‰§è¡ŒbarrieråŸè¯­ã€‚\n2.3.10 é¿å…é”ï¼šè¯»-å¤åˆ¶-æ›´æ–° æœ€å¿«çš„é”æ˜¯æ ¹æœ¬æ²¡æœ‰é”ã€‚\nç„¶è€Œï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥å…è®¸å†™æ“ä½œæ¥æ›´æ–°æ•°æ®ç»“æ„ï¼Œå³ä¾¿è¿˜æœ‰å…¶ä»–çš„è¿›ç¨‹æ­£åœ¨ä½¿ç”¨å®ƒã€‚çªé—¨åœ¨äºç¡®ä¿æ¯ä¸ªè¯»æ“ä½œè¦ä¹ˆè¯»å–æ—§çš„æ•°æ®ç‰ˆæœ¬ï¼Œè¦ä¹ˆè¯»å–æ–°çš„æ•°æ®ç‰ˆæœ¬ï¼Œä½†ç»ä¸èƒ½æ˜¯æ–°æ—§æ•°æ®çš„ä¸€äº›å¥‡æ€ªç»„åˆã€‚\nè¯»-å¤åˆ¶-æ›´æ–°ï¼Œå°†æ›´æ–°è¿‡ç¨‹ä¸­çš„ç§»é™¤å’Œå†åˆ†é…è¿‡ç¨‹åˆ†ç¦»å¼€æ¥ã€‚\n2.4 è°ƒåº¦ 2.4.1 è°ƒåº¦ç®€ä»‹ 1. è¿›ç¨‹è¡Œä¸º å½“ä¸€ä¸ªè¿›ç¨‹ç­‰å¾…å¤–éƒ¨è®¾å¤‡å®Œæˆå·¥ä½œè€Œè¢«é˜»å¡æ—¶ï¼Œæ‰æ˜¯I/Oæ´»åŠ¨ã€‚\nè®¡ç®—å¯†é›†å‹å’ŒI/Oå¯†é›†å‹ã€‚éšç€CPUå˜å¾—è¶Šæ¥è¶Šå¿«ï¼Œæ›´å¤šçš„è¿›ç¨‹å€¾å‘ä¸ºI/Oå¯†é›†å‹ã€‚\n2. ä½•æ—¶è°ƒåº¦ ç¬¬ä¸€ï¼Œåœ¨åˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹ä¹‹åï¼Œéœ€è¦å†³å®šçš„æ˜¯è¿è¡Œçˆ¶è¿›ç¨‹è¿˜æ˜¯è¿è¡Œå­è¿›ç¨‹ã€‚\nç¬¬äºŒï¼Œåœ¨ä¸€ä¸ªè¿›ç¨‹é€€å‡ºæ—¶å¿…é¡»åšå‡ºè°ƒåº¦å†³ç­–ã€‚\nç¬¬ä¸‰ï¼Œå½“ä¸€ä¸ªè¿›ç¨‹é˜»å¡åœ¨I/Oå’Œä¿¡å·é‡ä¸Šæˆ–ç”±äºå…¶ä»–åŸå› é˜»å¡æ—¶ï¼Œå¿…é¡»é€‰æ‹©å¦ä¸€ä¸ªè¿›ç¨‹è¿è¡Œã€‚\nç¬¬å››ï¼Œåœ¨ä¸€ä¸ªI/Oä¸­æ–­å‘ç”Ÿæ—¶ï¼Œå¿…é¡»åšå‡ºè°ƒåº¦å†³ç­–ã€‚\næ ¹æ®å¦‚ä½•å¤„ç†æ—¶é’Ÿä¸­æ–­ï¼Œå¯ä»¥æŠŠè°ƒåº¦ç®—æ³•åˆ†ä¸ºä¸¤ç±»ï¼š\néæŠ¢å å¼ æŠ¢å å¼ 3. è°ƒåº¦ç®—æ³•åˆ†ç±» ä¸‰ç§ç¯å¢ƒï¼š\næ‰¹å¤„ç†ã€‚éæŠ¢å å¼ç®—æ³•ã€‚ äº¤äº’å¼ã€‚æŠ¢å æ˜¯å¿…éœ€çš„ï¼ŒæœåŠ¡å™¨ä¹Ÿå½’äºæ­¤ç±»ã€‚ å®æ—¶ã€‚æŠ¢å æœ‰æ—¶æ˜¯ä¸éœ€è¦çš„ã€‚ å®æ—¶ç³»ç»Ÿåªè¿è¡Œé‚£äº›ç”¨æ¥æ¨è¿›ç°æœ‰åº”ç”¨çš„ç¨‹åºï¼Œè€Œäº¤äº’å¼ç³»ç»Ÿæ˜¯é€šç”¨çš„ï¼Œå®ƒå¯ä»¥è¿è¡Œä»»æ„çš„éåä½œç”šè‡³æ˜¯æœ‰æ¶æ„çš„ç¨‹åºã€‚\n4. è°ƒåº¦ç®—æ³•çš„ç›®æ ‡ æ‰€æœ‰ç³»ç»Ÿ\nå…¬å¹³â€”â€”ç»™æ¯ä¸ªè¿›ç¨‹å…¬å¹³çš„CPUä»½é¢ ç­–ç•¥å¼ºåˆ¶æ‰§è¡Œâ€”â€”ä¿è¯è§„å®šçš„ç­–ç•¥è¢«æ‰§è¡Œ å¹³è¡¡â€”â€”ä¿æŒç³»ç»Ÿçš„æ‰€æœ‰éƒ¨åˆ†éƒ½å¿™ç¢Œ æ‰¹å¤„ç†ç³»ç»Ÿ\nååé‡â€”â€”æ¯å°æ—¶æœ€å¤§ä½œä¸šæ•° å‘¨è½¬æ—¶é—´â€”â€”ä»æäº¤åˆ°ç»ˆæ­¢é—´çš„æœ€å°æ—¶é—´ CPUåˆ©ç”¨ç‡â€”â€”ä¿æŒCPUå§‹ç»ˆå¿™ç¢Œï¼ŒCPUåˆ©ç”¨ç‡å¹¶ä¸æ˜¯ä¸€ä¸ªå¥½çš„åº¦é‡å‚æ•°ã€‚çœŸæ­£æœ‰ä»·å€¼çš„æ˜¯ï¼Œç³»ç»Ÿæ¯å°æ—¶å¯å®Œæˆå¤šå°‘ä½œä¸šï¼ˆååé‡ï¼‰ï¼Œä»¥åŠå®Œæˆä½œä¸šéœ€è¦å¤šé•¿æ—¶é—´ï¼ˆå‘¨è½¬æ—¶é—´ï¼‰ã€‚ äº¤äº’å¼ç³»ç»Ÿ\nå“åº”æ—¶é—´â€”â€”å¿«é€Ÿå“åº”è¯·æ±‚ å‡è¡¡æ€§â€”â€”æ»¡è¶³ç”¨æˆ·çš„æœŸæœ› å®æ—¶ç³»ç»Ÿ\næ»¡è¶³æˆªæ­¢æ—¶é—´â€”â€”é¿å…ä¸¢å¤±æ•°æ® å¯é¢„æµ‹æ€§â€”â€”åœ¨å¤šåª’ä½“ç³»ç»Ÿä¸­é¿å…å“è´¨é™ä½ 2.4.2 æ‰¹å¤„ç†ç³»ç»Ÿä¸­çš„è°ƒåº¦ 1. å…ˆæ¥å…ˆæœåŠ¡ æœ€ç®€å•çš„æ˜¯éæŠ¢å å¼çš„å…ˆæ¥å…ˆæœåŠ¡ç®—æ³•ã€‚\nå½“åœ¨è¢«é˜»å¡çš„è¿›ç¨‹å˜ä¸ºå°±ç»ªæ—¶ï¼Œå°±åƒä¸€ä¸ªæ–°æ¥åˆ°çš„ä½œä¸šä¸€æ ·ï¼Œæ’åˆ°å°±ç»ªé˜Ÿåˆ—çš„æœ«å°¾ï¼Œå³æ’åœ¨æ‰€æœ‰è¿›ç¨‹æœ€åã€‚\nä¸»è¦ä¼˜ç‚¹æ˜¯æ˜“äºç†è§£å¹¶ä¸”ä¾¿äºåœ¨ç¨‹åºä¸­è¿è¡Œã€‚ç¼ºç‚¹å¾ˆæ˜æ˜¾ã€‚ä¾‹å¦‚ä¸€ä¸ªä¸€æ¬¡è¿è¡Œ1ç§’é’Ÿçš„è®¡ç®—å¯†é›†å‹è¿›ç¨‹å’Œå¾ˆå°‘ä½¿ç”¨CPUä½†æ˜¯æ¯ä¸ªéƒ½è¦è¿›è¡Œ1000æ¬¡ç£ç›˜è¯»æ“ä½œæ‰èƒ½å®Œæˆçš„å¤§é‡I/Oå¯†é›†å‹è¿›ç¨‹å­˜åœ¨ã€‚\n2. æœ€çŸ­ä½œä¸šä¼˜å…ˆ é€‚ç”¨äºè¿è¡Œæ—¶é—´å¯ä»¥é¢„çŸ¥çš„å¦ä¸€ä¸ªéæŠ¢å å¼çš„æ‰¹å¤„ç†è°ƒåº¦ç®—æ³•ã€‚\nåªæœ‰åœ¨æ‰€æœ‰ä½œä¸šéƒ½å¯åŒæ—¶è¿è¡Œçš„æƒ…å½¢ä¸‹ï¼Œæœ€çŸ­ä½œä¸šä¼˜å…ˆç®—æ³•æ‰æ˜¯æœ€ä¼˜çš„ã€‚\n3. æœ€çŸ­å‰©ä½™æ—¶é—´ä¼˜å…ˆ æœ€çŸ­ä½œä¸šä¼˜å…ˆçš„æŠ¢å å¼ç‰ˆæœ¬æ˜¯æœ€çŸ­å‰©ä½™æ—¶é—´ä¼˜å…ˆç®—æ³•ã€‚\nè°ƒåº¦ç¨‹åºæ€»æ˜¯é€‰æ‹©å‰©ä½™è¿è¡Œæ—¶é—´æœ€çŸ­çš„é‚£ä¸ªè¿›ç¨‹è¿è¡Œã€‚å†æ¬¡æé†’ï¼Œæœ‰å…³çš„è¿è¡Œæ—¶é—´å¿…é¡»æå‰æŒæ¡ã€‚\nè¿™ç§æ–¹å¼å¯ä»¥ä½¿æ–°çš„çŸ­ä½œä¸šè·å¾—è‰¯å¥½çš„æœåŠ¡ã€‚\n2.4.3 äº¤äº’å¼ç³»ç»Ÿä¸­çš„è°ƒåº¦ 1. è½®è½¬è°ƒåº¦ ä¸€ç§æœ€å¤è€ã€æœ€ç®€å•ã€æœ€å…¬å¹³ä¸”ä½¿ç”¨æœ€å¹¿çš„ç®—æ³•æ˜¯è½®è½¬è°ƒåº¦ã€‚æ¯ä¸ªè¿›ç¨‹è¢«åˆ†é…ä¸€ä¸ªæ—¶é—´æ®µï¼Œç§°ä¸ºæ—¶é—´ç‰‡ï¼Œå³å…è®¸è¯¥è¿›ç¨‹åœ¨è¯¥æ—¶é—´æ®µä¸­è¿è¡Œã€‚\næ—¶é—´ç‰‡è½®è½¬è°ƒåº¦ä¸­å”¯ä¸€æœ‰è¶£çš„ä¸€ç‚¹æ˜¯æ—¶é—´ç‰‡çš„é•¿åº¦ã€‚æ¶‰åŠåˆ°ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚\næ—¶é—´ç‰‡è®¾å¾—å¤ªçŸ­ä¼šå¯¼è‡´è¿‡å¤šçš„è¿›ç¨‹åˆ‡æ¢ï¼Œé™ä½äº†CPUæ•ˆç‡ï¼›è€Œè®¾å¾—å¤ªé•¿åˆå¯èƒ½å¼•èµ·å¯¹çŸ­çš„äº¤äº’è¯·æ±‚çš„å“åº”æ—¶é—´å˜é•¿ã€‚å°†æ—¶é—´ç‰‡è®¾ä¸º20msï½50msé€šå¸¸æ˜¯ä¸€ä¸ªæ¯”è¾ƒåˆç†çš„æŠ˜ä¸­ã€‚\n2. ä¼˜å…ˆçº§è°ƒåº¦ ä¼˜å…ˆçº§è°ƒåº¦çš„åŸºæœ¬æ€æƒ³æ˜¯ï¼šæ¯ä¸ªè¿›ç¨‹è¢«èµ‹äºˆä¸€ä¸ªä¼˜å…ˆçº§ï¼Œè¿è¡Œä¼˜å…ˆçº§æœ€é«˜çš„å¯è¿è¡Œè¿›ç¨‹çº¿è¿è¡Œã€‚\nä¸ºäº†é˜²æ­¢é«˜ä¼˜å…ˆçº§è¿›ç¨‹æ— ä¼‘æ­¢åœ°è¿è¡Œä¸‹å»ï¼Œè°ƒåº¦ç¨‹åºå¯èƒ½åœ¨æ¯ä¸ªæ—¶é’Ÿæ»´ç­”ï¼ˆå³æ¯ä¸ªæ—¶é’Ÿä¸­æ–­ï¼‰é™ä½å½“å‰è¿›ç¨‹çš„ä¼˜å…ˆçº§ã€‚å¦‚æœè¿™ä¸€è¡Œä¸ºå¯¼è‡´è¯¥è¿›ç¨‹çš„ä¼˜å…ˆçº§ä½äºæ¬¡é«˜ä¼˜å…ˆçº§çš„è¿›ç¨‹ï¼Œåˆ™è¿›è¡Œè¿›ç¨‹åˆ‡æ¢ã€‚å¦ä¸€ç§æ–¹æ³•æ˜¯ï¼Œç»™æ¯ä¸ªè¿›ç¨‹èµ‹äºˆä¸€ä¸ªå…è®¸è¿è¡Œçš„æœ€å¤§æ—¶é—´ç‰‡ï¼Œå½“ç”¨å®Œè¿™ä¸ªæ—¶é—´ç‰‡æ—¶ï¼Œæ¬¡é«˜ä¼˜å…ˆçº§çš„è¿›ç¨‹ä¾¿è·å¾—è¿è¡Œæœºä¼šã€‚\nä¼˜å…ˆçº§å¯ä»¥é™æ€èµ‹äºˆæˆ–åŠ¨æ€èµ‹äºˆã€‚\nä¸ºè¾¾åˆ°æŸç§ç›®çš„ï¼Œä¼˜å…ˆçº§å¯ä»¥ç”±ç³»ç»ŸåŠ¨æ€ç¡®å®šã€‚ä½¿I/Oå¯†é›†å‹è¿›ç¨‹è·å¾—è¾ƒå¥½æœåŠ¡çš„ä¸€ç§ç®€å•ç®—æ³•æ˜¯ï¼Œå°†å…¶ä¼˜å…ˆçº§è®¾ä¸º1/fï¼Œfä¸ºè¯¥è¿›ç¨‹åœ¨ä¸Šä¸€æ—¶é—´ç‰‡ä¸­æ‰€å çš„éƒ¨åˆ†ã€‚\nå¦‚æœä¸å¶å°”å¯¹ä¼˜å…ˆçº§è¿›è¡Œè°ƒæ•´ï¼Œåˆ™ä½ä¼˜å…ˆçº§è¿›ç¨‹å¾ˆå¯èƒ½ä¼šäº§ç”Ÿé¥¥é¥¿ç°è±¡ã€‚\n3. å¤šçº§é˜Ÿåˆ— å±äºæœ€é«˜ä¼˜å…ˆçº§ç±»çš„è¿›ç¨‹è¿è¡Œä¸€ä¸ªæ—¶é—´ç‰‡ï¼Œå±äºæ¬¡é«˜ä¼˜å…ˆçº§ç±»çš„è¿›ç¨‹è¿è¡Œ2ä¸ªæ—¶é—´ç‰‡ï¼Œå†æ¬¡ä¸€çº§è¿è¡Œ4ä¸ªæ—¶é—´ç‰‡ï¼Œä»¥æ­¤ç±»æ¨ã€‚å½“ä¸€ä¸ªè¿›ç¨‹ç”¨å®Œåˆ†é…çš„æ—¶é—´ç‰‡åï¼Œå®ƒè¢«ç§»åŠ¨åˆ°ä¸‹ä¸€ç±»ã€‚\néšç€è¿›ç¨‹ä¼˜å…ˆçº§çš„ä¸æ–­é™ä½ï¼Œå®ƒçš„è¿è¡Œé¢‘åº¦é€æ¸æ”¾æ…¢ï¼Œä»è€Œä¸ºçŸ­çš„äº¤äº’è¿›ç¨‹è®©å‡ºCPUã€‚\nå¯¹äºé‚£äº›åˆšå¼€å§‹è¿è¡Œä¸€æ®µé•¿æ—¶é—´ï¼Œè€Œåæ¥åˆéœ€è¦äº¤äº’çš„è¿›ç¨‹ï¼Œä¸ºäº†é˜²æ­¢å…¶æ°¸è¿œå¤„äºè¢«æƒ©ç½šçŠ¶æ€ï¼Œå¯ä»¥é‡‡å–ä¸‹é¢çš„ç­–ç•¥ã€‚åªè¦ç»ˆç«¯ä¸Šæœ‰å›è½¦é”®æŒ‰ä¸‹ï¼Œåˆ™å±äºè¯¥ç»ˆç«¯çš„æ‰€æœ‰è¿›ç¨‹å°±éƒ½è¢«ç§»åˆ°æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ ·åšçš„åŸå› æ˜¯å‡è®¾æ­¤æ—¶è¿›ç¨‹å³å°†éœ€è¦äº¤äº’ã€‚\n4. æœ€çŸ­è¿›ç¨‹ä¼˜å…ˆ é¦–å…ˆè¿è¡Œæœ€çŸ­çš„ä½œä¸šæ¥ä½¿å“åº”æ—¶é—´æœ€çŸ­ã€‚\nå¦‚ä½•ä»å½“å‰å¯è¿è¡Œè¿›ç¨‹ä¸­æ‰¾å‡ºæœ€çŸ­çš„é‚£ä¸€ä¸ªè¿›ç¨‹ã€‚ä¸€ç§åŠæ³•æ˜¯æ ¹æ®è¿›ç¨‹è¿‡å»çš„è¡Œä¸ºè¿›è¡Œæ¨æµ‹ï¼Œå¹¶æ‰§è¡Œä¼°è®¡è¿è¡Œæ—¶é—´æœ€çŸ­çš„é‚£ä¸€ä¸ªã€‚\nè€åŒ–æŠ€æœ¯ï¼Œå‡è®¾æŸä¸ªç»ˆç«¯ä¸ŠæŸæ¡å‘½ä»¤çš„ä¼°è®¡è¿è¡Œæ—¶é—´ä¸º$T_0$ã€‚ç°åœ¨å‡è®¾æµ‹é‡åˆ°å…¶ä¸‹ä¸€æ¬¡è¿è¡Œæ—¶é—´ä¸º$T_1$ã€‚å¯ä»¥ç”¨è¿™ä¸¤ä¸ªå€¼åŠ æƒå’Œæ¥æ”¹è¿›ä¼°è®¡æ—¶é—´ï¼Œå³$aT_0+(1-a)T_1$ã€‚å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©$a$çš„å€¼ã€‚\n5. ä¿è¯è°ƒåº¦ å‘ç”¨æˆ·ä½œå‡ºæ˜ç¡®çš„æ€§èƒ½ä¿è¯ï¼Œç„¶åå»å®ç°å®ƒã€‚è‹¥ç”¨æˆ·å·¥ä½œæ—¶æœ‰$n$ä¸ªç”¨æˆ·ç™»å½•ï¼Œåˆ™ç”¨æˆ·å°†è·å¾—CPUå¤„ç†èƒ½åŠ›çš„$1/n$ã€‚\nç³»ç»Ÿå¿…é¡»è·Ÿè¸ªå„ä¸ªè¿›ç¨‹è‡ªåˆ›å»ºä»¥æ¥å·²ä½¿ç”¨äº†å¤šå°‘CPUæ—¶é—´ã€‚ç„¶åå®ƒè®¡ç®—å„ä¸ªè¿›ç¨‹åº”è·å¾—çš„CPUæ—¶é—´ï¼Œå³è‡ªåˆ›å»ºä»¥æ¥çš„æ—¶é—´é™¤ä»¥$n$ã€‚è¯¥ç®—æ³•è½¬å‘æ¯”ç‡æœ€ä½çš„è¿›ç¨‹ã€‚\n6. å½©ç¥¨è°ƒåº¦ å…¶åŸºæœ¬æ€æƒ³æ˜¯ä¸ºè¿›ç¨‹æä¾›å„ç§ç³»ç»Ÿèµ„æºï¼ˆå¦‚CPUæ—¶é—´ï¼‰çš„å½©ç¥¨ã€‚ä¸€æ—¦éœ€è¦åšå‡ºä¸€é¡¹è°ƒåº¦å†³ç­–æ—¶ï¼Œå°±éšæœºæŠ½å‡ºä¸€å¼ å½©ç¥¨ï¼Œæ‹¥æœ‰è¯¥å½©ç¥¨çš„è¿›ç¨‹è·å¾—èµ„æºã€‚åœ¨åº”ç”¨åˆ°CPUè°ƒåº¦æ—¶ï¼Œç³»ç»Ÿå¯ä»¥æŒæ¡æ¯ç§’é’Ÿ50æ¬¡çš„ä¸€ç§å½©ç¥¨ï¼Œä½œä¸ºå¥–åŠ±æ¯ä¸ªè·å¥–è€…å¯ä»¥å¾—åˆ°20msçš„CPUæ—¶é—´ã€‚\næ‰€æœ‰è¿›ç¨‹æ˜¯å¹³ç­‰çš„ï¼Œä½†æ˜¯æŸäº›è¿›ç¨‹æ›´å¹³ç­‰ä¸€äº›ã€‚æ‹¥æœ‰å½©ç¥¨$f$ä»½é¢çš„è¿›ç¨‹å¤§çº¦å¾—åˆ°ç³»ç»Ÿèµ„æºçš„$f$ä»½é¢ã€‚\nå½©ç¥¨è°ƒåº¦æ˜¯ååº”è¿…é€Ÿçš„ã€‚\nå½©ç¥¨è°ƒåº¦å¯ä»¥ç”¨æ¥è§£å†³å…¶ä»–æ–¹æ³•å¾ˆéš¾è§£å†³çš„é—®é¢˜ï¼Œä¾‹å¦‚è§†é¢‘æœåŠ¡å™¨æä¾›è§†é¢‘æµï¼Œæ¯ä¸ªè§†é¢‘æµçš„å¸§é€Ÿç‡éƒ½ä¸ç›¸åŒã€‚\n7. å…¬å¹³åˆ†äº«è°ƒåº¦ è€ƒè™‘è°æ‹¥æœ‰è¿›ç¨‹è¿™ä¸€å› ç´ ã€‚\n2.4.4 å®æ—¶ç³»ç»Ÿä¸­çš„è°ƒåº¦ å®æ—¶ç³»ç»Ÿé€šå¸¸å¯ä»¥åˆ†ä¸ºç¡¬å®æ—¶å’Œè½¯å®æ—¶ã€‚å‰è€…çš„å«ä¹‰æ˜¯å¿…é¡»æ»¡è¶³ç»å¯¹çš„æˆªæ­¢æ—¶é—´ï¼Œåè€…çš„å«ä¹‰æ˜¯è™½ç„¶ä¸å¸Œæœ›å¶å°”é”™å¤±æˆªæ­¢æ—¶é—´ï¼Œä½†æ˜¯å¯ä»¥å®¹å¿ã€‚\nå®æ—¶ç³»ç»Ÿçš„è°ƒåº¦ç®—æ³•å¯ä»¥æ˜¯é™æ€æˆ–åŠ¨æ€çš„ã€‚\n2.4.5 ç­–ç•¥å’Œæœºåˆ¶ è§£å†³é—®é¢˜çš„æ–¹æ³•æ˜¯å°†è°ƒåº¦æœºåˆ¶ä¸è°ƒåº¦ç­–ç•¥åˆ†ç¦»è¿™ä¸ªä¸€è´¯çš„åŸåˆ™ã€‚\n2.4.6 çº¿ç¨‹è°ƒåº¦ ç”¨æˆ·çº§çº¿ç¨‹ï¼šè¿è¡Œæ—¶ç³»ç»Ÿä½¿ç”¨è°ƒåº¦ç®—æ³•å¯ä»¥æ˜¯ä¸Šé¢ä»‹ç»çš„ç®—æ³•ä¸­çš„ä»»æ„ä¸€ç§ï¼Œå¸¸ç”¨è½®è½¬è°ƒåº¦å’Œä¼˜å…ˆçº§è°ƒåº¦ã€‚\nå†…æ ¸çº§çº¿ç¨‹ã€‚\nç”¨æˆ·çº§çº¿ç¨‹å’Œå†…æ ¸çº§çº¿ç¨‹ä¹‹é—´çš„å·®åˆ«åœ¨äºæ€§èƒ½ã€‚ç”¨æˆ·çº§çº¿ç¨‹çš„çº¿ç¨‹åˆ‡æ¢éœ€è¦å°‘é‡çš„æœºå™¨æŒ‡ä»¤ï¼Œè€Œå†…æ ¸çº§çº¿ç¨‹éœ€è¦å®Œæ•´çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œä¿®æ”¹å†…å­˜æ˜ åƒï¼Œä½¿é«˜é€Ÿç¼“å­˜å¤±æ•ˆï¼Œè¿™å¯¼è‡´äº†è‹¥å¹²æ•°é‡çº§çš„å»¶è¿Ÿã€‚å¦ä¸€æ–¹é¢ï¼Œåœ¨ä½¿ç”¨å†…æ ¸çº§çº¿ç¨‹æ—¶ï¼Œä¸€æ—¦çº¿ç¨‹é˜»å¡åœ¨I/Oä¸Šå°±ä¸éœ€è¦åƒåœ¨ç”¨æˆ·çº§çº¿ç¨‹ä¸­é‚£æ ·å°†æ•´ä¸ªè¿›ç¨‹æŒ‚èµ·ã€‚\nç”¨æˆ·çº§çº¿ç¨‹å¯ä»¥ä½¿ç”¨ä¸“ä¸ºåº”ç”¨ç¨‹åºå®šåˆ¶çš„çº¿ç¨‹è°ƒåº¦ç¨‹åºã€‚è€Œåœ¨å†…æ ¸çº§çº¿ç¨‹ä¸­ï¼Œå†…æ ¸ä»æ¥ä¸äº†è§£æ¯ä¸ªçº¿ç¨‹çš„ä½œç”¨ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œåº”ç”¨å®šåˆ¶çš„çº¿ç¨‹è°ƒåº¦ç¨‹åºèƒ½å¤Ÿæ¯”å†…æ ¸æ›´å¥½åœ°æ»¡è¶³åº”ç”¨çš„éœ€è¦ã€‚\n2.5 ç»å…¸çš„IPCé—®é¢˜ 2.5.1 å“²å­¦å®¶å°±é¤é—®é¢˜ ä¸€ç§æ²¡æœ‰æ­»é”ï¼Œè€Œä¸”å¯¹äºä»»æ„ä½å“²å­¦å®¶çš„æƒ…å†µéƒ½èƒ½è·å¾—æœ€å¤§çš„å¹¶è¡Œåº¦ã€‚ä½¿ç”¨ä¸€ä¸ªæ•°ç»„stateè·Ÿè¸ªæ¯ä¸€ä¸ªå“²å­¦å®¶æ˜¯åœ¨è¿›é¤ã€æ€è€ƒè¿˜æ˜¯é¥¥é¥¿çŠ¶æ€ï¼ˆæ­£åœ¨è¯•å›¾æ‹¿å‰å­ï¼‰ã€‚ä¸€ä¸ªå“²å­¦å®¶åªæœ‰åœ¨ä¸¤ä¸ªé‚»å±…éƒ½æ²¡æœ‰è¿›é¤æ—¶æ‰å…è®¸è¿›å…¥åˆ°è¿›é¤çŠ¶æ€ã€‚\n2.5.2 è¯»è€…-å†™è€…é—®é¢˜ ä¸ºæ•°æ®åº“è®¿é—®å»ºç«‹äº†ä¸€ä¸ªæ¨¡å‹ã€‚\nç¬¬3ç«  å†…å­˜ç®¡ç† åˆ†å±‚å­˜å‚¨å™¨ä½“ç³» æ“ä½œç³»ç»Ÿä¸­ç®¡ç†åˆ†å±‚å­˜å‚¨å™¨ä½“ç³»çš„éƒ¨åˆ†ç§°ä¸ºå­˜å‚¨ç®¡ç†å™¨ã€‚å®ƒçš„ä»»åŠ¡æ˜¯æœ‰æ•ˆåœ°ç®¡ç†å†…å­˜ï¼Œå³è®°å½•å“ªäº›å†…å­˜æ˜¯æ­£åœ¨ä½¿ç”¨çš„ï¼Œå“ªäº›å†…å­˜æ˜¯ç©ºé—²çš„ï¼›åœ¨è¿›ç¨‹éœ€è¦æ—¶ä¸ºå…¶åˆ†é…å†…å­˜ï¼Œåœ¨è¿›ç¨‹ä½¿ç”¨å®Œåé‡Šæ”¾å†…å­˜ã€‚ 3.1 æ— å­˜å‚¨å™¨æŠ½è±¡ æœ€ç®€å•çš„å­˜å‚¨å™¨æŠ½è±¡å°±æ˜¯æ ¹æœ¬æ²¡æœ‰æŠ½è±¡ï¼Œå…¶æ¨¡å‹å°±æ˜¯ç®€å•çš„ç‰©ç†å†…å­˜ã€‚ åœ¨ä¸ä½¿ç”¨å­˜å‚¨å™¨æŠ½è±¡çš„æƒ…å†µä¸‹è¿è¡Œå¤šä¸ªç¨‹åº\næ“ä½œç³»ç»Ÿåªéœ€è¦æŠŠå½“å‰å†…å­˜ä¸­æ‰€æœ‰å†…å®¹ä¿å­˜åˆ°ç£ç›˜æ–‡ä»¶ä¸­ï¼Œç„¶åæŠŠä¸‹ä¸€ä¸ªç¨‹åºè¯»å…¥åˆ°å†…å­˜ä¸­å†è¿è¡Œå³å¯ã€‚åªè¦åœ¨æŸä¸€ä¸ªæ—¶é—´å†…å­˜ä¸­åªæœ‰ä¸€ä¸ªç¨‹åºï¼Œé‚£ä¹ˆå°±ä¸ä¼šå‘ç”Ÿå†²çªã€‚ ç”¨å†…å­˜é”®çš„æ–¹å¼å¹¶å‘åœ°è¿è¡Œå¤šä¸ªç¨‹åºçš„ç¼ºé™·ï¼šä¼šå‡ºç°å¯¹å†…å­˜åœ°å€çš„ä¸æ­£ç¡®è®¿é—®ï¼Œé—®é¢˜çš„å…³é”®æ˜¯ä¸¤ä¸ªç¨‹åºéƒ½å¼•ç”¨äº†ç»å¯¹ç‰©ç†åœ°å€ã€‚ 3.2 ä¸€ç§å­˜å‚¨å™¨æŠ½è±¡ï¼šåœ°å€ç©ºé—´ æŠŠç‰©ç†åœ°å€æš´éœ²ç»™è¿›ç¨‹çš„å‡ ä¸ªé—®é¢˜ï¼š\nç”¨æˆ·ç¨‹åºå¯ä»¥å¾ˆå®¹æ˜“åœ°ç ´åæ“ä½œç³»ç»Ÿï¼Œä»è€Œä½¿ç³»ç»Ÿæ…¢æ…¢åœ°åœæ­¢è¿è¡Œã€‚ æƒ³è¦åŒæ—¶è¿è¡Œå¤šä¸ªç¨‹åºæ˜¯å¾ˆå›°éš¾çš„ã€‚ 3.2.1 åœ°å€ç©ºé—´çš„æ¦‚å¿µ è¦ä½¿å¤šä¸ªåº”ç”¨ç¨‹åºåŒæ—¶å¤„äºå†…å­˜ä¸­å¹¶ä¸”äº’ä¸å½±å“ï¼Œéœ€è¦è§£å†³ä¸¤ä¸ªé—®é¢˜ï¼šä¿æŠ¤å’Œé‡å®šä½ã€‚ åœ°å€ç©ºé—´ä¸ºç¨‹åºåˆ›é€ äº†ä¸€ç§æŠ½è±¡çš„å†…å­˜ã€‚åœ°å€ç©ºé—´æ˜¯ä¸€ä¸ªè¿›ç¨‹å¯ç”¨äºå¯»å€å†…å­˜çš„ä¸€å¥—åœ°å€é›†åˆã€‚æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸€ä¸ªè‡ªå·±çš„åœ°å€ç©ºé—´ï¼Œå¹¶ä¸”è¿™ä¸ªåœ°å€ç©ºé—´ç‹¬ç«‹äºå…¶ä»–è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼ˆé™¤äº†åœ¨ä¸€äº›ç‰¹æ®Šæƒ…å†µä¸‹è¿›ç¨‹éœ€è¦å…±äº«å®ƒä»¬çš„åœ°å€ç©ºé—´å¤–ï¼‰ã€‚ åœ°å€ç©ºé—´æ¦‚å¿µä¸¾ä¾‹ ç”µè¯å·ç çš„åœ°å€ç©ºé—´æ˜¯ä» 0 000 000 åˆ° 9 999 999 x86çš„I/Oç«¯å£çš„åœ°å€ç©ºé—´ä»0åˆ°16 383 ä»¥â€œ.comâ€ç»“å°¾çš„ç½‘ç»œåŸŸåçš„é›†åˆä¹Ÿæ˜¯åœ°å€ç©ºé—´ åŸºå€å¯„å­˜å™¨ä¸ç•Œé™å¯„å­˜å™¨\nåŠ¨æ€é‡å®šä½ï¼Œç®€å•åœ°æŠŠæ¯ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´æ˜ å°„åˆ°ç‰©ç†å†…å­˜çš„ä¸åŒéƒ¨åˆ†ã€‚ å½“ä½¿ç”¨åŸºå€å¯„å­˜å™¨å’Œç•Œé™å¯„å­˜å™¨æ—¶ï¼Œç¨‹åºè£…è½½åˆ°å†…å­˜ä¸­è¿ç»­çš„ç©ºé—²ä½ç½®ä¸”è£…è½½æœŸé—´æ— é¡»é‡å®šä½ã€‚å½“ä¸€ä¸ªç¨‹åºè¿è¡Œæ—¶ï¼Œç¨‹åºçš„èµ·å§‹ç‰©ç†åœ°å€è£…è½½åˆ°åŸºå€å¯„å­˜å™¨ä¸­ï¼Œç¨‹åºçš„é•¿åº¦è£…è½½åˆ°ç•Œé™å¯„å­˜å™¨ä¸­ã€‚ æ¯æ¬¡ä¸€ä¸ªè¿›ç¨‹è®¿é—®å†…å­˜ï¼Œå–ä¸€æ¡æŒ‡ä»¤ï¼Œè¯»æˆ–å†™ä¸€ä¸ªæ•°æ®å­—ï¼ŒCPUç¡¬ä»¶ä¼šæŠŠåœ°å€å‘é€åˆ°å†…å­˜æ€»çº¿å‰ï¼Œè‡ªåŠ¨æŠŠåŸºå€å€¼åŠ åˆ°è¿›ç¨‹å‘å‡ºçš„åœ°å€å€¼ä¸Šã€‚åŒæ—¶ï¼Œå®ƒæ£€æŸ¥ç¨‹åºæä¾›çš„åœ°å€æ˜¯å¦ç­‰äºæˆ–å¤§äºç•Œé™å¯„å­˜å™¨é‡Œçš„å€¼ï¼Œå¦‚æœè®¿é—®çš„åœ°å€è¶…å‡ºäº†ç•Œé™ï¼Œä¼šäº§ç”Ÿé”™è¯¯å¹¶ä¸­æ­¢è®¿é—®ã€‚ ä½¿ç”¨åŸºå€å¯„å­˜å™¨å’Œç•Œé™å¯„å­˜å™¨æ˜¯ç»™æ¯ä¸ªè¿›ç¨‹æä¾›ç§æœ‰åœ°å€ç©ºé—´çš„éå¸¸å®¹æ˜“çš„æ–¹æ³•ï¼Œå› ä¸ºæ¯ä¸ªå†…å­˜åœ°å€åœ¨é€åˆ°å†…å­˜ä¹‹å‰ï¼Œéƒ½ä¼šè‡ªåŠ¨å…ˆåŠ ä¸ŠåŸºå€å¯„å­˜å™¨çš„å†…å®¹ã€‚ ä½¿ç”¨åŸºå€å¯„å­˜å™¨å’Œç•Œé™å¯„å­˜å™¨é‡å®šä½çš„ç¼ºç‚¹æ˜¯ï¼Œæ¯æ¬¡è®¿é—®å†…å­˜éƒ½éœ€è¦è¿›è¡ŒåŠ æ³•å’Œæ¯”è¾ƒè¿ç®—ã€‚æ¯”è¾ƒè¿ç®—å¯ä»¥åšå¾—å¾ˆå¿«ï¼Œä½†æ˜¯åŠ æ³•è¿ç®—ç”±äºè¿›ä½ä¼ é€’æ—¶é—´çš„é—®é¢˜ï¼Œåœ¨æ²¡æœ‰ç‰¹æ®Šç”µè·¯çš„æƒ…å†µä¸‹ä¼šæ˜¾å¾—å¾ˆæ…¢ã€‚ 3.2.2 äº¤æ¢æŠ€æœ¯ æ‰€æœ‰è¿›ç¨‹æ‰€éœ€è¦çš„RAMæ•°é‡æ€»å’Œé€šå¸¸è¦è¿œè¿œè¶…å‡ºå­˜å‚¨å™¨èƒ½å¤Ÿæ”¯æŒçš„èŒƒå›´ã€‚ æœ‰ä¸¤ç§å¤„ç†å†…å­˜è¶…è½½çš„é€šç”¨æ–¹æ³• äº¤æ¢æŠ€æœ¯ï¼Œå³æŠŠä¸€ä¸ªè¿›ç¨‹å®Œæ•´è°ƒå…¥å†…å­˜ï¼Œä½¿è¯¥è¿›ç¨‹è¿è¡Œä¸€æ®µæ—¶é—´ï¼Œç„¶åæŠŠå®ƒå­˜å›ç£ç›˜ã€‚ç©ºé—²è¿›ç¨‹ä¸»è¦å­˜å‚¨åœ¨ç£ç›˜ä¸Šï¼Œæ‰€ä»¥å½“å®ƒä»¬ä¸è¿è¡Œæ—¶å°±ä¸ä¼šå ç”¨å†…å­˜ã€‚ è™šæ‹Ÿå†…å­˜ï¼Œè¯¥ç­–ç•¥ç”šè‡³èƒ½ä½¿ç¨‹åºåœ¨åªæœ‰ä¸€éƒ¨åˆ†è¢«è°ƒå…¥å†…å­˜çš„æƒ…å†µä¸‹è¿è¡Œã€‚ äº¤æ¢åœ¨å†…å­˜ä¸­äº§ç”Ÿäº†å¤šä¸ªç©ºé—²åŒºï¼Œé€šè¿‡æŠŠæ‰€æœ‰æ”¾å…¥è¿›ç¨‹å°½å¯èƒ½å‘ä¸‹ç§»åŠ¨ï¼Œæœ‰å¯èƒ½å°†è¿™äº›å°çš„ç©ºé—²åŒºåˆæˆä¸€å¤§å—ã€‚è¯¥æŠ€æœ¯ç§°ä¸ºå†…å­˜ç´§ç¼©ã€‚é€šå¸¸ä¸è¿›è¡Œè¿™ä¸ªæ“ä½œï¼Œå› ä¸ºå®ƒè¦è€—è´¹å¤§é‡çš„CPUæ—¶é—´ã€‚ å¦‚æœå¤§éƒ¨åˆ†è¿›ç¨‹åœ¨è¿è¡Œæ—¶éƒ½è¦å¢é•¿ï¼Œä¸ºäº†å‡å°‘å› å†…å­˜åŒºåŸŸä¸å¤Ÿè€Œå¼•èµ·çš„è¿›ç¨‹äº¤æ¢å’Œç§»åŠ¨æ‰€äº§ç”Ÿçš„å¼€é”€ï¼Œä¸€ç§å¯ç”¨çš„æ–¹æ³•æ˜¯ï¼Œå½“æ¢å…¥æˆ–ç§»åŠ¨è¿›ç¨‹æ—¶ä¸ºå®ƒåˆ†é…ä¸€äº›é¢å¤–çš„å†…å­˜ã€‚ç„¶è€Œï¼Œå½“è¿›ç¨‹è¢«æ¢å‡ºåˆ°ç£ç›˜ä¸Šæ—¶ï¼Œåº”è¯¥åªäº¤æ¢è¿›ç¨‹å®é™…ä¸Šä½¿ç”¨çš„å†…å­˜ä¸­çš„å†…å®¹ï¼Œå°†é¢å¤–çš„å†…å­˜äº¤æ¢å‡ºå»æ˜¯ä¸€ç§æµªè´¹ã€‚ å¦‚æœè¿›ç¨‹æœ‰ä¸¤ä¸ªå¯å¢é•¿çš„æ®µï¼Œåœ¨ä¸¤è€…ä¹‹é—´çš„å†…å­˜å¯ä¾›ä¸¤ä¸ªæ®µä½¿ç”¨ã€‚ 3.2.3 ç©ºé—²å†…å­˜ç®¡ç† ä¸€èˆ¬è€Œè¨€ï¼Œæœ‰ä¸¤ç§æ–¹æ³•è·Ÿè¸ªå†…å­˜ä½¿ç”¨æƒ…å†µï¼šä½å›¾å’Œç©ºé—²åŒºé“¾è¡¨ã€‚\n1. ä½¿ç”¨ä½å›¾çš„å­˜å‚¨ç®¡ç†\nä½¿ç”¨ä½å›¾æ–¹æ³•æ—¶ï¼Œå†…å­˜å¯èƒ½è¢«åˆ’åˆ†æˆå°åˆ°å‡ ä¸ªå­—æˆ–å¤§åˆ°å‡ åƒå­—èŠ‚çš„åˆ†é…å•ä½ã€‚æ¯ä¸ªåˆ†é…å•å…ƒå¯¹åº”äºä½å›¾ä¸­çš„ä¸€ä½ï¼Œ0è¡¨ç¤ºç©ºé—²ï¼Œ1è¡¨ç¤ºå æœ‰ï¼ˆæˆ–è€…ç›¸åï¼‰ï¼Œ åˆ†é…å•å…ƒçš„å¤§å°æ˜¯ä¸€ä¸ªé‡è¦çš„è®¾è®¡å› ç´ ã€‚åˆ†é…å•å…ƒè¶Šå°ï¼Œä½å›¾è¶Šå¤§ã€‚è‹¥é€‰æ‹©æ¯”è¾ƒå¤§çš„åˆ†é…å•å…ƒï¼Œåˆ™ä½å›¾æ›´å°ã€‚ä½†è‹¥è¿›ç¨‹çš„å¤§å°ä¸æ˜¯åˆ†é…å•å…ƒçš„æ•´æ•°å€ï¼Œé‚£ä¹ˆåœ¨æœ€åä¸€ä¸ªåˆ†é…å•å…ƒä¸­å°±ä¼šæœ‰ä¸€å®šæ•°é‡çš„å†…å­˜è¢«æµªè´¹äº†ã€‚ è¿™ç§æ–¹æ³•çš„ä¸»è¦é—®é¢˜æ˜¯ï¼Œåœ¨å†³å®šæŠŠä¸€ä¸ªå kä¸ªåˆ†é…å•å…ƒçš„è¿›ç¨‹æ‰å…¥å†…å­˜æ—¶ï¼Œå­˜å‚¨ç®¡ç†å™¨å¿…é¡»æœç´¢ä½å›¾ï¼Œåœ¨ä½å›¾ä¸­æ‰¾å‡ºæœ‰kä¸ªè¿ç»­0çš„ä¸²ã€‚æŸ¥æ‰¾ä½å›¾ä¸­æŒ‡å®šé•¿åº¦çš„è¿ç»­0ä¸²æ˜¯è€—æ—¶çš„æ“ä½œï¼ˆå› ä¸ºåœ¨ä½å›¾ä¸­è¯¥ä¸²å¯èƒ½è·¨è¶Šå­—çš„è¾¹ç•Œï¼‰ï¼Œè¿™æ˜¯ä½å›¾çš„ç¼ºç‚¹ã€‚ 2. ä½¿ç”¨é“¾è¡¨çš„å­˜å‚¨ç®¡ç†\nç»´æŠ¤ä¸€ä¸ªè®°å½•å·²åˆ†é…å†…å­˜æ®µå’Œç©ºé—²å†…å­˜æ®µçš„é“¾è¡¨ã€‚å…¶ä¸­é“¾è¡¨ä¸­çš„ä¸€ä¸ªç»“ç‚¹æˆ–è€…åŒ…å«ä¸€ä¸ªè¿›ç¨‹ï¼Œæˆ–è€…æ˜¯ä¸¤ä¸ªè¿›ç¨‹é—´çš„ä¸€å—ç©ºé—²åŒºã€‚ é“¾è¡¨ä¸­çš„æ¯ä¸€ä¸ªç»“ç‚¹éƒ½åŒ…å«ä»¥ä¸‹åŸŸï¼šç©ºé—²åŒºï¼ˆHï¼‰æˆ–è¿›ç¨‹ï¼ˆPï¼‰çš„æŒ‡ç¤ºæ ‡å¿—ã€èµ·å§‹åœ°å€ã€é•¿åº¦å’ŒæŒ‡å‘ä¸‹ä¸€ç»“ç‚¹çš„æŒ‡é’ˆã€‚ å½“æŒ‰ç…§åœ°å€é¡ºåºåœ¨é“¾è¡¨ä¸­å­˜æ”¾è¿›ç¨‹å’Œç©ºé—²åŒºæ—¶ï¼Œå‡ ç§ç®—æ³•å¯ä»¥ç”¨æ¥ä¸ºåˆ›å»ºçš„è¿›ç¨‹åˆ†é…å†…å­˜ã€‚\né¦–æ¬¡é€‚é…ç®—æ³•ã€‚å­˜å‚¨ç®¡ç†å™¨æ²¿ç€æ®µé“¾è¡¨è¿›è¡Œæœç´¢ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªè¶³å¤Ÿå¤§çš„ç©ºé—²åŒºï¼Œé™¤éç©ºé—²åŒºå¤§å°å’Œåˆ†é…çš„ç©ºé—´å¤§å°æ­£å¥½ä¸€æ ·ï¼Œå¦åˆ™å°†è¯¥ç©ºé—²åŒºåˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†ä¾›è¿›ç¨‹ä½¿ç”¨ï¼Œå¦ä¸€éƒ¨åˆ†å½¢æˆæ–°çš„ç©ºé—²åŒºã€‚ ä¸‹æ¬¡é€‚é…ç®—æ³•ã€‚å®ƒçš„å·¥ä½œæ–¹å¼å’Œé¦–æ¬¡é€‚é…ç®—æ³•ç›¸åŒï¼Œä¸åŒç‚¹æ˜¯æ¯æ¬¡æ‰¾åˆ°åˆé€‚çš„ç©ºé—²åŒºæ—¶éƒ½è®°å½•å½“æ—¶çš„ä½ç½®ï¼Œä»¥ä¾¿åœ¨ä¸‹æ¬¡å¯»æ‰¾ç©ºé—²åŒºæ—¶ä»ä¸Šæ¬¡ç»“æŸçš„åœ°æ–¹å¼€å§‹æœç´¢ï¼Œè€Œä¸æ˜¯åƒé¦–æ¬¡é€‚é…ç®—æ³•é‚£æ ·æ¯æ¬¡éƒ½ä»å¤´å¼€å§‹ã€‚ä»¿çœŸç¨‹åºè¡¨æ˜ä¸‹æ¬¡é€‚é…ç®—æ³•æ€§èƒ½ç•¥ä½äºé¦–æ¬¡é€‚é…ç®—æ³•ã€‚ æœ€ä½³é€‚é…ç®—æ³•ã€‚æœç´¢æ•´ä¸ªé“¾è¡¨ï¼ˆä»å¼€å§‹åˆ°ç»“æŸï¼‰ï¼Œæ‰¾å‡ºèƒ½å¤Ÿå®¹çº³è¿›ç¨‹çš„æœ€å°çš„ç©ºé—²åŒºã€‚æœ€ä½³é€‚é…ç®—æ³•è¯•å›¾æ‰¾å‡ºæœ€æ¥è¿‘å®é™…éœ€è¦çš„ç©ºé—²åŒºï¼Œä»¥æœ€å¥½åœ°åŒ¹é…è¯·æ±‚å’Œå¯ç”¨ç©ºé—²åŒºï¼Œè€Œä¸æ˜¯æ‹†åˆ†ä¸€ä¸ªä»¥åå¯èƒ½ä¼šç”¨åˆ°çš„å¤§çš„ç©ºé—²åŒºã€‚ å› ä¸ºæ¯æ¬¡è°ƒç”¨æœ€ä½³é€‚é…ç®—æ³•æ—¶éƒ½è¦æœç´¢æ•´ä¸ªé“¾è¡¨ï¼Œæ‰€ä»¥å®ƒè¦æ¯”é¦–æ¬¡é€‚é…ç®—æ³•æ…¢ã€‚è®©äººæ„Ÿåˆ°æœ‰ç‚¹æ„å¤–çš„æ˜¯ï¼Œå®ƒæ¯”é¦–æ¬¡é€‚é…ç®—æ³•æˆ–ä¸‹æ¬¡é€‚é…ç®—æ³•æµªè´¹æ›´å¤šçš„å†…å­˜ï¼Œå› ä¸ºå®ƒä¼šäº§ç”Ÿå¤§é‡æ— ç”¨çš„å°ç©ºé—²åŒºã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œé¦–æ¬¡é€‚é…ç®—æ³•ç”Ÿæˆçš„ç©ºé—²åŒºæ›´å¤§ä¸€äº›ã€‚ æœ€å·®é€‚é…ç®—æ³•ã€‚æ€»æ˜¯åˆ†é…æœ€å¤§çš„å¯ç”¨ç©ºé—²åŒºï¼Œä½¿æ–°çš„ç©ºé—²åŒºæ¯”è¾ƒå¤§ä»è€Œå¯ä»¥ç»§ç»­ä½¿ç”¨ã€‚ä»¿çœŸç¨‹åºè¡¨æ˜æœ€å·®é€‚é…ç®—æ³•ä¹Ÿä¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚ å¦‚æœè¿›ç¨‹å’Œç©ºé—²åŒºä½¿ç”¨ä¸åŒçš„é“¾è¡¨ï¼Œåˆ™å¯ä»¥æŒ‰ç…§å¤§å°å¯¹ç©ºé—²åŒºé“¾è¡¨æ’åºï¼Œä»¥ä¾¿æé«˜æœ€ä½³é€‚é…ç®—æ³•çš„é€Ÿåº¦ã€‚ç©ºé—²åŒºé“¾è¡¨æŒ‰å¤§å°æ’åºæ—¶ï¼Œé¦–æ¬¡é€‚é…ç®—æ³•ä¸æœ€ä½³é€‚é…ç®—æ³•ä¸€æ ·å¿«ï¼Œè€Œä¸‹æ¬¡é€‚é…ç®—æ³•åœ¨è¿™é‡Œåˆ™æ¯«æ— æ„ä¹‰ã€‚\nå¿«é€Ÿé€‚é…ç®—æ³•ï¼Œå®ƒä¸ºé‚£äº›å¸¸ç”¨å¤§å°çš„ç©ºé—²åŒºç»´æŠ¤å•ç‹¬çš„é“¾è¡¨ã€‚å¿«é€Ÿé€‚é…ç®—æ³•å¯»æ‰¾ä¸€ä¸ªæŒ‡å®šå¤§å°çš„ç©ºé—²åŒºæ˜¯ååˆ†å¿«é€Ÿçš„ï¼Œä½†å®ƒå’Œæ‰€æœ‰å°†ç©ºé—²åŒºæŒ‰å¤§å°æ’åºçš„æ–¹æ¡ˆä¸€æ ·ï¼Œéƒ½æœ‰ä¸€ä¸ªå…±åŒçš„ç¼ºç‚¹ï¼Œå³åœ¨ä¸€ä¸ªè¿›ç¨‹ç»ˆæ­¢æˆ–è¢«æ¢å‡ºæ—¶ï¼Œå¯»æ‰¾å®ƒçš„ç›¸é‚»å—å¹¶æŸ¥çœ‹æ˜¯å¦å¯ä»¥åˆå¹¶çš„è¿‡ç¨‹æ˜¯éå¸¸è€—æ—¶çš„ã€‚å¦‚æœä¸è¿›è¡Œåˆå¹¶ï¼Œå†…å­˜å°†ä¼šå¾ˆå¿«åˆ†è£‚å‡ºå¤§é‡çš„è¿›ç¨‹æ— æ³•åˆ©ç”¨çš„å°ç©ºé—²åŒºã€‚\n3.3 è™šæ‹Ÿå†…å­˜ è¿˜æœ‰å¦å¤–ä¸€ä¸ªé—®é¢˜éœ€è¦è§£å†³ï¼šç®¡ç†è½¯ä»¶çš„è†¨èƒ€ã€‚ ç¨‹åºå¤§äºå†…å­˜ï¼Œä¸€ç§è§£å†³æ–¹æ³•æ˜¯æŠŠç¨‹åºåˆ†å‰²æˆè®¸å¤šç‰‡æ®µï¼Œç§°ä¸ºè¦†ç›–ã€‚ä½†æ˜¯æŠŠä¸€ä¸ªç¨‹åºåˆ†å‰²æˆå°çš„ã€æ¨¡å—åŒ–çš„ç‰‡æ®µæ˜¯éå¸¸è´¹æ—¶å’Œæ¯ç‡¥çš„ï¼Œå¹¶ä¸”å®¹æ˜“å‡ºé”™ã€‚å¾ˆå°‘ç¨‹åºå‘˜æ“…é•¿ä½¿ç”¨è¦†ç›–æŠ€æœ¯ã€‚ è™šæ‹Ÿå†…å­˜æŠ€æœ¯ã€‚å…¶åŸºæœ¬æ€æƒ³æ˜¯ï¼šæ¯ä¸ªç¨‹åºæ‹¥æœ‰è‡ªå·±çš„åœ°å€ç©ºé—´ï¼Œè¿™ä¸ªç©ºé—´è¢«åˆ†å‰²æˆå¤šä¸ªå—ï¼Œæ¯ä¸€å—ç§°ä½œä¸€é¡µæˆ–é¡µé¢ã€‚æ¯ä¸€é¡µæœ‰è¿ç»­çš„åœ°å€èŒƒå›´ã€‚è¿™äº›é¡µè¢«æ˜ å°„åˆ°ç‰©ç†å†…å­˜ï¼Œä½†å¹¶ä¸æ˜¯æ‰€æœ‰çš„é¡µéƒ½å¿…é¡»åœ¨å†…å­˜ä¸­æ‰èƒ½è¿è¡Œç¨‹åºã€‚å½“ç¨‹åºå¼•ç”¨åˆ°ä¸€éƒ¨åˆ†åœ¨ç‰©ç†å†…å­˜ä¸­çš„åœ°å€ç©ºé—´æ—¶ï¼Œç”±ç¡¬ä»¶ç«‹å³æ‰§è¡Œå¿…è¦çš„æ˜ å°„ã€‚å½“ç¨‹åºå¼•ç”¨åˆ°ä¸€éƒ¨åˆ†ä¸åœ¨ç‰©ç†å†…å­˜ä¸­çš„åœ°å€ç©ºé—´æ—¶ï¼Œç”±æ“ä½œç³»ç»Ÿè´Ÿè´£å°†ç¼ºå¤±çš„éƒ¨åˆ†è£…å…¥ç‰©ç†å†…å­˜å¹¶é‡æ–°æ‰§è¡Œå¤±è´¥çš„æŒ‡ä»¤ã€‚ ä»æŸä¸ªè§’åº¦æ¥è®²ï¼Œè™šæ‹Ÿå†…å­˜æ˜¯å¯¹åŸºå€å¯„å­˜å™¨å’Œç•Œé™å¯„å­˜å™¨çš„ä¸€ç§ç»¼åˆã€‚ 3.3.1 åˆ†é¡µ ç”±ç¨‹åºäº§ç”Ÿçš„è¿™äº›åœ°å€ç§°ä¸ºè™šæ‹Ÿåœ°å€ï¼Œå®ƒä»¬æ„æˆäº†ä¸€ä¸ªè™šæ‹Ÿåœ°å€ç©ºé—´ã€‚åœ¨ä½¿ç”¨è™šæ‹Ÿå†…å­˜çš„æƒ…å†µä¸‹ï¼Œè™šæ‹Ÿåœ°å€ä¸æ˜¯è¢«ç›´æ¥é€åˆ°å†…å­˜æ€»çº¿ä¸Šï¼Œè€Œæ˜¯è¢«é€åˆ°å†…å­˜ç®¡ç†å•å…ƒï¼ˆMemory Management Unit, MMUï¼‰ï¼ŒMMUæŠŠè™šæ‹Ÿåœ°å€æ˜ å°„ä¸ºç‰©ç†å†…å­˜åœ°å€ã€‚ è™šæ‹Ÿåœ°å€ç©ºé—´æŒ‰ç…§å›ºå®šå¤§å°åˆ’åˆ†æˆè¢«ç§°ä¸ºé¡µé¢çš„è‹¥å¹²å•å…ƒã€‚åœ¨ç‰©ç†å†…å­˜ä¸­å¯¹åº”çš„å•å…ƒç§°ä¸ºé¡µæ¡†ã€‚é¡µé¢å’Œé¡µæ¡†çš„å¤§å°é€šå¸¸æ˜¯ä¸€æ ·çš„ã€‚RAMå’Œç£ç›˜ä¹‹é—´çš„äº¤æ¢æ€»æ˜¯ä»¥æ•´ä¸ªé¡µé¢ä¸ºå•å…ƒè¿›è¡Œçš„ã€‚ é€šè¿‡æ°å½“åœ°è®¾ç½®MMUï¼Œå¯ä»¥æŠŠ16ä¸ªè™šæ‹Ÿé¡µé¢æ˜ å°„åˆ°8ä¸ªé¡µæ¡†ä¸­çš„ä»»ä½•ä¸€ä¸ªã€‚ MMUæ³¨æ„åˆ°è¯¥é¡µé¢æ²¡æœ‰è¢«æ˜ å°„ï¼Œäºæ˜¯ä½¿CPUé™·å…¥åˆ°æ“ä½œç³»ç»Ÿï¼Œè¿™ä¸ªé™·é˜±ç§°ä¸ºç¼ºé¡µä¸­æ–­æˆ–ç¼ºé¡µé”™è¯¯ã€‚æ“ä½œç³»ç»Ÿæ‰¾åˆ°ä¸€ä¸ªå¾ˆå°‘ä½¿ç”¨çš„é¡µæ¡†ä¸”æŠŠå®ƒçš„å†…å®¹å†™å…¥åˆ°ç£ç›˜ï¼ˆå¦‚æœå®ƒä¸åœ¨ç£ç›˜ä¸Šï¼‰ã€‚éšåæŠŠéœ€è¦è®¿é—®çš„é¡µé¢è¯»åˆ°åˆšæ‰å›æ”¶çš„é¡µæ¡†ä¸­ï¼Œä¿®æ”¹æ˜ å°„å…³ç³»ï¼Œç„¶åé‡æ–°å¯åŠ¨å¼•èµ·é™·é˜±çš„æŒ‡ä»¤ã€‚ MMUå†…éƒ¨ç»“æ„ï¼Œäº†è§£ä¸ºä»€ä¹ˆæˆ‘ä»¬é€‰ç”¨çš„é¡µé¢å¤§å°éƒ½æ˜¯2çš„æ•´æ•°æ¬¡å¹‚ã€‚è¾“å…¥çš„16ä½è™šæ‹Ÿåœ°å€è¢«åˆ†ä¸º4ä½çš„é¡µå·å’Œ12ä½çš„åç§»é‡ã€‚å¯ç”¨é¡µå·åº§ä½é¡µè¡¨çš„ç´¢å¼•ï¼Œä»¥å¾—å‡ºå¯¹åº”äºè¯¥è™šæ‹Ÿé¡µé¢çš„é¡µæ¡†å·ã€‚å¦‚æœâ€œåœ¨/ä¸åœ¨â€ä½ä¸º1ï¼Œåˆ™å°†åœ¨é¡µè¡¨ä¸­æŸ¥åˆ°çš„é¡µæ¡†å·å¤åˆ¶åˆ°è¾“å‡ºå¯„å­˜å™¨çš„é«˜3ä½ä¸­ï¼Œå†åŠ ä¸Šè¾“å…¥è™šæ‹Ÿåœ°å€ä¸­çš„ä½12ä½åç§»é‡ï¼Œå¦‚æ­¤å°±æ„æˆäº†15ä½çš„ç‰©ç†åœ°å€ã€‚è¾“å‡ºå¯„å­˜å™¨çš„å†…å®¹éšå³å¯è¢«ä½œä¸ºç‰©ç†åœ°å€é€åˆ°å†…å­˜æ€»çº¿ã€‚ 3.3.2 é¡µè¡¨ è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„ä¸€ç§ç®€å•å®ç°å¯ä»¥æ¦‚æ‹¬ä¸ºï¼šè™šæ‹Ÿåœ°å€è¢«åˆ†ä¸ºè™šæ‹Ÿé¡µå·ï¼ˆé«˜ä½éƒ¨åˆ†ï¼‰å’Œåç§»é‡ï¼ˆä½ä½éƒ¨åˆ†ï¼‰ä¸¤éƒ¨åˆ†ã€‚ è™šæ‹Ÿé¡µå·å¯ç”¨ä½œé¡µè¡¨çš„ç´¢å¼•ï¼Œä»¥æ‰¾åˆ°è¯¥è™šæ‹Ÿé¡µé¢å¯¹åº”çš„é¡µè¡¨é¡¹ã€‚ç”±é¡µè¡¨é¡¹å¯ä»¥æ‰¾åˆ°é¡µæ¡†å·ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ã€‚ç„¶åæŠŠé¡µæ¡†å·æ‹¼æ¥åˆ°åç§»é‡çš„é«˜ä½ç«¯ï¼Œä»¥æ›¿æ¢æ‰è™šæ‹Ÿé¡µå·ï¼Œå½¢æˆé€å¾€å†…å­˜çš„ç‰©ç†åœ°å€ã€‚ é¡µè¡¨çš„ç›®çš„æ˜¯æŠŠè™šæ‹Ÿé¡µé¢æ˜ å°„åˆ°é¡µæ¡†ã€‚ä»æ•°å­¦è§’åº¦è¯´ï¼Œé¡µè¡¨æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒçš„å‚æ•°æ˜¯è™šæ‹Ÿé¡µå·ï¼Œç»“æœæ˜¯ç‰©ç†é¡µæ¡†å·ã€‚é€šè¿‡è¿™ä¸ªå‡½æ•°å¯ä»¥æŠŠè™šæ‹Ÿåœ°å€ä¸­çš„è™šæ‹Ÿé¡µé¢åŸŸæ›¿æ¢æˆé¡µæ¡†åŸŸï¼Œä»è€Œå½¢æˆç‰©ç†åœ°å€ã€‚ é¡µè¡¨é¡¹çš„ç»“æ„\né¡µæ¡†å· â€œåœ¨/ä¸åœ¨â€ä½ ä¿æŠ¤ä½æŒ‡å‡ºä¸€ä¸ªé¡µå…è®¸ä»€ä¹ˆç±»å‹çš„è®¿é—®ã€‚ ä¸ºäº†è®°å½•é¡µé¢çš„ä½¿ç”¨çŠ¶å†µï¼Œå¼•å…¥äº†ä¿®æ”¹ä½å’Œè®¿é—®ä½ã€‚ ä¸è®ºæ˜¯è¯»è¿˜æ˜¯å†™ï¼Œç³»ç»Ÿéƒ½ä¼šåœ¨è¯¥é¡µé¢è¢«è®¿é—®æ—¶è®¾ç½®è®¿é—®ä½ã€‚å®ƒçš„å€¼è¢«ç”¨æ¥å¸®åŠ©æ“ä½œç³»ç»Ÿåœ¨å‘ç”Ÿç¼ºé¡µä¸­æ–­æ—¶é€‰æ‹©è¦è¢«æ·˜æ±°çš„é¡µé¢ã€‚ä¸å†ä½¿ç”¨çš„é¡µé¢è¦æ¯”æ­£åœ¨ä½¿ç”¨çš„é¡µé¢æ›´é€‚åˆæ·˜æ±°ã€‚ æœ€åä¸€ä½ç”¨äºç¦æ­¢è¯¥é¡µé¢è¢«é«˜é€Ÿç¼“å­˜ã€‚ åº”è¯¥æ³¨æ„çš„æ˜¯ï¼Œè‹¥æŸä¸ªé¡µé¢ä¸åœ¨å†…å­˜ä¸­ï¼Œç”¨äºä¿æŠ¤è¯¥é¡µé¢çš„ç£ç›˜åœ°å€ä¸æ˜¯é¡µè¡¨çš„ç»„æˆéƒ¨åˆ†ã€‚\nè™šæ‹Ÿå†…å­˜æœ¬è´¨ä¸Šæ˜¯ç”¨æ¥åˆ›é€ ä¸€ä¸ªæ–°çš„æŠ½è±¡æ¦‚å¿µâ€”â€”åœ°å€ç©ºé—´ï¼Œè¿™ä¸ªæ¦‚å¿µæ˜¯å¯¹ç‰©ç†å†…å­˜çš„æŠ½è±¡ï¼Œç±»ä¼¼äºè¿›ç¨‹æ˜¯å¯¹ç‰©ç†å¤„ç†å™¨ï¼ˆCPUï¼‰çš„æŠ½è±¡ã€‚è™šæ‹Ÿå†…å­˜çš„å®ç°ï¼Œæ˜¯å°†è™šæ‹Ÿåœ°å€ç©ºé—´åˆ†è§£æˆé¡µï¼Œå¹¶å°†æ¯ä¸€é¡µæ˜ å°„åˆ°ç‰©ç†å†…å­˜çš„æŸä¸ªé¡µæ¡†æˆ–è€…ï¼ˆæš‚æ—¶ï¼‰è§£é™¤æ˜ å°„ã€‚\n3.3.3 åŠ é€Ÿåˆ†é¡µè¿‡ç¨‹ åœ¨ä»»ä½•åˆ†é¡µç³»ç»Ÿä¸­ï¼Œéƒ½éœ€è¦è€ƒè™‘ä¸¤ä¸ªä¸»è¦é—®é¢˜ï¼š\nè™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„æ˜ å°„å¿…é¡»éå¸¸å¿«ã€‚ å¦‚æœè™šæ‹Ÿåœ°å€ç©ºé—´å¾ˆå¤§ï¼Œé¡µè¡¨ä¹Ÿä¼šå¾ˆå¤§ã€‚ ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯ç”±äºæ¯æ¬¡è®¿é—®å†…å­˜éƒ½éœ€è¦è¿›è¡Œè™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„æ˜ å°„ï¼Œæ‰€æœ‰çš„æŒ‡ä»¤æœ€ç»ˆéƒ½å¿…é¡»æ¥è‡ªå†…å­˜ï¼Œå¹¶ä¸”å¾ˆå¤šæŒ‡ä»¤ä¹Ÿä¼šè®¿é—®å†…å­˜ä¸­çš„æ“ä½œæ•°ã€‚\nç¬¬äºŒä¸ªé—®é¢˜æ¥è‡ªç°ä»£è®¡ç®—æœºä½¿ç”¨è‡³å°‘32ä½çš„è™šæ‹Ÿåœ°å€ï¼Œè€Œä¸”64ä½å˜å¾—è¶Šæ¥è¶Šæ™®éã€‚\nå¯¹å¤§è€Œå¿«é€Ÿçš„é¡µæ˜ å°„çš„éœ€æ±‚ç§°ä¸ºæ„å»ºè®¡ç®—æœºçš„é‡è¦çº¦æŸã€‚ä¸€ç§ç®€å•çš„è®¾è®¡æ˜¯ä½¿ç”¨â€œå¿«é€Ÿç¡¬ä»¶å¯„å­˜å™¨â€ï¼Œè¿™ä¸ªæ–¹æ³•çš„ä¼˜åŠ¿æ˜¯ç®€å•å¹¶ä¸”åœ¨æ˜ å°„è¿‡ç¨‹ä¸­ä¸éœ€è¦è®¿é—®å†…å­˜ã€‚è€Œç¼ºç‚¹æ˜¯åœ¨é¡µè¡¨å¾ˆå¤§æ—¶ï¼Œä»£ä»·é«˜æ˜‚ã€‚è€Œä¸”æ¯ä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢éƒ½å¿…é¡»è£…è½½æ•´ä¸ªé¡µè¡¨ï¼Œè¿™æ ·ä¼šé™ä½æ€§èƒ½ã€‚å¦ä¸€ç§æç«¯çš„æ–¹æ³•æ˜¯ï¼Œæ•´ä¸ªé¡µè¡¨éƒ½åœ¨å†…å­˜ä¸­ã€‚è¿™ç§åšæ³•çš„ç¼ºé™·æ˜¯åœ¨æ‰§è¡Œæ¯æ¡æŒ‡ä»¤æ—¶ï¼Œéƒ½éœ€è¦ä¸€æ¬¡æˆ–å¤šæ¬¡å†…å­˜è®¿é—®æ¥å®Œæˆé¡µè¡¨é¡¹çš„è¯»å…¥ï¼Œé€Ÿåº¦éå¸¸æ…¢ã€‚\n1. è½¬æ¢æ£€æµ‹ç¼“å†²åŒº\næœ‰äº†åˆ†é¡µæœºåˆ¶åï¼Œä¼šå› ä¸ºè¦è®¿é—®é¡µè¡¨è€Œå¼•èµ·æ›´å¤šæ¬¡çš„å†…å­˜è®¿é—®ã€‚\nä¸€ç§è§£å†³æ–¹æ¡ˆçš„å»ºç«‹åŸºäºè¿™æ ·ä¸€ç§è§‚å¯Ÿï¼šå¤§å¤šæ•°ç¨‹åºæ€»æ˜¯å¯¹å°‘é‡çš„é¡µé¢è¿›è¡Œå¤šæ¬¡çš„è®¿é—®ï¼Œè€Œä¸æ˜¯ç›¸åã€‚å› æ­¤ï¼Œåªæœ‰å¾ˆå°‘çš„é¡µè¡¨é¡¹ä¼šè¢«åå¤è¯»å–ï¼Œè€Œå…¶ä»–çš„é¡µè¡¨é¡¹å¾ˆå°‘è¢«è®¿é—®ã€‚\nä¸ºè®¡ç®—æœºè®¾ç½®ä¸€ä¸ªå°å‹çš„ç¡¬ä»¶è®¾å¤‡ï¼Œå°†è™šæ‹Ÿåœ°å€ç›´æ¥æ˜ å°„åˆ°ç‰©ç†åœ°å€ï¼Œè€Œä¸å¿…å†è®¿é—®é¡µè¡¨ã€‚è¿™ç§è®¾å¤‡ç§°ä¸ºè½¬æ¢æ£€æµ‹ç¼“å†²åŒºï¼ˆTranslation Lookaside Buffer, TLBï¼‰ï¼Œæœ‰æ—¶åˆç§°ä¸ºç›¸è”å­˜å‚¨å™¨æˆ–å¿«è¡¨ã€‚å®ƒé€šå¸¸åœ¨MMUä¸­ï¼Œæ¯ä¸ªè¡¨é¡¹è®°å½•äº†ä¸€ä¸ªé¡µé¢çš„ç›¸å…³ä¿¡æ¯ï¼ŒåŒ…æ‹¬è™šæ‹Ÿé¡µå·ã€é¡µé¢çš„ä¿®æ”¹ä½ã€ä¿æŠ¤ç ï¼ˆè¯»/å†™/æ‰§è¡Œæƒé™ï¼‰å’Œè¯¥é¡µæ‰€å¯¹åº”çš„ç‰©ç†é¡µæ¡†ã€‚\nå¦‚æœå‘ç°äº†ä¸€ä¸ªæœ‰æ•ˆçš„åŒ¹é…å¹¶ä¸”è¦è¿›è¡Œçš„è®¿é—®æ“ä½œå¹¶ä¸è¿åä¿æŠ¤ä½ï¼Œåˆ™å°†é¡µæ¡†å·ç›´æ¥ä»TLBä¸­å–å‡ºè€Œä¸å¿…å†è®¿é—®é¡µè¡¨ã€‚å¦‚æœè™šæ‹Ÿé¡µå·ç¡®å®æ˜¯åœ¨TLBä¸­ï¼Œä½†æŒ‡ä»¤è¯•å›¾åœ¨ä¸€ä¸ªåªè¯»é¡µé¢ä¸Šè¿›è¡Œå†™æ“ä½œï¼Œåˆ™ä¼šäº§ç”Ÿä¸€ä¸ªä¿æŠ¤é”™è¯¯ï¼Œå°±åƒå¯¹é¡µè¡¨è¿›è¡Œéæ³•è®¿é—®ä¸€æ ·ã€‚å¦‚æœMMUæ£€æµ‹åˆ°æ²¡æœ‰æœ‰æ•ˆçš„åŒ¹é…é¡¹ï¼Œå°±ä¼šè¿›è¡Œæ­£å¸¸çš„é¡µè¡¨æŸ¥è¯¢ã€‚æ¥ç€ä»TLBä¸­æ·˜æ±°ä¸€ä¸ªè¡¨é¡¹ï¼Œç„¶åç”¨æ–°æ‰¾åˆ°çš„é¡µè¡¨é¡¹ä»£æ›¿å®ƒã€‚å½“ä¸€ä¸ªè¡¨é¡¹è¢«æ¸…é™¤å‡ºTLBæ—¶ï¼Œå°†ä¿®æ”¹ä½å¤åˆ¶åˆ°å†…å­˜ä¸­çš„é¡µè¡¨é¡¹ï¼Œè€Œé™¤äº†è®¿é—®ä½ï¼Œå…¶ä»–çš„å€¼ä¸å˜ã€‚å½“é¡µè¡¨é¡¹ä»é¡µè¡¨è£…å…¥TLBä¸­æ—¶ï¼Œæ‰€æœ‰çš„å€¼éƒ½æ¥è‡ªå†…å­˜ã€‚\n2. è½¯ä»¶TLBç®¡ç†\nè®¸å¤šç°ä»£çš„RISCæœºå™¨ï¼Œå‡ ä¹æ‰€æœ‰çš„é¡µé¢ç®¡ç†éƒ½æ˜¯åœ¨è½¯ä»¶ä¸­å®ç°çš„ã€‚å½“å‘ç”ŸTLBè®¿é—®å¤±æ•ˆæ—¶ï¼Œä¸å†ç”±MMUåˆ°é¡µè¡¨ä¸­æŸ¥æ‰¾å¹¶å–å‡ºéœ€è¦çš„é¡µè¡¨é¡¹ï¼Œè€Œæ˜¯ç”Ÿæˆä¸€ä¸ªTLBå¤±æ•ˆå¹¶å°†é—®é¢˜äº¤ç»™æ“ä½œç³»ç»Ÿè§£å†³ã€‚\nå¦‚æœTLBå¤§åˆ°ï¼ˆå¦‚64ä¸ªè¡¨é¡¹ï¼‰å¯ä»¥å‡å°‘å¤±æ•ˆç‡æ—¶ï¼ŒTLBçš„è½¯ä»¶ç®¡ç†å°±ä¼šå˜å¾—è¶³å¤Ÿæœ‰æ•ˆã€‚\næ— è®ºæ˜¯ç”¨ç¡¬ä»¶è¿˜æ˜¯è½¯ä»¶æ¥å¤„ç†TLBå¤±æ•ˆï¼Œå¸¸è§æ–¹æ³•éƒ½æ˜¯æ‰¾åˆ°é¡µè¡¨å¹¶æ‰§è¡Œç´¢å¼•æ“ä½œä»¥å®šä½å°†è¦è®¿é—®çš„é¡µé¢ã€‚å¯ä»¥é€šè¿‡åœ¨å†…å­˜ä¸­çš„å›ºå®šä½ç½®ç»´æŠ¤ä¸€ä¸ªå¤§çš„ï¼ˆå¦‚4KBï¼‰TLBè¡¨é¡¹çš„è½¯ä»¶é«˜é€Ÿç¼“å­˜æ¥å‡å°‘TLBå¤±æ•ˆã€‚\nå½“ä¸€ä¸ªé¡µé¢è®¿é—®åœ¨å†…å­˜ä¸­è€Œä¸åœ¨TLBä¸­æ—¶ï¼Œå°†äº§ç”Ÿè½¯å¤±æ•ˆã€‚å½“é¡µé¢æœ¬èº«ä¸åœ¨å†…å­˜ä¸­ï¼ˆå½“ç„¶ä¹Ÿä¸åœ¨TLBä¸­ï¼‰æ—¶ï¼Œå°†äº§ç”Ÿç¡¬å¤±æ•ˆã€‚\nå¼•å‘ç¼ºé¡µé”™è¯¯çš„å‡ ç§æƒ…å†µï¼š\næ¬¡è¦ç¼ºé¡µé”™è¯¯ ä¸¥é‡ç¼ºé¡µé”™è¯¯ æ®µé”™è¯¯ 3.3.4 é’ˆå¯¹å¤§å†…å­˜çš„é¡µè¡¨ 1. å¤šçº§é¡µè¡¨\nå¼•å…¥å¤šçº§é¡µè¡¨çš„åŸå› æ˜¯é¿å…æŠŠå…¨éƒ¨é¡µè¡¨ä¸€ç›´ä¿å­˜åœ¨å†…å­˜ä¸­ã€‚ç‰¹åˆ«æ˜¯é‚£äº›ä»ä¸éœ€è¦çš„é¡µè¡¨å°±ä¸åº”è¯¥ä¿ç•™ã€‚\nå¤šç†è§£ä¹¦ä¸­çš„ä¾‹å­ã€‚\n2. å€’æ’é¡µè¡¨\nåœ¨è¿™ç§è®¾è®¡ä¸­ï¼Œå®é™…å†…å­˜ä¸­çš„æ¯ä¸ªé¡µæ¡†å¯¹åº”ä¸€ä¸ªè¡¨é¡¹ï¼Œè€Œä¸æ˜¯æ¯ä¸ªè™šæ‹Ÿé¡µé¢å¯¹åº”ä¸€ä¸ªè¡¨é¡¹ï¼Œä½†å®ƒä¹Ÿæœ‰ä¸¥é‡çš„ä¸è¶³ï¼šä»è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢ä¼šå˜å¾—å¾ˆå›°éš¾ã€‚\nå¯ä»¥ä½¿ç”¨TLBã€‚å®ç°æœç´¢çš„ä¸€ä¸ªå¯è¡Œçš„æ–¹æ³•æ˜¯å»ºç«‹ä¸€å¼ æ•£åˆ—è¡¨ï¼Œç”¨è™šæ‹Ÿåœ°å€æ¥æ•£åˆ—ã€‚å¦‚æœæ•£åˆ—è¡¨ä¸­çš„æ§½æ•°ä¸æœºå™¨ä¸­ç‰©ç†é¡µé¢æ•°ä¸€æ ·å¤šï¼Œé‚£ä¹ˆæ•£åˆ—è¡¨çš„å†²çªé“¾çš„å¹³å‡é•¿åº¦ä¼šæ˜¯ä¸€ä¸ªè¡¨é¡¹çš„é•¿åº¦ï¼Œè¿™å°†ä¼šå¤§å¤§æé«˜æ˜ å°„é€Ÿåº¦ã€‚ä¸€æ—¦é¡µæ¡†å·è¢«æ‰¾åˆ°ï¼Œæ–°çš„ï¼ˆè™šæ‹Ÿé¡µå·ï¼Œç‰©ç†é¡µæ¡†å·ï¼‰å¯¹å°±ä¼šè¢«è£…è½½åˆ°TLBä¸­ã€‚\nå€’æ’é¡µè¡¨åœ¨64ä½æœºå™¨ä¸­å¾ˆå¸¸è§ã€‚\n3.4 é¡µé¢ç½®æ¢ç®—æ³• å½“å‘ç”Ÿç¼ºé¡µä¸­æ–­æ—¶ï¼Œæ“ä½œç³»ç»Ÿå¿…é¡»åœ¨å†…å­˜ä¸­é€‰æ‹©ä¸€ä¸ªé¡µé¢å°†å…¶æ¢å‡ºå†…å­˜ï¼Œä»¥ä¾¿ä¸ºå³å°†è°ƒå…¥çš„é¡µé¢è…¾å‡ºç©ºé—´ã€‚å¦‚æœè¦æ¢å‡ºçš„é¡µé¢åœ¨å†…å­˜é©»ç•™æœŸé—´å·²ç»è¢«ä¿®æ”¹è¿‡ï¼Œå°±å¿…é¡»æŠŠå®ƒå†™å›ç£ç›˜ä»¥æ›´æ–°è¯¥é¡µé¢åœ¨ç£ç›˜ä¸Šçš„å‰¯æœ¬ï¼›å¦‚æœè¯¥é¡µé¢æ²¡æœ‰è¢«ä¿®æ”¹è¿‡ï¼ˆå¦‚ä¸€ä¸ªåŒ…å«ç¨‹åºæ­£æ–‡çš„é¡µé¢ï¼‰ï¼Œé‚£ä¹ˆå®ƒåœ¨ç£ç›˜ä¸Šçš„å‰¯æœ¬å·²ç»æ˜¯æœ€æ–°çš„ï¼Œä¸éœ€è¦å›å†™ã€‚ç›´æ¥ç”¨è°ƒå…¥çš„é¡µé¢è¦†ç›–è¢«æ·˜æ±°çš„é¡µé¢å°±å¯ä»¥äº†ã€‚\nå½“éœ€è¦ä»å†…å­˜ä¸­æ¢å‡ºæŸä¸ªé¡µé¢æ—¶ï¼Œå®ƒæ˜¯å¦åªèƒ½æ˜¯ç¼ºé¡µè¿›ç¨‹è‡ªå·±çš„é¡µé¢ï¼Ÿè¿™ä¸ªè¦æ¢å‡ºçš„é¡µé¢æ˜¯å¦å¯ä»¥å±äºå¦å¤–ä¸€ä¸ªè¿›ç¨‹ï¼Ÿåœ¨å‰ä¸€ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥æœ‰æ•ˆåœ°å°†æ¯ä¸€ä¸ªè¿›ç¨‹é™å®šåœ¨å›ºå®šçš„é¡µé¢æ•°ç›®å†…ï¼›åä¸€ç§æƒ…å†µåˆ™ä¸èƒ½ã€‚\n3.4.1 æœ€ä¼˜é¡µé¢ç½®æ¢ç®—æ³• ç®—æ³•å·¥ä½œåŸç†ï¼šåœ¨ç¼ºé¡µä¸­æ–­å‘ç”Ÿæ—¶ï¼Œæœ‰äº›é¡µé¢åœ¨å†…å­˜ä¸­ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªé¡µé¢ï¼ˆåŒ…å«ç´§æ¥ç€çš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„é‚£ä¸ªé¡µé¢ï¼‰å°†å¾ˆå¿«è¢«è®¿é—®ï¼Œå…¶ä»–é¡µé¢åˆ™å¯èƒ½è¦åˆ°10ã€100æˆ–1000æ¡æŒ‡ä»¤åæ‰ä¼šè¢«è®¿é—®ï¼Œæ¯ä¸ªé¡µé¢éƒ½å¯ä»¥ç”¨åœ¨è¯¥é¡µé¢é¦–æ¬¡è¢«è®¿é—®å‰æ‰€è¦æ‰§è¡Œçš„æŒ‡ä»¤æ•°ä½œä¸ºæ ‡è®°ã€‚\næœ€ä¼˜é¡µé¢ç½®æ¢ç®—æ³•è§„å®šåº”è¯¥ç½®æ¢æ ‡è®°æœ€å¤§çš„é¡µé¢ã€‚\nè¿™ä¸ªç®—æ³•å”¯ä¸€çš„é—®é¢˜å°±æ˜¯å®ƒæ˜¯æ— æ³•å®ç°çš„ã€‚å½“ç¼ºé¡µä¸­æ–­å‘ç”Ÿæ—¶ï¼Œæ“ä½œç³»ç»Ÿæ— æ³•çŸ¥é“å„ä¸ªé¡µé¢ä¸‹ä¸€æ¬¡å°†åœ¨ä»€ä¹ˆæ—¶å€™è¢«è®¿é—®ã€‚ç”¨è¿™ç§æ–¹å¼ï¼Œå¯ä»¥é€šè¿‡æœ€ä¼˜é¡µé¢ç½®æ¢ç®—æ³•å¯¹å…¶ä»–å¯å®ç°ç®—æ³•çš„æ€§èƒ½è¿›è¡Œæ¯”è¾ƒã€‚\nä¸ºäº†é¿å…æ··æ·†ï¼Œå¿…é¡»æ¸…æ¥šä»¥ä¸Šé¡µé¢è®¿é—®æƒ…å†µçš„è®°å½•åªé’ˆå¯¹åˆšåˆšè¢«æµ‹è¯•è¿‡çš„ç¨‹åºå’Œå®ƒçš„ä¸€ä¸ªç‰¹å®šçš„è¾“å…¥ã€‚\n3.4.2 æœ€è¿‘æœªä½¿ç”¨é¡µé¢ç½®æ¢ç®—æ³• ç³»ç»Ÿä¸ºæ¯ä¸€é¡µé¢è®¾ç½®äº†ä¸¤ä¸ªçŠ¶æ€ä½ã€‚å½“é¡µé¢è¢«è®¿é—®ï¼ˆè¯»æˆ–å†™ï¼‰æ—¶è®¾ç½®Rä½ï¼›å½“é¡µé¢è¢«å†™å…¥ï¼ˆå³ä¿®æ”¹ï¼‰æ—¶è®¾ç½®Mä½ã€‚ä¸€æ—¦è®¾ç½®æŸä½ä¸º1ï¼Œå®ƒå°±ä¸€ç›´ä¿æŒ1ç›´åˆ°æ“ä½œç³»ç»Ÿå°†å®ƒå¤ä½ã€‚\nå¦‚æœç¡¬ä»¶æ²¡æœ‰è¿™äº›ä½ï¼Œåˆ™å¯ä»¥ä½¿ç”¨æ“ä½œç³»ç»Ÿçš„ç¼ºé¡µä¸­æ–­å’Œæ—¶é’Ÿä¸­æ–­æœºåˆ¶è¿›è¡Œæ¨¡æ‹Ÿã€‚\nå¯ä»¥ç”¨Rä½å’ŒMä½æ¥æ„é€ ä¸€ä¸ªç®€å•çš„é¡µé¢ç½®æ¢ç®—æ³•ï¼šå½“å¯åŠ¨ä¸€ä¸ªè¿›ç¨‹æ—¶ï¼Œå®ƒçš„æ‰€æœ‰é¡µé¢çš„ä¸¤ä¸ªä½éƒ½ç”±æ“ä½œç³»ç»Ÿè®¾ç½®ä¸º0ï¼ŒRä½è¢«å®šæœŸåœ°ï¼ˆæ¯”å¦‚åœ¨æ¯æ¬¡æ—¶é’Ÿä¸­æ–­æ—¶ï¼‰æ¸…é›¶ï¼Œä»¥åŒºåˆ«æœ€è¿‘æ²¡æœ‰è¢«è®¿é—®çš„é¡µé¢å’Œè¢«è®¿é—®çš„é¡µé¢ã€‚\n4ç±»ï¼š\nç¬¬0ç±»ï¼šæ²¡æœ‰è¢«è®¿é—®ï¼Œæ²¡æœ‰è¢«ä¿®æ”¹ã€‚ ç¬¬1ç±»ï¼šæ²¡æœ‰è¢«è®¿é—®ï¼Œå·²è¢«ä¿®æ”¹ã€‚ ç¬¬2ç±»ï¼šå·²è¢«è®¿é—®ï¼Œæ²¡æœ‰è¢«ä¿®æ”¹ã€‚ ç¬¬3ç±»ï¼šå·²è¢«è®¿é—®ï¼Œå·²è¢«ä¿®æ”¹ã€‚ NRUç®—æ³•éšå³åœ°ä»ç±»ç¼–å·æœ€å°çš„éç©ºç±»ä¸­æŒ‘é€‰ä¸€ä¸ªé¡µé¢æ·˜æ±°ã€‚NRUç®—æ³•çš„ä¸»è¦ä¼˜ç‚¹æ˜¯æ˜“äºç†è§£å’Œèƒ½å¤Ÿæœ‰æ•ˆåœ°è¢«å®ç°ï¼Œè™½ç„¶å®ƒçš„æ€§èƒ½ä¸æ˜¯æœ€å¥½çš„ï¼Œä½†æ˜¯å·²ç»å¤Ÿç”¨äº†ã€‚\n3.4.3 å…ˆè¿›å…ˆå‡ºé¡µé¢ç½®æ¢ç®—æ³• ç”±æ“ä½œç³»ç»Ÿç»´æŠ¤ä¸€ä¸ªæ‰€æœ‰å½“å‰åœ¨å†…å­˜ä¸­çš„é¡µé¢çš„é“¾è¡¨ï¼Œæœ€æ–°è¿›å…¥çš„é¡µé¢æ”¾åœ¨è¡¨å°¾ï¼Œæœ€æ—©è¿›å…¥çš„é¡µé¢æ”¾åœ¨è¡¨å¤´ã€‚å½“å‘ç”Ÿç¼ºé¡µä¸­æ–­æ—¶ï¼Œæ·˜æ±°è¡¨å¤´çš„é¡µé¢å¹¶æŠŠæ–°è°ƒå…¥çš„é¡µé¢åŠ å…¥åˆ°è¡¨å°¾ã€‚\n3.4.4 ç¬¬äºŒæ¬¡æœºä¼šé¡µé¢ç½®æ¢ç®—æ³• ç¬¬äºŒæ¬¡æœºä¼šç®—æ³•å¯¹å…ˆè¿›å…ˆå‡ºé¡µé¢ç½®æ¢ç®—æ³•åšäº†ä¸€ä¸ªç®€å•çš„ä¿®æ”¹ï¼šæ£€æŸ¥æœ€è€é¡µé¢çš„Rä½ã€‚å¦‚æœRä½ä¸º0ï¼Œé‚£ä¹ˆè¿™ä¸ªé¡µé¢æ—¢è€åˆæ²¡æœ‰è¢«ä½¿ç”¨ï¼Œå¯ä»¥ç«‹åˆ»è¢«ç½®æ¢æ‰ï¼›å¦‚æœæ˜¯1ï¼Œå°±å°†Rä½æ¸…0ï¼Œå¹¶æŠŠè¯¥é¡µé¢æ”¾åˆ°é“¾è¡¨çš„å°¾ç«¯ï¼Œä¿®æ”¹å®ƒçš„è£…å…¥æ—¶é—´ä½¿å®ƒåƒåˆšè£…å…¥çš„ä¸€æ ·ï¼Œç„¶åç»§ç»­æœç´¢ã€‚\nç¬¬äºŒæ¬¡æœºä¼šç®—æ³•å°±æ˜¯å¯»æ‰¾ä¸€ä¸ªåœ¨æœ€è¿‘çš„æ—¶é’Ÿé—´éš”å†…æ²¡æœ‰è¢«è®¿é—®è¿‡çš„é¡µé¢ã€‚\n3.4.5 æ—¶é’Ÿé¡µé¢ç½®æ¢ç®—æ³• ç¬¬äºŒæ¬¡æœºä¼šç®—æ³•ç»å¸¸è¦åœ¨é“¾è¡¨ä¸­ç§»åŠ¨é¡µé¢ï¼Œæ—¢é™ä½äº†æ•ˆç‡åˆä¸æ˜¯å¾ˆæœ‰å¿…è¦ã€‚ä¸€ä¸ªæ›´å¥½çš„åŠæ³•æ˜¯æŠŠæ‰€æœ‰çš„é¡µé¢éƒ½ä¿å­˜åœ¨ä¸€ä¸ªç±»ä¼¼é’Ÿé¢çš„ç¯å½¢é“¾è¡¨ä¸­ï¼Œä¸€ä¸ªè¡¨é’ˆæŒ‡å‘æœ€è€çš„é¡µé¢ã€‚\n3.4.6 æœ€è¿‘æœ€å°‘ä½¿ç”¨é¡µé¢ç½®æ¢ç®—æ³• å¯¹æœ€ä¼˜ç®—æ³•çš„ä¸€ä¸ªå¾ˆå¥½çš„è¿‘ä¼¼æ˜¯åŸºäºè¿™æ ·çš„è§‚å¯Ÿï¼šåœ¨å‰é¢å‡ æ¡æŒ‡ä»¤ä¸­é¢‘ç¹ä½¿ç”¨çš„é¡µé¢å¾ˆå¯èƒ½åœ¨åé¢çš„å‡ æ¡æŒ‡ä»¤ä¸­è¢«ä½¿ç”¨ã€‚\nåœ¨ç¼ºé¡µä¸­æ–­å‘ç”Ÿæ—¶ï¼Œç½®æ¢æœªä½¿ç”¨æ—¶é—´æœ€é•¿çš„é¡µé¢ã€‚è¿™ä¸ªç­–ç•¥ç§°ä¸ºLRUï¼ˆLeast Recently Used, æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰é¡µé¢ç½®æ¢ç®—æ³•ã€‚\n3.4.7 ç”¨è½¯ä»¶æ¨¡æ‹ŸLRU NFUï¼ˆNot Frequently Usedï¼Œæœ€ä¸å¸¸ç”¨ï¼‰ç®—æ³•ã€‚è¯¥ç®—æ³•å°†æ¯ä¸ªé¡µé¢ä¸ä¸€ä¸ªè½¯ä»¶è®¡æ•°å™¨ç›¸å…³è”ï¼Œè®¡æ•°å™¨çš„åˆå€¼ä¸º0ã€‚æ¯æ¬¡æ—¶é’Ÿä¸­æ–­æ—¶ï¼Œç”±æ“ä½œç³»ç»Ÿæ‰«æå†…å­˜ä¸­æ‰€æœ‰çš„é¡µé¢ï¼Œå°†æ¯ä¸ªé¡µé¢çš„Rä½ï¼ˆå®ƒçš„å€¼æ˜¯0æˆ–1ï¼‰åŠ åˆ°å®ƒçš„è®¡ç®—å™¨ä¸Šã€‚è¿™ä¸ªè®¡ç®—å™¨å¤§ä½“ä¸Šè·Ÿè¸ªäº†å„ä¸ªé¡µé¢è¢«è®¿é—®çš„é¢‘ç¹ç¨‹åº¦ã€‚å‘ç”Ÿç¼ºé¡µä¸­æ–­æ—¶ï¼Œåˆ™ç½®æ¢è®¡æ•°å™¨å€¼æœ€å°çš„é¡µé¢ã€‚è¿™ä¸ªç®—æ³•çš„é—®é¢˜æ˜¯å®ƒä»æ¥ä¸å¿˜è®°ä»»ä½•äº‹æƒ…ã€‚\nè€åŒ–ç®—æ³•ï¼šé¦–å…ˆï¼Œåœ¨Rä½è¢«åŠ è¿›ä¹‹å‰å…ˆå°†è®¡æ•°å™¨å³ç§»ä¸€ä½ï¼›å…¶æ¬¡ï¼Œå°†Rä½åŠ åˆ°è®¡æ•°å™¨æœ€å·¦ç«¯çš„ä½è€Œä¸æ˜¯æœ€å³ç«¯çš„ä½ã€‚\n3.4.8 å·¥ä½œé›†é¡µé¢ç½®æ¢ç®—æ³• è¯·æ±‚è°ƒé¡µï¼Œå› ä¸ºé¡µé¢æ˜¯åœ¨éœ€è¦æ—¶è¢«è°ƒå…¥çš„ï¼Œè€Œä¸æ˜¯é¢„å…ˆè£…å…¥ã€‚\nå±€éƒ¨æ€§è®¿é—®è¡Œä¸ºï¼Œå³åœ¨è¿›ç¨‹è¿è¡Œçš„ä»»ä½•é˜¶æ®µï¼Œå®ƒéƒ½åªè®¿é—®è¾ƒå°‘çš„ä¸€éƒ¨åˆ†é¡µé¢ã€‚\nä¸€ä¸ªè¿›ç¨‹å½“å‰æ­£åœ¨ä½¿ç”¨çš„é¡µé¢çš„é›†åˆç§°ä¸ºå®ƒçš„å·¥ä½œé›†ã€‚è‹¥æ¯æ‰§è¡Œå‡ æ¡æŒ‡ä»¤ç¨‹åºå°±å‘ç”Ÿä¸€æ¬¡ç¼ºé¡µä¸­æ–­ï¼Œé‚£ä¹ˆå°±ç§°è¿™ä¸ªç¨‹åºå‘ç”Ÿäº†é¢ ç°¸ã€‚\nä¸å°‘åˆ†é¡µç³»ç»Ÿéƒ½ä¼šè®¾æ³•è·Ÿè¸ªè¿›ç¨‹çš„å·¥ä½œé›†ï¼Œä»¥ç¡®ä¿åœ¨è®©è¿›ç¨‹è¿è¡Œä¹‹å‰ï¼Œå®ƒçš„å·¥ä½œé›†å°±å·²åœ¨å†…å­˜ä¸­äº†ã€‚è¯¥æ–¹æ³•ç§°ä¸ºå·¥ä½œé›†æ¨¡å‹ï¼Œå…¶ç›®çš„åœ¨äºå¤§å¤§å‡å°‘ç¼ºé¡µä¸­æ–­ç‡ã€‚åœ¨è¿›ç¨‹è¿è¡Œå‰é¢„å…ˆè£…å…¥å…¶å·¥ä½œé›†é¡µé¢ä¹Ÿç§°ä¸ºé¢„å…ˆè°ƒé¡µã€‚\nåœ¨ä»»ä¸€æ—¶åˆ»tï¼Œéƒ½å­˜åœ¨ä¸€ä¸ªé›†åˆï¼Œå®ƒåŒ…å«æ‰€æœ‰æœ€è¿‘kæ¬¡å†…å­˜è®¿é—®æ‰€è®¿é—®è¿‡çš„é¡µé¢ã€‚è¿™ä¸ªé›†åˆw(k,t)å°±æ˜¯å·¥ä½œé›†ã€‚\näº‹å®ä¸Šå¤§å¤šæ•°ç¨‹åºä¼šä»»æ„è®¿é—®ä¸€å°éƒ¨åˆ†é¡µé¢ï¼Œä½†æ˜¯è¿™ä¸ªé›†åˆä¼šéšç€æ—¶é—´è€Œç¼“æ…¢å˜åŒ–ï¼Œè¿™ä¸ªäº‹å®ä¹Ÿè§£é‡Šäº†ä¸ºä»€ä¹ˆä¸€å¼€å§‹æ›²çº¿å¿«é€Ÿåœ°ä¸Šå‡è€Œkè¾ƒå¤§æ—¶ä¸Šå‡ä¼šå˜æ…¢ã€‚é¢„å…ˆè°ƒé¡µå°±æ˜¯åœ¨ç¨‹åºç»§ç»­è¿è¡Œä¹‹å‰é¢„å…ˆè£…å…¥æ¨æµ‹å‡ºçš„å·¥ä½œé›†çš„é¡µé¢ã€‚\né¡µé¢ç½®æ¢ç®—æ³•ï¼šå½“å‘ç”Ÿç¼ºé¡µä¸­æ–­æ—¶ï¼Œæ·˜æ±°ä¸€ä¸ªä¸åœ¨å·¥ä½œé›†çš„é¡µé¢ã€‚æ ¹æ®å®šä¹‰ï¼Œå·¥ä½œé›†å°±æ˜¯æœ€è¿‘kæ¬¡å†…å­˜è®¿é—®æ‰€ä½¿ç”¨è¿‡çš„é¡µé¢çš„é›†åˆã€‚\nä½œä¸ºæ›¿ä»£ï¼Œä¸€ç§èƒ½å¤Ÿå¸¸è§çš„è¿‘ä¼¼æ–¹æ³•å°±æ˜¯ï¼Œä¸æ˜¯å‘åæ‰¾æœ€è¿‘kæ¬¡çš„å†…å­˜è®¿é—®ï¼Œè€Œæ˜¯è€ƒè™‘å…¶æ‰§è¡Œæ—¶é—´ã€‚ä¸€ä¸ªè¿›ç¨‹ä»å®ƒå¼€å§‹æ‰§è¡Œåˆ°å½“å‰å®é™…ä½¿ç”¨çš„CPUæ—¶é—´æ€»æ•°é€šå¸¸ç§°ä½œå½“å‰å®é™…è¿è¡Œæ—¶é—´ã€‚é€šè¿‡è¿™ä¸ªè¿‘ä¼¼çš„æ–¹æ³•ï¼Œè¿›ç¨‹çš„å·¥ä½œé›†å¯ä»¥è¢«ç§°ä¸ºè¿‡å»çš„$\\tau$ç§’å®é™…è¿è¡Œæ—¶é—´ä¸­å®ƒæ‰€è®¿é—®è¿‡çš„é¡µé¢çš„é›†åˆã€‚\næ‰«ææ‰€æœ‰é¡µé¢æ£€æŸ¥Rä½ï¼š\nè‹¥ (R==1)ï¼šè®¾ç½®ä¸Šæ¬¡ä½¿ç”¨æ—¶é—´ä¸ºå½“å‰å®é™…æ—¶é—´ è‹¥(R == 0 ä¸”ç”Ÿå­˜æ—¶é—´ \u0026gt; $\\tau$) ï¼šç§»å‡ºè¿™ä¸ªé¡µé¢ è‹¥(R == 0 ä¸”ç”Ÿå­˜æ—¶é—´ \u0026lt;= $\\tau$) ï¼šè®°ä½æœ€å°æ—¶é—´ 3.4.9 å·¥ä½œé›†æ—¶é’Ÿé¡µé¢ç½®æ¢ç®—æ³• ä¸æ—¶é’Ÿç®—æ³•ä¸€æ ·ï¼Œæ‰€éœ€çš„æ•°æ®ç»“æ„æ˜¯ä¸€ä¸ªä»¥é¡µæ¡†ä¸ºå…ƒç´ çš„å¾ªç¯è¡¨ã€‚\nå¦‚æœRä½è¢«ç½®ä¸º1ï¼Œè¯¥é¡µé¢åœ¨å½“å‰æ—¶é’Ÿæ»´ç­”ä¸­å°±è¢«ä½¿ç”¨è¿‡ï¼Œé‚£ä¹ˆè¯¥é¡µé¢å°±ä¸é€‚åˆæ·˜æ±°ã€‚ç„¶åæŠŠè¯¥é¡µé¢çš„Rä½ç½®ä¸º0ï¼ŒæŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªé¡µé¢ï¼Œå¹¶é‡å¤è¯¥ç®—æ³•ã€‚\nå¦‚æœRä½è¢«ç½®ä¸º0ã€‚å¦‚æœé¡µé¢çš„ç”Ÿå­˜æ—¶é—´å¤§äº$\\tau$å¹¶ä¸”è¯¥é¡µé¢æ˜¯å¹²å‡€çš„ï¼Œç”³è¯·æ­¤é¡µæ¡†ï¼Œå¹¶æŠŠæ–°é¡µé¢æ”¾åœ¨å…¶ä¸­ã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœæ­¤é¡µé¢è¢«ä¿®æ”¹è¿‡ï¼Œå°±ä¸èƒ½ç«‹å³ç”³è¯·é¡µæ¡†ï¼ŒæŒ‡é’ˆç»§ç»­å‘å‰èµ°ã€‚\nåŸåˆ™ä¸Šï¼Œæ‰€æœ‰çš„é¡µé¢éƒ½æœ‰å¯èƒ½å› ä¸ºç£ç›˜I/Oåœ¨æŸä¸ªæ—¶é’Ÿå‘¨æœŸè¢«è°ƒåº¦ã€‚ä¸ºäº†é™ä½ç£ç›˜é˜»å¡ï¼Œéœ€è¦è®¾ç½®ä¸€ä¸ªé™åˆ¶ï¼Œå³æœ€å¤§åªå…è®¸å†™å›nä¸ªé¡µé¢ã€‚ä¸€æ—¦è¾¾åˆ°è¯¥é™åˆ¶ï¼Œå°±ä¸å…è®¸è°ƒåº¦æ–°çš„å†™æ“ä½œã€‚\n3.4.10 é¡µé¢ç½®æ¢ç®—æ³•å°ç»“ ç®—æ³• æ³¨é‡Š æœ€ä¼˜ç®—æ³• ä¸å¯å®ç°ï¼Œä½†å¯ç”¨ä½œåŸºå‡† NRUï¼ˆæœ€è¿‘æœªä½¿ç”¨ï¼‰ç®—æ³• LRUçš„å¾ˆç²—ç³™çš„è¿‘ä¼¼ FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰ç®—æ³• å¯èƒ½æŠ›å¼ƒé‡è¦é¡µé¢ ç¬¬äºŒæ¬¡æœºä¼šç®—æ³• æ¯”FIFOæœ‰è¾ƒå¤§çš„æ”¹å–„ æ—¶é’Ÿç®—æ³• ç°å®çš„ LRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰ç®—æ³• å¾ˆä¼˜ç§€ï¼Œä½†å¾ˆéš¾å®ç° NFUï¼ˆæœ€ä¸ç»å¸¸ä½¿ç”¨ï¼‰ç®—æ³• LRUçš„ç›¸å¯¹ç²—ç•¥çš„è¿‘ä¼¼ è€åŒ–ç®—æ³• éå¸¸è¿‘ä¼¼LRUçš„æœ‰æ•ˆç®—æ³• å·¥ä½œé›†ç®—æ³• å®ç°èµ·æ¥å¼€é”€å¾ˆå¤§ å·¥ä½œé›†æ—¶é’Ÿç®—æ³• å¥½çš„æœ‰æ•ˆç®—æ³• 3.7 åˆ†æ®µ ç¼–è¯‘å™¨çš„ä¾‹å­ã€‚ä¸€ä¸ªç›´è§‚å¹¶ä¸”é€šç”¨çš„æ–¹æ³•æ˜¯åœ¨æœºå™¨ä¸Šæä¾›å¤šä¸ªäº’ç›¸ç‹¬ç«‹çš„ç§°ä¸ºæ®µçš„åœ°å€ç©ºé—´ã€‚æ¯ä¸ªæ®µç”±ä¸€ä¸ªä»0åˆ°æœ€å¤§çš„çº¿æ€§åœ°å€åºåˆ—æ„æˆã€‚å„ä¸ªæ®µçš„é•¿åº¦å¯ä»¥æ˜¯0åˆ°æŸä¸ªå…è®¸çš„æœ€å¤§å€¼ä¹‹é—´çš„ä»»ä½•ä¸€ä¸ªå€¼ã€‚ä¸åŒæ®µçš„é•¿åº¦å¯ä»¥ä¸åŒï¼Œå¹¶ä¸”é€šå¸¸æƒ…å†µä¸‹ä¹Ÿéƒ½ä¸ç›¸åŒã€‚æ®µçš„é•¿åº¦åœ¨è¿è¡ŒæœŸé—´å¯ä»¥åŠ¨æ€æ”¹å˜ã€‚\næ®µå½“ç„¶æœ‰å¯èƒ½ä¼šè¢«è£…æ»¡ï¼Œä½†é€šå¸¸æƒ…å†µä¸‹æ®µéƒ½å¾ˆå¤§ï¼Œå› æ­¤è¿™ç§æƒ…å†µå‘ç”Ÿçš„å¯èƒ½æ€§å¾ˆå°ã€‚ç¨‹åºå¿…é¡»æä¾›ä¸¤éƒ¨åˆ†åœ°å€ï¼Œä¸€ä¸ªæ®µå·å’Œä¸€ä¸ªæ®µå†…åœ°å€ã€‚\næ®µæ˜¯ä¸€ä¸ªé€»è¾‘å®ä½“ã€‚ä¸€ä¸ªæ®µå¯èƒ½åŒ…æ‹¬ä¸€ä¸ªè¿‡ç¨‹ã€ä¸€ä¸ªæ•°ç»„ã€ä¸€ä¸ªå †æ ˆã€ä¸€ç»„æ•°ç»„å˜é‡ï¼Œä½†ä¸€èˆ¬å®ƒä¸ä¼šåŒæ—¶åŒ…å«å¤šç§ä¸åŒç±»å‹çš„å†…å®¹ã€‚\nå¦‚æœæ¯ä¸ªè¿‡ç¨‹éƒ½ä½äºä¸€ä¸ªç‹¬ç«‹çš„æ®µä¸­å¹¶ä¸”èµ·å§‹åœ°å€æ˜¯0ï¼Œé‚£ä¹ˆæŠŠå•ç‹¬ç¼–è¯‘å¥½çš„è¿‡ç¨‹é“¾æ¥èµ·æ¥çš„æ“ä½œå°±å¯ä»¥å¾—åˆ°å¾ˆå¤§çš„ç®€åŒ–ã€‚\nåˆ†æ®µä¹Ÿæœ‰åŠ©äºåœ¨å‡ ä¸ªè¿›ç¨‹ä¹‹é—´å…±äº«è¿‡ç¨‹å’Œæ•°æ®ã€‚\nå› ä¸ºæ¯ä¸ªæ®µæ˜¯ä¸€ä¸ªä¸ºç¨‹åºå‘˜æ‰€çŸ¥é“çš„é€»è¾‘å®ä½“ï¼Œæ¯”å¦‚ä¸€ä¸ªè¿‡ç¨‹æˆ–ä¸€ä¸ªæ•°ç»„ï¼Œæ•…ä¸åŒçš„æ®µå¯ä»¥æœ‰ä¸åŒç§ç±»çš„ä¿æŠ¤ã€‚\nè€ƒæŸ¥ç‚¹ åˆ†é¡µ åˆ†æ®µ éœ€è¦ç¨‹åºå‘˜äº†è§£æ­£åœ¨ä½¿ç”¨çš„è¿™ç§æŠ€æœ¯å—ï¼Ÿ å¦ æ˜¯ å­˜åœ¨å¤šå°‘çº¿æ€§åœ°å€ç©ºé—´ï¼Ÿ 1 è®¸å¤š æ•´ä¸ªåœ°å€ç©ºé—´å¯ä»¥è¶…å‡ºç‰©ç†å­˜å‚¨å™¨çš„å¤§å°å—ï¼Ÿ æ˜¯ æ˜¯ è¿‡ç¨‹å’Œæ•°æ®å¯ä»¥è¢«åŒºåˆ†å¹¶åˆ†åˆ«è¢«ä¿æŠ¤å—ï¼Ÿ å¦ æ˜¯ å…¶å¤§å°æµ®åŠ¨çš„è¡¨å¯ä»¥å¾ˆå®¹æ˜“æä¾›å—ï¼Ÿ å¦ æ˜¯ ç”¨æˆ·è¿‡ç¨‹çš„å…±äº«æ–¹ä¾¿å—ï¼Ÿ å¦ æ˜¯ ä¸ºä»€ä¹ˆå‘æ˜è¿™ç§æŠ€æœ¯ï¼Ÿ ä¸ºäº†å¾—åˆ°å¤§çš„çº¿æ€§åœ°å€ç©ºé—´è€Œä¸å¿…è´­ä¹°æ›´å¤§çš„ç‰©ç†å­˜å‚¨å™¨ ä¸ºäº†ä½¿ç¨‹åºå’Œæ•°æ®å¯ä»¥è¢«åˆ’åˆ†ä¸ºé€»è¾‘ä¸Šç‹¬ç«‹çš„åœ°å€ç©ºé—´å¹¶ä¸”æœ‰åŠ©äºå…±äº«å’Œä¿æŠ¤ 3.7.1 çº¯åˆ†æ®µçš„å®ç° åˆ†æ®µå’Œåˆ†é¡µçš„å®ç°æœ¬è´¨ä¸Šæ˜¯ä¸åŒçš„ï¼šé¡µé¢æ˜¯å®šé•¿çš„è€Œæ®µä¸æ˜¯ã€‚\nåœ¨ç³»ç»Ÿè¿è¡Œä¸€æ®µæ—¶é—´åå†…å­˜è¢«åˆ’åˆ†ä¸ºè®¸å¤šå—ï¼Œä¸€äº›å—åŒ…å«ç€æ®µï¼Œä¸€äº›åˆ™æˆäº†ç©ºé—²åŒºï¼Œè¿™ç§ç°è±¡ç§°ä¸ºæ£‹ç›˜å½¢ç¢ç‰‡æˆ–å¤–éƒ¨ç¢ç‰‡ã€‚ç©ºé—²åŒºçš„å­˜åœ¨ä½¿å†…å­˜è¢«æµªè´¹äº†ï¼Œè€Œè¿™å¯ä»¥é€šè¿‡å†…å­˜ç´§ç¼©æ¥è§£å†³ã€‚\n3.7.2 åˆ†æ®µå’Œåˆ†é¡µç»“åˆï¼šMULTICS å¦‚æœä¸€ä¸ªæ®µæ¯”è¾ƒå¤§ï¼ŒæŠŠå®ƒæ•´ä¸ªä¿å­˜åœ¨å†…å­˜ä¸­å¯èƒ½å¾ˆä¸æ–¹ä¾¿ç”šè‡³æ˜¯ä¸å¯èƒ½çš„ï¼Œå› æ­¤äº§ç”Ÿäº†å¯¹å®ƒè¿›è¡Œåˆ†é¡µçš„æƒ³æ³•ã€‚è¿™æ ·ï¼Œåªæœ‰é‚£äº›çœŸæ­£éœ€è¦çš„é¡µé¢æ‰ä¼šè¢«è°ƒå…¥å†…å­˜ã€‚\nMULTICSçš„è®¾è®¡è€…å†³å®šæŠŠæ¯ä¸ªæ®µéƒ½çœ‹ä½œä¸€ä¸ªè™šæ‹Ÿå†…å­˜å¹¶å¯¹å®ƒè¿›è¡Œåˆ†é¡µï¼Œä»¥ç»“åˆåˆ†é¡µçš„ä¼˜ç‚¹ï¼ˆç»Ÿä¸€çš„é¡µé¢å¤§å°å’Œåªåœ¨ä½¿ç”¨æ®µçš„ä¸€éƒ¨åˆ†æ—¶ä¸ç”¨æŠŠå®ƒå…¨éƒ¨è°ƒå…¥å†…å­˜ï¼‰å’Œåˆ†æ®µçš„ä¼˜ç‚¹ï¼ˆæ˜“äºç¼–ç¨‹ã€æ¨¡å—åŒ–ã€ä¿æŠ¤å’Œå…±äº«ï¼‰ã€‚\næ¯ä¸ªMULTICSç¨‹åºéƒ½æœ‰ä¸€ä¸ªæ®µè¡¨ï¼Œæ¯ä¸ªæ®µå¯¹åº”ä¸€ä¸ªæè¿°ç¬¦ã€‚æ®µè¡¨æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªæ®µå¹¶è¢«åˆ†é¡µã€‚ä¸€ä¸ªæ®µæè¿°ç¬¦åŒ…å«äº†ä¸€ä¸ªæ®µæ˜¯å¦åœ¨å†…å­˜ä¸­çš„æ ‡è®°ï¼Œåªè¦ä¸€ä¸ªæ®µçš„ä»»ä½•ä¸€éƒ¨åˆ†åœ¨å†…å­˜ä¸­è¿™ä¸ªæ®µå°±è¢«è®¤ä¸ºæ˜¯åœ¨å†…å­˜ä¸­ï¼Œå¹¶ä¸”å®ƒçš„é¡µè¡¨ä¹Ÿä¼šåœ¨å†…å­˜ä¸­ã€‚\næ¯ä¸ªæ®µéƒ½æ˜¯ä¸€ä¸ªæ™®é€šçš„è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚\nMULTICSä¸­çš„ä¸€ä¸ªåœ°å€ç”±ä¸¤éƒ¨åˆ†æ„æˆï¼šæ®µå·å’Œæ®µå†…åœ°å€ã€‚æ®µå†…åœ°å€åˆè¿›ä¸€æ­¥åˆ†ä¸ºé¡µå·å’Œé¡µå†…çš„å­—ã€‚ç®—æ³•å¦‚ä¸‹ï¼š\næ ¹æ®æ®µå·æ‰¾åˆ°æ®µæè¿°ç¬¦ã€‚ æ£€æŸ¥è¯¥æ®µçš„é¡µè¡¨æ˜¯å¦åœ¨å†…å­˜ä¸­ã€‚å¦‚æœåœ¨ï¼Œåˆ™æ‰¾åˆ°å®ƒçš„ä½ç½®ï¼›å¦‚æœä¸åœ¨ï¼Œåˆ™äº§ç”Ÿä¸€ä¸ªæ®µé”™è¯¯ã€‚å¦‚æœè®¿é—®è¿åäº†æ®µçš„ä¿æŠ¤è¦æ±‚å°±å‘å‡ºä¸€ä¸ªè¶Šç•Œé”™è¯¯ï¼ˆé™·é˜±ï¼‰ã€‚ æ£€æŸ¥æ‰€è¯·æ±‚çš„è™šæ‹Ÿé¡µé¢çš„é¡µè¡¨é¡¹ï¼Œå¦‚æœè¯¥é¡µé¢ä¸åœ¨å†…å­˜ä¸­åˆ™äº§ç”Ÿä¸€ä¸ªç¼ºé¡µä¸­æ–­ï¼Œå¦‚æœåœ¨å†…å­˜å°±ä»é¡µè¡¨é¡¹ä¸­å–å‡ºè¿™ä¸ªé¡µé¢åœ¨å†…å­˜ä¸­çš„èµ·å§‹åœ°å€ã€‚ æŠŠåç§»é‡åŠ åˆ°é¡µé¢çš„èµ·å§‹åœ°å€ä¸Šï¼Œå¾—åˆ°è¦è®¿é—®çš„å­—åœ¨å†…å­˜ä¸­çš„åœ°å€ã€‚ æœ€åè¿›è¡Œè¯»æˆ–å†™æ“ä½œã€‚ å®é™…ä¸Šï¼ŒMULTICSç¡¬ä»¶åŒ…å«äº†16ä¸ªå­—çš„é«˜é€ŸTLBã€‚\n3.7.3 åˆ†æ®µå’Œåˆ†é¡µç»“åˆï¼šIntel x86 x86å¤„ç†å™¨ä¸­è™šæ‹Ÿå†…å­˜çš„æ ¸å¿ƒæ˜¯ä¸¤å¼ è¡¨ï¼Œå³LDTï¼ˆå±€éƒ¨æè¿°ç¬¦è¡¨ï¼‰å’ŒGDTï¼ˆå…¨å±€æè¿°ç¬¦è¡¨ï¼‰ã€‚LDTæè¿°å±€éƒ¨äºæ¯ä¸ªç¨‹åºçš„æ®µï¼ŒåŒ…æ‹¬å…¶ä»£ç ã€æ•°æ®ã€å †æ ˆç­‰ï¼›GDTæè¿°ç³»ç»Ÿæ®µï¼ŒåŒ…æ‹¬æ“ä½œç³»ç»Ÿæœ¬èº«ã€‚\nä¸ºäº†è®¿é—®ä¸€ä¸ªæ®µï¼Œä¸€ä¸ªx86ç¨‹åºå¿…é¡»æŠŠè¿™ä¸ªæ®µçš„é€‰æ‹©å­è£…å…¥æœºå™¨çš„6ä¸ªæ®µå¯„å­˜å™¨çš„æŸä¸€ä¸ªä¸­ã€‚\nåœ¨é€‰æ‹©å­è¢«è£…å…¥æ®µå¯„å­˜å™¨æ—¶ï¼Œå¯¹åº”çš„æè¿°ç¬¦è¢«ä»LDTæˆ–GDTä¸­å–å‡ºè£…å…¥å¾®ç¨‹åºå¯„å­˜å™¨ä¸­ï¼Œä»¥ä¾¿å¿«é€Ÿåœ°è®¿é—®ã€‚ä¸€ä¸ªæè¿°ç¬¦ç”±8ä¸ªå­—èŠ‚æ„æˆï¼ŒåŒ…æ‹¬æ®µçš„åŸºå€ã€å¤§å°å’Œå…¶ä»–ä¿¡æ¯ã€‚\nå‡è®¾æ®µåœ¨å†…å­˜ä¸­å¹¶ä¸”åç§»é‡ä¹Ÿåœ¨èŒƒå›´å†…ï¼Œx86å¤„ç†å™¨æ¥ç€æŠŠæè¿°ç¬¦ä¸­32ä½çš„åŸºå€å’Œåç§»é‡ç›¸åŠ å½¢æˆçº¿æ€§åœ°å€ã€‚\nçº¿æ€§åœ°å€è¢«åˆ†ä¸ºä¸‰ä¸ªåŸŸï¼šç›®å½•ã€é¡µé¢å’Œåç§»é‡ã€‚\nx86å¤„ç†å™¨å’ŒMULTICSä¸€æ ·ï¼Œä¹Ÿæœ‰ä¸€ä¸ªå°çš„TLBæŠŠæœ€è¿‘ä½¿ç”¨è¿‡çš„â€œç›®å½•-é¡µé¢â€äºŒå…ƒç»„æ˜ å°„ä¸ºé¡µæ¡†çš„ç‰©ç†åœ°å€ã€‚\nç¬¬6ç«  æ­»é” è½¯ç¡¬ä»¶èµ„æºéƒ½æœ‰å¯èƒ½å‡ºç°æ­»é”ã€‚\n6.1 èµ„æº éœ€è¦æ’ä»–æ€§ä½¿ç”¨çš„å¯¹è±¡ç§°ä¸ºèµ„æºã€‚\n6.1.1 å¯æŠ¢å èµ„æºå’Œä¸å¯æŠ¢å èµ„æº èµ„æºåˆ†ä¸ºä¸¤ç±»ï¼šå¯æŠ¢å çš„å’Œä¸å¯æŠ¢å çš„ã€‚\nå¯æŠ¢å èµ„æºå¯ä»¥ä»æ‹¥æœ‰å®ƒçš„è¿›ç¨‹ä¸­æŠ¢å è€Œä¸ä¼šäº§ç”Ÿä»»ä½•å‰¯ä½œç”¨ï¼Œå­˜å‚¨å™¨å°±æ˜¯ä¸€ç±»å¯æŠ¢å çš„èµ„æºã€‚\nä¸å¯æŠ¢å èµ„æºæ˜¯æŒ‡åœ¨ä¸å¼•èµ·ç›¸å…³çš„è®¡ç®—å¤±è´¥çš„æƒ…å†µä¸‹ï¼Œæ— æ³•æŠŠå®ƒä»å æœ‰å®ƒçš„è¿›ç¨‹æŠ¢å è¿‡æ¥ã€‚\næŸä¸ªèµ„æºæ˜¯å¦å¯æŠ¢å å–å†³äºä¸Šä¸‹æ–‡ç¯å¢ƒã€‚\næ€»çš„æ¥è¯´ï¼Œæ­»é”ä¸ä¸å¯æŠ¢å èµ„æºæœ‰å…³ï¼Œæœ‰å…³å¯æŠ¢å èµ„æºçš„æ½œåœ¨æ­»é”é€šå¸¸å¯ä»¥é€šè¿‡åœ¨è¿›ç¨‹ä¹‹é—´é‡æ–°åˆ†é…èµ„æºè€ŒåŒ–è§£ã€‚\nä½¿ç”¨ä¸€ä¸ªèµ„æºæ‰€éœ€è¦çš„äº‹ä»¶é¡ºåºå¯ä»¥ç”¨æŠ½è±¡çš„å½¢å¼è¡¨ç¤ºå¦‚ä¸‹ï¼š\nè¯·æ±‚èµ„æº ä½¿ç”¨èµ„æº é‡Šæ”¾èµ„æº åœ¨åé¢çš„è®¨è®ºä¸­ï¼Œæˆ‘ä»¬å‡è®¾ï¼šå¦‚æœæŸä¸ªè¿›ç¨‹è¯·æ±‚èµ„æºå¤±è´¥ï¼Œé‚£ä¹ˆå®ƒå°±è¿›å…¥ä¼‘çœ çŠ¶æ€ã€‚\n6.1.2 èµ„æºè·å– æ­»é”æ˜¯éå¸¸å®¹æ˜“å‘ç”Ÿçš„ã€‚\n","date":"2022-07-01T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/07/01/Operating-System/","title":"ç°ä»£æ“ä½œç³»ç»Ÿç¬”è®°"},{"content":"ä»»åŠ¡ è¿™æ˜¯æ¢åšäº‘å®ä¹ çš„ç¬¬ä¸€ä¸ªé¡¹ç›®ï¼Œå‘ç°è´Ÿé¢æ–°é—»ã€‚\nå®ä¹ ç›®æ ‡\nå­¦ä¹ å’ŒæŒæ¡jsonä»£ç çš„è§£æå’Œç”Ÿæˆ å­¦ä¹ ä¸€ç§httpæœåŠ¡çš„æ–¹å¼ å­¦ä¹ å¦‚ä½•ä½¿ç”¨å¼€æ”¾API ç¬¬ä¸€æ­¥ã€å­¦ä¹ å’Œåˆ©ç”¨ç°æœ‰ä¸€ä¸ªæƒ…æ„Ÿè®¡ç®—API http://www.pullword.com/baobian/\nè°ƒç”¨æ ·ä¾‹ï¼šLinuxå‘½ä»¤è¡Œä¸‹æ‰§è¡Œ\n1 curl -X POST \u0026#39;http://baobianapi.pullword.com:9091/get.php\u0026#39; -d\u0026#39;åä¸€æœˆå†è§ï¼ŒåäºŒæœˆä½ å¥½ï¼Œ2021å¹´æœ€åä¸€ä¸ªæœˆæ€»ä¼šæœ‰ä¸æœŸè€Œé‡çš„æ¸©æš–ï¼Œå’Œç”Ÿç”Ÿä¸æ¯çš„å¸Œæœ›\u0026#39; â€“compressed è¿”å›çš„jsonç»“æœè¦èƒ½è§£æï¼Œå¤§äº0.5è¡¨ç¤ºæ­£é¢æƒ…æ„Ÿï¼Œå°äº-0.5è¡¨æ˜è´Ÿé¢æƒ…æ„Ÿã€‚æˆ–è€…ä½¿ç”¨å…¶ä»–è‡ªå·±ç†Ÿæ‚‰çš„APIä¹Ÿå¯ä»¥ã€‚æ¨èä½¿ç”¨æ¢åšå…¬å¼€çš„æœåŠ¡ã€‚\nç¬¬äºŒæ­¥ï¼Œå­¦ä¹ æä¾›httpæœåŠ¡çš„å·¥å…·\nCè¯­è¨€é€‰æ‰‹å¯ä»¥é€šè¿‡æœç‹—å·¥ä½œæµå¼€æºå·¥å…·å®ç°ã€‚ä¸ä¼šCå’ŒC++çš„åŒå­¦å¯ä»¥ç”¨phpä»£ç æˆ–è€…å…¶ä»–è‡ªå·±ç†Ÿæ‚‰çš„è¯­è¨€å®ç°ã€‚\nç¬¬ä¸‰æ­¥ï¼Œå­¦ä¹ å’Œäº†è§£æ•°æ®æº http://news.baidu.com/\nä»ç™¾åº¦æ–°é—»é¦–é¡µè·å¾—å½“å¤©çƒ­é—¨æ–°é—»ï¼Œç”¨curlæˆ–è€…wgetå‘½ä»¤é‡‡é›†é¦–é¡µã€‚ç„¶åæå–å…¶ä¸­çš„æ–°é—»æ ‡é¢˜å’ŒURL\nç¬¬å››æ­¥ï¼Œå°†ä»Šæ—¥æ–°é—»æ ‡é¢˜è°ƒç”¨æƒ…æ„Ÿè®¡ç®—APIå¾—åˆ°æ­£è´Ÿé¢è¯„ä»·ï¼Œæå–è´Ÿé¢ç»“æœçš„æ–°é—»æ ‡é¢˜å’ŒURLï¼Œé€šè¿‡ç¬¬äºŒæ­¥æŒæ¡çš„httpæœåŠ¡å·¥å…·ä»¥jsonæ ¼å¼å¯¹å¤–å±•ç¤ºã€‚å±•ç¤ºçš„å†…å®¹åŒ…æ‹¬æ ‡é¢˜å’ŒURLçš„åˆ—è¡¨ã€‚åœ¨è‡ªå·±çš„linuxæœºå™¨ä¸Šèƒ½è®¿é—®å³å¯ï¼Œæœ‰å…¬ç½‘æœåŠ¡å™¨çš„å¯ä»¥å¼€æ”¾å…¬ç½‘URLä¾›æˆ‘ä»¬æ£€æŸ¥ï¼Œæ²¡æœ‰å…¬ç½‘æœåŠ¡å™¨çš„æˆªå›¾å³å¯ã€‚\nçˆ¬å–ç™¾åº¦æ–°é—» æ‰“å¼€ç™¾åº¦æ–°é—»ï¼ŒF12æŸ¥çœ‹é¡µé¢æºç ï¼Œå¯ä»¥çœ‹åˆ°çƒ­ç‚¹æ–°é—»çš„class=mod-tab-pane activeã€‚ ç”¨å¦‚ä¸‹æ–¹æ³•å¾—åˆ°æ–°é—»æ ‡é¢˜å’Œé“¾æ¥ï¼š\n1 2 3 4 5 6 // è·å–çƒ­ç‚¹æ–°é—»HTMLä»£ç  Elements hotNews = doc.select(\u0026#34;[class=mod-tab-pane active]\u0026#34;).select(\u0026#34;a\u0026#34;); // è·å–æ–°é—»æ ‡é¢˜åŠé“¾æ¥ for (int i = 0; i \u0026lt; hotNews.size(); i++) { news.put(hotNews.get(i).text(), hotNews.get(i).attr(\u0026#34;href\u0026#34;)); } ç¨‹åºçš„å®Œæ•´é€»è¾‘æ˜¯å…ˆå¾—åˆ°ç™¾åº¦æ–°é—»çš„HTMLæ–‡ä»¶ï¼Œå†ä»classç­›é€‰å¾—åˆ°ç›¸åº”çš„æ ‡é¢˜å’Œé“¾æ¥ï¼Œè¿™é‡ŒElementsç±»æ˜¯å®ç°äº†List\u0026lt;Element\u0026gt;æ¥å£ï¼Œå› æ­¤æ˜¯å¯ä»¥éå†çš„ï¼Œåœ¨éå†æ—¶åŠ å…¥å­˜æ”¾æ–°é—»çš„æ ‡é¢˜å’Œé“¾æ¥çš„å“ˆå¸Œè¡¨ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package com.jinjin.news.controller; import org.jsoup.Jsoup; import org.jsoup.nodes.Document; import org.jsoup.select.Elements; import java.io.IOException; import java.util.HashMap; /** * @author æ–‡è¿› * @version 1.0 */ public class News { /** * * @param url è®¿é—®è·¯å¾„ * @return */ public Document getDocument (String url){ try { //5000æ˜¯è®¾ç½®è¿æ¥è¶…æ—¶æ—¶é—´ï¼Œå•ä½ms return Jsoup.connect(url).timeout(5000).get(); } catch (IOException e) { e.printStackTrace(); } return null; } /** * @param url è®¿é—®ç½‘ç«™çš„url * @return è¿”å›çƒ­ç‚¹æ–°é—»çš„æ ‡é¢˜å’Œé“¾æ¥ */ public HashMap getNews (String url) { Document doc = getDocument(url); HashMap\u0026lt;String, String\u0026gt; news = new HashMap\u0026lt;\u0026gt;(); // è·å–çƒ­ç‚¹æ–°é—»HTMLä»£ç  Elements hotNews = doc.select(\u0026#34;[class=mod-tab-pane active]\u0026#34;).select(\u0026#34;a\u0026#34;); // è·å–æ–°é—»æ ‡é¢˜åŠé“¾æ¥ for (int i = 0; i \u0026lt; hotNews.size(); i++) { news.put(hotNews.get(i).text(), hotNews.get(i).attr(\u0026#34;href\u0026#34;)); // System.out.println(hotNews.get(i).text() + \u0026#34; \u0026#34; + hotNews.get(i).attr(\u0026#34;href\u0026#34;)); } return news; } } å‚è€ƒèµ„æ–™ï¼šJavaçˆ¬å–ç½‘é¡µå†…å®¹çš„ç®€å•ä¾‹å­\nä½¿ç”¨æƒ…æ„Ÿè®¡ç®—API æƒ…æ„Ÿè®¡ç®—APIé“¾æ¥æ˜¯ï¼šhttp://www.pullword.com/baobian/\næˆ‘ä»¬è¦åšçš„æ˜¯å°†çˆ¬å–åˆ°çš„æ–°é—»æ ‡é¢˜ç”¨POSTæ–¹æ³•å‘ä¸Šè¿°é“¾æ¥å‘è¯·æ±‚ï¼Œæœ€åå¾—åˆ°ä¸€ä¸ªjsonç»“æœï¼Œæå–å…¶ä¸­çš„æƒ…æ„Ÿæ•°å€¼ï¼Œå°†è´Ÿçš„æƒ…æ„Ÿå€¼å¯¹åº”çš„æ–°é—»æ ‡é¢˜ä¿å­˜ä¸‹æ¥ï¼Œç”±äºä¹‹å‰å­˜å–çš„æ–°é—»æ˜¯HashMapï¼Œå› æ­¤å¾—åˆ°è´Ÿé¢æ–°é—»çš„URLä¹Ÿä¸æ˜¯éš¾äº‹äº†ã€‚\nå‚è€ƒjavaå‘æŒ‡å®šURLå‘é€GETæˆ–POSTè¯·æ±‚ï¼Œæˆ‘ä»¬ç”¨åˆ°äº†UrlUtilså·¥å…·ç±»ï¼Œæˆ‘ä»¬éœ€è¦ç”¨çš„æ˜¯public static String sendPost(String url, String param){}è¿™ä¸ªå¸¦å‚æ•°çš„å‘é€POSTè¯·æ±‚çš„æ–¹æ³•ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 package com.jinjin.news.controller; import com.sun.org.slf4j.internal.Logger; import com.sun.org.slf4j.internal.LoggerFactory; import java.io.*; import java.net.URL; import java.net.URLConnection; import java.util.Iterator; import java.util.List; import java.util.Map; /** * @author æ–‡è¿› * @version 1.0 */ public class UrlUtils { private static final Logger log = LoggerFactory.getLogger(UrlUtils.class); /** * å‘æŒ‡å®šURLå‘é€GETæ–¹æ³•çš„è¯·æ±‚ * * @param url å‘é€è¯·æ±‚çš„URL * @param param è¯·æ±‚å‚æ•°ï¼Œè¯·æ±‚å‚æ•°åº”è¯¥æ˜¯ name1=value1\u0026amp;name2=value2 çš„å½¢å¼ã€‚ * @return URL æ‰€ä»£è¡¨è¿œç¨‹èµ„æºçš„å“åº”ç»“æœ */ public static String sendGet(String url, String param) { String result = \u0026#34;\u0026#34;; BufferedReader in = null; try { String urlNameString = url + \u0026#34;?\u0026#34; + param; URL realUrl = new URL(urlNameString); // æ‰“å¼€å’ŒURLä¹‹é—´çš„è¿æ¥ URLConnection connection = realUrl.openConnection(); // è®¾ç½®é€šç”¨çš„è¯·æ±‚å±æ€§ connection.setRequestProperty(\u0026#34;accept\u0026#34;, \u0026#34;*/*\u0026#34;); connection.setRequestProperty(\u0026#34;connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;); connection.setRequestProperty(\u0026#34;user-agent\u0026#34;, \u0026#34;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\u0026#34;); // å»ºç«‹å®é™…çš„è¿æ¥ connection.connect(); // è·å–æ‰€æœ‰å“åº”å¤´å­—æ®µ Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = connection.getHeaderFields(); // éå†æ‰€æœ‰çš„å“åº”å¤´å­—æ®µ // for (String key : map.keySet()) { // System.out.println(key + \u0026#34;---\u0026gt;\u0026#34; + map.get(key)); // } // å®šä¹‰ BufferedReaderè¾“å…¥æµæ¥è¯»å–URLçš„å“åº” in = new BufferedReader(new InputStreamReader( connection.getInputStream())); String line; while ((line = in.readLine()) != null) { result += line; } } catch (Exception e) { log.error(\u0026#34;å‘é€GETè¯·æ±‚å‡ºç°å¼‚å¸¸ï¼\u0026#34; + e); e.printStackTrace(); } // ä½¿ç”¨finallyå—æ¥å…³é—­è¾“å…¥æµ finally { try { if (in != null) { in.close(); } } catch (Exception e2) { e2.printStackTrace(); } } return result; } /** * å‘æŒ‡å®š URL å‘é€POSTæ–¹æ³•çš„è¯·æ±‚ * * @param url å‘é€è¯·æ±‚çš„ URL * @param paramMap è¯·æ±‚å‚æ•° * @return æ‰€ä»£è¡¨è¿œç¨‹èµ„æºçš„å“åº”ç»“æœ */ public static String sendPost(String url, Map\u0026lt;String, ?\u0026gt; paramMap) { PrintWriter out = null; BufferedReader in = null; String result = \u0026#34;\u0026#34;; String param = \u0026#34;\u0026#34;; Iterator\u0026lt;String\u0026gt; it = paramMap.keySet().iterator(); while (it.hasNext()) { String key = it.next(); param += key + \u0026#34;=\u0026#34; + paramMap.get(key) + \u0026#34;\u0026amp;\u0026#34;; } try { URL realUrl = new URL(url); // æ‰“å¼€å’ŒURLä¹‹é—´çš„è¿æ¥ URLConnection conn = realUrl.openConnection(); // è®¾ç½®é€šç”¨çš„è¯·æ±‚å±æ€§ conn.setRequestProperty(\u0026#34;accept\u0026#34;, \u0026#34;*/*\u0026#34;); conn.setRequestProperty(\u0026#34;connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;); conn.setRequestProperty(\u0026#34;Accept-Charset\u0026#34;, \u0026#34;utf-8\u0026#34;); conn.setRequestProperty(\u0026#34;user-agent\u0026#34;, \u0026#34;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\u0026#34;); // å‘é€POSTè¯·æ±‚å¿…é¡»è®¾ç½®å¦‚ä¸‹ä¸¤è¡Œ conn.setDoOutput(true); conn.setDoInput(true); // è·å–URLConnectionå¯¹è±¡å¯¹åº”çš„è¾“å‡ºæµ out = new PrintWriter(conn.getOutputStream()); // å‘é€è¯·æ±‚å‚æ•° out.print(param); // flushè¾“å‡ºæµçš„ç¼“å†² out.flush(); // å®šä¹‰BufferedReaderè¾“å…¥æµæ¥è¯»å–URLçš„å“åº” in = new BufferedReader(new InputStreamReader(conn.getInputStream(), \u0026#34;UTF-8\u0026#34;)); String line; while ((line = in.readLine()) != null) { result += line; } } catch (Exception e) { log.error(e.getMessage(), e); } //ä½¿ç”¨finallyå—æ¥å…³é—­è¾“å‡ºæµã€è¾“å…¥æµ finally { try { if (out != null) { out.close(); } if (in != null) { in.close(); } } catch (IOException ex) { ex.printStackTrace(); } } return result; } /** * å‘é€postè¯·æ±‚ jsonæ ¼å¼ * * @param url * @param param jsonå­—ç¬¦ä¸² * @return */ public static String sendPost(String url, String param) { PrintWriter out = null; BufferedReader in = null; StringBuilder result = new StringBuilder(); try { URL realUrl = new URL(url); // // å¿½ç•¥httpsåŠŸèƒ½ï¼Œæ™®é€šä½¿ç”¨å¯ä»¥åˆ é™¤ // if (\u0026#34;https\u0026#34;.equalsIgnoreCase(realUrl.getProtocol())) { // // SslUtils.ignoreSsl(); // } // æ‰“å¼€å’ŒURLä¹‹é—´çš„è¿æ¥ URLConnection conn = realUrl.openConnection(); // è®¾ç½®é€šç”¨çš„è¯·æ±‚å±æ€§ conn.setRequestProperty(\u0026#34;accept\u0026#34;, \u0026#34;*/*\u0026#34;); conn.setRequestProperty(\u0026#34;connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;); conn.setRequestProperty(\u0026#34;Accept-Charset\u0026#34;, \u0026#34;utf-8\u0026#34;); conn.setRequestProperty(\u0026#34;user-agent\u0026#34;, \u0026#34;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\u0026#34;); // å‘é€POSTè¯·æ±‚å¿…é¡»è®¾ç½®å¦‚ä¸‹ä¸¤è¡Œ conn.setDoOutput(true); conn.setDoInput(true); // è·å–URLConnectionå¯¹è±¡å¯¹åº”çš„è¾“å‡ºæµ //out = new PrintWriter(conn.getOutputStream()); out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), \u0026#34;UTF-8\u0026#34;)); // å‘é€è¯·æ±‚å‚æ•° out.print(param); // flushè¾“å‡ºæµçš„ç¼“å†² out.flush(); // å®šä¹‰BufferedReaderè¾“å…¥æµæ¥è¯»å–URLçš„å“åº” in = new BufferedReader(new InputStreamReader(conn.getInputStream(), \u0026#34;UTF-8\u0026#34;)); String line; while ((line = in.readLine()) != null) { //result += line; result.append(line); } } catch (Exception e) { System.out.println(\u0026#34;å‘é€ POST è¯·æ±‚å‡ºç°å¼‚å¸¸!\u0026#34; + e); e.printStackTrace(); } //ä½¿ç”¨finallyå—æ¥å…³é—­è¾“å‡ºæµã€è¾“å…¥æµ finally { try { if (out != null) { out.close(); } if (in != null) { in.close(); } } catch (IOException ex) { ex.printStackTrace(); } } //log.info(\u0026#34;urlè¿”å›: \u0026#34; +result); return result.toString(); } } åˆ›å»ºSpring Booté¡¹ç›® ä¸Šè¿°æ¨¡å—éƒ½æµ‹è¯•å¥½ä¹‹åï¼Œæœ€åå°±æ˜¯è¿”å›JSONæ•°æ®æ ¼å¼ï¼Œå‚è€ƒ\u0026lt;åç«¯åˆå­¦è€…\u0026gt;Spring Boot è¿”å› JSON æ•°æ®åŠæ•°æ®å°è£…ï¼Œæœ‰å¤šç§æ–¹æ³•ï¼Œå…¶ä¸­ä¸€ç§ç”¨Spring Bootä¸­çš„@RestControlleræ³¨è§£æ¥è¿”å›JSONæ•°æ®ï¼Œé‚£ä¹ˆæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªSpring Booté¡¹ç›®ï¼Œå†æŠŠä¸Šè¿°æ¨¡å—çš„ä»£ç è¿ç§»è¿‡æ¥å°±å¥½å•¦ã€‚\nåˆ›å»ºSpring Booté¡¹ç›®çš„æ­¥éª¤å‚è€ƒ2020å…¥é—¨æ•™ç¨‹macOS ä½¿ç”¨Intellj IDEA åˆ›å»ºspring booté¡¹ç›®ã€‚\nè¿”å›JSONæ•°æ®æ ¼å¼ é¦–å…ˆä¸ºäº†æ–¹ä¾¿è¿”å›JSONæ•°æ®æ ¼å¼ï¼Œæˆ‘ä»¬å…ˆå°†NegativeNewså°è£…æˆä¸€ä¸ªç±»ï¼Œå…¶ä¸»è¦çš„å±æ€§å°±ä¸¤ä¸ªï¼šæ–°é—»çš„æ ‡é¢˜titleå’Œå¯¹åº”çš„urlã€‚å‰©ä¸‹çš„å°±æ˜¯å¸¸è§çš„æ„é€ å™¨ä»¥åŠgetã€setæ–¹æ³•ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.jinjin.news.controller; /** * @author æ–‡è¿› * @version 1.0 */ public class NegativeNews { private String title; private String url; public NegativeNews(String title, String url) { this.title = title; this.url = url; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } } è¿”å›JSONæ•°æ®æ ¼å¼å¯ä»¥é€‰æ‹©å¤šç§å½¢å¼ï¼Œè¿™é‡Œç”±äºè¦è¿”å›çš„æ–°é—»æœ‰å¤šæ¡ï¼Œå› æ­¤æˆ‘ä»¬è¿”å›ä¸€ä¸ªList\u0026lt;NegativeNews\u0026gt;ã€‚\nåœ¨è¿”å›JSONæ•°æ®æ ¼å¼æ–¹æ³•çš„å‰é¢åŠ ä¸Šæ³¨è§£@RequestMapping(\u0026quot;/negativeNews\u0026quot;)ï¼Œåœ¨è¯·æ±‚è¯¥é¡µé¢æ—¶ï¼Œå°±ä¼šæ‰§è¡Œå…¶ä¸­çš„ä»£ç ï¼Œå› æ­¤æˆ‘ä»¬å°†ä¸Šè¿°çˆ¬å–ç™¾åº¦æ–°é—»æ ‡é¢˜ï¼Œå‘æƒ…æ„Ÿè®¡ç®—APIå‘é€POSTè¯·æ±‚ï¼Œå¾—åˆ°è´Ÿé¢æ–°é—»ï¼Œç»¼åˆåˆ°è¯¥æ–¹æ³•ä¸­ä¸€èµ·æ‰§è¡Œã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package com.jinjin.news.controller; import com.sun.net.httpserver.HttpServer; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.io.IOException; import java.net.InetSocketAddress; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * @author æ–‡è¿› * @version 1.0 */ @RestController public class HttpServers { @RequestMapping(\u0026#34;/negativeNews\u0026#34;) public List\u0026lt;NegativeNews\u0026gt; returnJson( ) { // è·å–ç™¾åº¦æ–°é—»ä¸­çƒ­ç‚¹æ–°é—»çš„æ ‡é¢˜å’Œé“¾æ¥ HashMap\u0026lt;String, String\u0026gt; news = new News().getNews(\u0026#34;http://news.baidu.com/\u0026#34;); // è´Ÿé¢æ–°é—» HashMap\u0026lt;String, String\u0026gt; negativeNews = new HashMap\u0026lt;\u0026gt;(); // é€šè¿‡æ–°é—»æ ‡é¢˜å¾—åˆ°çš„æƒ…æ„Ÿå€¼ï¼Œå°†è´Ÿé¢æ–°é—»æ·»åŠ åˆ° negativeNews ä¸­ for (Map.Entry\u0026lt;String, String\u0026gt; entry : news.entrySet()) { // å¾—åˆ°æƒ…æ„ŸAPIè¿”å›çš„ç»“æœï¼Œä¾‹å¦‚ data = {\u0026#34;result\u0026#34;:0.739306} String data = UrlUtils.sendPost(\u0026#34;http://baobianapi.pullword.com:9091/get.php\u0026#34;, entry.getKey()); // æå–ç»“æœä¸­çš„åˆ†æ•°å€¼ data = {\u0026#34;result\u0026#34;: score} String score = data.substring(10, data.length() - 1); // å°†åˆ†æ•°å€¼ score è½¬æ¢æˆdoubleæ•°å€¼ï¼Œæ–¹ä¾¿æ‰¾åˆ°è´Ÿé¢æƒ…ç»ªçš„æ–°é—» double emotion = Double.parseDouble(score); // å°†è´Ÿé¢æ–°é—»æ·»åŠ åˆ° negativeNews ä¸­ if (emotion \u0026lt; -0.5) { negativeNews.put(entry.getKey(), entry.getValue()); } } // è¿”å› JSON æ•°æ®æ ¼å¼ List\u0026lt;NegativeNews\u0026gt; negativeNewsList = new ArrayList\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;String, String\u0026gt; entry : negativeNews.entrySet()) { NegativeNews nNews = new NegativeNews(entry.getKey(), entry.getValue()); negativeNewsList.add(nNews); } return negativeNewsList; } } éƒ¨ç½²åˆ°æœåŠ¡å™¨ éƒ¨ç½²åˆ°æœåŠ¡å™¨æœ‰ä¸¤ç§æ–¹å¼ï¼Œå‚è€ƒï¼š\nspring boot é¡¹ç›®éƒ¨ç½²åˆ°æœåŠ¡å™¨ ä¸¤ç§æ–¹å¼ SpringBoot é¡¹ç›®éƒ¨ç½²åˆ°æœåŠ¡å™¨çš„ä¸¤ç§æ–¹å¼ mavené¡¹ç›®æ‰“åŒ… æˆ‘ä»¬é€‰æ‹©æ‰“åŒ…æˆjaråŒ…ï¼Œå…¶ä¸­ï¼Œæœ‰å¯èƒ½é‡åˆ°å‘ç”Ÿä¸€äº›ç±»æ‰¾ä¸åˆ°çš„é”™è¯¯ï¼Œéœ€è¦å°†æœ¬åœ°jaråŒ…æ‰“åŒ…è¿›å»ï¼Œå‚è€ƒmavené¡¹ç›®å¼•å…¥æœ¬åœ°jaråŒ…å²ä¸Šæœ€è¯¦ç»†å®è·µæ–¹æ³•ã€‚\nè§£å†³å¦‚ä¸‹ç±»æ‰¾ä¸åˆ°çš„æƒ…å†µï¼š\n1 2 import com.sun.org.slf4j.internal.Logger; import com.sun.org.slf4j.internal.LoggerFactory; ç»è¿‡è·Ÿè¸ªï¼Œè¿™ä¸¤ä¸ªéƒ½åœ¨rt.jarç±»ä¸­ï¼Œç”¨å¼•å…¥æœ¬åœ°jaråŒ…çš„æ–¹æ³•è¿˜æ˜¯ä¸æˆåŠŸï¼Œæœ€ç»ˆå‚è€ƒIdeaæœ¬åœ°mavenæ‰“åŒ…ï¼Œç¨‹åºåŒ…ä¸å­˜åœ¨è§£å†³äº†ï¼Œå°†rt.jarå¤åˆ¶åˆ°jdk/jre/lib/extä¸­ã€‚\nå¼•å…¥org.jsonï¼Œä»ä¸­è·å–ç›¸åº”ç‰ˆæœ¬çš„ä¾èµ–ä»£ç ï¼Œæ·»åŠ åˆ°pom.xmlé…ç½®æ–‡ä»¶ä¸­ã€‚\n1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;!-- jsoup HTML parser library @ http://jsoup.org/ --\u0026gt; \u0026lt;groupId\u0026gt;org.jsoup\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsoup\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; æ·»åŠ åï¼Œåœ¨mavenä¸­æŒ‰åˆ·æ–°æŒ‰é’®ï¼Œå¦‚ä¸‹å›¾ï¼š\næ‰“åŒ…å¥½åç°åœ¨æœ¬åœ°æµ‹è¯•ä¸€ä¸‹ï¼Œç»ˆç«¯è¿›å…¥åˆ°jaræ‰€åœ¨çš„è·¯å¾„ï¼Œè¿è¡Œå¦‚ä¸‹ä»£ç ï¼š\n1 java -jar åŒ…å.jar Linuxä¸Šè¿è¡Œ å‚è€ƒåœ¨Linuxä¸Šè¿è¡Œspringbooté¡¹ç›®ã€‚\nä¸ºäº†è®©æœåŠ¡ç«¯å…³é—­SSHè¿æ¥åä¾ç„¶è¿è¡Œï¼Œè¿è¡Œæ—¶æ‰§è¡Œå¦‚ä¸‹å‘½ä»¤ï¼š\n1 nohup java -jar åŒ…å.jar \u0026amp; æ€æ‰è¿è¡Œä¸­çš„è¿›ç¨‹ï¼Œé¦–å…ˆæŸ¥çœ‹ï¼š\n1 ps aux|grep getCimiss-surf.jar æ¥ç€æ€æ‰è¿›ç¨‹ï¼š\n1 kill -9 30768 MacOSä¸ŠæŸ¥çœ‹å¯¹åº”ç«¯å£çš„è¿›ç¨‹ï¼š\n1 lsof -i tcp:ç«¯å£å· æ€æ‰å¯¹åº”è¿›ç¨‹ï¼š\n1 kill -9 PIDå· ä»£ç åŠå…¬ç½‘åœ°å€ è‡³æ­¤æ•´ä¸ªè¿‡ç¨‹å°±å®Œæˆäº†:)\nä»£ç ï¼šnegativeNews å…¬ç½‘åœ°å€ï¼šhttp://139.155.0.15/negativeNews å…¬ç½‘è¯·æ±‚è´Ÿé¢æ–°é—»æˆªå›¾ï¼š ","date":"2022-05-08T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/08/liangbo-negative-news/","title":"å‘ç°è´Ÿé¢æ–°é—»"},{"content":"æ»‘åŠ¨çª—å£ æ»‘åŠ¨çª—å£æ¨¡æ¿ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 int left = 0, right = 0; while (right \u0026lt; s.size()) { // å¢å¤§çª—å£ window.add(s[right]); right++; while (window needs shrink) { // ç¼©å°çª—å£ window.remove(s[left]); left++; } } 209.é•¿åº¦æœ€å°çš„å­æ•°ç»„ è¿™é“é¢˜HotStarä¸€é¢è€ƒåˆ°äº†ï¼Œç”¨æ»‘åŠ¨çª—å£è§£å†³ã€‚è¿™é‡Œå†™çš„æ˜¯å‰ç¼€å’Œæ•°ç»„å’Œæ»‘åŠ¨çª—å£æ¥è§£å†³ï¼Œ å…¶å®ä¹Ÿå¯ä»¥é™ä½ç©ºé—´å¤æ‚åº¦ï¼Œç›´æ¥ç”¨æ»‘åŠ¨çª—å£è§£å†³ï¼Œä¸€ä¸ªå˜é‡æ¥è®°å­æ•°ç»„çš„å’Œã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { // å‰ç¼€å’Œæ•°ç»„ + æ»‘åŠ¨çª—å£ public int minSubArrayLen(int target, int[] nums) { int[] preSum = new int[nums.length]; int sum = 0; for (int i = 0; i \u0026lt; nums.length; i++) { sum += nums[i]; preSum[i] = sum; } int left = 0, right = 0; int length = Integer.MAX_VALUE; while (left \u0026lt;= right \u0026amp;\u0026amp; right \u0026lt; nums.length) { while (right \u0026lt; nums.length \u0026amp;\u0026amp; preSum[right] - preSum[left] + nums[left] \u0026lt; target) { right++; } System.out.println(right); length = Math.min(length, right - left + 1); System.out.println(length); left++; } return preSum[nums.length - 1] \u0026lt; target ? 0 : length; } } 3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² ç›´æ¥ä¸Šä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { // æ»‘åŠ¨çª—å£ public int lengthOfLongestSubstring(String s) { if (s.length() == 0) return 0; int left = 0, right = 0; int length = 1; Set\u0026lt;Character\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); while (left \u0026lt;= right \u0026amp;\u0026amp; right \u0026lt; s.length()) { while (right \u0026lt; s.length() \u0026amp;\u0026amp; !set.contains(s.charAt(right))) { set.add(s.charAt(right)); right++; } // System.out.println(\u0026#34;left \u0026#34; + left + \u0026#34; right \u0026#34; + right); length = Math.max(length, right - left); set.remove(s.charAt(left)); left++; } return length; } } è¿™é‡Œå’Œæ¨¡æ¿æœ‰æ‰€åŒºåˆ«ï¼Œä¸è¿‡æ€è·¯éƒ½æ˜¯ä¸€æ ·çš„ã€‚è¿™é‡Œæ˜¯ä¸åœçš„åœ¨ç§»åŠ¨å³æŒ‡é’ˆï¼Œä¸€æ—¦ä¸æ»¡è¶³æ¡ä»¶ï¼Œå°±è°ƒèŠ‚å·¦æŒ‡é’ˆã€‚\n76.æœ€å°è¦†ç›–å­ä¸² è¿™é“é¢˜éœ€è¦å¥½å¥½æƒ³ä¸€ä¸‹ï¼Œä»€ä¹ˆæ—¶å€™æ”¶ç¼©çª—å£ï¼Œæˆ‘ä»¬çŸ¥é“è‚¯å®šæ˜¯çª—å£ä¸­å·²ç»åŒ…å«äº†æ•´ä¸ªå­—ç¬¦ä¸²tä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼Œä½†æ˜¯è¿™ä¸ªé€»è¾‘å¦‚ä½•å»å®ç°å‘¢ï¼Ÿä¸‹é¢å‡è®¾String s = \u0026quot;ADOBECODEBANC\u0026quot;ï¼ŒString t = \u0026quot;ABC\u0026quot;ã€‚\né¦–å…ˆæ ¹æ®å­—ç¬¦ä¸²tæ„é€ ä¸€ä¸ªå“ˆå¸Œè¡¨subStringMapã€‚ æ»‘åŠ¨çª—å£å†…çš„å“ˆå¸Œè¡¨è®°ä¸ºcurMapï¼Œä½†æ˜¯è¿™ä¸ªå“ˆå¸Œè¡¨ä¸å­˜å‚¨æ»‘åŠ¨çª—å£å†…æ‰€æœ‰çš„å­—ç¬¦å’Œç›¸åº”å‡ºç°çš„æ¬¡æ•°ï¼Œæˆ‘ä»¬åªå…³å¿ƒé‚£äº›åœ¨subStringMapä¸­åŒ…å«çš„å­—ç¬¦ã€‚ è®¾ç½®ä¸€ä¸ªå˜é‡validï¼Œè®°å½•çª—å£å†…çš„æœ‰æ•ˆå­—ç¬¦çš„ä¸ªæ•°ã€‚å¦‚æœå½“å‰çª—å£ä¸­Aå‡ºç°çš„æ¬¡æ•°è¾¾åˆ°äº†subStringMapä¸­Aå‡ºç°çš„æ¬¡æ•°ï¼Œvalid++ï¼Œä¹Ÿå°±æ˜¯æ»‘åŠ¨çª—å£å†…è¦†ç›–äº†å­—ç¬¦Aï¼Œè¿™ä¹Ÿæ˜¯ä¸ºäº†åé¢å¥½åˆ¤æ–­çª—å£æ”¶ç¼©æ¡ä»¶ï¼Œä¹Ÿå°±æ˜¯valid == subStringMap.size()ï¼Œæ»¡è¶³è¿™ä¸ªæ¡ä»¶è¯´æ˜æ»‘åŠ¨çª—å£å†…åˆšå¥½è¦†ç›–äº†å­ä¸²ã€‚è¿™ä¸€æ­¥æ€è·¯æœ€ä¸ºå…³é”®ã€‚ çª—å£æ”¶ç¼©åï¼Œæ›´æ–°ç›¸åº”å˜é‡çš„å€¼ï¼ŒcurMapè¦å˜ï¼Œvalidä¹Ÿéœ€è¦æ›´æ–°ã€‚ æœ€åä¸ºäº†è¿”å›æœ€å°çš„è¦†ç›–å­ä¸²ï¼Œç”¨lenå’Œstartä¸¤ä¸ªå˜é‡æ¥è®°å½•ç»“æœã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { // æ»‘åŠ¨çª—å£ public String minWindow(String s, String t) { if (t.length() \u0026gt; s.length()) return \u0026#34;\u0026#34;; HashMap\u0026lt;Character, Integer\u0026gt; subStringMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; t.length(); i++) { subStringMap.put(t.charAt(i), subStringMap.getOrDefault(t.charAt(i), 0) + 1); } HashMap\u0026lt;Character, Integer\u0026gt; curMap = new HashMap\u0026lt;\u0026gt;(); int left = 0, right = 0; int valid = 0; int start = 0, len = Integer.MAX_VALUE; while (right \u0026lt; s.length()) { char c = s.charAt(right); right++; if (subStringMap.containsKey(c)) { curMap.put(c, curMap.getOrDefault(c, 0) + 1); if (curMap.get(c).equals(subStringMap.get(c))) { valid++; } } while (valid == subStringMap.size()) { // æ›´æ–°æœ€å°å­—ç¬¦ä¸² if (right - left \u0026lt; len) { start = left; len = right - left; } char d = s.charAt(left); left++; if (subStringMap.containsKey(d)) { if (subStringMap.get(d).equals(curMap.get(d))) { valid--; } curMap.put(d, curMap.getOrDefault(d, 0) - 1); } } } return len == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(start, start + len); } } å‚è€ƒèµ„æ–™ æˆ‘å†™äº†é¦–è¯—ï¼ŒæŠŠæ»‘åŠ¨çª—å£ç®—æ³•ç®—æ³•å˜æˆäº†é»˜å†™é¢˜ ","date":"2022-05-07T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/07/Algorithms-sliding-window/","title":"æ»‘åŠ¨çª—å£ç›¸å…³ç®—æ³•"},{"content":"JDK 1.7 æ„é€ æ–¹æ³• 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { // æ£€æŸ¥è¾“å…¥å‚æ•°çš„åˆæ³•æ€§ if (!(loadFactor \u0026gt; 0) || initialCapacity \u0026lt; 0 || concurrencyLevel \u0026lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel \u0026gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // MAX_SEGMENTS = 1 \u0026lt;\u0026lt; 16, å³ 2 ^ 16 // Find power-of-two sizes best matching arguments // sshift æ˜¯ ssize ä» 1 å‘å·¦ç§»ä½çš„æ¬¡æ•° int sshift = 0; // segments çš„é•¿åº¦ï¼Œæ˜¯ 2 çš„ N æ¬¡æ–¹ int ssize = 1; // è®¡ç®—å‡ºä¸€ä¸ªå¤§äºç­‰äº concurrencyLevel çš„æœ€å°çš„ 2 çš„ N æ¬¡æ–¹çš„å€¼ä½œä¸º segments çš„é•¿åº¦ while (ssize \u0026lt; concurrencyLevel) { ++sshift; ssize \u0026lt;\u0026lt;= 1; } // segmentShift ç”¨äºå®šä½å‚ä¸æ•£åˆ—è¿ç®—çš„ä½æ•° this.segmentShift = 32 - sshift; // æ•£åˆ—è¿ç®—çš„æ©ç  this.segmentMask = ssize - 1; if (initialCapacity \u0026gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; /* cap æ˜¯ segment é‡Œ HashEntry æ•°ç»„çš„é•¿åº¦ï¼Œ cap ç­‰äº initialCapacity é™¤ä»¥ sszie çš„å€æ•° c ï¼Œ å¦‚æœ c å¤§äº 2ï¼Œå°±ä¼šå–å¤§äºç­‰äº c çš„ 2 çš„ N æ¬¡æ–¹å€¼ï¼Œ æ‰€ä»¥ cap ä¸æ˜¯ 2ï¼Œå°±æ˜¯ 2 çš„ N æ¬¡æ–¹ã€‚ */ int c = initialCapacity / ssize; if (c * ssize \u0026lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; // MIN_SEGMENT_TABLE_CAPACITY = 2 while (cap \u0026lt; c) cap \u0026lt;\u0026lt;= 1; // create segments and segments[0] Segment\u0026lt;K,V\u0026gt; s0 = new Segment\u0026lt;K,V\u0026gt;(loadFactor, (int)(cap * loadFactor), (HashEntry\u0026lt;K,V\u0026gt;[])new HashEntry[cap]); Segment\u0026lt;K,V\u0026gt;[] ss = (Segment\u0026lt;K,V\u0026gt;[])new Segment[ssize]; // æŠŠ s0 å­˜åˆ° Segment æ•°ç»„ä¸­ï¼Œä»…ä»…åˆ›å»ºäº†ä¸€ä¸ª Segment ç”¨æ¥ä½œåŸå‹å¯¹è±¡ã€‚ UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; } put()æ–¹æ³• 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Map çš„ put æ–¹æ³• public V put(K key, V value) { Segment\u0026lt;K,V\u0026gt; s; // value ä¸èƒ½ä¸ºç©º if (value == null) throw new NullPointerException(); // è®¡ç®— hash å€¼ int hash = hash(key); /* j ä¸º Segment ä¸­çš„ä¸‹æ ‡ é»˜è®¤æƒ…å†µä¸‹ segmentShift ä¸º 28ï¼ŒsegmentMask ä¸º 15 hash \u0026gt;\u0026gt;\u0026gt; segmentShift å‘å³æ— ç¬¦å·ç§»åŠ¨ 28 ä½ï¼Œæ„æ€æ˜¯è®©é«˜ 4 ä½å‚ä¸åˆ°æ•£åˆ—è¿ç®—ä¸­ ç„¶åå’Œæ©ç  segmentMask åšä¸è¿ç®—ï¼Œå¾—åˆ°çš„å€¼ä¸€å®šæ˜¯ 0000 ï½ 1111 èŒƒå›´å†…çš„å€¼ï¼Œå³ 0 ï½ 15 */ int j = (hash \u0026gt;\u0026gt;\u0026gt; segmentShift) \u0026amp; segmentMask; if ((s = (Segment\u0026lt;K,V\u0026gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j \u0026lt;\u0026lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false); } è¡¥å……ä¸Šè¿°æºç ä¸­çš„å³ç§»ä¸æ— ç¬¦å·å³ç§»çš„åŒºåˆ«ï¼š\nå³ç§»\u0026raquo; ï¼šè¯¥æ•°å¯¹åº”çš„äºŒè¿›åˆ¶ç æ•´ä½“å³ç§»ï¼Œå·¦è¾¹çš„ç”¨åŸæœ‰æ ‡å¿—ä½è¡¥å……ï¼Œå³è¾¹è¶…å‡ºçš„éƒ¨åˆ†èˆå¼ƒã€‚ æ— ç¬¦å·å³ç§»\u0026raquo;\u0026gt; ï¼šä¸ç®¡æ­£è´Ÿæ ‡å¿—ä½ä¸º0è¿˜æ˜¯1ï¼Œå°†è¯¥æ•°çš„äºŒè¿›åˆ¶ç æ•´ä½“å³ç§»ï¼Œå·¦è¾¹éƒ¨åˆ†æ€»æ˜¯ä»¥0å¡«å……ï¼Œå³è¾¹éƒ¨åˆ†èˆå¼ƒã€‚ åœ¨ä¸Šè¿°put()æ–¹æ³•ä¸­ï¼Œhashæ–¹æ³•ä¸ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private int hash(Object k) { /* A randomizing value associated with this instance that is applied to hash code of keys to make hash collisions harder to find. private transient final int hashSeed = randomHashSeed(this); */ int h = hashSeed; if ((0 != h) \u0026amp;\u0026amp; (k instanceof String)) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h \u0026lt;\u0026lt; 15) ^ 0xffffcd7d; h ^= (h \u0026gt;\u0026gt;\u0026gt; 10); h += (h \u0026lt;\u0026lt; 3); h ^= (h \u0026gt;\u0026gt;\u0026gt; 6); h += (h \u0026lt;\u0026lt; 2) + (h \u0026lt;\u0026lt; 14); return h ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } å†æ•£åˆ—çš„ç›®çš„æ˜¯å‡å°‘æ•£åˆ—å†²çªï¼Œä½¿å…ƒç´ èƒ½å¤Ÿå‡åŒ€åœ°åˆ†å¸ƒåœ¨ä¸åŒçš„Segmentä¸­ï¼Œä»è€Œæé«˜å®¹å™¨çš„å­˜å–æ•ˆç‡ã€‚\nSegmentä¸­çš„putæ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // Segment ä¸­çš„ put æ–¹æ³• final V put(K key, int hash, V value, boolean onlyIfAbsent) { HashEntry\u0026lt;K,V\u0026gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { HashEntry\u0026lt;K,V\u0026gt;[] tab = table; int index = (tab.length - 1) \u0026amp; hash; HashEntry\u0026lt;K,V\u0026gt; first = entryAt(tab, index); for (HashEntry\u0026lt;K,V\u0026gt; e = first;;) { if (e != null) { K k; if ((k = e.key) == key || (e.hash == hash \u0026amp;\u0026amp; key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { if (node != null) node.setNext(first); else node = new HashEntry\u0026lt;K,V\u0026gt;(hash, key, value, first); int c = count + 1; if (c \u0026gt; threshold \u0026amp;\u0026amp; tab.length \u0026lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { unlock(); } return oldValue; } å‚è€ƒèµ„æ–™ æˆ‘å°±çŸ¥é“é¢è¯•å®˜æ¥ä¸‹æ¥è¦é—®æˆ‘ ConcurrentHashMap åº•å±‚åŸç†äº† javaä¸­å³ç§»è¿ç®—ç¬¦\u0026raquo;å’Œæ— ç¬¦å·å³ç§»è¿ç®—ç¬¦\u0026raquo;\u0026gt;çš„åŒºåˆ« ","date":"2022-05-06T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/06/ConcurrentHashMap/","title":"ConcurrentHashMapæºç åˆ†æ"},{"content":"é¢è¯•é—®é¢˜ï¼š\nè‡ªæˆ‘ä»‹ç» æ•°å­¦ä¸“ä¸šä¸ºä»€ä¹ˆè½¬è®¡ç®—æœºï¼Ÿ æœ¬ç§‘ä¸“ä¸šæ˜¯åº”ç”¨æ•°å­¦ï¼Œä¸ºä»€ä¹ˆæœ‰è®¡ç®—æœºç›¸å…³è¯¾ç¨‹ã€‚ ç”¨è¿‡MySQLå—ï¼Ÿç†Ÿæ‚‰äº‹åŠ¡å—ï¼Ÿ è¿™ä¸ªæˆ‘æ²¡ç­”ä¸Šæ¥ï¼Œä¸å¤ªä¼šã€‚ å¯¹SpringBootäº†è§£å—ï¼Ÿ å‘œå‘œå‘œï¼Œè¿˜æ²¡å­¦åˆ°é‚£é‡Œã€‚ è®²ä¸‹HashMapã€‚ å¯¹è®¡ç®—æœºç½‘ç»œçš„äº†è§£ã€‚ TCPå’ŒUDPçš„åŒºåˆ«ã€‚ ä¸‹é¢å°±æ˜¯å‘ä¸ªé“¾æ¥å¼€å§‹å†™ä»£ç ï¼Œé¢˜ç›®æ˜¯209.é•¿åº¦æœ€å°çš„å­æ•°ç»„ã€‚\næˆ‘å¼€å§‹æƒ³åˆ°å­æ•°ç»„æ±‚å’Œï¼Œå°±è¦ç”¨åˆ°å‰ç¼€å’Œæ•°ç»„ï¼Œç„¶åç”¨åŒæŒ‡é’ˆæ¥éå†ï¼Œä½†æ˜¯åŒæŒ‡é’ˆéå†é€»è¾‘æœ‰é—®é¢˜ã€‚é¢è¯•å®˜æé†’äº†ç”¨æ»‘åŠ¨çª—å£ï¼Œè®²äº†ä¸‹å®ç°çš„é€»è¾‘ï¼Œç„¶åè®©æˆ‘å®ç°ï¼Œå®ç°çš„æ—¶å€™è¿˜å‡ºé”™äº†ï¼ŒæŠ¥ä¸‹æ ‡è¶Šç•Œé”™è¯¯ï¼Œæ˜¯åˆ¤æ–­ä½ç½®åŠ é”™äº†ã€‚æœ€ååŠ äº†ä¸€ä¸ªç‰¹åˆ¤ï¼Œå°±ç»“æŸäº†ã€‚å†™å®Œåé—®äº†å¤æ‚åº¦ã€‚\nå†™ä»£ç è¿™å—å¤§æ¦‚èŠ±äº†ä¸€ä¸ªå¤šå°æ—¶ï¼Œæ˜¯æˆ‘å¤ªèœäº†ã€‚ä¸‹é¢å°±æ˜¯åé—®ç¯èŠ‚ã€‚\næˆ‘é—®äº†åœ¨ç¼–ç¨‹ä¸­ä¼šç”¨åˆ°å“ªäº›æ•°å­¦çŸ¥è¯†å—ï¼Ÿé¢è¯•å®˜è¯´è¿™è¾¹æ ¸å¿ƒä»£ç åŸºæœ¬å¼€å‘å®Œäº†ï¼Œå¦‚æœåé¢æƒ³è¦æ·±å…¥äº†è§£ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œå¯¹ä»£ç ç†è§£è¿˜æ˜¯æœ‰å¸®åŠ©çš„ã€‚\né—®äº†å¯¹Hotstarçš„äº†è§£ï¼Œå“ˆå“ˆï¼Œæˆ‘äº†è§£çš„ä¸å¤šã€‚é¢è¯•å®˜å°±ä»‹ç»äº†ä¸‹ã€‚\né¢è¯•ä½“éªŒè¶…æ£’ï¼Œé¢è¯•å®˜é—®é—®é¢˜æ„Ÿè§‰å¾ˆæ¸©æŸ”ï¼Œç®—æ³•é¢˜ä¹Ÿä¼šå¼•å¯¼ã€‚\nå‘œå‘œå‘œï¼Œæ”¶åˆ°äº†æ„Ÿè°¢ä¿¡:(\né©å‘½å°šæœªæˆåŠŸï¼ŒåŒå¿—ä»éœ€åŠªåŠ›ï¼\n","date":"2022-05-06T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/06/interview-hotstar1/","title":"Hotstarä¸€é¢"},{"content":"å›¾çš„éå† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // è®°å½•è¢«éå†è¿‡çš„èŠ‚ç‚¹ boolean[] visited; // è®°å½•ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„ boolean[] onPath; /* å›¾éå†æ¡†æ¶ */ void traverse(Graph graph, int s) { if (visited[s]) return; // ç»è¿‡èŠ‚ç‚¹ sï¼Œæ ‡è®°ä¸ºå·²éå† visited[s] = true; // åšé€‰æ‹©ï¼šæ ‡è®°èŠ‚ç‚¹ s åœ¨è·¯å¾„ä¸Š onPath[s] = true; for (int neighbor : graph.neighbors(s)) { traverse(graph, neighbor); } // æ’¤é”€é€‰æ‹©ï¼šèŠ‚ç‚¹ s ç¦»å¼€è·¯å¾„ onPath[s] = false; } å›¾ä¸­åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¯ 207.è¯¾ç¨‹è¡¨ é¦–å…ˆå°†è¯¾ç¨‹è¡¨çš„ä¾èµ–å…³ç³»è½¬æ¢ä¸ºå›¾ï¼Œæ¥ç€å¦‚æœå›¾ä¸­å­˜åœ¨ç¯ï¼Œå°±è¿”å›falseï¼Œå¦åˆ™è¿”å›trueã€‚\næ·±åº¦ä¼˜å…ˆæœç´¢æ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { onPath = new boolean[numCourses]; visited = new boolean[numCourses]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); for (int i = 0; i \u0026lt; numCourses; i++) { traverse(graph, i); } return !hasCycle; } boolean[] onPath; // è®°å½•è·¯å¾„ boolean[] visited; // è®°å½•è®¿é—®çš„èŠ‚ç‚¹ boolean hasCycle; // å›¾ä¸­æ˜¯å¦æœ‰ç¯ // å›æº¯ï¼Œæ·±åº¦ä¼˜å…ˆæœç´¢ private void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; } if (hasCycle || visited[s]) { // å·²ç»æ‰¾åˆ°ç¯æˆ–è€…å·²ç»éå†è¿‡äº† return; } // å‰åºä»£ç ä½ç½® onPath[s] = true; visited[s] = true; for (int t : graph[s]) { traverse(graph, t); } // ååºä»£ç ä½ç½® onPath[s] = false; } // å»ºå›¾ private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new List[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; // ä¿®å®Œ edge[1] è¯¾ç¨‹åæ‰èƒ½ä¿® edge[0] graph[from].add(to); } return graph; } } æ—¶é—´å¤æ‚åº¦ï¼š$O(n+m)$ï¼Œ$n$ä¸ºè¯¾ç¨‹æ•°ï¼Œ$m$ä¸ºå…ˆä¿®è¯¾ç¨‹çš„è¦æ±‚æ•°ã€‚\nç©ºé—´å¤æ‚åº¦ï¼š$O(n+m)$ã€‚\nå¹¿åº¦ä¼˜å…ˆæœç´¢æ–¹æ³•ï¼Œé¦–å…ˆè¦å»ºç«‹ä¸€ä¸ªå…¥åº¦çš„æ•°ç»„ï¼Œå¦‚æœå…¥åº¦ä¸º0å°±åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ï¼Œæ¥ç€å¹¿åº¦æœç´¢æœ‰ä¾èµ–çš„èŠ‚ç‚¹ï¼Œå¹¶å°†è¿™äº›èŠ‚ç‚¹çš„å…¥åº¦å‡ä¸€ï¼Œå¦‚æœæœ€åéå†çš„èŠ‚ç‚¹ä¸ªæ•°ä¸numCoursesç›¸åŒï¼Œåˆ™è¯´æ˜æ²¡æœ‰å½¢æˆç¯ã€‚å› ä¸ºå¦‚æœå½¢æˆç¯çš„è¯ï¼Œç¯ä¸­çš„èŠ‚ç‚¹çš„å…¥åº¦ä¸ä¼šå‡å°‘åˆ°0ï¼Œè‚¯å®šä¸ä¼šåŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ï¼Œä¹Ÿå°±ä¸ä¼šéå†åˆ°ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // æ–¹æ³•äºŒï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢ public boolean canFinish(int numCourses, int[][] prerequisites) { // å»ºå›¾ List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); // æ„å»ºå…¥åº¦æ•°ç»„ int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; // èŠ‚ç‚¹ to çš„å…¥åº¦åŠ ä¸€ indegree[to]++; } // æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ— Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { // å¦‚æœå…¥åº¦ä¸º0ï¼Œåˆ™åŠ å…¥é˜Ÿåˆ— q.offer(i); } } int count = 0; // è®°å½•éå†çš„èŠ‚ç‚¹çš„ä¸ªæ•° while (!q.isEmpty()) { // å¼¹å‡ºèŠ‚ç‚¹å¹¶å°†å®ƒæŒ‡å‘çš„èŠ‚ç‚¹çš„å…¥åº¦å‡ä¸€ int cur = q.poll(); count++; for (int next : graph[cur]) { indegree[next]--; // å¦‚æœå…¥åº¦ä¸º0ï¼Œåˆ™åŠ å…¥é˜Ÿåˆ—ä¸­ if (indegree[next] == 0) { q.offer(next); } } } // å¦‚æœæ‰€æœ‰èŠ‚ç‚¹éƒ½éå†è¿‡ï¼Œåˆ™è¯´æ˜æ²¡æœ‰å½¢æˆç¯ return count == numCourses; } æ‹“æ‰‘æ’åº 210.è¯¾ç¨‹è¡¨II æ‹“æ‰‘æ’åºå°±æ˜¯åè½¬ååºéå†çš„ç»“æœã€‚æ³¨æ„è¿™é‡Œçš„ä¾èµ–å…³ç³»ä¾ç„¶æ˜¯å…ˆä¿®å®Œedge[1]è¯¾ç¨‹å†ä¿®edge[0]è¯¾ç¨‹ï¼Œå›¾ä¸­edge[1] -\u0026gt; edge[0]ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { onPath = new boolean[numCourses]; visited = new boolean[numCourses]; List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); for (int i = 0; i \u0026lt; numCourses; i++) { traverse(graph, i); } if (hasCycle) { // å¦‚æœå­˜åœ¨ç¯ return new int[]{}; } // é€†ååºéå†çš„ç»“æœå°±æ˜¯æ‹“æ‰‘æ’åºçš„ç»“æœ Collections.reverse(postorder); // è¿™é‡Œç›´æ¥è°ƒç”¨Collectionsçš„æ¥å£ int[] res = new int[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { res[i] = postorder.get(i); } return res; } boolean[] onPath; boolean[] visited; boolean hasCycle; List\u0026lt;Integer\u0026gt; postorder = new ArrayList\u0026lt;\u0026gt;(); void traverse(List\u0026lt;Integer\u0026gt;[] graph, int s) { if (onPath[s]) { hasCycle = true; } if (visited[s] || hasCycle) { return; } // å‰åºéå†ä½ç½® visited[s] = true; onPath[s] = true; for (int t : graph[s]) { traverse(graph, t); } // ååºéå†ä½ç½® postorder.add(s); onPath[s] = false; } // å»ºå›¾å‡½æ•° private List\u0026lt;Integer\u0026gt;[] buildGraph(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = new LinkedList[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; // å…ˆä¿® edge[1] å†ä¿® edge[0] graph[from].add(to); } return graph; } } å¹¿åº¦ä¼˜å…ˆæœç´¢æ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // æ–¹æ³•äºŒï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢ public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;Integer\u0026gt;[] graph = buildGraph(numCourses, prerequisites); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { int from = edge[1], to = edge[0]; indegree[to]++; } // æ ¹æ®å…¥åº¦æ•°ç»„åˆå§‹åŒ–é˜Ÿåˆ— Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { q.offer(i); } } // å¹¿åº¦ä¼˜å…ˆæœç´¢ int count = 0; // è®°å½•éå†çš„æ¬¡æ•° int[] res = new int[numCourses]; // è®°å½•ç»“æœ while (!q.isEmpty()) { int cur = q.poll(); res[count] = cur; count++; for (int next : graph[cur]) { indegree[next]--; if (indegree[next] == 0) { q.offer(next); } } } // å¦‚æœå­˜åœ¨ç¯å°±è¿”å›ç©ºæ•°ç»„ return count == numCourses ? res : new int[]{}; } å‰‘æŒ‡ Offer II 115. é‡å»ºåºåˆ— è¿™é“é¢˜çš„å…³é”®ç‚¹æ˜¯å¦‚ä½•ä¿è¯é‡å»ºåºåˆ—çš„å”¯ä¸€æ€§ï¼Œå…¶å®å°±æ˜¯åˆ¤æ–­q.size() == 1ï¼Œä¹Ÿå°±æ˜¯é˜Ÿåˆ—çš„å¤§å°æ˜¯å¦ä¸º1ã€‚\nè¿˜æœ‰ä¸€ç‚¹ç»†èŠ‚éœ€è¦æ³¨æ„ï¼Œé‚£å°±æ˜¯å…ˆè¦ä¿è¯é‡å»ºåºåˆ—é›†ä¸­çš„å…ƒç´ ä¸º{1,...,n}ï¼Œè¿™é‡Œç”¨Seté›†åˆæ¥åˆ¤æ–­ã€‚\nå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Solution { public boolean sequenceReconstruction(int[] org, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; seqs) { // ä¿è¯é‡å»ºåºåˆ—é›†çš„å®Œæ•´æ€§ï¼Œå³é‡å»ºåºåˆ—ä¸­å…ƒç´ èƒ½æ˜¯ {1,...,n} Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (List\u0026lt;Integer\u0026gt; list : seqs) { for (int ele : list) { set.add(ele); } } // å¦‚æœsetä¸­å…ƒç´ ä¸å¤Ÿï¼Œè¿”å› false if (set.size() != org.length) return false; // å¦‚æœå…ƒç´ ä¸åŒ¹é…ï¼Œè¿”å› false for (int i = 1; i \u0026lt;= org.length; i++) { if (!set.contains(i)) { return false; } } List\u0026lt;Integer\u0026gt;[] graph = buildGraph(org, seqs); // åˆå§‹åŒ–é˜Ÿåˆ— Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt; indegree.length; i++) { if (indegree[i] == 0) { q.offer(i); } } int count = 0; int[] res = new int[org.length]; while (!q.isEmpty()) { // ä¿è¯å”¯ä¸€æ€§ if (q.size() \u0026gt; 1) return false; int cur = q.poll(); res[count] = cur; // è®°å½•æ‹“æ‰‘æ’åºç»“æœ count++; int nextCount = 0; for (int next : graph[cur]) { indegree[next]--; if (indegree[next] == 0) { q.offer(next); } } } // å‡ºç°ç¯çš„æƒ…å†µ if (count != org.length) return false; // æ¯”è¾ƒæ¯ä¸€ä¸ªå…ƒç´  for (int i = 0; i \u0026lt; org.length; i++) { if (org[i] != res[i]) return false; } return true; } // å»ºå›¾ int[] indegree; // å…¥åº¦æ•°ç»„ private List\u0026lt;Integer\u0026gt;[] buildGraph(int[] org, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; seqs) { List\u0026lt;Integer\u0026gt;[] graph = new LinkedList[org.length + 1]; indegree = new int[org.length + 1]; for (int i = 0; i \u0026lt;= org.length; i++) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (List\u0026lt;Integer\u0026gt; ele : seqs) { if (ele.size() \u0026lt; 2) continue; for (int i = 1; i \u0026lt; ele.size(); i++) { int from = ele.get(i - 1), to = ele.get(i); graph[from].add(to); indegree[to]++; } } return graph; } } å‚è€ƒèµ„æ–™ labuladongçš„ç®—æ³•å°æŠ„ ","date":"2022-05-06T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/06/Algorithms-graph/","title":"å›¾ç›¸å…³ç®—æ³•"},{"content":"ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  å•è°ƒæ ˆçš„ä¸€ä¸ªåº”ç”¨æ˜¯æ±‚ä¸‹ä¸€ä¸ªæ›´å¤§çš„å…ƒç´ ã€‚å…¶ä¸­ç”¨åˆ°çš„è¾ƒå¤šçš„æ˜¯æ¥å£Dequeï¼Œç±»å›¾ç»“æ„å¦‚ä¸‹ï¼š 496.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ I 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { // å•è°ƒæ ˆ + å“ˆå¸Œè¡¨ public int[] nextGreaterElement(int[] nums1, int[] nums2) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // æ–¹ä¾¿è¿”å›ç­”æ¡ˆ // Deque æ˜¯åŒç«¯é˜Ÿåˆ— Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); // é€†åºéå†æ•°ç»„ for (int i = nums2.length - 1; i \u0026gt;= 0; i--) { // å¦‚æœæ ˆä¸ä¸ºç©ºï¼Œå¹¶ä¸”å½“å‰çš„å€¼æ¯”æ ˆé¡¶å…ƒç´ å¤§ï¼Œåˆ™æŠ›å‡ºæ ˆé¡¶å…ƒç´ ï¼Œå› ä¸ºä¸å¯èƒ½æ˜¯ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  // ç›´åˆ°æ ˆä¸ºç©ºæˆ–è€…æ‰¾åˆ°ä¸‹ä¸€ä¸ªæ›´å¤§çš„å…ƒç´  while (!stack.isEmpty() \u0026amp;\u0026amp; nums2[i] \u0026gt;= stack.peek()) { stack.pop(); } // å­˜å‚¨å½“å‰æ•°çš„ä¸‹ä¸€ä¸ªæœ€å¤§å…ƒç´ ï¼Œæ•°ç»„ä¸­æ²¡æœ‰é‡å¤å…ƒç´ ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨HashMap map.put(nums2[i], stack.isEmpty() ? -1 : stack.peek()); // å‘æ ˆä¸­æ·»åŠ å½“å‰å…ƒç´  stack.push(nums2[i]); } int[] ans = new int[nums1.length]; for (int i = 0; i \u0026lt; nums1.length; i++) { ans[i] = map.get(nums1[i]); } return ans; } } 503.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ II è¿™é‡Œè¦æ±‚çš„æ˜¯å¾ªç¯æ•°ç»„ï¼Œå¯ä»¥è½¬æ¢ä¸ºä¸Šä¸€é¢˜ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º 2 * n çš„æ•°ç»„ç”¨ä¸Šä¸€é¢˜çš„æ–¹æ³•ï¼Œå®é™…ä¸Šå¯ä»¥é€šè¿‡æŒ‡æ ‡å–æ¨¡æ¥è¾¾åˆ°è¿™ä¸ªæ•ˆæœã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { // å•è°ƒæ ˆ + å¾ªç¯æ•°ç»„ public int[] nextGreaterElements(int[] nums) { int n = nums.length; int[] res = new int[n]; Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); // ç”¨æŒ‡æ ‡å–æ¨¡æ¥æ¨¡æ‹Ÿæœ‰ 2 * n é•¿åº¦çš„æ•°ç»„[0, ... , n - 1, 0, ... , n - 1] for (int i = 2 * n - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; nums[i % n] \u0026gt;= stack.peek()) { stack.pop(); } res[i % n] = (stack.isEmpty() ? -1 : stack.peek()); stack.push(nums[i % n]); } return res; } } 739.æ¯æ—¥æ¸©åº¦ è¿™é“é¢˜ä¾ç„¶æ˜¯ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ çš„å˜å½¢ï¼Œæ¢æ±¤ä¸æ¢è¯ï¼Œæ ˆä¸­å­˜æ”¾çš„æ˜¯æ•°ç»„çš„ä¸‹æ ‡ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { // å•è°ƒæ ˆ public int[] dailyTemperatures(int[] temperatures) { int[] ans = new int[temperatures.length]; // ä¸ºäº†è¿”å›å¤©æ•°ï¼Œæ ˆä¸­å­˜æ”¾çš„æ˜¯æ•°ç»„çš„ä¸‹æ ‡ Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); for (int i = temperatures.length - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[i] \u0026gt;= temperatures[stack.peek()]) { stack.pop(); } ans[i] = stack.isEmpty() ? 0 : (stack.peek() - i); stack.push(i); } return ans; } } 42.æ¥é›¨æ°´ æ€è·¯æ˜¯ï¼šåˆ©ç”¨å•è°ƒæ ˆï¼Œæ ˆä¸­çš„å…ƒç´ æŒ‰é«˜åº¦é€’å‡ï¼Œå¦‚æœæ ˆä¸­è‡³å°‘æœ‰ä¸¤ä¸ªå…ƒç´ ï¼Œè¯´æ˜é«˜åº¦åœ¨ä¸‹é™ï¼Œè€Œå¦‚æœå½“å‰å…ƒç´ çš„é«˜åº¦æ¯”è¾ƒé«˜ï¼Œé‚£ä¹ˆå°±å¯ä»¥å½¢æˆä¸€ä¸ªæ´¼åœ°ï¼Œèƒ½å¤Ÿæ¥é›¨æ°´ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { // å•è°ƒæ ˆ public int trap(int[] height) { int ans = 0; Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); int n = height.length; for (int i = 0; i \u0026lt; n; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; height[i] \u0026gt; height[stack.peek()]) { int top = stack.pop(); if (stack.isEmpty()) { break; } // å¦‚æœæ ˆä¸­å­˜åœ¨è‡³å°‘ä¸¤ä¸ªå…ƒç´ ï¼Œå½“å‰çš„å€¼æ¯”è¾ƒé«˜ï¼Œé‚£ä¹ˆå¯ä»¥å½¢æˆä¸€ä¸ªæ´¼åœ°ï¼Œå¯ä»¥æ¥é›¨æ°´ int left = stack.peek(); int currWidth = i - left - 1; int currHeight = Math.min(height[left] - height[top], height[i] - height[top]); ans += currWidth * currHeight; } stack.push(i); } return ans; } } ","date":"2022-05-01T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/05/01/monotonic-stack/","title":"å•è°ƒæ ˆç›¸å…³é¢˜ç›®"},{"content":"å‚è€ƒåå¤§ç»å…¸æ’åºç®—æ³•ã€‚\nå†’æ³¡æ’åº 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class BubbleSort { public int[] sort(int[] sourceArray) { // å¯¹ arr è¿›è¡Œæ‹·è´ï¼Œä¸æ”¹å˜å‚æ•°å†…å®¹ int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i \u0026lt; arr.length; i++) { // è®¾å®šä¸€ä¸ªæ ‡è®°ï¼Œè‹¥ä¸º trueï¼Œåˆ™è¡¨ç¤ºæ­¤æ¬¡å¾ªç¯æ²¡æœ‰è¿›è¡Œäº¤æ¢ï¼Œä¹Ÿå°±æ˜¯å¾…æ’åºåˆ—å·²ç»æœ‰åºï¼Œæ’åºå·²ç»å®Œæˆ boolean flag = true; for (int j = 0; j \u0026lt; arr.length - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; } } if (flag) { break; } } return arr; } } é€‰æ‹©æ’åº 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Selection { public static void sort(Comparable[] a) { // å°† a[] æŒ‰å‡åºæ’åˆ— int N = a.length; for (int i = 0; i \u0026lt; N; i++) { // å°† a[i] å’Œ a[i + 1 ... N] ä¸­æœ€å°çš„å…ƒç´ äº¤æ¢ int min = i; // æœ€å°å…ƒç´ çš„ç´¢å¼• for (int j = i + 1; j \u0026lt; N; j++) { if (less(a[j], a[min])) min = j; // æ‰¾åˆ°a[i+1,...,N]ä¸­æœ€å°çš„å…ƒç´  } exch(a, i, min); } } } æ’å…¥æ’åº 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Insertion { public static void sort(Comparable[] a) { // å°† a[] æŒ‰å‡åºæ’åˆ— int N = a.length; for (int i = 1; i \u0026lt; N; i++) { // å°† a[i] æ’å…¥åˆ° a[i - 1]ã€a[i - 2]ã€a[i - 3]...ä¹‹ä¸­ // less(a[j], a[j - 1])ï¼Œæ˜¯å¦‚æœ a[j] æ¯” a[j - 1] å° for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); } } } } å¸Œå°”æ’åº å¸Œå°”æ’åºçš„æ€æƒ³æ˜¯ä½¿æ•°ç»„ä¸­ä»»æ„é—´éš” h çš„å…ƒç´ éƒ½æ˜¯æœ‰åºçš„ã€‚å¸Œå°”æ’åºæ›´é«˜æ•ˆçš„åŸå› æ˜¯å®ƒæƒè¡¡äº†å­æ•°ç»„çš„è§„æ¨¡å’Œæœ‰åºæ€§ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Shell { public static void sort(Comparable[] a) { // å°† a[] æŒ‰å‡åºæ’åˆ— int N = a.length; int h = 1; while (h \u0026lt; N/3) h = 3 * h + 1; // 1, 4, 13, 40, 121, 364, 1093, ... while (h \u0026gt;= 1) { // å°†æ•°ç»„å˜ä¸º h æœ‰åº for (int i = h; i \u0026lt; N; i++) { // å°† a[i] æ’å…¥åˆ° a[i - h], a[i - 2 * h], a[i - 3 * h]...ä¹‹ä¸­ for (int j = i; j \u0026gt;= h \u0026amp;\u0026amp; less(a[j], a[j - h]) ; j -= h) { exch(a, j, j - h); } h = h / 3; } } } } å½’å¹¶æ’åº å½’å¹¶æ’åºå°†æ•°ç»„åˆ†æˆä¸¤ä¸ªå­æ•°ç»„åˆ†åˆ«è¿›è¡Œæ’åºï¼Œå¹¶å°†æœ‰åºçš„å­æ•°ç»„å½’å¹¶ä»¥å°†æ•´ä¸ªæ•°ç»„æ’åºï¼Œé€’å½’è°ƒç”¨å‘ç”Ÿåœ¨å¤„ç†æ•´ä¸ªæ•°ç»„ä¹‹å‰ã€‚\nåŸåœ°å½’å¹¶çš„æŠ½è±¡æ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static void merge(Comparable[] a, int lo, int mid, int hi) { // å°†a[lo,...,mid]å’Œa[mid + 1,...,hi]å½’å¹¶ int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { // å°†a[lo,...,hi]å¤åˆ¶åˆ°aux[lo,...,hi] aux[k] = a[k]; } for (int k = lo; k \u0026lt;= hi; k++) { // å½’å¹¶å›åˆ°a[lo,...,hi] if (i \u0026gt; mid) a[k] = aux[j++]; else if (j \u0026gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } } è‡ªé¡¶å‘ä¸‹çš„å½’å¹¶æ’åºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Merge { private static Comparable[] aux; // å½’å¹¶æ‰€éœ€çš„è¾…åŠ©æ•°ç»„ public static void sort(Comparable[] a) { aux = new Comparable[a.length]; // ä¸€æ¬¡æ€§åˆ†é…ç©ºé—´ sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { // å°†æ•°ç»„a[lo,...,hi]æ’åº if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, lo, mid); // å°†å·¦åŠè¾¹æ’åº sort(a, mid + 1, hi); // å°†å³åŠè¾¹æ’åº merge(a, lo, mid, hi); // å½’å¹¶ç»“æœ } } å¿«é€Ÿæ’åº å¿«é€Ÿæ’åºå°†æ•°ç»„æ’åºçš„æ–¹å¼æ˜¯å½“ä¸¤ä¸ªå­æ•°ç»„éƒ½æœ‰åºæ—¶æ•´ä¸ªæ•°ç»„ä¹Ÿå°±è‡ªç„¶æœ‰åºäº†ï¼Œé€’å½’è°ƒç”¨å‘ç”Ÿåœ¨å¤„ç†æ•´ä¸ªæ•°ç»„ä¹‹åã€‚\né¦–å…ˆæ˜¯åˆ‡åˆ†ç®—æ³•ï¼Œä½¿å¾— a[lo...j-1] \u0026lt;= a[j] \u0026lt;= a[j+1...hi]ï¼Œè¿”å›æŒ‡æ ‡jã€‚å®ç°åˆ‡åˆ†ç®—æ³•çš„æ€è·¯æ˜¯å…ˆéšæœºåœ°å–a[lo]ä½œä¸ºåˆ‡åˆ†å…ƒç´ ï¼Œç„¶åæˆ‘ä»¬ä»æ•°ç»„çš„å·¦ç«¯å¼€å§‹å‘å³æ‰«æç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªå¤§äºç­‰äºå®ƒçš„å…ƒç´ ï¼Œå†ä»æ•°ç»„çš„å³ç«¯å¼€å§‹å‘å·¦æ‰«æç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªå°äºç­‰äºå®ƒçš„å…ƒç´ ï¼Œäº¤æ¢å®ƒä»¬çš„ä½ç½®ã€‚å¦‚æ­¤ç»§ç»­ï¼Œæˆ‘ä»¬ä¿è¯å·¦æŒ‡é’ˆiçš„å·¦ä¾§å…ƒç´ éƒ½ä¸å¤§äºåˆ‡åˆ†å…ƒç´ ï¼Œå³æŒ‡é’ˆjçš„å³ä¾§å…ƒç´ éƒ½ä¸å°äºåˆ‡åˆ†å…ƒç´ ã€‚å½“ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡æ—¶ï¼Œå°†åˆ‡åˆ†å…ƒç´ a[lo]å’Œå·¦å­æ•°ç»„æœ€å³ä¾§çš„å…ƒç´ a[j]äº¤æ¢åè¿”å›jå³å¯ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static int partition(Comparable[] a, int lo, int hi) { // å°†æ•°ç»„åˆ‡åˆ†ä¸º a[lo,...,i - 1], a[i], a[i + 1,...,hi] int i = lo, j = hi + 1; // å·¦å³æ‰«ææŒ‡é’ˆ Comparable v = a[lo]; // åˆ‡åˆ†å…ƒç´  while (true) { // æ‰«æå·¦å³ï¼Œæ£€æŸ¥æ‰«ææ˜¯å¦ç»“æŸå¹¶äº¤æ¢å…ƒç´  while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; exch(a, i, j); } exch(a, lo, j); // å°† v = a[j] æ”¾å…¥æ­£ç¡®çš„ä½ç½® return j; } å¿«é€Ÿæ’åºç®—æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 public class Quick { public static void sort(Comparable[] a) { StdRandom.shuffle(a); // æ¶ˆé™¤å¯¹è¾“å…¥çš„ä¾èµ– sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int j = partition(a, lo, hi); // å³åˆ‡åˆ†ç®—æ³• sort(a, lo, j - 1); // å°†å·¦åŠéƒ¨åˆ† a[lo,...,j - 1]æ’åº sort(a, j + 1, hi); // å°†å³åŠéƒ¨åˆ† a[j + 1,...,hi]æ’åº } } å¿«é€Ÿæ’åºä¸­é‡è¦çš„å°±æ˜¯åˆ‡åˆ†ç®—æ³•ï¼Œåˆ‡åˆ†ç®—æ³•è¿˜æœ‰ä¸‰å‘åˆ‡åˆ†ã€‚ç»´æŠ¤ä¸€ä¸ªæŒ‡é’ˆltä½¿å¾—a[lo,...,lt-1]ä¸­çš„å…ƒç´ éƒ½å°äºvï¼Œä¸€ä¸ªæŒ‡é’ˆgtä½¿å¾—a[gt+1,..,hi]ä¸­çš„å…ƒç´ éƒ½å¤§äºvï¼Œä¸€ä¸ªæŒ‡é’ˆiä½¿å¾—a[lt,...,i-1]ä¸­çš„å…ƒç´ éƒ½ç­‰äºvã€‚\nä¸‰å‘åˆ‡åˆ†çš„å¿«é€Ÿæ’åº:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Quick3way { private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int lt = lo, i = lo + 1, gt = hi; Comparable v = a[lo]; while (i \u0026lt;= gt) { int cmp = a[i].compareTo(v); if (cmp \u0026lt; 0) exch(a, lt++, i++); else if (cmp \u0026gt; 0) exch(a, i, gt--); else i++; } // ç°åœ¨ a[lo,...,lt-1] \u0026lt; v = a[lt,...,gt] \u0026lt; a[gt+1,...,hi] æˆç«‹ sort(a, lo, lt - 1); sort(a, gt + 1, hi); } } ä¸‰å‘åˆ‡åˆ†ç›¸å…³LeetCodeé¢˜ç›®ï¼š\n75.é¢œè‰²åˆ†ç±» LeetCodeæ’åºç»ƒä¹  912.æ’åºæ•°ç»„ ","date":"2022-04-30T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/04/30/sortAlgorithms/","title":"æ’åºç®—æ³•"},{"content":"æ‰“å°å­—æ¯â€œOâ€ ç»™ä¸€ä¸ªæ•°nï¼Œæ‰“å°4nè¡Œå­—ç¬¦ä¸²ï¼Œæ˜¯ä¸€ä¸ªå¤§â€œOâ€çš„å½¢çŠ¶ã€‚\nä¾‹1: n = 1\n1 2 3 4 .**. *..* *..* .**. ä¾‹2: n = 2\n1 2 3 4 5 6 7 8 ..****.. .******. **....** **....** **....** **....** .******. ..****.. ä¾‹3: n = 3\n1 2 3 4 5 6 7 8 9 10 11 12 ...******... ..********.. .**********. ***......*** ***......*** ***......*** ***......*** ***......*** ***......*** .**********. ..********.. ...******... æ€è·¯ å°†æ‰“å°æ¯ä¸€è¡ŒæŠ½è±¡æˆä¸€ä¸ªå‡½æ•°ï¼Œä¾‹å¦‚ç¬¬ä¸€è¡Œï¼Œå…ˆæ‰“å°å­—ç¬¦ch1ï¼Œé‡å¤times1éï¼Œå†æ‰“å°ch2æœ‰times2éï¼Œæœ€åæ‰“å°ch1 æœ‰times1éã€‚\nä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.util.Scanner; /** * @author æ–‡è¿› * @version 1.0 */ public class N1 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; 4 * n; i++) { if (i \u0026lt; n) { // [0, ..., n - 1] sb.append(printStr(\u0026#39;.\u0026#39;, n - i, \u0026#39;*\u0026#39;, 4 * n - 2 * (n - i))); } else if (i \u0026gt;= 3 * n) { // [3n, ..., 4n - 1] sb.append(printStr(\u0026#39;.\u0026#39;, i - 3 * n + 1, \u0026#39;*\u0026#39;, 4 * n - 2 * (i - 3 * n + 1))); } else { // [n, ..., 3n - 1] sb.append(printStr(\u0026#39;*\u0026#39;, n, \u0026#39;.\u0026#39;, 2 * n)); } sb.append(\u0026#34;\\n\u0026#34;); } // // æˆ–è€…åˆ†å¼€å†™ï¼Œåˆ†åˆ«æ‰“å°ä¸‰å¤§æ®µ // for (int i = n; i \u0026gt; 0; i--) { // sb.append(printStr(\u0026#39;.\u0026#39;, i, \u0026#39;*\u0026#39;, 4 * n - 2 * i)); // sb.append(\u0026#34;\\n\u0026#34;); // } // for (int i = 0; i \u0026lt; 2 * n; i++) { // sb.append(printStr(\u0026#39;*\u0026#39;, n, \u0026#39;.\u0026#39;, 2 * n)); // sb.append(\u0026#34;\\n\u0026#34;); // } // for (int i = 1; i \u0026lt;= n; i++) { // sb.append(printStr(\u0026#39;.\u0026#39;, i, \u0026#39;*\u0026#39;, 4 * n - 2 * i)); // sb.append(\u0026#34;\\n\u0026#34;); // } System.out.println(sb); } // ch1 * times1 + ch2 * times2 + ch1 * times1 public static StringBuilder printStr(char ch1, int times1, char ch2, int times2) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; times1; i++) { sb.append(ch1); } for (int i = 0; i \u0026lt; times2; i++) { sb.append(ch2); } for (int i = 0; i \u0026lt; times1; i++) { sb.append(ch1); } return sb; } } næ•°ä¹‹å’Œ è¦æ„é€ ä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„ï¼Œè¾“å…¥ä¸‰ä¸ªå‚æ•°nï¼Œkï¼Œxã€‚nè¡¨ç¤ºæ•°ç»„çš„é•¿åº¦ï¼Œæ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ ä¸ç›¸ç­‰ä¸”ä¸è¶…è¿‡kï¼Œnä¸ªæ•°çš„å’Œä¸ºkã€‚æœ€åè¾“å‡ºä¸€ä¸ªä»»æ„ä¸€ä¸ªç»“æœå°±å¯ä»¥ï¼Œå¦‚æœæ‰¾ä¸åˆ°è¿™æ ·çš„æ•°ç»„ï¼Œå°±è¿”å›-1ã€‚\nä¾‹1 è¾“å…¥\n1 4 6 15 è¾“å‡ºï¼š\n1 1 5 6 3 ä¾‹2 è¾“å…¥\n1 2 3 4 è¾“å‡º\n1 -1 æ€è·¯ è¿™ä¸ªé¢˜æ˜¯næ•°ä¹‹å’Œçš„é—®é¢˜ï¼Œè”æƒ³åˆ°åœ¨ä¸€ä¸ªæ•°ç»„ä¸­æ±‚å’Œä¸ºtargetçš„nä¸ªæ•°ã€‚å¦‚æœn=2ï¼Œé‚£ä¹ˆå°±æ˜¯ä¸¤æ•°ä¹‹å’Œï¼Œå¯ä»¥å…ˆå¯¹æ•°ç»„æ’åºï¼Œç”¨åŒæŒ‡é’ˆæ±‚ä¸¤æ•°ä¹‹å’Œã€‚å½“æ±‚nä¸ªæ•°ä¹‹å’Œä¸ºtargetæ—¶ï¼Œå¯ä»¥å…ˆå›ºå®šä¸€ä¸ªæ•°nums[i]ï¼Œå†æ±‚n-1ä¸ªæ•°çš„å’Œä¸ºtarget-nums[i]ã€‚\nè¿™é“é¢˜åªéœ€è¿”å›ä¸€ä¸ªå¯è¡Œç»“æœï¼Œé‚£ä¹ˆå½“æ‰¾åˆ°ä¸€ä¸ªè§£æ—¶å°±ç«‹åˆ»è¿”å›ï¼Œå¯ä»¥é¿å…ä¸å¿…è¦çš„é€’å½’è°ƒç”¨ã€‚\nåŒæ—¶é¢˜ç›®ä¸­å‘Šè¯‰æˆ‘ä»¬è¿”å›çš„æ•°ä¸è¶…è¿‡kå¹¶ä¸”å„ä¸ç›¸åŒï¼Œé‚£ä¹ˆæå‰æ„é€ çš„æ•°ç»„å¯ä»¥æ˜¯nums = [1,2,3,...,k]ï¼Œä¸”numsæ•°ç»„ä¸éœ€è¦å†æ’åºäº†ã€‚\nç±»ä¼¼çš„LeetCodeé¢˜ç›®ï¼š\n1.ä¸¤æ•°ä¹‹å’Œ 15.ä¸‰æ•°ä¹‹å’Œ 18.å››æ•°ä¹‹å’Œ 454.å››æ•°ç›¸åŠ II ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import java.util.LinkedList; import java.util.List; import java.util.Scanner; /** * @author æ–‡è¿› * @version 1.0 */ public class N2 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int k = scanner.nextInt(); int x = scanner.nextInt(); int[] nums = new int[k]; for (int i = 0; i \u0026lt; k; i++) { nums[i] = i + 1; } List\u0026lt;Integer\u0026gt; res = nSum(nums, n, 0, x); if (res.size() == n) { StringBuilder sb = new StringBuilder(); for (Integer ele : res) { sb.append(ele + \u0026#34; \u0026#34;); } System.out.println(sb); } else { System.out.println(-1); } } /* n æ•°ä¹‹å’Œï¼Œnums[] æå‰æ’å¥½åºäº†ï¼Œå¹¶ä¸”å„ä¸ç›¸åŒ åŒæŒ‡é’ˆæ–¹æ³• */ public static List\u0026lt;Integer\u0026gt; nSum(int[] nums, int n, int start, int target) { List\u0026lt;Integer\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); if (n \u0026lt; 2 || n \u0026gt; nums.length) return res; if (n == 2) { int left = start, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum \u0026lt; target) { left++; } else if (sum \u0026gt; target) { right--; } else { res.add(nums[left]); res.add(nums[right]); left++; right--; } } } else { for (int i = start; i \u0026lt; nums.length - 1; i++) { List\u0026lt;Integer\u0026gt; list = nSum(nums, n - 1, i + 1, target - nums[i]); if (list.size() == n - 1) { for (Integer ele : list) { res.add(ele); } res.add(nums[i]); break; } } } return res; } } ","date":"2022-04-19T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/04/19/intern-wangyi/","title":"ç½‘æ˜“å®ä¹ ç¬”è¯•é¢˜"},{"content":"ç¬¬2ç«  Javaå¹¶å‘æœºåˆ¶çš„åº•å±‚å®ç°åŸç† 2.1 volatileçš„åº”ç”¨ volatileçš„ä¸¤æ¡å®ç°åŸåˆ™ï¼š\nLockå‰ç¼€æŒ‡ä»¤ä¼šå¼•èµ·å¤„ç†å™¨ç¼“å­˜å›å†™åˆ°å†…å­˜ã€‚ ä¸€ä¸ªå¤„ç†å™¨çš„ç¼“å­˜å›å†™åˆ°å†…å­˜ä¼šå¯¼è‡´å…¶ä»–å¤„ç†å™¨çš„ç¼“å­˜æ— æ•ˆã€‚ 2.2 synchronizedçš„å®ç°åŸç†ä¸åº”ç”¨ synchronizedå®ç°åŒæ­¥çš„åŸºç¡€ï¼šJavaä¸­çš„æ¯ä¸€ä¸ªå¯¹è±¡éƒ½å¯ä»¥ä½œä¸ºé”ã€‚å…·ä½“è¡¨ç°ä¸ºä»¥ä¸‹3ç§å½¢å¼ï¼š\nå¯¹äºæ™®é€šåŒæ­¥æ–¹æ³•ï¼Œé”æ˜¯å½“å‰å®ä¾‹å¯¹è±¡ã€‚ å¯¹äºé™æ€åŒæ­¥æ–¹æ³•ï¼Œé”æ˜¯å½“å‰ç±»çš„Classå¯¹è±¡ã€‚ å¯¹äºåŒæ­¥æ–¹æ³•å—ï¼Œé”æ˜¯Synchonizedæ‹¬å·é‡Œé…ç½®çš„å¯¹è±¡ã€‚ Synchonizedåœ¨JVMé‡Œçš„å®ç°ï¼ŒJVMåŸºäºè¿›å…¥å’Œé€€å‡ºMonitorå¯¹è±¡æ¥å®ç°æ–¹æ³•åŒæ­¥å’Œä»£ç å—åŒæ­¥ã€‚ä»£ç å—åŒæ­¥æ˜¯ä½¿ç”¨monitorenterå’ŒmonitorexitæŒ‡ä»¤å®ç°çš„ã€‚\nmonitorenteræŒ‡ä»¤åœ¨ç¼–è¯‘åæ’å…¥åˆ°åŒæ­¥ä»£ç å—çš„å¼€å§‹ä½ç½®ï¼Œè€Œmonitorexitæ˜¯æ’å…¥åˆ°æ–¹æ³•ç»“æŸå¤„å’Œå¼‚å¸¸å¤„ï¼ŒJVMä¿è¯æ¯ä¸ªmonitorenterå¿…é¡»æœ‰å¯¹åº”çš„monitorexitä¸ä¹‹é…å¯¹ã€‚\n2.2.1 Javaå¯¹è±¡å¤´ ç¬¬3ç«  Javaå†…å­˜æ¨¡å‹ 3.1 Javaå†…å­˜æ¨¡å‹çš„åŸºç¡€ 3.1.1 å¹¶å‘ç¼–ç¨‹æ¨¡å‹çš„ä¸¤ä¸ªå…³é”®é—®é¢˜ çº¿ç¨‹ä¹‹é—´å¦‚ä½•é€šä¿¡ çº¿ç¨‹ä¹‹é—´å¦‚ä½•åŒæ­¥ï¼ŒåŒæ­¥æ˜¯æŒ‡ç¨‹åºä¸­ç”¨äºæ§åˆ¶ä¸åŒçº¿ç¨‹é—´æ“ä½œå‘ç”Ÿç›¸å¯¹é¡ºåºçš„æœºåˆ¶ã€‚ çº¿ç¨‹ä¹‹é—´çš„é€šä¿¡æœºåˆ¶ï¼šå…±äº«å†…å­˜å’Œæ¶ˆæ¯ä¼ é€’ã€‚\nJavaçš„å¹¶å‘é‡‡ç”¨çš„æ˜¯å…±äº«å†…å­˜æ¨¡å‹ï¼ŒJavaçº¿ç¨‹ä¹‹é—´çš„é€šä¿¡æ€»æ˜¯éšå¼è¿›è¡Œï¼Œæ•´ä¸ªé€šä¿¡è¿‡ç¨‹å¯¹ç¨‹åºå‘˜å®Œå…¨é€æ˜ã€‚\n3.1.2 Javaå†…å­˜æ¨¡å‹çš„æŠ½è±¡ç»“æ„ åœ¨Javaä¸­ï¼Œæ‰€æœ‰å®ä¾‹åŸŸã€é™æ€åŸŸå’Œæ•°ç»„å…ƒç´ éƒ½å­˜å‚¨åœ¨å †å†…å­˜ä¸­ï¼Œå †å†…å­˜åœ¨çº¿ç¨‹ä¹‹é—´å…±äº«ã€‚\nJMMå®šä¹‰äº†çº¿ç¨‹å’Œä¸»å†…å­˜ä¹‹é—´çš„æŠ½è±¡å…³ç³»ï¼šçº¿ç¨‹ä¹‹é—´çš„å…±äº«å˜é‡å­˜å‚¨åœ¨ä¸»å†…å­˜ä¸­ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªç§æœ‰çš„æœ¬åœ°å†…å­˜ï¼Œæœ¬åœ°å†…å­˜ä¸­å­˜å‚¨äº†è¯¥çº¿ç¨‹ä»¥è¯»/å†™å…±äº«å˜é‡çš„å‰¯æœ¬ã€‚\n3.1.3 ä»æºä»£ç åˆ°æŒ‡ä»¤åºåˆ—çš„é‡æ’åº é‡æ’åºåˆ†ä¸º3ç§ï¼š\nç¼–è¯‘å™¨ä¼˜åŒ–çš„é‡æ’åº æŒ‡ä»¤çº§å¹¶è¡Œçš„é‡æ’åº å†…å­˜ç³»ç»Ÿçš„é‡æ’åº 3.1.4 å¹¶å‘ç¼–ç¨‹æ¨¡å‹çš„åˆ†ç±» ç”±äºå†™ç¼“å†²åŒºä»…å¯¹è‡ªå·±çš„å¤„ç†å™¨å¯è§ï¼Œå®ƒä¼šå¯¼è‡´å¤„ç†å™¨æ‰§è¡Œå†…å­˜æ“ä½œçš„é¡ºåºå¯èƒ½ä¼šä¸å†…å­˜å®é™…çš„æ“ä½œæ‰§è¡Œé¡ºåºä¸ä¸€è‡´ã€‚\nå¸¸è§çš„å¤„ç†å™¨éƒ½å…è®¸Store-Loadé‡æ’åºï¼Œå¸¸è§çš„å¤„ç†å™¨éƒ½ä¸å…è®¸å¯¹å­˜åœ¨æ•°æ®ä¾èµ–çš„æ“ä½œåšé‡æ’åºã€‚\n3.1.5 happens-beforeç®€ä»‹ happens-beforeä»…ä»…è¦æ±‚å‰ä¸€ä¸ªæ“ä½œï¼ˆæ‰§è¡Œçš„ç»“æœï¼‰å¯¹åä¸€ä¸ªæ“ä½œå¯è§ï¼Œä¸”å‰ä¸€ä¸ªæ“ä½œæŒ‰é¡ºåºæ’åœ¨ç¬¬äºŒä¸ªæ“ä½œä¹‹å‰ã€‚\nä¸€ä¸ªhappens-beforeè§„åˆ™å¯¹åº”äºä¸€ä¸ªæˆ–å¤šä¸ªç¼–è¯‘å™¨å’Œå¤„ç†å™¨é‡æ’åºè§„åˆ™ã€‚\n3.2 é‡æ’åº 3.2.1 æ•°æ®ä¾èµ–æ€§ å¦‚æœä¸¤ä¸ªæ“ä½œè®¿é—®åŒä¸€ä¸ªå˜é‡ï¼Œä¸”è¿™ä¸¤ä¸ªæ“ä½œä¸­æœ‰ä¸€ä¸ªä¸ºå†™æ“ä½œï¼Œæ­¤æ—¶è¿™ä¸¤ä¸ªæ“ä½œä¹‹é—´å°±å­˜åœ¨æ•°æ®ä¾èµ–æ€§ã€‚\nç¼–è¯‘å™¨å’Œå¤„ç†å™¨ä¸ä¼šæ”¹å˜å­˜åœ¨æ•°æ®ä¾èµ–å…³ç³»çš„ä¸¤ä¸ªæ“ä½œçš„æ‰§è¡Œé¡ºåºã€‚\n3.2.2 as-if-serialè¯­ä¹‰ as-if-serialè¯­ä¹‰ï¼šä¸ç®¡æ€ä¹ˆé‡æ’åºï¼ˆç¼–è¯‘å™¨å’Œå¤„ç†å™¨ä¸ºäº†æé«˜å¹¶è¡Œåº¦ï¼‰ï¼Œï¼ˆå•çº¿ç¨‹ï¼‰ç¨‹åºçš„æ‰§è¡Œç»“æœä¸èƒ½è¢«æ”¹å˜ã€‚\n3.2.3 ç¨‹åºé¡ºåºè§„åˆ™ A happens-before Bï¼Œå½“å®é™…æ‰§è¡Œæ—¶Bå´å¯ä»¥æ’åœ¨Aä¹‹å‰æ‰§è¡Œã€‚ è½¯ä»¶æŠ€æœ¯å’Œç¡¬ä»¶æŠ€æœ¯çš„å…±åŒç›®æ ‡ï¼šåœ¨ä¸æ”¹å˜ç¨‹åºæ‰§è¡Œç»“æœçš„å‰æä¸‹ï¼Œå°½å¯èƒ½æé«˜å¹¶è¡Œåº¦ã€‚\n3.2.4 é‡æ’åºå¯¹å¤šçº¿ç¨‹çš„å½±å“ å½“ä»£ç ä¸­å­˜åœ¨æ§åˆ¶ä¾èµ–æ—¶ï¼Œä¼šå½±å“æŒ‡ä»¤åºåˆ—æ‰§è¡Œçš„å¹¶è¡Œåº¦ã€‚ä¸ºæ­¤ï¼Œç¼–è¯‘å™¨å’Œå¤„ç†å™¨ä¼šé‡‡ç”¨çŒœæµ‹æ‰§è¡Œæ¥æ§åˆ¶ç›¸å…³æ€§å¯¹å¹¶è¡Œåº¦çš„å½±å“ã€‚\nåœ¨å¤šçº¿ç¨‹ç¨‹åºä¸­ï¼Œå¯¹å­˜åœ¨æ§åˆ¶ä¾èµ–çš„æ“ä½œé‡æ’åºï¼Œå¯èƒ½ä¼šæ”¹å˜ç¨‹åºçš„æ‰§è¡Œç»“æœã€‚\n3.3 é¡ºåºä¸€è‡´æ€§ 3.3.1 æ•°æ®ç«äº‰ä¸é¡ºåºä¸€è‡´æ€§ å¦‚æœç¨‹åºæ˜¯æ­£ç¡®åŒæ­¥çš„ï¼Œç¨‹åºçš„æ‰§è¡Œå°†å…·æœ‰é¡ºåºä¸€è‡´æ€§ã€‚\n3.3.2 é¡ºåºä¸€è‡´æ€§å†…å­˜æ¨¡å‹ é¡ºåºä¸€è‡´æ€§å†…å­˜æ¨¡å‹æœ‰ä¸¤å¤§ç‰¹æ€§ï¼š\nä¸€ä¸ªçº¿ç¨‹ä¸­çš„æ‰€æœ‰æ“ä½œå¿…é¡»æŒ‰ç…§ç¨‹åºçš„é¡ºåºæ¥æ‰§è¡Œã€‚ ï¼ˆä¸ç®¡ç¨‹åºæ˜¯å¦åŒæ­¥ï¼‰æ‰€æœ‰çº¿ç¨‹éƒ½åªèƒ½çœ‹åˆ°ä¸€ä¸ªå•ä¸€çš„æ“ä½œæ‰§è¡Œé¡ºåºã€‚åœ¨é¡ºåºä¸€è‡´æ€§å†…å­˜æ¨¡å‹ä¸­ï¼Œæ¯ä¸ªæ“ä½œéƒ½å¿…é¡»åŸå­æ‰§è¡Œä¸”ç«‹åˆ»å¯¹æ‰€æœ‰çº¿ç¨‹å¯è§ã€‚ æœªåŒæ­¥ç¨‹åºåœ¨JMMä¸­ä¸ä½†æ•´ä½“çš„æ‰§è¡Œé¡ºåºæ˜¯æ— åºçš„ï¼Œè€Œä¸”æ‰€æœ‰çº¿ç¨‹çœ‹åˆ°çš„æ“ä½œæ‰§è¡Œé¡ºåºä¹Ÿå¯èƒ½ä¸ä¸€è‡´ã€‚\n3.3.3 åŒæ­¥ç¨‹åºçš„é¡ºåºä¸€è‡´æ€§ç»“æœ åœ¨JMMä¸­ï¼Œä¸´ç•ŒåŒºå†…çš„ä»£ç å¯ä»¥é‡æ’åºï¼ˆä½†JMMä¸å…è®¸ä¸´ç•ŒåŒºå†…çš„ä»£ç â€œé€¸å‡ºâ€åˆ°ä¸´ç•ŒåŒºä¹‹å¤–ï¼Œé‚£æ ·ä¼šç ´åç›‘è§†å™¨çš„è¯­ä¹‰ï¼‰ã€‚\n3.3.4 æœªåŒæ­¥ç¨‹åºçš„æ‰§è¡Œç‰¹æ€§ å¯¹äºæœªåŒæ­¥æˆ–æœªæ­£ç¡®åŒæ­¥çš„å¤šçº¿ç¨‹ç¨‹åºï¼ŒJMMåªæä¾›æœ€å°å®‰å…¨æ€§ï¼šçº¿ç¨‹æ‰§è¡Œæ—¶è¯»å–åˆ°çš„å€¼ï¼Œè¦ä¹ˆæ˜¯ä¹‹å‰æŸä¸ªçº¿ç¨‹å†™å…¥çš„å€¼ï¼Œè¦ä¹ˆæ˜¯é»˜è®¤å€¼ï¼ˆ0ï¼ŒNullï¼ŒFalseï¼‰ï¼ŒJMMä¿è¯çº¿ç¨‹è¯»æ“ä½œè¯»å–åˆ°çš„å€¼ä¸ä¼šæ— ä¸­ç”Ÿæœ‰çš„å†’å‡ºæ¥ã€‚\nJMMä¸ä¿è¯å¯¹64ä½çš„longå‹å’Œdoubleå‹å˜é‡çš„å†™æ“ä½œå…·æœ‰åŸå­æ€§ï¼Œè€Œé¡ºåºä¸€è‡´æ€§æ¨¡å‹ä¿è¯å¯¹æ‰€æœ‰çš„å†…å­˜è¯»/å†™æ“ä½œéƒ½å…·æœ‰åŸå­æ€§ã€‚\nä»JSR-133å†…å­˜æ¨¡å‹å¼€å§‹ï¼ˆå³ä»JDK5å¼€å§‹ï¼‰ï¼Œä»…ä»…åªå…è®¸æŠŠä¸€ä¸ª64ä½long/doubleå‹å˜é‡çš„å†™æ“ä½œæ‹†åˆ†ä¸ºä¸¤ä¸ª32ä½çš„å†™æ“ä½œæ¥æ‰§è¡Œï¼Œä»»æ„çš„è¯»æ“ä½œåœ¨JSR-133ä¸­éƒ½å¿…é¡»å…·æœ‰åŸå­æ€§ï¼ˆå³ä»»æ„è¯»æ“ä½œå¿…é¡»è¦åœ¨å•ä¸ªè¯»äº‹åŠ¡ä¸­æ‰§è¡Œï¼‰ã€‚\n3.4 volatileçš„å†…å­˜è¯­ä¹‰ 3.4.1 volatileçš„ç‰¹æ€§ æŠŠå¯¹volatileå˜é‡çš„å•ä¸ªè¯»/å†™ï¼Œçœ‹æˆæ˜¯ä½¿ç”¨åŒä¸€ä¸ªé”å¯¹è¿™äº›å•ä¸ªè¯»/å†™æ“ä½œåšäº†åŒæ­¥ã€‚\nå¯è§æ€§ã€‚å¯¹ä¸€ä¸ªvolatileå˜é‡çš„è¯»ï¼Œæ€»æ˜¯èƒ½çœ‹åˆ°ï¼ˆä»»æ„çº¿ç¨‹ï¼‰å¯¹è¿™ä¸ªvolatileå˜é‡æœ€åçš„å†™å…¥ã€‚ åŸå­æ€§ï¼šå¯¹ä»»æ„å•ä¸ªvolatileå˜é‡çš„è¯»/å†™å…·æœ‰åŸå­æ€§ï¼Œä½†ç±»ä¼¼äºvolatile++è¿™ç§å¤åˆæ“ä½œä¸å…·æœ‰åŸå­æ€§ã€‚ 3.4.2 volatileå†™-è¯»å»ºç«‹çš„happens-beforeå…³ç³» volatileå†™å’Œé”çš„é‡Šæ”¾æœ‰ç›¸åŒçš„å†…å­˜è¯­ä¹‰ï¼›volatileè¯»ä¸é”çš„è·å–æœ‰ç›¸åŒçš„å†…å­˜è¯­ä¹‰ã€‚\n3.4.3 volatileå†™-è¯»çš„å†…å­˜è¯­ä¹‰ å½“å†™ä¸€ä¸ªvolatileå˜é‡æ—¶ï¼ŒJMMä¼šæŠŠè¯¥çº¿ç¨‹å¯¹åº”çš„æœ¬åœ°å†…å­˜ä¸­çš„å…±äº«å˜é‡å€¼åˆ·æ–°åˆ°ä¸»å†…å­˜ã€‚ å½“è¯»ä¸€ä¸ªvolatileå˜é‡æ—¶ï¼ŒJMMä¼šæŠŠè¯¥çº¿ç¨‹å¯¹åº”çš„æœ¬åœ°å†…å­˜ç½®ä¸ºæ— æ•ˆã€‚çº¿ç¨‹æ¥ä¸‹æ¥å°†ä»ä¸»å†…å­˜ä¸­è¯»å–å…±äº«å˜é‡ã€‚\nå¯ä»¥çœ‹ä½œæ˜¯åœ¨ä¸¤ä¸ªçº¿ç¨‹ä¹‹é—´åœ¨è¿›è¡Œæ¶ˆæ¯ä¼ é€’ã€‚\n3.4.4 volatileå†…å­˜è¯­ä¹‰çš„å®ç° å½“ç¬¬äºŒä¸ªæ“ä½œæ˜¯volatileå†™æ—¶ï¼Œä¸ç®¡ç¬¬ä¸€ä¸ªæ“ä½œæ˜¯ä»€ä¹ˆï¼Œéƒ½ä¸èƒ½é‡æ’åºã€‚ å½“ç¬¬ä¸€ä¸ªæ“ä½œæ—¶volatileè¯»æ—¶ï¼Œä¸ç®¡ç¬¬äºŒä¸ªæ“ä½œæ˜¯ä»€ä¹ˆï¼Œéƒ½ä¸èƒ½é‡æ’åºã€‚ å½“ç¬¬ä¸€ä¸ªæ“ä½œæ—¶volatileå†™ï¼Œç¬¬äºŒä¸ªæ“ä½œæ˜¯volatileè¯»æ—¶ï¼Œä¸èƒ½é‡æ’åºã€‚ åŸºäºä¿å®ˆç­–ç•¥çš„JMMå†…å­˜å±éšœæ’å…¥ç­–ç•¥ï¼š\nåœ¨æ¯ä¸ªvolatileå†™æ“ä½œçš„å‰é¢æ’å…¥ä¸€ä¸ªStoreStoreå±éšœã€‚ åœ¨æ¯ä¸ªvolatileå†™æ“ä½œçš„åé¢æ’å…¥ä¸€ä¸ªStoreLoadå±éšœã€‚ åœ¨æ¯ä¸ªvolatileè¯»æ“ä½œçš„åé¢æ’å…¥ä¸€ä¸ªLoadLoadå±éšœã€‚ åœ¨æ¯ä¸ªvolatileè¯»æ“ä½œçš„åé¢æ’å…¥ä¸€ä¸ªLoadStoreå±éšœã€‚ å› ä¸ºx86ä»…ä¼šå¯¹å†™-è¯»æ“ä½œåšé‡æ’åºï¼Œå› æ­¤JMMä»…éœ€åœ¨volatileå†™æ“ä½œçš„åé¢æ’å…¥ä¸€ä¸ªStoreLoadå±éšœã€‚\n3.4.5 JSR-133ä¸ºä»€ä¹ˆè¦å¢å¼ºvolatileçš„å†…å­˜è¯­ä¹‰ ä¸¥æ ¼é™åˆ¶ç¼–è¯‘å™¨å’Œå¤„ç†å™¨å¯¹volatileå˜é‡ä¸æ™®é€šå˜é‡çš„é‡æ’åºï¼Œç¡®ä¿volatileçš„å†™-è¯»å’Œé”çš„é‡Šæ”¾-è·å–å…·æœ‰ç›¸åŒçš„å†…å­˜è¯­ä¹‰ã€‚\nåœ¨åŠŸèƒ½ä¸Šï¼Œé”æ¯”volatileæ›´å¼ºå¤§ï¼›åœ¨å¯ä¼¸ç¼©æ€§å’Œæ‰§è¡Œæ€§èƒ½ä¸Šï¼Œvolatileæ›´æœ‰ä¼˜åŠ¿ã€‚\n3.5 é”çš„å†…å­˜è¯­ä¹‰ 3.5.1 é”çš„é‡Šæ”¾-è·å–å»ºç«‹çš„happens-beforeå…³ç³» é”é™¤äº†è®©ä¸´ç•ŒåŒºäº’æ–¥æ‰§è¡Œå¤–ï¼Œè¿˜å¯ä»¥è®©é‡Šæ”¾é”çš„çº¿ç¨‹å‘è·å–åŒä¸€ä¸ªé”çš„çº¿ç¨‹å‘é€æ¶ˆæ¯ã€‚\n3.5.2 é”çš„é‡Šæ”¾å’Œè·å–çš„å†…å­˜è¯­ä¹‰ çœ‹ä½œæ˜¯ä¸¤ä¸ªçº¿ç¨‹ä¹‹é—´é€šè¿‡ä¸»å†…å­˜å‘é€æ¶ˆæ¯ã€‚\n3.5.3 é”å†…å­˜è¯­ä¹‰çš„å®ç° ReentrantLockçš„å®ç°ä¾èµ–äºJavaåŒæ­¥æ¡†æ¶AbstractQueuedSynchronizerï¼ˆç®€ç§°AQSï¼‰ã€‚AQSä½¿ç”¨ä¸€ä¸ªæ•´å‹çš„volatileå˜é‡ï¼ˆå‘½åä¸ºstateï¼‰æ¥ç»´æŒåŒæ­¥çŠ¶æ€ã€‚\nReentrantLockåˆ†ä¸ºå…¬å¹³é”å’Œéå…¬å¹³é”ã€‚\nä½¿ç”¨å…¬å¹³é”æ—¶ï¼ŒåŠ é”æ–¹æ³•lockè°ƒç”¨è½¨è¿¹å¦‚ä¸‹ï¼š\nReentrantLock:lock() 1 2 3 4 5 6 7 8 9 10 11 public ReentrantLock() { sync = new NonfairSync(); // é»˜è®¤æ„é€ å™¨ä¸ºéå…¬å¹³é” } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); //true ä¸ºå…¬å¹³é”ï¼Œ false ä¸ºéå…¬å¹³é” } public void lock() { sync.lock(); // å¦‚æœä¸ºå…¬å¹³é”å°±è°ƒç”¨FairSyncçš„lock()ï¼Œåä¹‹å°±è°ƒç”¨NonfairSync.lock() } FairSync:lock() (ReentrantLockçš„å†…éƒ¨ç±») 1 2 3 final void lock() { acquire(1); } AbstractQueuedSynchronizer:acquire(int arg) 1 2 3 4 5 public final void acquire(int arg) { if (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } ReentrantLock:tryAcquire(int acquires) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; final void lock() { acquire(1); } /** * Fair version of tryAcquire. Don\u0026#39;t grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); /* åœ¨AQSä¸­æœ‰å¦‚ä¸‹çš„å˜é‡ state ä»¥åŠ getSatate()æ–¹æ³•ï¼š private volatile int state; protected final int getState() { return state; } */ int c = getState(); // è·å–é”çš„å¼€å§‹ï¼Œé¦–å…ˆè¯» volatile å˜é‡ state if (c == 0) { if (!hasQueuedPredecessors() \u0026amp;\u0026amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u0026lt; 0) throw new Error(\u0026#34;Maximum lock count exceeded\u0026#34;); setState(nextc); return true; } return false; } ä½¿ç”¨å…¬å¹³é”æ—¶ï¼Œè§£é”æ–¹æ³•unlock()è°ƒç”¨è½¨è¿¹ï¼š\nReentrantLock:unlock() 1 2 3 public void unlock() { sync.release(1); } AbstractQueuedSynchronizer:release(int arg) 1 2 3 4 5 6 7 8 9 public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } Sync:tryRelase(int releases) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } /* AQSä¸­çš„setStateæ–¹æ³•ï¼š protected final void setState(int newState) { state = newState; } */ setState(c); // é‡Šæ”¾é”çš„æœ€åï¼Œå†™ volatileå˜é‡state return free; } å…¬å¹³é”åœ¨é‡Šæ”¾é”çš„æœ€åå†™volatileå˜é‡stateï¼Œåœ¨è·å–é”æ—¶é¦–å…ˆè¯»è¿™ä¸ªvolatileå˜é‡ã€‚å› æ­¤ï¼Œé‡Šæ”¾é”çš„çº¿ç¨‹åœ¨å†™volatileå˜é‡ä¹‹å‰å¯è§çš„å…±äº«å˜é‡ï¼Œåœ¨è·å–é”çš„çº¿ç¨‹è¯»å–åŒä¸€ä¸ªvolatileå˜é‡åå°†ç«‹å³å˜å¾—å¯¹è·å–é”çš„çº¿ç¨‹å¯è§ã€‚\néå…¬å¹³é”è·å–é”çš„æ–¹å¼å’Œå…¬å¹³é”ç›¸åŒã€‚éå…¬å¹³é”çš„åŠ é”æ–¹æ³•lock()è°ƒç”¨è½¨è¿¹å¦‚ä¸‹ï¼š\nReentrantLock:lock() NonfairSync:lock() 1 2 3 4 5 6 final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } AbstractQueuedSynchronizer:compareAndSetState(int expect, int update) 1 2 3 4 protected final boolean compareAndSetState(int expect, int update) { // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } è¯¥æ–¹æ³•ä»¥åŸå­æ“ä½œçš„æ–¹å¼æ›´æ–°stateå˜é‡ã€‚compareAndSetState()ç®€ç§°CASæ–¹æ³•ã€‚å¦‚æœå½“å‰çŠ¶æ€å€¼ç­‰äºé¢„æœŸå€¼ï¼Œåˆ™ä»¥åŸå­çš„æ–¹å¼å°†åŒæ­¥çŠ¶æ€è®¾ç½®ä¸ºç»™å®šçš„æ›´æ–°å€¼ã€‚æ­¤æ“ä½œå…·æœ‰volatileè¯»å’Œå†™çš„å†…å­˜è¯­ä¹‰ã€‚\nsun.misc.Unsafeç±»çš„compareAndSwapInt()æ–¹æ³•çš„æºä»£ç ï¼š\n1 public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); è¿™æ˜¯ä¸€ä¸ªæœ¬åœ°è°ƒç”¨æ–¹æ³•ï¼Œä¼šè°ƒç”¨ç›¸åº”çš„C++ä»£ç ï¼Œé‡è¦çš„æ˜¯æºä»£ç ä¸­å«æœ‰cmpxchgï¼Œç¨‹åºä¼šæ ¹æ®å½“å‰å¤„ç†å™¨çš„ç±»å‹æ¥å†³å®šæ˜¯å¦ä¸ºcmpxchgæŒ‡ä»¤æ·»åŠ lockå‰ç¼€ã€‚å¦‚æœæ˜¯å½“å¤„ç†å™¨ï¼Œå°±çœç•¥lockæŒ‡ä»¤ï¼Œå¦‚æœæ˜¯å¤šå¤„ç†å™¨å°±åŠ ä¸Šlockå‰ç¼€ã€‚\nintelæ‰‹å†Œå¯¹lockå‰ç¼€çš„è¯´æ˜ï¼š\nç¡®ä¿å¯¹å†…å­˜çš„è¯»-æ”¹-å†™æ“ä½œçš„åŸå­æ‰§è¡Œã€‚Intelä½¿ç”¨ç¼“å­˜é”å®šæ¥ä¿è¯æŒ‡ä»¤æ‰§è¡Œçš„åŸå­æ€§ã€‚ç¼“å­˜é”å®šå°†å¤§å¤§é™ä½lockå‰ç¼€æŒ‡ä»¤çš„æ‰§è¡Œå¼€é”€ã€‚ ç¦æ­¢è¯¥æŒ‡ä»¤ï¼Œä¸ä¹‹å‰å’Œä¹‹åçš„è¯»å’Œå†™æŒ‡ä»¤é‡æ’åºã€‚ æŠŠå†™ç¼“å†²åŒºä¸­çš„æ‰€æœ‰æ•°æ®åˆ·æ–°åˆ°å†…å­˜ä¸­ã€‚ å…¬å¹³é”å’Œéå…¬å¹³é”çš„å†…å­˜è¯­ä¹‰ï¼š\nå…¬å¹³é”å’Œéå…¬å¹³é”é‡Šæ”¾æ—¶ï¼Œæœ€åéƒ½è¦å†™ä¸€ä¸ªvolatileå˜é‡stateã€‚ å…¬å¹³é”è·å–æ—¶ï¼Œé¦–å…ˆä¼šå»è¯»volatileå˜é‡ã€‚ éå…¬å¹³é”è·å–æ—¶ï¼Œé¦–å…ˆä¼šç”¨CASæ›´æ–°volatileå˜é‡ï¼Œè¿™ä¸ªæ“ä½œåŒæ—¶å…·æœ‰volatileè¯»å’Œvolatileå†™çš„å†…å­˜è¯­ä¹‰ã€‚ é”é‡Šæ”¾-è·å–çš„å†…å­˜è¯­ä¹‰çš„å®ç°è‡³å°‘æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹å¼ï¼š\nåˆ©ç”¨volatileå˜é‡çš„å†™-è¯»æ‰€å…·æœ‰çš„å†…å­˜è¯­ä¹‰ã€‚ åˆ©ç”¨CASæ‰€é™„å¸¦çš„volatileè¯»å’Œvolatileå†™çš„å†…å­˜è¯­ä¹‰ã€‚ 3.5.4 concurrentåŒ…çš„å®ç° ä¸€ä¸ªé€šç”¨åŒ–çš„å®ç°æ¨¡å¼ï¼š\né¦–å…ˆï¼Œå£°æ˜å…±äº«å˜é‡volatile. ç„¶åï¼Œä½¿ç”¨CASçš„åŸå­æ¡ä»¶æ›´æ–°æ¥å®ç°çº¿ç¨‹ä¹‹é—´çš„åŒæ­¥ã€‚ åŒæ—¶ï¼Œé…åˆä»¥vilatileçš„è¯»/å†™å’ŒCASæ‰€å…·æœ‰çš„volatileè¯»å’Œå†™çš„å†…å­˜è¯­ä¹‰æ¥å®ç°çº¿ç¨‹ä¹‹é—´çš„åŒæ­¥ã€‚ 3.6 finalåŸŸçš„å†…å­˜è¯­ä¹‰ 3.6.1 finalåŸŸçš„é‡æ’åºè§„åˆ™ åœ¨æ„é€ å‡½æ•°å†…å¯¹ä¸€ä¸ªfinalåŸŸçš„å†™å…¥ï¼Œä¸éšåæŠŠè¿™ä¸ªè¢«æ„é€ å¯¹è±¡çš„å¼•ç”¨èµ‹å€¼ç»™ä¸€ä¸ªå¼•ç”¨å˜é‡ï¼Œè¿™ä¸¤ä¸ªæ“ä½œä¸èƒ½é‡æ’åºã€‚ åˆæ¬¡è¯»ä¸€ä¸ªåŒ…å«finalåŸŸçš„å¯¹è±¡çš„å¼•ç”¨ï¼Œä¸éšååˆæ¬¡è¯»è¿™ä¸ªfinalåŸŸï¼Œè¿™ä¸¤ä¸ªæ“ä½œä¹‹é—´ä¸èƒ½é‡æ’åºã€‚ 3.6.2 å†™finalåŸŸçš„é‡æ’åºè§„åˆ™ å†™finalåŸŸçš„é‡æ’åºè§„åˆ™ç¦æ­¢æŠŠfinalåŸŸçš„å†™é‡æ’åºåˆ°æ„é€ å‡½æ•°ä¹‹å¤–ï¼Œå…·ä½“å®ç°ï¼š\nJMMç¦æ­¢ç¼–è¯‘å™¨æŠŠfinalåŸŸçš„å†™é‡æ’åºåˆ°æ„é€ å‡½æ•°ä¹‹å¤–ã€‚ ç¼–è¯‘å™¨ä¼šåœ¨finalåŸŸçš„å†™ä¹‹åï¼Œæ„é€ å‡½æ•°returnä¹‹å‰ï¼Œæ’å…¥ä¸€ä¸ªStoreStoreå±éšœã€‚è¿™ä¸ªå±éšœç¦æ­¢å¤„ç†å™¨æŠŠfinalåŸŸçš„å†™é‡æ’åºåˆ°æ„é€ å‡½æ•°ä¹‹å¤–ã€‚ å†™finalåŸŸçš„é‡æ’åºå¯ä»¥ä¿è¯ï¼šåœ¨å¯¹è±¡å¼•ç”¨ä¸ºä»»æ„çº¿ç¨‹å¯è§ä¹‹å‰ï¼Œå¯¹è±¡çš„finalåŸŸå·²ç»è¢«æ­£ç¡®åˆå§‹åŒ–è¿‡äº†ï¼Œè€Œæ™®é€šåŸŸä¸å…·æœ‰è¿™ä¸ªä¿éšœã€‚\n3.6.3 è¯»finalåŸŸçš„é‡æ’åºè§„åˆ™ åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­ï¼Œåˆæ¬¡è¯»å¯¹è±¡å¼•ç”¨ä¸åˆæ¬¡è¯»è¯¥å¯¹è±¡åŒ…å«çš„finalåŸŸï¼Œè¿™ä¸¤ä¸ªæ“ä½œä¹‹é—´ä¸èƒ½é‡æ’åºã€‚å®ç°ï¼š\nJMMç¦æ­¢å¤„ç†å™¨é‡æ’åºè¿™ä¸¤ä¸ªæ“ä½œã€‚ ç¼–è¯‘å™¨ä¼šåœ¨è¯»finalåŸŸæ“ä½œçš„å‰é¢æ’å…¥ä¸€ä¸ªLoadLoadå±éšœã€‚ è¿™ä¸¤ä¸ªæ“ä½œä¹‹é—´å­˜åœ¨é—´æ¥ä¾èµ–å…³ç³»ã€‚\nè¯»finalåŸŸçš„é‡æ’åºè§„åˆ™å¯ä»¥ç¡®ä¿ï¼šåœ¨è¯»ä¸€ä¸ªå¯¹è±¡çš„finalåŸŸä¹‹å‰ï¼Œä¸€å®šä¼šå…ˆè¯»åŒ…å«è¿™ä¸ªfinalåŸŸçš„å¯¹è±¡çš„å¼•ç”¨ã€‚\n3.6.4 finalåŸŸä¸ºå¼•ç”¨ç±»å‹ å¯¹äºå¼•ç”¨ç±»å‹ï¼Œå†™finalåŸŸçš„é‡æ’åºè§„åˆ™å¯¹ç¼–è¯‘å™¨å’Œå¤„ç†å™¨å¢åŠ äº†å¦‚ä¸‹çº¦æŸï¼šåœ¨æ„é€ å‡½æ•°å†…å¯¹ä¸€ä¸ªfinalå¼•ç”¨çš„å¯¹è±¡çš„æˆå‘˜åŸŸçš„å†™å…¥ï¼Œä¸éšååœ¨æ„é€ å‡½æ•°å¤–æŠŠè¿™ä¸ªè¢«æ„é€ å¯¹è±¡çš„å¼•ç”¨èµ‹å€¼ç»™ä¸€ä¸ªå¼•ç”¨å˜é‡ï¼Œè¿™ä¸¤ä¸ªæ“ä½œä¹‹é—´ä¸èƒ½é‡æ’åºã€‚\n3.6.5 ä¸ºä»€ä¹ˆfinalå¼•ç”¨ä¸èƒ½ä»æ„é€ å‡½æ•°å†…â€œæº¢å‡ºâ€ åœ¨æ„é€ å‡½æ•°è¿”å›å‰ï¼Œè¢«æ„é€ å¯¹è±¡çš„å¼•ç”¨ä¸èƒ½ä¸ºå…¶ä»–çº¿ç¨‹æ‰€è§ï¼Œå› ä¸ºæ­¤æ—¶çš„finalåŸŸå¯èƒ½è¿˜æ²¡æœ‰è¢«åˆå§‹åŒ–ã€‚åœ¨æ„é€ å‡½æ•°è¿”å›åï¼Œä»»æ„çº¿ç¨‹éƒ½å°†ä¿è¯èƒ½çœ‹åˆ°finalåŸŸæ­£ç¡®åˆå§‹åŒ–ä¹‹åçš„å€¼ã€‚\n3.6.6 finalè¯­ä¹‰åœ¨å¤„ç†å™¨ä¸­çš„å®ç° X86å¤„ç†å™¨ï¼Œåªä¼šå¯¹Store-Loadè¿›è¡Œé‡æ’åºã€‚æ ¹æ®finalåŸŸé‡æ’åºè§„åˆ™ï¼Œä»¥åŠX86å¤„ç†å™¨ä¸ä¼šå¯¹å­˜åœ¨é—´æ¥ä¾èµ–å…³ç³»çš„æ“ä½œè¿›è¡Œé‡æ’åºï¼Œå› æ­¤åœ¨X86å¤„ç†å™¨ä¸­ï¼ŒfinalåŸŸçš„è¯»/å†™ä¸ä¼šæ’å…¥ä»»ä½•å†…å­˜å±éšœï¼\n3.6.7 JSR-133ä¸ºä»€ä¹ˆè¦å¢å¼ºfinalçš„è¯­ä¹‰ é€šè¿‡ä¸ºfinalåŸŸå¢åŠ å†™å’Œè¯»é‡æ’åºè§„åˆ™ï¼Œå¯ä»¥ä¸ºJavaç¨‹åºå‘˜æä¾›åˆå§‹åŒ–çš„å®‰å…¨ä¿è¯ï¼šåªè¦å¯¹è±¡æ˜¯æ­£ç¡®æ„é€ çš„ï¼ˆè¢«æ„é€ å¯¹è±¡çš„å¼•ç”¨åœ¨æ„é€ å‡½æ•°ä¸­æ²¡æœ‰â€œæº¢å‡ºâ€ï¼‰ï¼Œé‚£ä¹ˆä¸éœ€è¦ä½¿ç”¨åŒæ­¥ï¼ˆæŒ‡lockå’Œvolatileçš„ä½¿ç”¨ï¼‰å°±å¯ä»¥ä¿è¯ä»»æ„çº¿ç¨‹éƒ½èƒ½çœ‹åˆ°è¿™ä¸ªfinalåŸŸåœ¨æ„é€ å‡½æ•°ä¸­è¢«åˆå§‹åŒ–ä¹‹åçš„å€¼ã€‚\n3.7 happens-before 3.7.1 JMMçš„è®¾è®¡ JSR-133ä¸“å®¶ç»„åœ¨è®¾è®¡JMMæ—¶çš„æ ¸å¿ƒç›®æ ‡æ˜¯æ‰¾åˆ°ä¸€ä¸ªå¥½çš„å¹³è¡¡ç‚¹ï¼šä¸€æ–¹é¢ï¼Œè¦ä¸ºç¨‹åºå‘˜æä¾›è¶³å¤Ÿå¼ºçš„å†…å­˜å¯è§æ€§ä¿è¯ï¼›å¦ä¸€æ–¹é¢ï¼Œå¯¹ç¼–è¯‘å™¨å’Œå¤„ç†å™¨çš„é™åˆ¶å°½å¯èƒ½åœ°æ”¾æ¾ã€‚\nJMMå¯¹ä¸åŒæ€§è´¨çš„é‡æ’åºï¼Œé‡‡å–ä¸åŒçš„ç­–ç•¥ï¼š\nå¯¹äºä¼šæ”¹å˜ç¨‹åºæ‰§è¡Œç»“æœçš„é‡æ’åºï¼ŒJMMè¦æ±‚ç¼–è¯‘å™¨å’Œå¤„ç†å™¨å¿…é¡»ç¦æ­¢è¿™ç§é‡æ’åºã€‚ å¯¹äºä¸ä¼šæ”¹å˜ç¨‹åºæ‰§è¡Œç»“æœçš„é‡æ’åºï¼ŒJMMå¯¹ç¼–è¯‘å™¨å’Œå¤„ç†å™¨ä¸åšè¦æ±‚ï¼ˆJMMè¿è¡Œè¿™ç§é‡æ’åºï¼‰ã€‚ 3.7.2 happens-beforeçš„å®šä¹‰ happens-beforeå…³ç³»æœ¬è´¨ä¸Šå’Œas-if-serialè¯­ä¹‰æ˜¯ä¸€å›äº‹ï¼Œéƒ½æ˜¯ä¸ºäº†åœ¨ä¸æ”¹å˜ç¨‹åºæ‰§è¡Œç»“æœçš„å‰æä¸‹ï¼Œå°½å¯èƒ½åœ°æé«˜ç¨‹åºæ‰§è¡Œçš„å¹¶è¡Œåº¦ã€‚\n3.7.3 happens-beforeè§„åˆ™ ç¨‹åºé¡ºåºè§„åˆ™ ç›‘è§†å™¨é”è§„åˆ™ volatileå˜é‡è§„åˆ™ ä¼ é€’æ€§ start()è§„åˆ™ï¼šå¦‚æœçº¿ç¨‹Aæ‰§è¡Œæ“ä½œThreadB.start()ï¼ˆå¯åŠ¨çº¿ç¨‹Bï¼‰ï¼Œé‚£ä¹ˆAçº¿ç¨‹çš„ThreadB.start()æ“ä½œhappens-beforeäºçº¿ç¨‹Bä¸­çš„ä»»æ„æ“ä½œã€‚ join()è§„åˆ™ï¼šå¦‚æœçº¿ç¨‹Aæ‰§è¡Œæ“ä½œThreadB.join()å¹¶æˆåŠŸè¿”å›ï¼Œé‚£ä¹ˆBçº¿ç¨‹ä¸­çš„ä»»æ„æ“ä½œhappens-beforeäºçº¿ç¨‹Aä»ThreadB.join()æ“ä½œæˆåŠŸè¿”å›ã€‚ 3.8 åŒé‡æ£€æŸ¥é”å®šä¸å»¶è¿Ÿåˆå§‹åŒ– 3.8.1 åŒé‡æ£€æŸ¥é”å®šçš„ç”±æ¥ å¸Œæœ›é€šè¿‡åŒé‡æ£€æŸ¥é”å®šæ¥é™ä½åŒæ­¥çš„å¼€é”€ã€‚\n3.8.2 é—®é¢˜çš„æ ¹æº åˆ›å»ºå¯¹è±¡instance = new Instance();å¯ä»¥åˆ†è§£ä¸ºå¦‚ä¸‹3è¡Œä¼ªä»£ç ï¼š\n1 2 3 memory = allocate();\t// 1:åˆ†é…å¯¹è±¡çš„å†…å­˜ç©ºé—´ ctorInstance(memory);\t// 2:åˆå§‹åŒ–å¯¹è±¡ instance = memory; // 3:è®¾ç½®instanceæŒ‡å‘åˆšåˆ†é…çš„å†…å­˜åœ°å€ 2å’Œ3ä¹‹é—´ï¼Œå¯èƒ½è¢«é‡æ’åºï¼Œè¿™ä¼šå¯¼è‡´é—®é¢˜çš„å‘ç”Ÿã€‚\nä¸¤ä¸ªåŠæ³•å®ç°çº¿ç¨‹å®‰å…¨çš„å»¶è¿Ÿåˆå§‹åŒ–ï¼š\nä¸å…è®¸2å’Œ3é‡æ’åºã€‚ å…è®¸2å’Œ3é‡æ’åºï¼Œä½†ä¸å…è®¸å…¶ä»–çº¿ç¨‹â€œçœ‹åˆ°â€è¿™ä¸ªé‡æ’åºã€‚ 3.8.3 åŸºäºvolatileçš„è§£å†³æ–¹æ¡ˆ åœ¨åŒé‡æ£€æŸ¥é”å®šæ–¹æ³•çš„åŸºç¡€ä¸Šå°†instanceå£°æ˜ä¸ºvolatileå‹ã€‚\n1 private volatile static Instance instance; 2å’Œ3ä¹‹é—´çš„é‡æ’åºåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­ä¼šè¢«ç¦æ­¢ã€‚\n3.8.4 åŸºäºç±»åˆå§‹åŒ–çš„è§£å†³æ–¹æ¡ˆ å¾…è¯»ã€‚\n3.9 Javaå†…å­˜æ¨¡å‹ç»¼è¿° 3.9.1 å¤„ç†å™¨çš„å†…å­˜æ¨¡å‹ ç”±äºå¸¸è§çš„å¤„ç†å™¨å†…å­˜æ¨¡å‹æ¯”JMMè¦å¼±ï¼ŒJavaç¼–è¯‘å™¨åœ¨ç”Ÿæˆå­—èŠ‚ç æ—¶ï¼Œä¼šåœ¨æ‰§è¡ŒæŒ‡ä»¤åºåˆ—çš„é€‚å½“ä½ç½®æ’å…¥å†…å­˜å±éšœæ¥é™åˆ¶å¤„ç†å™¨çš„é‡æ’åºã€‚JMMåœ¨ä¸åŒçš„å¤„ç†å™¨ä¸­éœ€è¦æ’å…¥çš„å†…å­˜å±éšœçš„æ•°é‡å’Œç§ç±»ä¹Ÿä¸ç›¸åŒã€‚\n3.9.2 å„ç§å†…å­˜æ¨¡å‹ä¹‹é—´çš„å…³ç³» JMMæ˜¯ä¸€ä¸ªè¯­è¨€çº§çš„å†…å­˜æ¨¡å‹ï¼Œå¤„ç†å™¨å†…å­˜æ¨¡å‹æ˜¯ç¡¬ä»¶çº§çš„å†…å­˜æ¨¡å‹ï¼Œé¡ºåºä¸€è‡´æ€§å†…å­˜æ¨¡å‹æ˜¯ä¸€ä¸ªç†è®ºå‚è€ƒæ¨¡å‹ã€‚\n3.9.3 JMMçš„å†…å­˜å¯è§æ€§ä¿è¯ ä¸‰ç±»ï¼š\nå•çº¿ç¨‹ç¨‹åºã€‚ æ­£ç¡®åŒæ­¥çš„å¤šçº¿ç¨‹ç¨‹åºã€‚ æœªåŒæ­¥/æœªæ­£ç¡®åŒæ­¥çš„å¤šçº¿ç¨‹ç¨‹åºã€‚æä¾›æœ€å°å®‰å…¨ä¿éšœï¼šçº¿ç¨‹æ‰§è¡Œæ—¶è¯»å–åˆ°çš„å€¼ï¼Œè¦ä¹ˆæ˜¯ä¹‹å‰æŸä¸ªçº¿ç¨‹å†™å…¥çš„å€¼ï¼Œè¦ä¹ˆæ˜¯é»˜è®¤å€¼ï¼ˆ0ã€nullã€falseï¼‰ã€‚ æœ€å°å®‰å…¨ä¿éšœä¸64ä½æ•°æ®çš„éåŸå­æ€§å†™å¹¶ä¸çŸ›ç›¾ã€‚æœ€å°å®‰å…¨æ€§å¹¶ä¸ä¿è¯çº¿ç¨‹è¯»å–åˆ°çš„å€¼ï¼Œä¸€å®šæ˜¯æŸä¸ªçº¿ç¨‹å†™å®Œåçš„å€¼ã€‚æœ€å°å®‰å…¨æ€§ä¿è¯çº¿ç¨‹è¯»å–åˆ°çš„å€¼ä¸ä¼šæ˜¯æ— ä¸­ç”Ÿæœ‰çš„å†’å‡ºæ¥ï¼Œä½†å¹¶ä¸ä¿è¯çº¿ç¨‹è¯»å–åˆ°çš„å€¼ä¸€å®šæ˜¯æ­£ç¡®çš„ã€‚\n3.9.4 JSR-133å¯¹æ—§å†…å­˜æ¨¡å‹çš„ä¿®è¡¥ ä¸»è¦æœ‰ä¸¤ä¸ªï¼š\nå¢å¼ºvolatileçš„å†…å­˜è¯­ä¹‰ã€‚ å¢å¼ºfinalçš„å†…å­˜è¯­ä¹‰ã€‚ ç¬¬4ç«  Javaå¹¶å‘ç¼–ç¨‹åŸºç¡€ 4.1 çº¿ç¨‹ç®€ä»‹ 4.1.1 ä»€ä¹ˆæ˜¯çº¿ç¨‹ ç°ä»£æ“ä½œç³»ç»Ÿè°ƒåº¦çš„æœ€å°å•å…ƒæ˜¯çº¿ç¨‹ï¼Œä¹Ÿå«è½»é‡çº§è¿›ç¨‹ï¼Œåœ¨ä¸€ä¸ªè¿›ç¨‹é‡Œå¯ä»¥åˆ›å»ºå¤šä¸ªçº¿ç¨‹ï¼Œè¿™äº›çº¿ç¨‹éƒ½æ‹¥æœ‰å„è‡ªçš„è®¡æ•°å™¨ã€å †æ ˆå’Œå±€éƒ¨å˜é‡ç­‰å±æ€§ï¼Œå¹¶ä¸”èƒ½å¤Ÿè®¿é—®å…±äº«çš„å†…å­˜å˜é‡ã€‚\nJavaç¨‹åºå¤©ç”Ÿå°±æ˜¯å¤šçº¿ç¨‹ç¨‹åºï¼Œå› ä¸ºæ‰§è¡Œmain()æ–¹æ³•çš„æ˜¯ä¸€ä¸ªåç§°ä¸ºmainçš„çº¿ç¨‹ã€‚\n4.1.2 ä¸ºä»€ä¹ˆè¦ä½¿ç”¨å¤šçº¿ç¨‹ æ›´å¤šçš„å¤„ç†å™¨æ ¸å¿ƒ æ›´å¿«çš„å“åº”æ—¶é—´ æ›´å¥½çš„ç¼–ç¨‹æ¨¡å‹ 4.1.3 çº¿ç¨‹ä¼˜å…ˆçº§ åœ¨Javaçº¿ç¨‹ä¸­ï¼Œé€šè¿‡ä¸€ä¸ªæ•´å‹æˆå‘˜å˜é‡priorityæ¥æ§åˆ¶ä¼˜å…ˆçº§ï¼Œä¼˜å…ˆçº§çš„èŒƒå›´ä»1ï½10ï¼Œåœ¨çº¿ç¨‹æ„å»ºçš„æ—¶å€™å¯ä»¥é€šè¿‡setPriority(int)æ–¹æ³•æ¥ä¿®æ”¹ä¼˜å…ˆçº§ï¼Œé»˜è®¤ä¼˜å…ˆçº§æ˜¯5ï¼Œä¼˜å…ˆçº§é«˜çš„çº¿ç¨‹åˆ†é…æ—¶é—´ç‰‡çš„æ•°é‡è¦å¤šäºä¼˜å…ˆçº§ä½çš„çº¿ç¨‹ã€‚\nç¨‹åºæ­£ç¡®æ€§ä¸èƒ½ä¾èµ–çº¿ç¨‹çš„ä¼˜å…ˆçº§é«˜ä½ï¼Œæœ‰äº›æ“ä½œç³»ç»Ÿä¼šå¿½ç•¥å¯¹çº¿ç¨‹ä¼˜å…ˆçº§çš„è®¾å®šã€‚\n4.1.4 çº¿ç¨‹çš„çŠ¶æ€ çº¿ç¨‹åœ¨æ‰§è¡ŒRunnableçš„run()æ–¹æ³•ä¹‹åå°†ä¼šè¿›å…¥ç»ˆæ­¢çŠ¶æ€ã€‚\n4.1.5 Daemonçº¿ç¨‹ Daemonçº¿ç¨‹æ˜¯ä¸€ç§æ”¯æŒå‹çº¿ç¨‹ï¼Œå› ä¸ºå®ƒä¸»è¦è¢«ç”¨åšç¨‹åºä¸­åå°è°ƒåº¦åŠæ”¯æŒæ€§å·¥ä½œï¼Œä¹Ÿå°±æ˜¯å®ˆæŠ¤çº¿ç¨‹ã€‚å½“ä¸€ä¸ªJavaè™šæ‹Ÿæœºä¸­ä¸å­˜åœ¨éDaemonçº¿ç¨‹çš„æ—¶å€™ï¼ŒJavaè™šæ‹Ÿæœºå°†ä¼šé€€å‡ºã€‚\nè°ƒç”¨Thread.setDaemon(true)å°†çº¿ç¨‹è®¾ç½®ä¸ºDaemonçº¿ç¨‹ã€‚\nåœ¨Javaè™šæ‹Ÿæœºé€€å‡ºæ—¶Daemonçº¿ç¨‹ä¸­çš„finallyå—ä¸ä¸€å®šä¼šæ‰§è¡Œã€‚\n4.2 å¯åŠ¨å’Œç»ˆæ­¢çº¿ç¨‹ 4.2.1 æ„é€ çº¿ç¨‹ æ„é€ ä¸€ä¸ªçº¿ç¨‹ï¼Œä¼šè°ƒç”¨Thread.javaä¸­çš„æ„é€ å™¨ï¼š\n1 2 3 public Thread(Runnable target, String name) { init(null, target, name, 0); } æ¥ç€è°ƒç”¨initæ–¹æ³•ï¼š\n1 2 3 4 private void init(ThreadGroup g, Runnable target, String name, long stackSize) { init(g, target, name, stackSize, null, true); } è°ƒç”¨ä¸‹é¢çš„initæ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { if (name == null) { throw new NullPointerException(\u0026#34;name cannot be null\u0026#34;); } this.name = name; // å½“å‰çº¿ç¨‹å°±æ˜¯è¯¥çº¿ç¨‹çš„çˆ¶çº¿ç¨‹ Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it\u0026#39;s an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn\u0026#39;t have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; // å°† daemonã€priorityå±æ€§è®¾ç½®ä¸ºçˆ¶çº¿ç¨‹çš„å¯¹åº”å±æ€§ this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); // å°†çˆ¶çº¿ç¨‹çš„ inheritThreadLocal å¤åˆ¶è¿‡æ¥ if (inheritThreadLocals \u0026amp;\u0026amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); // åˆ†é…ä¸€ä¸ªçº¿ç¨‹ID } ä¸€ä¸ªæ–°æ„é€ çš„çº¿ç¨‹å¯¹è±¡æ˜¯ç”±å…¶parentçº¿ç¨‹æ¥è¿›è¡Œç©ºé—´åˆ†é…çš„ï¼Œè€Œchildçº¿ç¨‹ç»§æ‰¿äº†parentæ˜¯å¦ä¸ºDaemonã€ä¼˜å…ˆçº§å’ŒåŠ è½½èµ„æºçš„contextClassLoaderä»¥åŠå¯ç»§æ‰¿çš„ThreadLocalï¼ŒåŒæ—¶è¿˜ä¼šåˆ†é…ä¸€ä¸ªå”¯ä¸€çš„IDæ¥æ ‡è¯†è¿™ä¸ªchildçº¿ç¨‹ã€‚\n4.2.2 å¯åŠ¨çº¿ç¨‹ çº¿ç¨‹strart()æ–¹æ³•çš„å«ä¹‰ï¼šå½“å‰çº¿ç¨‹ï¼ˆå³parentçº¿ç¨‹ï¼‰åŒæ­¥å‘ŠçŸ¥Javaè™šæ‹Ÿæœºï¼Œåªè¦çº¿ç¨‹è§„åˆ’å™¨ç©ºé—²ï¼Œåº”ç«‹å³å¯åŠ¨è°ƒç”¨start()æ–¹æ³•çš„çº¿ç¨‹ã€‚\n4.2.3 ç†è§£ä¸­æ–­ ä¸­æ–­å¯ä»¥ç†è§£ä¸ºçº¿ç¨‹çš„ä¸€ä¸ªæ ‡è¯†ä½å±æ€§ï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªè¿è¡Œä¸­çš„çº¿ç¨‹æ˜¯å¦è¢«å…¶ä»–çº¿ç¨‹è¿›è¡Œäº†ä¸­æ–­æ“ä½œã€‚\nçº¿ç¨‹é€šè¿‡æ£€æŸ¥è‡ªèº«æ˜¯å¦è¢«ä¸­æ–­æ¥è¿›è¡Œå“åº”ï¼Œçº¿ç¨‹é€šè¿‡æ–¹æ³•isInterrupted()æ¥è¿›è¡Œåˆ¤æ–­æ˜¯å¦è¢«ä¸­æ–­ã€‚\n1 2 3 4 5 public boolean isInterrupted() { return isInterrupted(false); } private native boolean isInterrupted(boolean ClearInterrupted); æˆ–è€…è°ƒç”¨é™æ€æ–¹æ³•Thread.interrupted()å¯¹å½“å‰çº¿ç¨‹çš„ä¸­æ–­æ ‡è¯†ä½è¿›è¡Œå¤ä½ã€‚\n1 2 3 public static boolean interrupted() { return currentThread().isInterrupted(true); } å¦‚æœè¯¥çº¿ç¨‹å·²ç»å¤„äºç»ˆç»“çŠ¶æ€ï¼Œå³ä½¿è¯¥çº¿ç¨‹è¢«ä¸­æ–­è¿‡ï¼Œåœ¨è°ƒç”¨è¯¥çº¿ç¨‹å¯¹è±¡çš„isInterrupted()æ—¶ä¾æ—§ä¼šè¿”å›falseã€‚\nè®¸å¤šæ–¹æ³•åœ¨æŠ›å‡ºInterruptedExceptionä¹‹å‰ï¼ŒJavaè™šæ‹Ÿæœºä¼šå…ˆå°†è¯¥çº¿ç¨‹çš„ä¸­æ–­æ ‡è¯†ä½æ¸…é™¤ï¼Œç„¶åæŠ›å‡ºInterruptedExceptionï¼Œæ­¤æ—¶è°ƒç”¨isInterrupted()æ–¹æ³•å°†ä¼šè¿”å›falseã€‚\n1 2 3 4 5 6 7 /** * @throws InterruptedException * if any thread has interrupted the current thread. The * \u0026lt;i\u0026gt;interrupted status\u0026lt;/i\u0026gt; of the current thread is * cleared when this exception is thrown. */ public static native void sleep(long millis) throws InterruptedException; 4.2.4 è¿‡æœŸçš„suspend()ã€resume()å’Œstop() suspend()ã€resume()å’Œstop()ç±»ä¼¼CDæœºæ’­æ”¾éŸ³ä¹æ—¶çš„æš‚åœã€æ¢å¤å’Œåœæ­¢æ“ä½œã€‚\n4.2.5 å®‰å…¨åœ°ç»ˆæ­¢çº¿ç¨‹ ä¸­æ–­æ“ä½œ åˆ©ç”¨ä¸€ä¸ªbooleanå˜é‡æ¥æ§åˆ¶æ˜¯å¦éœ€è¦åœæ­¢ä»»åŠ¡å¹¶ç»ˆæ­¢è¯¥çº¿ç¨‹ã€‚ è¿™ä¸¤ç§æ–¹æ³•å¯ä»¥ä½¿çº¿ç¨‹åœ¨ç»ˆæ­¢æ—¶æœ‰æœºä¼šå»æ¸…ç†èµ„æºã€‚\n4.3 çº¿ç¨‹é—´é€šä¿¡ 4.3.1 volatileå’Œsynchronizedå…³é”®å­— Javaæ”¯æŒå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®ä¸€ä¸ªå¯¹è±¡æˆ–è€…å¯¹è±¡çš„æˆå‘˜å˜é‡ï¼Œç”±äºæ¯ä¸ªçº¿ç¨‹å¯ä»¥æ‹¥æœ‰è¿™ä¸ªå˜é‡çš„æ‹·è´ï¼Œæ‰€ä»¥ç¨‹åºåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œä¸€ä¸ªçº¿ç¨‹çœ‹åˆ°çš„å˜é‡ä¸ä¸€å®šæ˜¯æœ€æ–°çš„ã€‚ å…³é”®å­—volatileå¯ä»¥ç”¨æ¥ä¿®é¥°å­—æ®µï¼ˆæˆå‘˜å˜é‡ï¼‰ã€‚ å…³é”®å­—synchronizedå¯ä»¥ä¿®é¥°æ–¹æ³•æˆ–è€…ä»¥åŒæ­¥å—çš„å½¢å¼æ¥è¿›è¡Œä½¿ç”¨ã€‚ é€šè¿‡classä¿¡æ¯ï¼Œå¯¹äºåŒæ­¥å—çš„å®ç°ä½¿ç”¨äº†monitorenterå’ŒmonitorexitæŒ‡ä»¤ï¼Œè€ŒåŒæ­¥æ–¹æ³•åˆ™æ˜¯ä¾é æ–¹æ³•ä¿®é¥°ç¬¦ä¸Šçš„ACC_SYNCHRONIZEDæ¥å®Œæˆã€‚ æ— è®ºé‡‡ç”¨å“ªç§æ–¹å¼ï¼Œå…¶æœ¬è´¨æ˜¯å¯¹ä¸€ä¸ªå¯¹è±¡çš„ç›‘è§†å™¨è¿›è¡Œè·å–ï¼Œè€Œè¿™ä¸ªè·å–è¿‡ç¨‹æ˜¯æ’ä»–çš„ï¼Œä¹Ÿå°±æ˜¯åŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹è·å–åˆ°ç”±synchronizedæ‰€ä¿æŠ¤å¯¹è±¡çš„ç›‘è§†å™¨ã€‚ ä»»æ„ä¸€ä¸ªå¯¹è±¡éƒ½æ‹¥æœ‰è‡ªå·±çš„ç›‘è§†å™¨ã€‚ å¯¹è±¡ã€ç›‘è§†å™¨ã€åŒæ­¥é˜Ÿåˆ—å’Œæ‰§è¡Œçº¿ç¨‹ä¹‹é—´çš„å…³ç³»å›¾ 4.3.2 ç­‰å¾…/é€šçŸ¥æœºåˆ¶ ç­‰å¾…/é€šçŸ¥çš„ç›¸å…³æ–¹æ³•æ˜¯ä»»æ„Javaå¯¹è±¡éƒ½å…·å¤‡çš„ï¼Œè¢«å®šä¹‰åœ¨è¶…ç±»java.lang.Objectä¸Šã€‚ ç­‰å¾…/é€šçŸ¥æœºåˆ¶ï¼Œæ˜¯æŒ‡ä¸€ä¸ªçº¿ç¨‹Aè°ƒç”¨äº†å¯¹è±¡Oçš„wait()æ–¹æ³•è¿›å…¥ç­‰å¾…çŠ¶æ€ï¼Œè€Œå¦ä¸€ä¸ªçº¿ç¨‹Bè°ƒç”¨äº†å¯¹è±¡Oçš„notify()æˆ–è€…notifyAll()æ–¹æ³•ï¼Œçº¿ç¨‹Aæ”¶åˆ°é€šçŸ¥åä»å¯¹è±¡Oçš„wait()æ–¹æ³•è¿”å›ï¼Œè¿›è€Œæ‰§è¡Œåç»­æ“ä½œã€‚ ç»†èŠ‚ï¼š\nä½¿ç”¨wait()ã€notify()å’ŒnotifyAll()æ—¶éœ€è¦å…ˆå¯¹è°ƒç”¨å¯¹è±¡åŠ é”ã€‚ è°ƒç”¨wait()æ–¹æ³•åï¼Œçº¿ç¨‹çŠ¶æ€ç”±RUNNINGå˜ä¸ºWAITINGï¼Œå¹¶å°†å½“å‰çº¿ç¨‹æ”¾ç½®åˆ°å¯¹è±¡çš„ç­‰å¾…é˜Ÿåˆ—ã€‚ notify()æˆ–notifyAll()æ–¹æ³•è°ƒç”¨åï¼Œç­‰å¾…çº¿ç¨‹ä¾æ—§ä¸ä¼šä»wait()è¿”å›ï¼Œéœ€è¦è°ƒç”¨notify()æˆ–notifyAll()çš„çº¿ç¨‹é‡Šæ”¾é”ä¹‹åï¼Œç­‰å¾…çº¿ç¨‹æ‰æœ‰æœºä¼šä»wait()è¿”å›ã€‚ notify()æ–¹æ³•å°†ç­‰å¾…é˜Ÿåˆ—ä¸­çš„ä¸€ä¸ªç­‰å¾…çº¿ç¨‹ä»ç­‰å¾…é˜Ÿåˆ—ä¸­ç§»åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œè€ŒnotifyAll()æ–¹æ³•åˆ™æ˜¯å°†ç­‰å¾…é˜Ÿåˆ—ä¸­æ‰€æœ‰çš„çº¿ç¨‹å…¨éƒ¨ç§»åˆ°åŒæ­¥é˜Ÿåˆ—ï¼Œè¢«ç§»åŠ¨çš„çº¿ç¨‹çŠ¶æ€ç”±WAITINGå˜ä¸ºBLOCKEDã€‚ ä»wait()æ–¹æ³•è¿”å›çš„å‰ææ˜¯è·å¾—äº†è°ƒç”¨å¯¹è±¡çš„é”ã€‚ 4.3.3 ç­‰å¾…/é€šçŸ¥çš„ç»å…¸èŒƒå¼ ç­‰å¾…æ–¹éµå¾ªå¦‚ä¸‹åŸåˆ™ï¼š\nè·å–å¯¹è±¡çš„é”ã€‚ å¦‚æœæ¡ä»¶ä¸æ»¡è¶³ï¼Œé‚£ä¹ˆè°ƒç”¨å¯¹è±¡çš„wait()æ–¹æ³•ï¼Œè¢«é€šçŸ¥åä»è¦æ£€æŸ¥æ¡ä»¶ã€‚ æ¡ä»¶æ»¡è¶³åˆ™æ‰§è¡Œå¯¹åº”çš„é€»è¾‘ã€‚ é€šçŸ¥æ–¹éµå¾ªå¦‚ä¸‹åŸåˆ™ï¼š\nè·å¾—å¯¹è±¡çš„é”ã€‚ æ”¹å˜æ¡ä»¶ã€‚ é€šçŸ¥æ‰€æœ‰ç­‰å¾…åœ¨å¯¹è±¡ä¸Šçš„çº¿ç¨‹ã€‚ 4.3.4 ç®¡é“è¾“å…¥/è¾“å‡ºæµ ç®¡é“è¾“å…¥/è¾“å‡ºæµä¸»è¦ç”¨äºçº¿ç¨‹ä¹‹é—´çš„æ•°æ®ä¼ è¾“ï¼Œè€Œä¼ è¾“çš„åª’ä»‹ä¸ºå†…å­˜ã€‚ 4ç§å…·ä½“å®ç°ï¼šPipedOutputStreamã€PipedOutputStreamã€PipedReaderå’ŒPipedWriterï¼Œå‰ä¸¤ç§é¢å‘å­—èŠ‚ï¼Œåä¸¤ç§é¢å‘å­—ç¬¦ã€‚ å¯¹äºPipedç±»å‹çš„æµï¼Œå¿…é¡»å…ˆè¦è¿›è¡Œç»‘å®šï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨connect()æ–¹æ³•ï¼Œå¦‚æœæ²¡æœ‰å°†è¾“å…¥/è¾“å‡ºæµç»‘å®šèµ·æ¥ï¼Œå¯¹äºè¯¥æµçš„è®¿é—®å°†ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚ 4.3.5 Thread.join()çš„ä½¿ç”¨ å¦‚æœä¸€ä¸ªçº¿ç¨‹Aæ‰§è¡Œäº†thread.join()è¯­å¥ï¼Œå…¶å«ä¹‰æ˜¯ï¼šå½“çº¿ç¨‹Aç­‰å¾…threadçº¿ç¨‹ç»ˆæ­¢ä¹‹åæ‰ä»thread.join()è¿”å›ã€‚ æ¯ä¸ªçº¿ç¨‹ç»ˆæ­¢çš„å‰ææ˜¯å‰é©±çº¿ç¨‹ç»ˆæ­¢ï¼Œæ¯ä¸ªçº¿ç¨‹ç­‰å¾…å‰é©±çº¿ç¨‹ç»ˆæ­¢åï¼Œæ‰ä»join()æ–¹æ³•è¿”å›ï¼Œè¿™é‡Œæ¶‰åŠäº†ç­‰å¾…/é€šçŸ¥æœºåˆ¶ã€‚ å½“çº¿ç¨‹ç»ˆæ­¢æ—¶ï¼Œä¼šè°ƒç”¨çº¿ç¨‹è‡ªèº«çš„notifyAll()æ–¹æ³•ï¼Œä¼šé€šçŸ¥æ‰€æœ‰ç­‰å¾…åœ¨è¯¥çº¿ç¨‹å¯¹è±¡ä¸Šçš„çº¿ç¨‹ã€‚ 4.3.6 ThreadLocalçš„ä½¿ç”¨ ThreadLocalï¼Œå³çº¿ç¨‹å˜é‡ï¼Œæ˜¯ä¸€ä¸ªä»¥ThreadLocalå¯¹è±¡ä¸ºé”®ã€ä»»æ„å¯¹è±¡ä¸ºå€¼çš„å­˜å‚¨ç»“æ„ï¼Œè¿™ä¸ªç»“æ„è¢«é™„å¸¦åœ¨çº¿ç¨‹ä¸Šï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æ ¹æ®ä¸€ä¸ªThreadLocalå¯¹è±¡æŸ¥è¯¢åˆ°ç»‘å®šåœ¨è¿™ä¸ªçº¿ç¨‹ä¸Šçš„ä¸€ä¸ªå€¼ã€‚ å¯ä»¥é€šè¿‡set(T)æ–¹æ³•æ¥è®¾ç½®ä¸€ä¸ªå€¼ï¼Œåœ¨å½“å‰çº¿ç¨‹ä¸‹å†é€šè¿‡get()æ–¹æ³•è·å–åˆ°åŸå…ˆè®¾ç½®çš„å€¼ã€‚ ","date":"2022-03-28T00:00:00Z","image":"https://wenjin1997.github.io/img/2022-03-28-The-Art-of-Java-Concurrency-Programming/background.jpg","permalink":"https://wenjin1997.github.io/2022/03/28/The-Art-of-Java-Concurrency-Programming/","title":"Javaå¹¶å‘ç¼–ç¨‹çš„è‰ºæœ¯ç¬”è®°"},{"content":"åˆ›å»ºMatlabå¿«æ·æ–¹å¼ åœ¨å‘½ä»¤çª—å£æ‰§è¡Œå¦‚ä¸‹å‘½ä»¤ï¼Œå‚è€ƒLinuxä¸‹å®‰è£…matlabåŠåˆ›å»ºå¿«æ·æ–¹å¼ 1 sudo gedit /usr/share/applications/matlab.desktop åœ¨æ–‡ä»¶ä¸­è¾“å…¥å¦‚ä¸‹å‘½ä»¤ï¼š 1 2 3 4 5 6 7 8 9 10 [Desktop Entry] Encoding=UTF-8 Name=matlab Comment=MATLAB R2014b Exec=/usr/local/MATLAB/R2014b/bin/matlab -desktop Icon=/usr/local/MATLAB/R2014b/bin/matlab_logo.png Terminal=false StartupNotify=true Type=Application Categories=Application;Development; ä¸»è¦æ˜¯Execå’ŒIconè·¯å¾„å†™å¯¹ã€‚ 3. ç”¨ä¸‹é¢çš„å‘½ä»¤å¯ä»¥æ‰“å¼€åº”ç”¨åˆ—è¡¨ç›®å½•ï¼Œå‚è€ƒubuntuåˆ é™¤å›¾æ ‡\n1 sudo nautilus /usr/share/applications åˆ›å»ºAnacondaå¿«æ·æ–¹å¼ ä¸ä¸Šè¿°è¿‡ç¨‹ç±»ä¼¼ï¼ŒAnaconda.desktopæ–‡ä»¶å†…å®¹å¦‚ä¸‹ï¼š\n1 sudo gedit /usr/share/applications/Anaconda.desktop 1 2 3 4 5 6 7 8 9 10 11 12 [Desktop Entry] Version=1.0 Name=Anaconda Type=Application GenericName=Anaconda Comment=Scientific Python Development Environment - Python3 Exec=sh /home/ä½ çš„anaconda3æ‰€åœ¨æ–‡ä»¶å¤¹å/anaconda3/bin/anaconda-navigator Categories=Development;Science;IDE;Qt;Education; Icon=/home/ä½ çš„anaconda3æ‰€åœ¨æ–‡ä»¶å¤¹å/anaconda3/lib/python3.7/site-packages/anaconda_navigator/static/images/anaconda-icon-256x256.png Terminal=false StartupNotify=true MimeType=text/x-python; ","date":"2022-03-23T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/03/23/Ubuntu/","title":"Ubuntuä¸‹åˆ›å»ºå¿«æ·æ–¹å¼"},{"content":"è¯¾ç¨‹ä»‹ç» å­¦ä¹ è®¡ç®—æœºç½‘ç»œæ—¶æ‰¾åˆ°äº†è¿™å¥—è¯¾ç¨‹ï¼Œä½œä¸ºå…¥é—¨è¿˜æ˜¯ä¸é”™çš„ï¼Œè€å¸ˆçš„PPTéƒ½å¾ˆé€šä¿—æ˜“æ‡‚ã€‚å¯ä»¥åœ¨MOOCè®¡ç®—æœºç½‘ç»œä¸Šä¸‹è½½è¯¾ç¨‹PPTï¼ŒBç«™ä¸Šè®¡ç®—æœºç½‘ç»œå¾®è¯¾å ‚ï¼ˆæœ‰å­—å¹•æ— èƒŒæ™¯éŸ³ä¹ç‰ˆï¼‰ä¹Ÿæœ‰è¯¾ç¨‹è§†é¢‘ã€‚\nç¬¬1ç«  æ¦‚è¿° 1.1 è®¡ç®—æœºç½‘ç»œåœ¨ä¿¡æ¯æ—¶ä»£çš„ä½œç”¨ ç•¥ã€‚\n1.2 å› ç‰¹ç½‘æ¦‚è¿° ç½‘ç»œæ˜¯ç”±è‹¥å¹²ç»“ç‚¹å’Œè¿æ¥è¿™äº›ç»“ç‚¹çš„é“¾è·¯ç»„æˆã€‚\nå¤šä¸ªç½‘ç»œå¯ä»¥é€šè¿‡è·¯ç”±å™¨äº’è¿èµ·æ¥ï¼Œè¿™æ ·å°±æ„æˆäº†ä¸€ä¸ªè¦†ç›–èŒƒå›´æ›´å¤§çš„ç½‘ç»œï¼Œå³äº’è”ç½‘ã€‚å› æ­¤ï¼Œäº’è”ç½‘å°±æ˜¯â€œç½‘ç»œçš„ç½‘ç»œâ€ã€‚\nå› ç‰¹ç½‘æ˜¯ä¸–ç•Œä¸Šæœ€å¤§çš„äº’è¿ç½‘ç»œã€‚å®ƒæ˜¯ä¸€ä¸ªä¸“ç”¨åè¯ï¼Œé‡‡ç”¨TCP/IPåè®®æ—ä½œä¸ºé€šä¿¡çš„è§„åˆ™ï¼Œå…¶å‰èº«æ˜¯ç¾å›½çš„ARPANETã€‚\nISP(Internet Service Provider)ï¼šå› ç‰¹ç½‘æœåŠ¡æä¾›è€…ã€‚ä¾‹å¦‚å›½å†…çš„ä¸­å›½ç”µä¿¡ã€ä¸­å›½è”é€šå’Œä¸­å›½ç§»åŠ¨ã€‚\nå› ç‰¹ç½‘çš„ç»„æˆï¼šè¾¹ç¼˜éƒ¨åˆ†+æ ¸å¿ƒéƒ¨åˆ†\n1.3 ç”µè·¯äº¤æ¢ã€åˆ†ç»„äº¤æ¢ã€æŠ¥æ–‡äº¤æ¢ åˆ†ç»„äº¤æ¢ï¼š\nå‘é€æ–¹ï¼šæ„é€ åˆ†ç»„ã€å‘é€åˆ†ç»„ è·¯ç”±å™¨ï¼šå­˜å‚¨è½¬å‘åˆ†ç»„ æ¥æ”¶æ–¹ï¼šæ¥æ”¶åˆ†ç»„ã€è¿˜åŸæŠ¥æ–‡ åˆ†ç»„äº¤æ¢çš„ä¼˜ç¼ºç‚¹ï¼š\nä¼˜ç‚¹ æ— éœ€å»ºç«‹è¿æ¥ çº¿è·¯åˆ©ç”¨ç‡é«˜ ç®€åŒ–äº†å­˜å‚¨ç®¡ç† åŠ é€Ÿä¼ è¾“ å‡å°‘å‡ºé”™æ¦‚ç‡å’Œé‡å‘æ•°æ®é‡ ç¼ºç‚¹ å¼•å‘äº†è½¬å‘æ—¶å»¶ éœ€è¦é¢å¤–çš„ä¿¡æ¯é‡ å¯¹äºæ•°æ®æŠ¥æœåŠ¡ï¼Œå­˜åœ¨å¤±åºã€ä¸¢å¤±å’Œé‡å¤åˆ†ç»„çš„é—®é¢˜ï¼›å¯¹äºè™šç”µè·¯æœåŠ¡ï¼Œå­˜åœ¨å‘¼å«å»ºç«‹ã€æ•°æ®ä¼ è¾“å’Œè™šç”µè·¯é‡Šæ”¾ä¸‰ä¸ªè¿‡ç¨‹ 1.4 è®¡ç®—æœºç½‘ç»œçš„å®šä¹‰ä¸åˆ†ç±» è®¡ç®—æœºç½‘ç»œï¼šä¸€äº›äº’ç›¸è¿æ¥çš„ã€è‡ªæ²»çš„è®¡ç®—æœºçš„é›†åˆã€‚\n1.5 è®¡ç®—æœºç½‘ç»œçš„æ€§èƒ½æŒ‡æ ‡ ğŸš©1.6 è®¡ç®—æœºç½‘ç»œä½“ç³»ç»“æ„ åº”ç”¨å±‚ :è§£å†³é€šè¿‡åº”ç”¨è¿›ç¨‹çš„äº¤äº’æ¥å®ç°ç‰¹å®šç½‘ç»œåº”ç”¨çš„é—®é¢˜ã€‚ä¸ºç‰¹å®šåº”ç”¨ç¨‹åºæä¾›æ•°æ®ä¼ è¾“æœåŠ¡ï¼Œä¾‹å¦‚ HTTPã€DNS ç­‰åè®®ã€‚æ•°æ®å•ä½ä¸ºæŠ¥æ–‡ã€‚\nè¡¨ç¤ºå±‚ :æ•°æ®å¤„ç†ï¼ˆç¼–è§£ç ã€åŠ å¯†è§£å¯†ã€å‹ç¼©è§£å‹ç¼©ï¼‰ã€‚\nä¼šè¯å±‚ :ç®¡ç†ï¼ˆå»ºç«‹ã€ç»´æŠ¤ã€é‡è¿ï¼‰åº”ç”¨ç¨‹åºä¹‹é—´çš„å¯¹è¯ã€‚\nä¼ è¾“å±‚ :è§£å†³è¿›ç¨‹ä¹‹é—´åŸºäºç½‘ç»œçš„é€šä¿¡é—®é¢˜ã€‚ä¸ºè¿›ç¨‹æä¾›é€šç”¨æ•°æ®ä¼ è¾“æœåŠ¡ã€‚ç”±äºåº”ç”¨å±‚åè®®å¾ˆå¤šï¼Œå®šä¹‰é€šç”¨çš„ä¼ è¾“å±‚åè®®å°±å¯ä»¥æ”¯æŒä¸æ–­å¢å¤šçš„åº”ç”¨å±‚åè®®ã€‚è¿è¾“å±‚åŒ…æ‹¬ä¸¤ç§åè®®:ä¼ è¾“æ§åˆ¶åè®® TCPï¼Œæä¾›é¢å‘è¿æ¥ã€å¯é çš„æ•°æ®ä¼ è¾“æœåŠ¡ï¼Œæ•°æ®å•ä½ä¸ºæŠ¥æ–‡æ®µ;ç”¨æˆ·æ•°æ®æŠ¥åè®® UDPï¼Œæä¾› æ— è¿æ¥ã€å°½æœ€å¤§åŠªåŠ›çš„æ•°æ®ä¼ è¾“æœåŠ¡ï¼Œæ•°æ®å•ä½ä¸ºç”¨æˆ·æ•°æ®æŠ¥ã€‚TCP ä¸»è¦æä¾›å®Œæ•´æ€§æœåŠ¡ï¼ŒUDP ä¸»è¦æä¾›åŠæ—¶æ€§æœåŠ¡ã€‚\nç½‘ç»œå±‚ :è§£å†³åˆ†ç»„åœ¨å¤šä¸ªç½‘ç»œä¸Šä¼ è¾“ï¼ˆè·¯ç”±ï¼‰çš„é—®é¢˜ã€‚ä¸ºä¸»æœºæä¾›æ•°æ®ä¼ è¾“æœåŠ¡ã€‚è€Œä¼ è¾“å±‚åè®®æ˜¯ä¸ºä¸»æœºä¸­çš„è¿›ç¨‹æä¾›æ•°æ®ä¼ è¾“æœåŠ¡ã€‚ç½‘ç»œå±‚æŠŠä¼ è¾“å±‚ä¼ é€’ä¸‹æ¥çš„æŠ¥æ–‡æ®µæˆ–è€…ç”¨æˆ·æ•°æ®æŠ¥å°è£…æˆåˆ†ç»„ã€‚\næ•°æ®é“¾è·¯å±‚ :è§£å†³åˆ†ç»„åœ¨ä¸€ä¸ªç½‘ç»œï¼ˆæˆ–ä¸€æ®µé“¾è·¯ï¼‰ä¸Šä¼ è¾“çš„é—®é¢˜ã€‚ç½‘ç»œå±‚é’ˆå¯¹çš„è¿˜æ˜¯ä¸»æœºä¹‹é—´çš„æ•°æ®ä¼ è¾“æœåŠ¡ï¼Œè€Œä¸»æœºä¹‹é—´å¯ä»¥æœ‰å¾ˆå¤šé“¾è·¯ï¼Œé“¾è·¯å±‚åè®®å°±æ˜¯ä¸ºåŒä¸€é“¾è·¯çš„ä¸»æœºæä¾›æ•°æ®ä¼ è¾“æœåŠ¡ã€‚æ•°æ®é“¾è·¯å±‚æŠŠç½‘ç»œå±‚ä¼ ä¸‹æ¥çš„åˆ†ç»„å°è£…æˆå¸§ã€‚\nç‰©ç†å±‚ :è§£å†³ä½¿ç”¨ä½•ç§ä¿¡å·æ¥ä¼ è¾“æ¯”ç‰¹çš„é—®é¢˜ã€‚è€ƒè™‘çš„æ˜¯æ€æ ·åœ¨ä¼ è¾“åª’ä½“ä¸Šä¼ è¾“æ•°æ®æ¯”ç‰¹æµï¼Œè€Œä¸æ˜¯æŒ‡å…·ä½“çš„ä¼ è¾“åª’ä½“ã€‚ç‰©ç†å±‚çš„ä½œç”¨æ˜¯å°½å¯èƒ½å±è”½ä¼ è¾“åª’ä½“å’Œé€šä¿¡æ‰‹æ®µçš„å·®å¼‚ï¼Œä½¿æ•°æ®é“¾è·¯å±‚æ„Ÿè§‰ä¸åˆ°è¿™äº›å·®å¼‚ã€‚\nç¬¬2ç«  ç‰©ç†å±‚ 2.1 ç‰©ç†å±‚çš„åŸºæœ¬æ¦‚å¿µ 2.2 ç‰©ç†å±‚ä¸‹é¢çš„ä¼ è¾“åª’ä½“ 2.3 ä¼ è¾“æ–¹å¼ 2.4 ç¼–ç ä¸è°ƒåˆ¶ 2.5 ä¿¡é“çš„æé™å®¹é‡ ç¬¬3ç«  æ•°æ®é“¾è·¯å±‚ 3.1 æ•°æ®é“¾è·¯å±‚æ¦‚è¿° 3.2 å°è£…æˆå¸§ 3.3 å·®é”™æ£€æµ‹ 3.4 å¯é ä¼ è¾“ 3.4.1 å¯é ä¼ è¾“çš„åŸºæœ¬æ¦‚å¿µ 3.4.2 åœæ­¢-ç­‰å¾…åè®®SW 3.4.3 å›é€€Nå¸§åè®®GBN 3.4.4 é€‰æ‹©é‡ä¼ åè®®SR 3.5 ç‚¹å¯¹ç‚¹åè®®PPP 3.6 åª’ä½“æ¥å…¥æ§åˆ¶MAC 3.6.1åŸºæœ¬æ¦‚å¿µ 3.6.2é™æ€åˆ’åˆ†ä¿¡é“ 3.6.3 CSMA/CD 3.6.4 CSMA/CA 3.7 MACåœ°å€ã€IPåœ°å€ä»¥åŠARPåè®® 3.7.1 MACåœ°å€ 3.7.2 IPåœ°å€ 3.7.3 ARPåè®® 3.8 é›†çº¿å™¨ä¸äº¤æ¢æœºçš„åŒºåˆ« 3.9 ä»¥å¤ªç½‘äº¤æ¢æœºè‡ªå­¦ä¹ å’Œè½¬å‘å¸§çš„æµç¨‹ 3.10 ä»¥å¤ªç½‘äº¤æ¢æœºçš„ç”Ÿæˆæ ‘åè®®STP 3.11 è™šæ‹Ÿå±€åŸŸç½‘VLAN 3.11.1æ¦‚è¿° 3.11.2 å®ç°æœºåˆ¶ ç¬¬4ç«  ç½‘ç»œå±‚ 4.1 ç½‘ç»œå±‚æ¦‚è¿° 4.2 ç½‘ç»œå±‚æä¾›çš„ä¸¤ç§æœåŠ¡ 4.3 IPv4åœ°å€ 4.3.1 IPv4åœ°å€æ¦‚è¿° 4.3.2 åˆ†ç±»ç¼–å€çš„IPv4åœ°å€ 4.3.3 åˆ’åˆ†å­ç½‘çš„IPv4åœ°å€ 4.3.4 æ— åˆ†ç±»ç¼–å€çš„IPv4åœ°å€ 4.3.5 IPv4åœ°å€çš„åº”ç”¨è§„åˆ’ 4.4 IPæ•°æ®åŒ…çš„å‘é€å’Œè½¬å‘è¿‡ç¨‹ 4.5 é™æ€è·¯ç”±é…ç½®åŠå…¶å¯èƒ½äº§ç”Ÿçš„è·¯ç”±ç¯è·¯é—®é¢˜ 4.6 è·¯ç”±é€‰æ‹©åè®® 4.6.1 è·¯ç”±é€‰æ‹©åè®®æ¦‚è¿° 4.6.2 è·¯ç”±ä¿¡æ¯åè®®RIPçš„åŸºæœ¬å·¥ä½œåŸç† 4.6.3 å¼€æ”¾æœ€çŸ­è·¯å¾„ä¼˜å…ˆOSPFçš„åŸºæœ¬å·¥ä½œåŸç† 4.6.4 è¾¹ç•Œç½‘å…³åè®®BGPçš„åŸºæœ¬å·¥ä½œåŸç† 4.7 IPv4æ•°æ®æŠ¥çš„é¦–éƒ¨æ ¼å¼ é‡è¦çš„æ˜¯èƒ½ç”»å‡ºIPv4æ•°æ®æŠ¥çš„é¦–éƒ¨æ ¼å¼\n4.8 ç½‘é™…æ§åˆ¶åè®®ICMP ç›®çš„ï¼šä¸ºäº†æ›´æœ‰æ•ˆåœ°è½¬å‘IPæ•°æ®æŠ¥å’Œæé«˜äº¤ä»˜æˆåŠŸçš„æœºä¼š å°è£…åœ¨IPæ•°æ®æŠ¥ä¸­ ICMPå·®é”™æŠ¥å‘ŠæŠ¥æ–‡åˆ†ä¸º5ç§ï¼šç»ˆç‚¹ä¸å¯è¾¾ã€æºç‚¹æŠ‘åˆ¶ã€æ—¶é—´è¶…è¿‡ã€å‚æ•°é—®é¢˜ã€æ”¹å˜è·¯ç”±ï¼ˆé‡å®šå‘ï¼‰ ä¸åº”å‘é€ICMPå·®é”™æŠ¥å‘ŠæŠ¥æ–‡ æœ‰4ç§æƒ…å†µ ICMPè¯¢é—®æŠ¥æ–‡ å›é€è¯·æ±‚å’Œå›ç­”ï¼šæµ‹è¯•ç›®çš„ç«™æ˜¯å¦å¯è¾¾ æ—¶é—´æˆ³è¯·æ±‚å’Œå›ç­”ï¼šè¿›è¡Œæ—¶é’ŸåŒæ­¥å’Œæµ‹é‡æ—¶é—´ ICMPåº”ç”¨ åˆ†ç»„ç½‘é—´æ¢æµ‹PING è·Ÿè¸ªè·¯ç”± 4.9 è™šæ‹Ÿä¸“ç”¨ç½‘VPNå’Œç½‘ç»œåœ°å€è½¬æ¢NAT VPNï¼šåˆ©ç”¨å…¬ç”¨çš„å› ç‰¹ç½‘ä½œä¸ºæœ¬æœºæ„å„ä¸“ç”¨ç½‘ç»œä¹‹é—´çš„é€šä¿¡è½½ä½“ è™šæ‹Ÿä¸“ç”¨ç½‘ä¸­çš„å„ä¸»æœºæ‰€åˆ†é…çš„åœ°å€åº”è¯¥æ˜¯æœ¬æœºæ„å¯è‡ªç”±åˆ†é…çš„ä¸“ç”¨åœ°å€ã€‚æœ‰ä¸“ç”¨åœ°å€ã€‚ NATï¼šå¯ä½¿å¤§é‡ä½¿ç”¨å†…éƒ¨ä¸“ç”¨åœ°å€çš„ç½‘ç»œç”¨æˆ·å…±äº«å°‘é‡å¤–éƒ¨å…¨çƒåœ°å€ ç½‘ç»œåœ°å€ä¸ç«¯å£å·è½¬æ¢ï¼šNAPTï¼Œç”¨ä¸€ä¸ªå…¨çƒIPåœ°å€å°±å¯ä»¥ä½¿æœ¬åœ°åœ°å€çš„ä¸»æœºåŒæ—¶å’Œå› ç‰¹ç½‘ä¸Šçš„ä¸»æœºè¿›è¡Œé€šä¿¡ã€‚ NATå¯¹å¤–ç½‘å±è”½äº†å†…ç½‘ä¸»æœºçš„ç½‘ç»œåœ°å€ï¼Œèƒ½ä¸ºå†…ç½‘çš„ä¸»æœºæä¾›ä¸€å®šçš„å®‰å…¨ä¿æŠ¤ã€‚ ç¬¬5ç«  è¿è¾“å±‚ 5.1 è¿è¾“å±‚æ¦‚è¿° è®¡ç®—æœºç½‘ç»œä½“ç³»ç»“æ„ä¸­çš„ç‰©ç†å±‚ã€æ•°æ®é“¾è·¯å±‚å’Œç½‘ç»œå±‚å…±åŒè§£å†³äº†å°†ä¸»æœºé€šè¿‡å¼‚æ„ç½‘ç»œäº’è”èµ·æ¥è¯´é¢ä¸´çš„é—®é¢˜ï¼Œå®ç°äº†ä¸»æœºåˆ°ä¸»æœºçš„é€šä¿¡ã€‚ è¿è¾“å±‚ä»»åŠ¡ï¼šä¸ºè¿è¡Œåœ¨ä¸åŒä¸»æœºä¸Šçš„åº”ç”¨è¿›ç¨‹æä¾›ç›´æ¥çš„é€šä¿¡æœåŠ¡ è¿è¾“åè®®ï¼šé¢å‘è¿æ¥çš„TCPå’Œæ— è¿æ¥çš„UDP 5.2 è¿è¾“å±‚ç«¯å£å·ã€å¤ç”¨å’Œåˆ†ç”¨çš„æ¦‚å¿µ TCP/IPä½“ç³»çš„è¿è¾“å±‚ä½¿ç”¨ç«¯å£å·æ¥åŒºåˆ†åº”ç”¨å±‚çš„ä¸åŒè¿›ç¨‹ ç†ŸçŸ¥ç«¯å£å· ç™»è®°ç«¯å£å· çŸ­æš‚ç«¯å£å· ç«¯å£å·åªå…·æœ‰æœ¬åœ°æ„ä¹‰ å‘é€æ–¹çš„å¤ç”¨å’Œæ¥æ”¶æ–¹çš„åˆ†ç”¨ ç†ŸçŸ¥ç«¯å£å· 5.3 UDPå’ŒTCPçš„å¯¹æ¯” UDPçš„é¦–éƒ¨æ ¼å¼\n5.4 TCPçš„æµé‡æ§åˆ¶ æ‰€è°“æµé‡æ§åˆ¶å°±æ˜¯è®©å‘é€æ–¹çš„å‘é€é€Ÿç‡ä¸è¦å¤ªå¿«ï¼Œè¦è®©æ¥æ”¶æ–¹æ¥å¾—åŠæ¥æ”¶ã€‚\nåˆ©ç”¨æ»‘åŠ¨çª—å£æœºåˆ¶å¯ä»¥å¾ˆæ–¹ä¾¿åœ°åœ¨TCPè¿æ¥ä¸Šå®ç°å¯¹å‘é€æ–¹çš„æµé‡æ§åˆ¶ã€‚\nTCPæ¥æ”¶æ–¹åˆ©ç”¨è‡ªå·±çš„æ¥æ”¶çª—å£çš„å¤§å°æ¥é™åˆ¶å‘é€æ–¹å‘é€çª—å£çš„å¤§å°ã€‚ TCPå‘é€æ–¹æ”¶åˆ°æ¥æ”¶æ–¹çš„é›¶çª—å£é€šçŸ¥åï¼Œåº”å¯åŠ¨æŒç»­è®¡æ—¶å™¨ã€‚æŒç»­è®¡æ—¶å™¨è¶…æ—¶åï¼Œå‘æ¥æ”¶æ–¹å‘é€é›¶çª—å£æ¢æµ‹æŠ¥æ–‡ã€‚ 5.5 TCPçš„æ‹¥å¡æ§åˆ¶ åœ¨æŸæ®µæ—¶é—´å†…ï¼Œè‹¥å¯¹ç½‘ç»œä¸­æŸä¸€èµ„æºçš„éœ€æ±‚è¶…è¿‡äº†è¯¥èµ„æºæ‰€èƒ½æä¾›çš„éƒ¨åˆ†ï¼Œç½‘ç»œæ€§èƒ½å°±è¦å˜åã€‚è¿™ç§æƒ…å†µå°±å«åšæ‹¥å¡ã€‚\n5.6 TCPè¶…æ—¶é‡ä¼ æ—¶é—´çš„é€‰æ‹© è¶…æ—¶é‡ä¼ æ—¶é—´RTOåº”ç•¥å¤§äºåŠ æƒå¹³å‡å¾€è¿”æ—¶é—´RTTsï¼ˆåˆç§°ä¸ºå¹³æ»‘çš„å¾€è¿”æ—¶é—´ï¼‰ã€‚\n5.7 TCPå¯é ä¼ è¾“çš„å®ç° 5.8 TCPçš„è¿è¾“è¿æ¥ç®¡ç† 5.8.1 TCPçš„è¿æ¥å»ºç«‹ å‘é€é’ˆå¯¹TCPè¿æ¥è¯·æ±‚çš„ç¡®è®¤çš„ç¡®è®¤ä¸å¤šä½™ï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢å¤±æ•ˆçš„è¿æ¥è¯·æ±‚æŠ¥æ–‡æ®µçªç„¶åˆé‡ä¼ åˆ°äº†TCPæœåŠ¡å™¨ï¼Œå› è€Œå¯¼è‡´é”™è¯¯ã€‚\nTCP ä¸ºä»€ä¹ˆæ˜¯ä¸‰æ¬¡æ¡æ‰‹ï¼Œè€Œä¸æ˜¯ä¸¤æ¬¡æˆ–å››æ¬¡ï¼Ÿ\n5.8.2 TCPçš„è¿æ¥é‡Šæ”¾ å‚è€ƒä¸¤å¼ åŠ¨å›¾-å½»åº•æ˜ç™½TCPçš„ä¸‰æ¬¡æ¡æ‰‹ä¸å››æ¬¡æŒ¥æ‰‹:\nä¸ºä»€ä¹ˆå»ºç«‹è¿æ¥æ˜¯ä¸‰æ¬¡æ¡æ‰‹ï¼Œå…³é—­è¿æ¥ç¡®æ˜¯å››æ¬¡æŒ¥æ‰‹å‘¢ï¼Ÿ\nå»ºç«‹è¿æ¥çš„æ—¶å€™ï¼Œ æœåŠ¡å™¨åœ¨LISTENçŠ¶æ€ä¸‹ï¼Œæ”¶åˆ°å»ºç«‹è¿æ¥è¯·æ±‚çš„SYNæŠ¥æ–‡åï¼ŒæŠŠACKå’ŒSYNæ”¾åœ¨ä¸€ä¸ªæŠ¥æ–‡é‡Œå‘é€ç»™å®¢æˆ·ç«¯ã€‚è€Œå…³é—­è¿æ¥æ—¶ï¼ŒæœåŠ¡å™¨æ”¶åˆ°å¯¹æ–¹çš„FINæŠ¥æ–‡æ—¶ï¼Œä»…ä»…è¡¨ç¤ºå¯¹æ–¹ä¸å†å‘é€æ•°æ®äº†ä½†æ˜¯è¿˜èƒ½æ¥æ”¶æ•°æ®ï¼Œè€Œè‡ªå·±ä¹Ÿæœªå¿…å…¨éƒ¨æ•°æ®éƒ½å‘é€ç»™å¯¹æ–¹äº†ï¼Œæ‰€ä»¥å·±æ–¹å¯ä»¥ç«‹å³å…³é—­ï¼Œä¹Ÿå¯ä»¥å‘é€ä¸€äº›æ•°æ®ç»™å¯¹æ–¹åï¼Œå†å‘é€FINæŠ¥æ–‡ç»™å¯¹æ–¹æ¥è¡¨ç¤ºåŒæ„ç°åœ¨å…³é—­è¿æ¥ï¼Œå› æ­¤ï¼Œå·±æ–¹ACKå’ŒFINä¸€èˆ¬éƒ½ä¼šåˆ†å¼€å‘é€ï¼Œä»è€Œå¯¼è‡´å¤šäº†ä¸€æ¬¡ã€‚\n5.9 TCPæŠ¥æ–‡æ®µçš„é¦–éƒ¨æ ¼å¼ åºå·ï¼šæŒ‡å‡ºæœ¬TCPæŠ¥æ–‡æ®µæ•°æ®è½½è·çš„ç¬¬ä¸€ä¸ªå­—èŠ‚çš„åºå·\nç¡®è®¤å·ï¼šæŒ‡å‡ºæœŸæœ›æ”¶åˆ°å¯¹æ–¹ä¸‹ä¸€ä¸ªTCPæŠ¥æ–‡æ®µçš„æ•°æ®è½½è·çš„ç¬¬ä¸€ä¸ªå­—èŠ‚çš„åºå·ï¼ŒåŒæ—¶ä¹Ÿæ˜¯å¯¹ä¹‹å‰æ”¶åˆ°çš„æ‰€æœ‰æ•°æ®çš„ç¡®è®¤ã€‚\nTCPè§„å®šï¼Œåœ¨è¿æ¥å»ºç«‹åæ‰€æœ‰ä¼ é€çš„TCPæŠ¥æ–‡æ®µéƒ½å¿…é¡»æŠŠACKç½®1ã€‚\nä¿ç•™ï¼šå 6æ¯”ç‰¹\næ ¡éªŒå’Œï¼šåœ¨è®¡ç®—æ ¡éªŒå’Œæ—¶ï¼Œè¦åœ¨TCPæŠ¥æ–‡æ®µçš„å‰é¢åŠ ä¸Š12å­—èŠ‚çš„ä¼ªé¦–éƒ¨ã€‚\nå¤ä½æ ‡è¯†ä½RSTï¼šç”¨æ¥å¤ä½TCPè¿æ¥ã€‚ä¸º1è¡¨æ˜TCPè¿æ¥å‡ºç°äº†å¼‚å¸¸ã€‚RSTç½®1è¿˜ç”¨æ¥æ‹’ç»ä¸€ä¸ªéæ³•çš„æŠ¥æ–‡æ®µæˆ–æ‹’ç»æ‰“å¼€ä¸€ä¸ªTCPè¿æ¥ã€‚\nPSHï¼šæ¨é€æ ‡å¿—ä½\nç´§æ€¥æ ‡è®°ä½URG\nç´§æ€¥æŒ‡é’ˆï¼šå 16æ¯”ç‰¹ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½ï¼Œç”¨æ¥æŒ‡æ˜ç´§æ€¥æ•°æ®çš„é•¿åº¦ã€‚\né€‰é¡¹ï¼šæœ€å¤§æŠ¥æ–‡æ®µé•¿åº¦MSSé€‰é¡¹ã€çª—å£æ‰©å¤§é€‰é¡¹ã€æ—¶é—´æˆ³é€‰é¡¹ï¼ˆè®¡ç®—å¾€è¿”æ—¶é—´RTTï¼Œå¤„ç†åºå·è¶…èŒƒå›´çš„æƒ…å†µï¼‰ã€é€‰æ‹©ç¡®è®¤é€‰é¡¹\nç¬¬6ç«  åº”ç”¨å±‚ 6.1 åº”ç”¨å±‚æ¦‚è¿° 6.2 å®¢æˆ·/æœåŠ¡å™¨æ–¹å¼å’Œå¯¹ç­‰æ–¹å¼ 6.3 åŠ¨æ€ä¸»æœºé…ç½®åè®®DHCP 6.4 åŸŸåç³»ç»ŸDNS(Domain Name System) ä¸ºäº†æé«˜DNSçš„æŸ¥è¯¢æ•ˆç‡ï¼Œå¹¶å‡è½»æ ¹åŸŸåæœåŠ¡å™¨çš„è´Ÿè·å’Œå‡å°‘å› ç‰¹ç½‘ä¸ŠDNSæŸ¥è¯¢æŠ¥æ–‡çš„æ•°é‡ï¼Œåœ¨åŸŸåæœåŠ¡å™¨å’Œä¸»æœºä¸­å¹¿æ³›ä½¿ç”¨äº†é«˜é€Ÿç¼“å­˜ã€‚\nDNSæŠ¥æ–‡ä½¿ç”¨è¿è¾“å±‚çš„UDPåè®®å°è£…ï¼Œè¿è¾“å±‚ç«¯å£å·ä¸º53ã€‚\n6.5 æ–‡ä»¶ä¼ é€åè®®FTP 6.6 ç”µå­é‚®ä»¶ 6.7 ä¸‡ç»´ç½‘WWW ä¸‡ç»´ç½‘æ˜¯è¿è¡Œåœ¨å› ç‰¹ç½‘ä¸Šçš„ä¸€ä¸ªåˆ†å¸ƒå¼åº”ç”¨ã€‚\nä¸‡ç»´ç½‘åˆ©ç”¨ç½‘é¡µä¹‹é—´çš„è¶…é“¾æ¥å°†ä¸åŒç½‘ç«™çš„ç½‘é¡µé“¾æ¥æˆä¸€å¼ é€»è¾‘ä¸Šçš„ä¿¡æ¯ç½‘ã€‚\nä¸‡ç»´ç½‘ä½¿ç”¨ç»Ÿä¸€èµ„æºå®šä½ç¬¦URLæ¥æŒ‡æ˜å› ç‰¹ç½‘ä¸Šä»»ä½•ç§ç±»â€œèµ„æºâ€çš„ä½ç½®ã€‚URLä¸€èˆ¬å½¢å¼ï¼š\u0026lt;åè®®\u0026gt;://\u0026lt;ä¸»æœº\u0026gt;:\u0026lt;ç«¯å£\u0026gt;/\u0026lt;è·¯å¾„\u0026gt;\nä¸‡ç»´ç½‘æ–‡æ¡£\nè¶…æ–‡æœ¬æ ‡è®°è¯­è¨€HTMLï¼Œä½¿ç”¨å¤šç§æ ‡ç­¾æ¥æè¿°ç½‘é¡µçš„ç»“æ„å’Œå†…å®¹ å±‚å æ ·å¼è¡¨CSSï¼Œä»å®¡ç¾çš„è§’åº¦æ¥æè¿°ç½‘é¡µçš„æ ·å¼ JavaScriptï¼Œä¸€ç§è„šæœ¬è¯­è¨€ï¼Œæ§åˆ¶ç½‘é¡µè¡Œä¸º Cookieæ˜¯ä¸€ç§å¯¹æ— çŠ¶æ€çš„HTTPè¿›è¡ŒçŠ¶æ€åŒ–çš„æŠ€æœ¯ã€‚\n","date":"2022-03-23T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/03/23/internet/","title":"è®¡ç®—æœºç½‘ç»œçŸ¥è¯†æ€»ç»“"},{"content":"ä¸»è¦å‚è€ƒvuepress-theme-recoè®¾ç½®mathå…¬å¼ã€‚\næ­¥éª¤ å®šä½åˆ°åšå®¢çš„æ ¹ç›®å½•ä¸‹ï¼Œå®‰è£…åº“ 1 npm i markdown-it-texmath å®‰è£…markdown-it 1 npm install markdown-it --save å®‰è£…katex 1 npm install katex ä¿®æ”¹.vuepress/config.jsæ–‡ä»¶ 1 2 3 4 5 6 7 markdown: { lineNumbers: true, anchor: { permalink: false }, toc: {includeLevel: [1,2]}, extendMarkdown: md =\u0026gt; { md.use(require(\u0026#39;markdown-it-texmath\u0026#39;)) } headéƒ¨åˆ†æ·»åŠ ä¸‹é¢çš„ä»£ç ï¼š\n1 2 3 4 5 [\u0026#39;link\u0026#39;, {\u0026#34;rel\u0026#34;:\u0026#39;stylesheet\u0026#39;, \u0026#34;href\u0026#34;:\u0026#39;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css\u0026#39;}], [\u0026#39;link\u0026#39;, {\u0026#34;rel\u0026#34;:\u0026#39;stylesheet\u0026#39;, \u0026#34;href\u0026#34;:\u0026#39;https://gitcdn.xyz/cdn/goessner/markdown-it-texmath/master/texmath.css\u0026#39;}], [\u0026#39;script\u0026#39;, {\u0026#34;src\u0026#34;: \u0026#39;https://github.com/markdown-it/markdown-it/blob/master/bin/markdown-it.js\u0026#39;}], [\u0026#39;script\u0026#39;, {\u0026#34;src\u0026#34;: \u0026#39;https://gitcdn.xyz/cdn/goessner/markdown-it-texmath/master/texmath.js\u0026#39;}], [\u0026#39;script\u0026#39;, {\u0026#34;src\u0026#34;: \u0026#39;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js\u0026#39;}] æ›´æ–°æäº¤åï¼Œå°±å¤§åŠŸå‘Šæˆäº†ã€‚ ","date":"2022-03-09T00:00:00Z","permalink":"https://wenjin1997.github.io/2022/03/09/mathEquationBlog/","title":"vuepressé…ç½®åšå®¢æ”¯æŒæ•°å­¦å…¬å¼"},{"content":"æœ€ç®€æ˜¾æ ¼å¼ å¯¹äºå¦‚ä¸‹çƒ­ä¼ å¯¼æ–¹ç¨‹ï¼š $$ \\begin{cases} \\frac{\\partial u}{\\partial t} =\\frac{\\partial ^2 u}{\\partial t} \\quad 0","date":"2021-05-24T00:00:00Z","permalink":"https://wenjin1997.github.io/2021/05/24/heat-equation/","title":"æ•°å€¼æ±‚è§£çƒ­ä¼ å¯¼æ–¹ç¨‹"},{"content":"æ±‚è§£å¦‚ä¸‹å¸¸å¾®åˆ†æ–¹ç¨‹ï¼š\n$$ \\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2, \\\\\\ u(1)=1 \\end{cases}\t\\end{aligned} $$ç²¾ç¡®è§£ å°†åŸæ–¹ç¨‹åŒ–ä¸º$tdu+udt=0$ï¼Œåˆ™æœ‰$d(ut)=0$ï¼Œè§£å¾—$ut=C$($C$ä¸ºå¸¸æ•°)ï¼Œä»£å…¥åˆå§‹æ¡ä»¶å¾—$C=1$ï¼Œä»è€Œè¯¥æ–¹ç¨‹çš„ç²¾ç¡®è§£ä¸ºï¼š $$ \\begin{aligned} u=\\frac{1}{t},(1\\leq t \\leq2). \\end{aligned} $$æ¬§æ‹‰æ–¹æ³• ä»£å…¥æ¬§æ‹‰æ ¼å¼å¾—ï¼š $$ \\begin{aligned} u_{i+1}=u_{i}+hf(t_i,u_i)=u_i+h(-\\frac{u_i}{t_i}) \\end{aligned} $$éšå¼æ¬§æ‹‰æ–¹æ³• ç”±éšå¼æ¬§æ‹‰æ ¼å¼å¾—ï¼š $$ \\begin{aligned} u_{i+1}=u_{i}+hf(t_{i+1},u_{i+1})=u_i+h(-\\frac{u_{i+1}}{t_{i+1}})ï¼Œ \\end{aligned} $$ ç§»é¡¹åŒ–ç®€å¯å¾—ï¼š $$ \\begin{aligned} u_{i+1}=\\frac{t_{i+1}u_i}{t_{i+1}+h} \\end{aligned} $$ç¨‹åº æ ¹æ®ä¸Šè¿°æ¨å¯¼ï¼Œç”¨pythonç¼–å†™ç¨‹åºï¼Œä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # implict euler method import numpy as np import matplotlib.pyplot as plt # the right term of the ODE def f(t, u): f = -u/t return f # the exact solution of ODE def fexact(t): fexact = 1/t return fexact N = 100 t_n = 2.0 dt = (t_n - 1.0) / N t = np.arange(1.0, t_n + dt, dt) u_euler = np.arange(1.0, t_n + dt, dt) u = np.arange(1.0, t_n + dt, dt) u_true = np.arange(1.0, t_n + dt, dt) i = 0 while i \u0026lt; N: t[i+1] = t[i] + dt u_euler[i+1] = u_euler[i] + dt * f(t[i], u_euler[i]) u[i+1] = (u[i] * t[i+1])/(t[i+1] + dt) u_true[i+1] = fexact(t[i+1]) i = i + 1 err_euler = max(abs(u_euler - u_true)) err_implict_euler = max(abs(u - u_true)) print(\u0026#34;The error of euler method: \u0026#34;,err_euler) print(\u0026#34;The error of implict euler method: \u0026#34;,err_implict_euler) # begin drawing plt.title(\u0026#39;Result\u0026#39;) plt.plot(t, u_euler, color=\u0026#39;green\u0026#39;, label=\u0026#39;euler\u0026#39;) plt.plot(t, u, color=\u0026#39;blue\u0026#39;, label=\u0026#39;implict euler\u0026#39;) plt.plot(t, u_true, color=\u0026#39;red\u0026#39;, label=\u0026#39;exact\u0026#39;) plt.legend() # show the legend plt.xlabel(\u0026#39;t\u0026#39;) plt.ylabel(\u0026#39;u\u0026#39;) plt.show() ç»“æœåˆ†æ å½“å–$h=0.01$æ—¶ï¼Œæ­¤æ—¶æ¬§æ‹‰æ–¹æ³•çš„è¯¯å·®ä¸º0.02631578947368396ï¼Œéšå¼æ¬§æ‹‰æ–¹æ³•çš„è¯¯å·®ä¸º0.023809523809523836ï¼Œç»“æœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\nå½“å–ä¸åŒ$h$ï¼Œå¾—åˆ°çš„è¯¯å·®å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼š\n$h$ æ¬§æ‹‰æ–¹æ³• éšå¼æ¬§æ‹‰æ–¹æ³• $\\frac{1}{2}$ 0.16666666666666663 0.09999999999999998 $\\frac{1}{4}$ 0.0714285714285714 0.05555555555555558 $\\frac{1}{8}$ 0.033333333333333215 0.02941176470588236 $\\frac{1}{16}$ 0.01612903225806467 0.015151515151515138 $\\frac{1}{32}$ 0.00793650793650813 0.007692307692307665 $\\frac{1}{64}$ 0.0039370078740155193 0.003875968992248069 ","date":"2021-03-11T00:00:00Z","image":"https://wenjin1997.github.io/img/2021-03-11-eluer-method/background.jpg","permalink":"https://wenjin1997.github.io/2021/03/11/euler-method/","title":"æ¬§æ‹‰æ–¹æ³•ã€éšå¼æ¬§æ‹‰æ–¹æ³•"},{"content":"æ­¥éª¤ 1.åœ¨æœ¬åœ°å»ºç«‹ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œå¹¶å®šä½åˆ°è¯¥æ–‡ä»¶å¤¹ä¸‹\n2.è¾“å…¥å‘½ä»¤git init git config --global user.name \u0026quot;wenjin1997\u0026quot; git config --global user.email \u0026quot;wenjin1997@126.com\u0026quot; 3.é…ç½®SSHssh-keygen -t rsa -C \u0026quot;xxxxxxxx@163.com\u0026quot; (ç™»å½•githubçš„é‚®ç®±)ï¼Œä¸­é—´éœ€è¦è®¾ç½®å¯†ç ï¼Œå¯ä»¥ç›´æ¥æŒ‰å›è½¦\n4.æ‹·è´SSHpbcopy \u0026lt; ~/.ssh/id_rsa.pub\n5.åœ¨githubçš„settingsä¸­æ·»åŠ åˆšåˆšçš„SSH\n6.æ‰“å¼€ç»ˆç«¯ï¼ŒéªŒè¯æ˜¯å¦é…ç½®æˆåŠŸssh -T git@github.com\n7.è®¾ç½®ç™»å½•ååŠé‚®ç®±\n1 2 git config --global user.name \u0026#34;your name\u0026#34; git config --global user.email \u0026#34;your_email@youremail.com\u0026#34; 8.å°†é¡¹ç›®å…‹éš†åˆ°æœ¬åœ°ï¼Œä¾‹å¦‚git clone git@github.com:wenjin1997/python-notes.git\n","date":"2021-01-24T00:00:00Z","permalink":"https://wenjin1997.github.io/2021/01/24/git/","title":"å¦‚ä½•ç”¨gitåŒæ­¥æœ¬åœ°ä»£ç åˆ°github"},{"content":"ä¹¦ç±ä¿¡æ¯ ä¹¦åï¼šã€Šç»ƒä¹ çš„å¿ƒæ€ï¼šå¦‚ä½•åŸ¹å…»è€å¿ƒã€ä¸“æ³¨å’Œè‡ªå¾‹ã€‹ ä½œè€…ï¼šæ‰˜é©¬æ–¯ M.æ–¯ç‰¹çº³ ä¹¦æ‘˜ æ€»è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬åŸ¹è‚²ç»ƒä¹ çš„å¿ƒæ€ï¼Œå½’ç»“ä¸ºä¸€äº›ç®€å•çš„æ³•åˆ™ï¼š\nè®©è‡ªå·±å§‹ç»ˆä»¥è¿‡ç¨‹ä¸ºå¯¼å‘ã€‚ é‡ç‚¹å…³æ³¨å½“å‰ã€‚ å°†è¿‡ç¨‹ç¡®å®šä¸ºç›®æ ‡ï¼Œå¹¶ä¸”è¿ç”¨æ€»ç›®æ ‡ä½œä¸ºèˆ¹èˆµï¼Œä»¥æŒ‡å¼•è‡ªå·±çš„åŠªåŠ›ã€‚ å¯¹è‡ªå·±æƒ³è¦åšåˆ°çš„äº‹æƒ…åˆ»æ„åœ°è®­ç»ƒï¼Œå¸¦ç€æ„å›¾è®­ç»ƒï¼Œå¹¶ä¸”è‡ªå§‹è‡³ç»ˆæ¸…é†’åœ°çŸ¥é“é‚£ç§æ„å›¾ã€‚ èšç„¦äºè¿‡ç¨‹æ—¶ï¼Œä½ æœŸæœ›çš„ç»“æœä¼šå¾ˆè½»æ¾ã€å¾ˆè‡ªç„¶åœ°å‡ºç°ã€‚èšç„¦äºç»“æœæ—¶ï¼Œä½ ä¾¿é©¬ä¸Šé™·å…¥çº ç»“ä¹‹ä¸­ï¼Œå¯¹è¿‡ç¨‹æ„Ÿåˆ°åŒå€¦ã€ä¸å®‰ã€å¤±è´¥å’Œä¸è€çƒ¦ã€‚\né€šå‘è€å¿ƒçš„ç¬¬ä¸€æ­¥æ˜¯æ„è¯†åˆ°ä½ çš„å†…å¿ƒç‹¬ç™½æ˜¯ä»€ä¹ˆæ—¶å€™å¼€å§‹ç–¯ç‹‚å¥”èµ°ï¼Œå¹¶ä¸”æ‹–ç€ä½ ä¸€è·¯ç‹‚å¥”ã€‚\nåŸ¹å…»è€å¿ƒçš„ç¬¬äºŒæ­¥æ˜¯ç†è§£å’Œæ¥å—è¿™æ ·ä¸€ä¸ªç°å®ï¼šä¸è®ºä»€ä¹ˆäº‹æƒ…ï¼Œéƒ½ä¸ä¼šå°½å–„å°½ç¾ã€‚çœŸæ­£çš„å®Œç¾ï¼Œä¸€æ–¹é¢æ€»åœ¨ä¸åœæ¼”å˜ï¼Œå¦ä¸€æ–¹é¢ä¹Ÿæ€»åœ¨ä½ çš„å†…å¿ƒå‡ºç°ï¼Œæ­£å¦‚ä¹‹å‰ä¾‹ä¸¾è¿‡çš„ç»½æ”¾çš„é²œèŠ±é‚£æ ·ã€‚\nè·å¾—ä»»ä½•ä¸œè¥¿æ‰€å¸¦æ¥çš„çœŸæ­£çš„å…´å¥‹æ„Ÿï¼Œä¸è®ºè¿™æ ·ä¸œè¥¿æ˜¯ä¸€ä»¶ç‰©å“è¿˜æ˜¯ä¸€ä¸ªä¸ªäººç›®æ ‡ï¼Œå…¶å®æ˜¯ä½ å¯¹è·å¾—å®ƒé‚£ä¸€åˆ»çš„é¢„æµ‹ã€‚çœŸæ­£çš„æ„‰æ‚¦å–å†³äºä½ äº§ç”Ÿå’Œä¿æŒçš„æ¯…åŠ›ä¸è€å¿ƒã€‚å®ƒä»¬æ­£æ˜¯ä½ åœ¨é•¿æ—¶é—´å†…ä¸ºäº‰å–æ‹¥æœ‰è¿™æ ·ä¸œè¥¿è€ŒåŠªåŠ›å·¥ä½œæ—¶æ‰€éœ€è¦çš„ã€‚\nåˆ¤æ–­ï¼Œå¯¹æˆ‘ä»¬ç”Ÿæ´»çš„è¿è½¬æ˜¯å¿…è¦çš„ï¼Œä½†ä¹Ÿæœ‰ä¸€ä¸ªä¸åˆ©çš„æ–¹é¢ï¼šå®ƒä»¬å¹¶ä¸ä¼šä»¥ä¸€ç§è¶…ç„¶çš„ç‰¹æ€§æ¥æ‰§è¡Œã€‚é€šå¸¸å…¶ä¸­åŒ…å«ç€æŸç§æƒ…ç»ªï¼Œè€Œæƒ…ç»ªçš„æ•°é‡ä¸æˆ‘ä»¬å¯¹åˆ¤æ–­çš„é‡è¦æ€§çš„æ„ŸçŸ¥ç¨‹åº¦æ˜¯æˆæ¯”ä¾‹çš„ã€‚\nä½ æ¥åˆ°è¿™ä¸ªä¸–ç•Œä¸Šçš„æ—¶å€™ï¼Œåªå¸¦ç€ä½ çœŸæ­£çš„è‡ªæˆ‘è€Œæ¥ï¼›è€Œä½ ç¦»å¼€è¿™ä¸ªä¸–ç•Œæ—¶ï¼Œä¹Ÿåªèƒ½å¸¦èµ°ä½ æœ€çœŸå®çš„è‡ªæˆ‘ã€‚ä½ åœ¨ç²¾ç¥ä¸Šè·å¾—çš„ä¸€åˆ‡ï¼Œå°†ä¸°å¯Œå’Œå‘å±•ä½ çš„çœŸå®è‡ªæˆ‘ï¼Œå˜æˆä½ æ°¸æ’çš„ä¸€éƒ¨åˆ†ã€‚\nè¯»åæ„Ÿ é˜…è¯»å®Œè¿™æœ¬ä¹¦å¹¶æ²¡æœ‰èŠ±è´¹æˆ‘å¤šå°‘æ—¶é—´ï¼Œå‡ ä¹æ˜¯ä¸€å£æ°”å°±è¯»å®Œäº†ã€‚ä½†æ˜¯å…¶ä¸­çš„æ€æƒ³æ–¹æ³•å€¼å¾—æ…¢æ…¢å­¦ä¹ å¹¶åœ¨ç”Ÿæ´»ä¸­å»å®è·µã€‚\næœ€é‡è¦çš„å°±æ˜¯ä¸ºäº†è¾¾æˆæŸä¸ªç›®æ ‡æˆ–è€…å®ŒæˆæŸä»¶äº‹æƒ…æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥æ›´åŠ æ³¨é‡è¿‡ç¨‹è€Œä¸æ˜¯ç»“æœã€‚æˆ‘ä»¬å¸¸å¸¸è¯´â€œå°½åŠ›å°±å¥½äº†ï¼Œä¸è¦å¼ºæ±‚è‡ªå·±â€ï¼Œæˆ‘è®¤ä¸ºè¿™ç®—æ˜¯è®©è‡ªå·±å·æ‡’çš„ä¸€ä¸ªå€Ÿå£æˆ–è€…æ˜¯ç»“æœä¸ç†æƒ³æ—¶çš„ä¸€ä¸ªå®‰æ…°ï¼Œä¸æ³¨é‡è¿‡ç¨‹è¿˜æ˜¯æœ‰æ‰€ä¸åŒã€‚æˆ‘ä»¬éœ€è¦æ´»åœ¨å½“ä¸‹ï¼Œè€Œä¸æ˜¯è¿‡å»æˆ–è€…æœªæ¥ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æˆ‘ä»¬æœŸæœ›çš„æœªæ¥ï¼Œå®ƒåº”å½“æ˜¯æŒ‡å¼•æˆ‘ä»¬è¡ŒåŠ¨çš„æ–¹å‘ï¼Œç¡®ä¿è‡ªå·±æ²¡æœ‰èµ°åï¼Œæˆ‘ä»¬åº”è¯¥ä½“éªŒä¸æ„Ÿå—ç°åœ¨ï¼Œä¸è¦è¿‡å¤šçš„å…³æ³¨äºç°åœ¨è·ç¦»ç›®æ ‡è¿˜æœ‰å¤šè¿œå¤šè¿œï¼Œè¿™åªä¼šå¾’å¢è‡ªå·±çš„ç„¦è™‘ä¸æ‹…å¿§ï¼Œåè€Œä¼šå½±å“å‰è¿›çš„é€Ÿåº¦ã€‚\nä¹¦ä¸­æåˆ°äº†ä¸€ä¸ªæ–¹æ³•æ˜¯DOCï¼Œå³Doã€Observeã€Correctï¼Œæˆ‘è®¤ä¸ºéå¸¸æœ‰å¸®åŠ©ã€‚æ¯”å¦‚æˆ‘ä»¬æ³¨æ„åˆ°è‡ªå·±ä¸ºæŸä»¶äº‹æƒ…æ‹…å¿ƒæ—¶ï¼Œè¿™å°±å®ç°äº†åšï¼ˆDoï¼‰çš„éƒ¨åˆ†ã€‚ç°åœ¨ï¼Œè§‚å¯Ÿï¼ˆObserveï¼‰è‡ªå·±æƒ³è¦çš„è¡Œä¸ºï¼Œåœ¨å¯¹è‡ªå·±ä¸ºé‚£ä»¶äº‹æƒ…æ‹…å¿ƒçš„è§‚å¯Ÿä¸­ï¼Œå°†è‡ªå·±ä¸æ‹…å¿ƒé‚£ä¸€ä¸¾åŠ¨éš”ç¦»å¼€æ¥ã€‚å½“è‡ªå·±æ„è¯†åˆ°è‡ªå·±æ‹…å¿ƒçš„æƒ…ç»ªå¯¹äºæ‹…å¿ƒçš„é—®é¢˜å¹¶æ²¡æœ‰å½±å“æ—¶ï¼Œå°½å¯èƒ½åœ°è®©è‡ªå·±ä»è¿™ç§æƒ…ç»ªä¸­è§£è„±å‡ºæ¥ï¼ˆå°±æ˜¯çº æ­£ï¼ˆCorrectï¼‰çš„è¿‡ç¨‹ï¼‰ã€‚\næˆ‘è®¤ä¸ºä¹¦ä¸­è¿˜æœ‰ä¸€ä¸ªå¯¹æˆ‘æœ‰å¯å‘çš„è§‚ç‚¹æ˜¯ï¼Œä¸è®ºä»€ä¹ˆäº‹æƒ…ï¼Œéƒ½ä¸ä¼šå°½å–„å°½ç¾ã€‚æˆ‘ä¸€ç›´åœ¨å¹»æƒ³ç€ä¸€ä¸ªç†æƒ³çš„è‡ªå·±ï¼Œå¥¹å¾ˆå‹¤å¥‹ï¼Œè‡ªå¾‹ï¼Œçƒ­çˆ±å­¦ä¹ ï¼Œçƒ­çˆ±ç”Ÿæ´»ï¼Œå–„äºäº¤æµï¼Œå¼€æœ—ç§¯æï¼Œå¥½åƒä¸€ç›´éƒ½æ˜¯é‚£ä¹ˆé˜³å…‰ç§¯æï¼Œå…¶å®è¿™çœŸçš„å°±æ˜¯å¹»æƒ³ï¼Œå¯¹ç°å®æ— æµäºäº‹ï¼Œç”šè‡³å½“è‡ªå·±å‡ºç°è´Ÿé¢æƒ…ç»ªæˆ–è€…å˜å¾—æ‡’æƒ°æ—¶ï¼Œå°±ä¼šäº§ç”Ÿæ„§ç–šè‡ªè´£ï¼Œç¦»é‚£ä¸ªç†æƒ³ä¸­çš„è‡ªå·±æ›´åŠ é¥è¿œäº†ï¼Œè¿™å®Œå®Œå…¨å…¨ä¼šå½±å“å½“ä¸‹çš„è¡Œä¸ºã€‚ä¸å¦‚åœ¨ä¸€å¼€å§‹å°±æ„è¯†åˆ°ï¼Œæ²¡æœ‰ä»€ä¹ˆæ˜¯å®Œç¾çš„ï¼Œè‡ªå·±å°±æ˜¯è¿™æ ·å­˜åœ¨çš„ï¼Œè¿™æ‰æ˜¯çœŸå®çš„è‡ªå·±ï¼Œè‡³äºæƒ³è¦æ”¹å˜ä»€ä¹ˆï¼Œé‚£å°±å¤šå…³æ³¨å¦‚ä½•åšåˆ°ï¼Œè€Œä¸æ˜¯æ‰¹åˆ¤ä¸€ä¸ªè¿‡å»çš„è‡ªå·±ï¼Œè¿™å®Œå…¨æ˜¯ä¸å€¼å¾—çš„ã€‚\nå¦‚æœè¯´è¦å»æ€è€ƒä»€ä¹ˆæ˜¯äººç”Ÿçš„ç›®æ ‡ï¼Œæˆ‘ä»¬æ˜¯ä¸ºäº†ä»€ä¹ˆè€Œæ´»ã€‚æˆ‘è®¤ä¸ºè¿™æœ¬ä¹¦ç»™æˆ‘çš„ä¸€ä¸ªæƒ³æ³•å°±æ˜¯ï¼Œæ²¡æœ‰ä»€ä¹ˆç›®æ ‡ï¼Œé‡è¦çš„å°±æ˜¯è‡ªå·±ä½“éªŒåˆ°äº†ä»€ä¹ˆã€‚å…³æ³¨äºç°åœ¨åœ¨åšä»€ä¹ˆï¼Œç°åœ¨ä½“éªŒåˆ°äº†ä»€ä¹ˆï¼Œè¿™äº›å°±æ„æˆäº†æ•´ä¸ªè‡ªå·±çš„ä¸€ç”Ÿã€‚å¯èƒ½è‡ªå·±æ‰€æœ‰çš„åŠªåŠ›ä¸ä»˜å‡ºå¹¶ä¸æ˜¯ä¸ºäº†è·å¾—ç‰©è´¨ä¸çŸ­æš‚çš„å¿«ä¹ï¼Œè€Œæ˜¯å¯»å¾—è‡ªå·±å†…å¿ƒçš„å¹³é™ã€‚å•Šå•Š~~ è‡ªå·±è¿˜æ²¡è¾¾åˆ°ä»€ä¹ˆç‰©è´¨æ¡ä»¶å‘¢ï¼Œè¯´è¿™ä¸ªæœ‰äº›å¤§äº†ï¼Œå¯Œäººçš„å¿«ä¹ä½ ä½“ä¼šä¸åˆ°~~ å“ˆå“ˆ~~~\n","date":"2020-03-10T00:00:00Z","permalink":"https://wenjin1997.github.io/2020/03/10/Practices/","title":"ã€Šç»ƒä¹ çš„å¿ƒæ€ï¼šå¦‚ä½•åŸ¹å…»è€å¿ƒã€ä¸“æ³¨å’Œè‡ªå¾‹ã€‹"}]